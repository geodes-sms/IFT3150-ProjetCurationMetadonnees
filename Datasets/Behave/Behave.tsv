key	project	title	abstract	keywords	authors	venue	doi	references	pages	bibtex	screened_decision	final_decision	mode	inclusion_criteria	exclusion_criteria	reviewer_count	source	year	meta_title	link	publisher	metadata_missing
0	Behave	On the understanding of BDD scenarios’ quality: Preliminary practitioners’ opinions	[Context & Motivation] In agile development, acceptance tests are written to express the details from the conversations between customers and developers. One of the formats to express those details is BDD (Behavior-Driven Development) scenarios, which use a ubiquitous language, one that business and technical people can understand, to build an executable specification that represents a system behavior. [Question/Problem] Problems caused by bad documentation are known to cause project failure and we believe those problems apply to documentation in the format of acceptance tests as well. Thus, in the long-term, we seek to understand what would be the definition of a good BDD scenario and the criteria to define it. [Principal idea/results] To achieve that, we previously identified known requirements’ quality attributes that would be suitable to evaluate BDD scenarios’ quality. Based on that list of attributes, we now aim to validate that list with practitioners, identify their interpretation of the listed attributes, and uncover general recommendations to write BDD scenarios. [Contribution] Preliminary results from our initial set of interviews revealed practitioners’ interpretations for consistent, testable, valuable, understandable, and unambiguous attributes and some recommendations to write good BDD scenarios, such as the use of declarative form of writing. © Springer International Publishing AG, part of Springer Nature 2018.		Oliveira G., Marczak S.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	[Context & Motivation] In agile development, acceptance tests are written to express the details from the conversations between customers and developers. One of the formats to express those details is BDD (Behavior-Driven Development) scenarios, which use a ubiquitous language, one that business and technical people can understand, to build an executable specification that represents a system behavior. [Question/Problem] Problems caused by bad documentation are known to cause project failure and we believe those problems apply to documentation in the format of acceptance tests as well. Thus, in the long-term, we seek to understand what would be the definition of a good BDD scenario and the criteria to define it. [Principal idea/results] To achieve that, we previously identified known requirements’ quality attributes that would be suitable to evaluate BDD scenarios’ quality. Based on that list of attributes, we now aim to validate that list with practitioners, identify their interpretation of the listed attributes, and uncover general recommendations to write BDD scenarios. [Contribution] Preliminary results from our initial set of interviews revealed practitioners’ interpretations for consistent, testable, valuable, understandable, and unambiguous attributes and some recommendations to write good BDD scenarios, such as the use of declarative form of writing. © Springer International Publishing AG, part of Springer Nature 2018.				Excluded	Excluded	new_screen			2						
1	Behave	Testing schematron using XSpec	[No abstract available]		[No author name available]	Balisage Series on Markup Technologies	[No abstract available]				Excluded	Excluded	new_screen			2						
2	Behave	Enhancing the Student Learning Experience by Adopting TDD and BDD in Course Projects	A demonstration of the application and contribution of Test-Driven Development (TDD) and Behavior-Driven Development (BDD) in the student learning experience in the context of a Software Engineering course. Background: Software testing is an activity for ensuring software quality. Although teaching testing rigorously to students is a priority in academia, undergraduate students often encounter difficulties performing testing tasks effectively. Intended Outcomes: To increase satisfaction rate and course grades, and reduce delivery time. Application Design: We experimented with the Software Engineering Laboratory (LES) course of a Private University in the Bachelor of Computer Science and Information Systems courses. This experiment corroborated the learning difficulties of students. Collected data were assessed both quantitatively and qualitatively. Findings: Backed up with statistical tests, the results showed a reduction in student absences, higher student satisfaction rate, and higher grades in the courses. Furthermore, our approach allowed students to deliver a product in a short period, representing a possibility of adoption of BDD due to their successful learning experience. Finally, we aim to foster a discussion of appropriate teaching methods of software testing.	Software Testing;Student Learning Experience;Software Engineering Education;course Project;Agile Software Development	F. G. Rocha; L. S. Souza; T. S. Silva; G. Rodríguez	2021 IEEE Global Engineering Education Conference (EDUCON)	A demonstration of the application and contribution of Test-Driven Development (TDD) and Behavior-Driven Development (BDD) in the student learning experience in the context of a Software Engineering course. Background: Software testing is an activity for ensuring software quality. Although teaching testing rigorously to students is a priority in academia, undergraduate students often encounter difficulties performing testing tasks effectively. Intended Outcomes: To increase satisfaction rate and course grades, and reduce delivery time. Application Design: We experimented with the Software Engineering Laboratory (LES) course of a Private University in the Bachelor of Computer Science and Information Systems courses. This experiment corroborated the learning difficulties of students. Collected data were assessed both quantitatively and qualitatively. Findings: Backed up with statistical tests, the results showed a reduction in student absences, higher student satisfaction rate, and higher grades in the courses. Furthermore, our approach allowed students to deliver a product in a short period, representing a possibility of adoption of BDD due to their successful learning experience. Finally, we aim to foster a discussion of appropriate teaching methods of software testing.				Included	Included	new_screen			2						
3	Behave	How to Evaluate BDD Scenarios' Quality?	A scenario from the Behavior-driven development (BDD) practice is a known format to represent acceptance tests in agile methodologies, communicating assumptions and expectations by expressing the details that result from the conversations between customers and developers. We believe that this formalization of behavior need to be of good quality to avoid known requirement problems that arise from bad documentation, such as incomplete, underspecified and inconsistent requirements. However, there are only informal guidelines to guide practitioners on their BDD scenarios' elaboration and quality evaluations. To address this lack of guidance, we define a set of quality attributes and propose a question-based checklist to assist BDD scenarios' quality evaluations. [Methods] The quality attributes were identified from an interview-based study with 18 practitioners. In this study, practitioners shared their interpretations on an initial set of literature-informed quality attributes and their own personal evaluation criteria. We consolidated both in a single list of newly redefined attributes, used in the definition of our proposed checklist. We believe that our newly re-defined quality attributes and question-based checklist can enhance the existing guidelines and practitioners' ability to evaluate BDD scenario's quality by providing them with an standard guideline for scenarios' refinement conversations.	behavior-driven development; empirical study; checklist; documentation; quality	Oliveira, Gabriel; Marczak, Sabrina; Moralles, Cassiano	Proceedings of the XXXIII Brazilian Symposium on Software Engineering	A scenario from the Behavior-driven development (BDD) practice is a known format to represent acceptance tests in agile methodologies, communicating assumptions and expectations by expressing the details that result from the conversations between customers and developers. We believe that this formalization of behavior need to be of good quality to avoid known requirement problems that arise from bad documentation, such as incomplete, underspecified and inconsistent requirements. However, there are only informal guidelines to guide practitioners on their BDD scenarios' elaboration and quality evaluations. To address this lack of guidance, we define a set of quality attributes and propose a question-based checklist to assist BDD scenarios' quality evaluations. [Methods] The quality attributes were identified from an interview-based study with 18 practitioners. In this study, practitioners shared their interpretations on an initial set of literature-informed quality attributes and their own personal evaluation criteria. We consolidated both in a single list of newly redefined attributes, used in the definition of our proposed checklist. We believe that our newly re-defined quality attributes and question-based checklist can enhance the existing guidelines and practitioners' ability to evaluate BDD scenario's quality by providing them with an standard guideline for scenarios' refinement conversations.				Included	Included	new_screen			2						
4	Behave	Implementing behavior driven development in an open source ERP	A typical problem in Software Engineering is how to guarantee that all system's requirements are correctly implemented through source code. Traditionally, requirement tracing is a manual task comprised of keeping links from requirements to source code, going through different modeling artifacts, including models. However, these techniques cannot guarantee that requirements are always correctly implemented by source code. Aiming at solving this problem, Behavior-Driven Development (BDD) is a specification technique that automatically checks if all functional requirements are treated properly by source code through the connection of the textual description of requirements to automated tests. Given that for Enterprise Information Systems, requirements are usually identified by analyzing business process models, and these processes are implemented through workflows, connecting workflows to automated tests through BDD specifications can provide automated requirements traceability. The aim of this paper is to briefly present this proposal and show how it was implemented for the open source ERP5 system. © 2013 IFIP International Federation for Information Processing.		De Carvalho R.A., De Carvalho E Silva F.L., Manhães R.S., De Oliveira G.L.	Lecture Notes in Business Information Processing	A typical problem in Software Engineering is how to guarantee that all system's requirements are correctly implemented through source code. Traditionally, requirement tracing is a manual task comprised of keeping links from requirements to source code, going through different modeling artifacts, including models. However, these techniques cannot guarantee that requirements are always correctly implemented by source code. Aiming at solving this problem, Behavior-Driven Development (BDD) is a specification technique that automatically checks if all functional requirements are treated properly by source code through the connection of the textual description of requirements to automated tests. Given that for Enterprise Information Systems, requirements are usually identified by analyzing business process models, and these processes are implemented through workflows, connecting workflows to automated tests through BDD specifications can provide automated requirements traceability. The aim of this paper is to briefly present this proposal and show how it was implemented for the open source ERP5 system. © 2013 IFIP International Federation for Information Processing.				Included	Included	new_screen			2						
5	Behave	Business Language Driven Development: Joining business process models to automated tests	A typical problem in Software Engineering is how to guarantee that every system requirement is correctly implemented by source code. Many techniques were proposed, mostly based on taking notes of relationships between requirements and code in modeling and documenting artifacts. However, these techniques cannot guarantee that the artifacts are always synchronized with source code. Aiming at solving this problem, Behavior-Driven Development (BDD) is a specification technique that automatically checks that all functional requirements are treated properly by source code, through connecting the textual description of requirements to automated tests. Nevertheless, in some software development areas, such as Enterprise Information Systems (EIS), requirements are usually identified by analyzing business process models - which use graphical notations of the underlying processes logic. Therefore, the aim of this paper is to present Business Language Driven Development (BLDD), a method that aims to extend BDD, by connecting business process models directly to automated tests, thus guaranteeing that requirements are properly covered by code. © 2012 Taylor & Francis Group, London.		De Carvalho R.A., De Carvalho E Silva F.L., Manhaes R.S.	Advances in Enterprise Information Systems II - Proceedings of the 5th International Conference on Research and Practical Issues of Enterprise Information Systems, CONFENIS 2011	A typical problem in Software Engineering is how to guarantee that every system requirement is correctly implemented by source code. Many techniques were proposed, mostly based on taking notes of relationships between requirements and code in modeling and documenting artifacts. However, these techniques cannot guarantee that the artifacts are always synchronized with source code. Aiming at solving this problem, Behavior-Driven Development (BDD) is a specification technique that automatically checks that all functional requirements are treated properly by source code, through connecting the textual description of requirements to automated tests. Nevertheless, in some software development areas, such as Enterprise Information Systems (EIS), requirements are usually identified by analyzing business process models - which use graphical notations of the underlying processes logic. Therefore, the aim of this paper is to present Business Language Driven Development (BLDD), a method that aims to extend BDD, by connecting business process models directly to automated tests, thus guaranteeing that requirements are properly covered by code. © 2012 Taylor & Francis Group, London.				Included	Included	new_screen			2						
6	Behave	Test Automation Using Selenium Webdriver 3.0 with C#	About the Book Test Automation using Selenium WebDriver with C#, is the latest book released on Selenium 3.0 using C# as a programming language. This Selenium book has been designed with the objectives of simplicity and ease of understanding. After the huge success of author Vaibhav Mittal and Navneesh Gargs Test Automation books on Selenium with Java, UFT and Microsoft Coded UI this book follows a similar step by step approach to Install, configure and design automation framework using Selenium WebDriver using Visual Studio 2017 and its components. Who is this book for? This book is recommended both for those who are beginning to learn test automation (using Selenium WebDriver) and for advanced automation users. It follows a unique training based approach instead of a regular textbook approach. Using a step by step approach, it guides the students through the exercises using pictorial snapshots. It includes many practical examples and issues which most of the automation testers encounter in day-to-day automation. These experiences will give you an insight into what challenges you could face with automation in the real world. Practical examples cover how to use most of the features within Selenium WebDriver using Visual Studio 2017. No Programming Background? A major fear amongst functional testers who want to learn Selenium is of programming language and coding. As a part of this, we will cover just enough basics of C# programming language that will give the readers the confidence to use Selenium WebDriver. Integrations Covered This book covers Selenium Webdriver integration with independent components to be installed like Microsoft Visual Studio 2017, Katalon, Extent Report, VSTS (Continuous Integration tool) and Specflow (Behaviour Driven Development). We will cover step by step installation, configuration and use of each of these components. Those want to know about Cross Browser testing, it covers how to use Selenium WebDriver to run on IE, Firefox and Chrome browsers. It also covers aspects of Continuous Integration tool from Microsoft (VSTS) so that Selenium WebDriver scripts can be integrated with the development environment and run on nightly builds.		Mittal, Vaibhav; Garg, Navneesh		About the Book Test Automation using Selenium WebDriver with C#, is the latest book released on Selenium 3.0 using C# as a programming language. This Selenium book has been designed with the objectives of simplicity and ease of understanding. After the huge success of author Vaibhav Mittal and Navneesh Gargs Test Automation books on Selenium with Java, UFT and Microsoft Coded UI this book follows a similar step by step approach to Install, configure and design automation framework using Selenium WebDriver using Visual Studio 2017 and its components. Who is this book for? This book is recommended both for those who are beginning to learn test automation (using Selenium WebDriver) and for advanced automation users. It follows a unique training based approach instead of a regular textbook approach. Using a step by step approach, it guides the students through the exercises using pictorial snapshots. It includes many practical examples and issues which most of the automation testers encounter in day-to-day automation. These experiences will give you an insight into what challenges you could face with automation in the real world. Practical examples cover how to use most of the features within Selenium WebDriver using Visual Studio 2017. No Programming Background? A major fear amongst functional testers who want to learn Selenium is of programming language and coding. As a part of this, we will cover just enough basics of C# programming language that will give the readers the confidence to use Selenium WebDriver. Integrations Covered This book covers Selenium Webdriver integration with independent components to be installed like Microsoft Visual Studio 2017, Katalon, Extent Report, VSTS (Continuous Integration tool) and Specflow (Behaviour Driven Development). We will cover step by step installation, configuration and use of each of these components. Those want to know about Cross Browser testing, it covers how to use Selenium WebDriver to run on IE, Firefox and Chrome browsers. It also covers aspects of Continuous Integration tool from Microsoft (VSTS) so that Selenium WebDriver scripts can be integrated with the development environment and run on nightly builds.				Excluded	Excluded	new_screen			2						
7	Behave	Bridging the Gap between Requirements Modeling and Behavior-Driven Development	Acceptance criteria (AC) are implementation agnostic conditions that a system must meet to be consistent with its requirements and be accepted by its stakeholders. Each acceptance criterion is typically expressed as a natural-language statement with a clear pass or fail outcome. Writing AC is a tedious and error-prone activity, especially when the requirements specifications evolve and there are different analysts and testing teams involved. Analysts and testers must iterate multiple times to ensure that AC are understandable and feasible, and accurately address the most important requirements and workflows of the system being developed. In many cases, analysts express requirements through models, along with natural language, typically in some variant of the UML. AC must then be derived by developers and testers from such models. In this paper, we bridge the gap between requirements models and AC by providing a UML-based modeling methodology and an automated solution to generate AC. We target AC in the form of Behavioral Specifications in the context of Behavioral-Driven Development (BDD), a widely used agile practice in many application domains. More specially we target the well-known Gherkin language to express AC, which then can be used to generate executable test cases. We evaluate our modeling methodology and AC generation solution through an industrial case study in the financial domain. Our results suggest that (1) our methodology is feasible to apply in practice, and (2) the additional modeling effort required by our methodology is outweighed by the benefits the methodology brings in terms of automated and systematic AC generation and improved model precision.	Software testing;BDD;modeling;requirements engineering;text generation;Gherkin;FinTech	M. Alferez; F. Pastore; M. Sabetzadeh; L. Briand; J. Riccardi	2019 ACM/IEEE 22nd International Conference on Model Driven Engineering Languages and Systems (MODELS)	Acceptance criteria (AC) are implementation agnostic conditions that a system must meet to be consistent with its requirements and be accepted by its stakeholders. Each acceptance criterion is typically expressed as a natural-language statement with a clear pass or fail outcome. Writing AC is a tedious and error-prone activity, especially when the requirements specifications evolve and there are different analysts and testing teams involved. Analysts and testers must iterate multiple times to ensure that AC are understandable and feasible, and accurately address the most important requirements and workflows of the system being developed. In many cases, analysts express requirements through models, along with natural language, typically in some variant of the UML. AC must then be derived by developers and testers from such models. In this paper, we bridge the gap between requirements models and AC by providing a UML-based modeling methodology and an automated solution to generate AC. We target AC in the form of Behavioral Specifications in the context of Behavioral-Driven Development (BDD), a widely used agile practice in many application domains. More specially we target the well-known Gherkin language to express AC, which then can be used to generate executable test cases. We evaluate our modeling methodology and AC generation solution through an industrial case study in the financial domain. Our results suggest that (1) our methodology is feasible to apply in practice, and (2) the additional modeling effort required by our methodology is outweighed by the benefits the methodology brings in terms of automated and systematic AC generation and improved model precision.				Included	Included	new_screen			2						
8	Behave	Design and validation of a C++ code generator from Abstract State Machines specifications	According to best practices of model-driven engineering, the implementation of a system should be obtained from its model through a systematic model-to-code transformation. We present in this paper a methodology supported by the Asm2C++ tool, which allows the users to generate C++ code from abstract state machine models. Thanks to Asm2C++, the implementation is generated in a seamless manner with an assurance of potential bug freeness of the generated code. Following the same approach, model-based testing suggests deriving also (unit) tests from abstract models. We extend the Asm2C++ tool such that it can automatically produce unit tests for the generated code. Abstract test sequences, either generated randomly or through model checking, are translated to concrete C++ unit tests using the Boost library. In a similar manner, also, scenarios are generated in a behavior-driven development (BDD) approach. To guarantee the correctness of the transformation process, we define a mechanism to test the correctness of the model-to-code transformation with respect to two main criteria: syntactical correctness and semantic correctness, which is based on the definition of conformance between the specification and the code. Using this approach, we have devised a process able to test the generated code by reusing unit tests. The process has been used to validate our model-to-code transformations. © 2019 John Wiley & Sons, Ltd.		Bonfanti S., Gargantini A., Mashkoor A.	Journal of Software: Evolution and Process	According to best practices of model-driven engineering, the implementation of a system should be obtained from its model through a systematic model-to-code transformation. We present in this paper a methodology supported by the Asm2C++ tool, which allows the users to generate C++ code from abstract state machine models. Thanks to Asm2C++, the implementation is generated in a seamless manner with an assurance of potential bug freeness of the generated code. Following the same approach, model-based testing suggests deriving also (unit) tests from abstract models. We extend the Asm2C++ tool such that it can automatically produce unit tests for the generated code. Abstract test sequences, either generated randomly or through model checking, are translated to concrete C++ unit tests using the Boost library. In a similar manner, also, scenarios are generated in a behavior-driven development (BDD) approach. To guarantee the correctness of the transformation process, we define a mechanism to test the correctness of the model-to-code transformation with respect to two main criteria: syntactical correctness and semantic correctness, which is based on the definition of conformance between the specification and the code. Using this approach, we have devised a process able to test the generated code by reusing unit tests. The process has been used to validate our model-to-code transformations. © 2019 John Wiley & Sons, Ltd.				Excluded	Excluded	new_screen			2						
9	Behave	An optimized algorithm on distributed network node data access path based on behavior drive model	According to different node data access objects, and based on the idea of behavior-driven development, an interface-oriented node data access tool is designed and implemented. The tool mainly implements an executable node data access tool that is based on MFC, and writes a set of Win32 console application, which improves the node data automation access scripts and encapsulates the module interfaces, thus improving the distributed network data access speed. © (2014) Trans Tech Publications, Switzerland.		Jiang W.X., Hu X.Z., Wang S., Liang Y.	Applied Mechanics and Materials	According to different node data access objects, and based on the idea of behavior-driven development, an interface-oriented node data access tool is designed and implemented. The tool mainly implements an executable node data access tool that is based on MFC, and writes a set of Win32 console application, which improves the node data automation access scripts and encapsulates the module interfaces, thus improving the distributed network data access speed. © (2014) Trans Tech Publications, Switzerland.				Excluded	Excluded	new_screen			2						
10	Behave	The new Y Chromosome Haplotype Reference Database	After opening the first version of an internet-accessible worldwide reference database of Y chromosome profiles 14 years ago and six years after the last major relaunch the new YHRD 4.0 repository and website has been rolled-out. By November 2014 about 136k 9-locus haplotypes, among these 84k 17-locus haplotypes, 25k 23-locus haplotypes and 15k Y SNP profiles from 917 sampling locations in 128 countries have been submitted by more than 250 institutes and laboratories. In geographic terms, about 39% of the YHRD samples are from Europe, 32% from Asia, 16% from South America, 6% from North America, 4% from Africa and 2% from Oceania/Australia. Worldwide collaboration is the driving force for the rapid growth of the database and this, in turn, allows the evaluation and implementation of enhanced interpretation tools (variable frequency estimators, LR-based mixture and kinship analysis, Y-SNP-based ancestry assessment).	Database, Y chromosome, Haplotype, Y-STR, Frequency estimation, Metapopulation	Willuweit, Sascha; Roewer, Lutz	Forensic Science International: Genetics	After opening the first version of an internet-accessible worldwide reference database of Y chromosome profiles 14 years ago and six years after the last major relaunch the new YHRD 4.0 repository and website has been rolled-out. By November 2014 about 136k 9-locus haplotypes, among these 84k 17-locus haplotypes, 25k 23-locus haplotypes and 15k Y SNP profiles from 917 sampling locations in 128 countries have been submitted by more than 250 institutes and laboratories. In geographic terms, about 39% of the YHRD samples are from Europe, 32% from Asia, 16% from South America, 6% from North America, 4% from Africa and 2% from Oceania/Australia. Worldwide collaboration is the driving force for the rapid growth of the database and this, in turn, allows the evaluation and implementation of enhanced interpretation tools (variable frequency estimators, LR-based mixture and kinship analysis, Y-SNP-based ancestry assessment).				Excluded	Excluded	new_screen			2						
11	Behave	Digital forensics as a service: Stepping up the game	After providing Digital Forensics as a Service (DFaaS) implementations to law enforcement agencies for close to a decade, we present our view from an inside-out perspective. We share the lessons learned from an organizational, operational and development perspective in a forensic and legal context. We conclude with our vision on how to bring the DFaaS concept to the next level for both investigative and innovative purposes.	Digital forensics, Digital forensics as a service, DFaaS, Hansken	van Beek, H. M. A.; van den Bos, J.; Boztas, A.; van Eijk, E. J.; Schramp, R.; Ugen, M.	Forensic Science International: Digital Investigation	After providing Digital Forensics as a Service (DFaaS) implementations to law enforcement agencies for close to a decade, we present our view from an inside-out perspective. We share the lessons learned from an organizational, operational and development perspective in a forensic and legal context. We conclude with our vision on how to bring the DFaaS concept to the next level for both investigative and innovative purposes.				Excluded	Excluded	new_screen			2						
12	Behave	Behavior-Driven Development Benefits and Challenges: Reports from an Industrial Study	Agile approaches arose as a way of addressing some of the main challenges in software development, such as changing requirements, lack of understanding about the system scope, and out-of-sync between code, requirements, and documentation. Studies show that agile projects still suffer from lack of customer support, resulting in difficulties to represent customer needs on requested features. Behavior-Driven Development (BDD) brings a structured way to represent user behaviors and to validate user stories by using an ubiquitous language, shared among everyone involved on the development of the software. The approach allows the creation of scenarios that can be used by the team to share information between different stakeholders, enabling all those players to successfully collaborate and coordinate their work. In this paper, we report on an empirical study conducted with 24 IT professionals with practical experience on BDD. Through this, we identify the perceived benefits and challenges of adopting BDD.	agile development; behavior-driven development; empirical study; grounded theory	Pereira, Lauriane; Sharp, Helen; de Souza, Cleidson; Oliveira, Gabriel; Marczak, Sabrina; Bastos, Ricardo	Proceedings of the 19th International Conference on Agile Software Development: Companion	Agile approaches arose as a way of addressing some of the main challenges in software development, such as changing requirements, lack of understanding about the system scope, and out-of-sync between code, requirements, and documentation. Studies show that agile projects still suffer from lack of customer support, resulting in difficulties to represent customer needs on requested features. Behavior-Driven Development (BDD) brings a structured way to represent user behaviors and to validate user stories by using an ubiquitous language, shared among everyone involved on the development of the software. The approach allows the creation of scenarios that can be used by the team to share information between different stakeholders, enabling all those players to successfully collaborate and coordinate their work. In this paper, we report on an empirical study conducted with 24 IT professionals with practical experience on BDD. Through this, we identify the perceived benefits and challenges of adopting BDD.				Included	Included	new_screen			2						
13	Behave	Legend: An Agile DSL Toolset for Web Acceptance Testing	Agile development emphasizes collaborations among customers, business analysts, domain experts, developers, and testers. However, the large scale and rapid pace of many agile projects presents challenges during testing activities. Large sets of test artifacts must be comprehensible and available to various stakeholders, traceable to requirements, and easily maintainable as the software evolves. In this paper we describe Legend, a toolset that leverages domain-specific language to streamline functional testing in agile projects. Some key features of the toolset include test template generation from user stories, model-based automation, test inventory synchronization, and centralized test tagging.	Behavior-Driven Development; Software Testing; Agile Development; Domain-Specific Languages; Test Automation	King, Tariq M.; Nunez, Gabriel; Santiago, Dionny; Cando, Adam; Mack, Cody	Proceedings of the 2014 International Symposium on Software Testing and Analysis	Agile development emphasizes collaborations among customers, business analysts, domain experts, developers, and testers. However, the large scale and rapid pace of many agile projects presents challenges during testing activities. Large sets of test artifacts must be comprehensible and available to various stakeholders, traceable to requirements, and easily maintainable as the software evolves. In this paper we describe Legend, a toolset that leverages domain-specific language to streamline functional testing in agile projects. Some key features of the toolset include test template generation from user stories, model-based automation, test inventory synchronization, and centralized test tagging.				Included	Included	new_screen			2						
14	Behave	Combining STPA and BDD for Safety Analysis and Verification in Agile Development	Agile development is in widespread use, even in safety-critical domains. However, there is a lack of an appropriate safety analysis and verification method in agile development. In this poster, we propose the use of Behavior Driven Development for safety verification with System-Theoretic Process Analysis for safety analysis in agile development. It shows a good capability on communication effectiveness through a preliminary controlled experiment.	agile development; safety verification; safety-critical systems	Wang, Yang; Wagner, Stefan	Proceedings of the 40th International Conference on Software Engineering: Companion Proceeedings	Agile development is in widespread use, even in safety-critical domains. However, there is a lack of an appropriate safety analysis and verification method in agile development. In this poster, we propose the use of Behavior Driven Development for safety verification with System-Theoretic Process Analysis for safety analysis in agile development. It shows a good capability on communication effectiveness through a preliminary controlled experiment.				Included	Included	new_screen			2						
15	Behave	Poster: Combining STPA and BDD for Safety Analysis and Verification in Agile Development	Agile development is in widespread use, even in safety-critical domains. However, there is a lack of an appropriate safety analysis and verification method in agile development. In this poster, we propose the use of Behavior Driven Development for safety verification with System-Theoretic Process Analysis for safety analysis in agile development. It shows a good capability on communication effectiveness through a preliminary controlled experiment.	Agile Development;Safety Verification;Safety-Critical Systems	Y. Wang; S. Wagner	2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion)	Agile development is in widespread use, even in safety-critical domains. However, there is a lack of an appropriate safety analysis and verification method in agile development. In this poster, we propose the use of Behavior Driven Development for safety verification with System-Theoretic Process Analysis for safety analysis in agile development. It shows a good capability on communication effectiveness through a preliminary controlled experiment.				Excluded	Excluded	new_screen			2						
16	Behave	Identifying critical areas for improvement in agile multi-site co-development	Agile processes potentially ease distributed software development by demanding regular communication and self-management of virtual team members. However, being designed for collocated teams, extensions to the regular process need to be made. We investigate critical areas of improvement based on a case of distributed Scrum involving two unaffiliated Austrian IT organizations that collaborate to build software. We identified eight critical areas for improvement originating from interviews, retrospective meetings and an in-depth case analysis. Key suggestions for practice include the establishment of long-lived single-site Scrum teams and the application of Behavior Driven Development (BDD) to make implicit requirement knowledge explicit and transparent to all of the distributed parties. Copyright © 2013 SCITEPRESS.		Vallon R., Bayrhammer K., Strobl S., Bernhart M., Grechenig T.	ENASE 2013 - Proceedings of the 8th International Conference on Evaluation of Novel Approaches to Software Engineering	Agile processes potentially ease distributed software development by demanding regular communication and self-management of virtual team members. However, being designed for collocated teams, extensions to the regular process need to be made. We investigate critical areas of improvement based on a case of distributed Scrum involving two unaffiliated Austrian IT organizations that collaborate to build software. We identified eight critical areas for improvement originating from interviews, retrospective meetings and an in-depth case analysis. Key suggestions for practice include the establishment of long-lived single-site Scrum teams and the application of Behavior Driven Development (BDD) to make implicit requirement knowledge explicit and transparent to all of the distributed parties. Copyright © 2013 SCITEPRESS.				Excluded	Excluded	new_screen			2						
17	Behave	Quality of software requirements specification in agile projects: A cross-case analysis of six companies	Agile Software Development (ASD) has several limitations concerning its requirements engineering activities. Improving the quality of Software Requirements Specifications (SRSs) in ASD may help to gain a competitive advantage in the software industry. Based on the findings of a Systematic Mapping study, six industrial case studies in different contexts were conducted to investigate and characterize the requirements specification activity in ASD. Data collected from documents, observations, and interviews with software engineers were triangulated, analyzed, and synthesized using Grounded Theory and Meta-Ethnography. The analysis and cross-synthesis of the six case studies resulted in a model describing the phenomenon. This model defines the simplicity and objectivity as essential quality factors of SRSs in ASD. The main factors that affect the SRSs quality in ASD projects are related to their customer-driven nature that leads to prolix SRSs, hindering its understanding from the developer perspective. The emerged model is supported by explanations and provides a deeper understanding of the requirements specification activity in ASD. This creates opportunities for further studies and improvements in SRSs for ASD in industry.	Requirements specification, Agile methods, Empirical study, Agile Requirements Engineering	Medeiros, Juliana; Vasconcelos, Alexandre; Silva, Carla; Goulão, Miguel	Journal of Systems and Software	Agile Software Development (ASD) has several limitations concerning its requirements engineering activities. Improving the quality of Software Requirements Specifications (SRSs) in ASD may help to gain a competitive advantage in the software industry. Based on the findings of a Systematic Mapping study, six industrial case studies in different contexts were conducted to investigate and characterize the requirements specification activity in ASD. Data collected from documents, observations, and interviews with software engineers were triangulated, analyzed, and synthesized using Grounded Theory and Meta-Ethnography. The analysis and cross-synthesis of the six case studies resulted in a model describing the phenomenon. This model defines the simplicity and objectivity as essential quality factors of SRSs in ASD. The main factors that affect the SRSs quality in ASD projects are related to their customer-driven nature that leads to prolix SRSs, hindering its understanding from the developer perspective. The emerged model is supported by explanations and provides a deeper understanding of the requirements specification activity in ASD. This creates opportunities for further studies and improvements in SRSs for ASD in industry.				Excluded	Excluded	new_screen			2						
18	Behave	Assessing The Effectiveness Of Test-Driven Development and Behavior-Driven Development in an Industry Setting	Agile software development deviates from the traditional and plan-based approaches to software engineering as its iterative cycles embrace changes in software requirements. Test-Driven Development (TDD) and Behavior-Driven Development (BDD) are techniques that have been recently adopted by the software industry and have evolved from agile practices. These techniques aim at improving both the quality of the delivered software and the developers' productivity. They are several studies that have been conducted on TDD in both academic and industry settings with however only a few on BDD. While TDD and BDD have both become popular, many organizations and developers still do not understand the differences between these concepts or where they overlap. The aim of this paper is to assess the effectiveness of these two approaches in terms of external code quality, internal code quality and developers' productivity. To understand the weaknesses and strengths of each of these methods, a literature review was first performed. An experiment was then carried out in an industry setting to observe the effectiveness of TDD and BDD on a number of subjects. Our results showed that both techniques indeed increased the external quality of the delivered product. However, a decrease in productivity and internal quality were noted when BDD was used compared to TDD which might be due to the additional steps involved in BDD.	Test-Driven Development;Behavior-Driven Development;TDD;BDD;productivity;quality;code coverage	A. S. Dookhun; L. Nagowah	2019 International Conference on Computational Intelligence and Knowledge Economy (ICCIKE)	Agile software development deviates from the traditional and plan-based approaches to software engineering as its iterative cycles embrace changes in software requirements. Test-Driven Development (TDD) and Behavior-Driven Development (BDD) are techniques that have been recently adopted by the software industry and have evolved from agile practices. These techniques aim at improving both the quality of the delivered software and the developers' productivity. They are several studies that have been conducted on TDD in both academic and industry settings with however only a few on BDD. While TDD and BDD have both become popular, many organizations and developers still do not understand the differences between these concepts or where they overlap. The aim of this paper is to assess the effectiveness of these two approaches in terms of external code quality, internal code quality and developers' productivity. To understand the weaknesses and strengths of each of these methods, a literature review was first performed. An experiment was then carried out in an industry setting to observe the effectiveness of TDD and BDD on a number of subjects. Our results showed that both techniques indeed increased the external quality of the delivered product. However, a decrease in productivity and internal quality were noted when BDD was used compared to TDD which might be due to the additional steps involved in BDD.				Included	Included	new_screen			2						
19	Behave	The effect of Test-Driven Development and Behavior-Driven Development on Project Success Factors: A Systematic Literature Review Based Study	Agile testing approaches test-driven development (TDD), behavior-driven development (BDD); have gained popularity since the introduction of agile practices. The concept of using these approaches in software projects is to help projects succeed. The effect of TDD and BDD on Project success factors namely, cost, time, and customer satisfaction/external quality, remains an area of investigation. Therefore, this study investigates the results of previously published articles on the effect of TDD and BDD on project success factors. A systematic literature review has been conducted considering articles published between 1999 up to 2020. Thirty-one studies were selected and analyzed. 74.1% of studies are experiments, 25.8% are case studies. 67.7% of these studies were performed in an industrial setting, 29.0% were performed in an academic setting and only one study with 3.22% was mixed academic and industrial settings. The result shows that the TDD and the BDD consume more time and cost compared to traditional testing (TLD). Moreover, the TDD as TLD may not necessarily satisfy the customer unlike the BDD appears that achieve customer satisfaction. Although, when TDD compared to BDD, TDD consumed more time and lower customer acceptance than the BDD.	Test Driven Development;Behavior Driven Development;Test Last Development;Systematic Literature Review;Agile Testing;Projects Success Factors	H. M. Abushama; H. A. Alassam; F. A. Elhaj	2020 International Conference on Computer, Control, Electrical, and Electronics Engineering (ICCCEEE)	Agile testing approaches test-driven development (TDD), behavior-driven development (BDD); have gained popularity since the introduction of agile practices. The concept of using these approaches in software projects is to help projects succeed. The effect of TDD and BDD on Project success factors namely, cost, time, and customer satisfaction/external quality, remains an area of investigation. Therefore, this study investigates the results of previously published articles on the effect of TDD and BDD on project success factors. A systematic literature review has been conducted considering articles published between 1999 up to 2020. Thirty-one studies were selected and analyzed. 74.1% of studies are experiments, 25.8% are case studies. 67.7% of these studies were performed in an industrial setting, 29.0% were performed in an academic setting and only one study with 3.22% was mixed academic and industrial settings. The result shows that the TDD and the BDD consume more time and cost compared to traditional testing (TLD). Moreover, the TDD as TLD may not necessarily satisfy the customer unlike the BDD appears that achieve customer satisfaction. Although, when TDD compared to BDD, TDD consumed more time and lower customer acceptance than the BDD.				Excluded	Excluded	new_screen			2						
20	Behave	Behavior driven testing in ALMA telescope calibration software	ALMA software development cycle includes well defined testing stages that involves developers, testers and scientists. We adapted Behavior Driven Development (BDD) to testing activities applied to Telescope Calibration (TELCAL) software. BDD is an agile technique that encourages communication between roles by defining test cases using natural language to specify features and scenarios, what allows participants to share a common language and provides a high level set of automated tests. This work describes how we implemented and maintain BDD testing for TELCAL, the infrastructure needed to support it and proposals to expand this technique to other subsystems. © COPYRIGHT SPIE. Downloading of the abstract is permitted for personal use only.		Gil J.P., Garces M., Broguiere D., Shen T.-C.	Proceedings of SPIE - The International Society for Optical Engineering	ALMA software development cycle includes well defined testing stages that involves developers, testers and scientists. We adapted Behavior Driven Development (BDD) to testing activities applied to Telescope Calibration (TELCAL) software. BDD is an agile technique that encourages communication between roles by defining test cases using natural language to specify features and scenarios, what allows participants to share a common language and provides a high level set of automated tests. This work describes how we implemented and maintain BDD testing for TELCAL, the infrastructure needed to support it and proposals to expand this technique to other subsystems. © COPYRIGHT SPIE. Downloading of the abstract is permitted for personal use only.				Included	Included	new_screen			2						
21	Behave	Behavior-Driven Requirements Traceability via Automated Acceptance Tests	Although information retrieval advances significantly improved automated traceability tools, their accuracy is still far from 100% and therefore they still need human intervention. Furthermore, despite the demonstrated benefits of traceability, many practitioners find the overhead for its creation and maintenance too high. We propose the Behavior Driven Traceability Method (BDT) that takes a different standpoint on automated traceability: we establish ubiquitous traceability between user story requirements and source code by taking advantage of the automated acceptance tests that are created as part of the Behavior Driven Development process.	User stories;automated acceptance tests;traceability;requirements;behavior-driven development	G. Lucassen; F. Dalpiaz; J. M. E. M. van der Werf; S. Brinkkemper; D. Zowghi	2017 IEEE 25th International Requirements Engineering Conference Workshops (REW)	Although information retrieval advances significantly improved automated traceability tools, their accuracy is still far from 100% and therefore they still need human intervention. Furthermore, despite the demonstrated benefits of traceability, many practitioners find the overhead for its creation and maintenance too high. We propose the Behavior Driven Traceability Method (BDT) that takes a different standpoint on automated traceability: we establish ubiquitous traceability between user story requirements and source code by taking advantage of the automated acceptance tests that are created as part of the Behavior Driven Development process.				Included	Included	new_screen			2						
22	Behave	Orchestration of Domain Specific Test Languages with a Behavior Driven Development approach	An airplane is composed by many complexes and embedded systems. During the integration testing phase, the design office produces requirements of the targeted system, and the test center produces concrete test procedures to be executed on a test bench. In this context, integration tests are mostly written in natural language and manually executed step by step by a tester. In order to formalize integration tests procedures dedicated to each system with domain specific languages approved by testers, and in order to automatize integration tests, we have introduced agile practices in the integration testing phase. We have chosen a Behavior Driven Development (BDD) approach to orchestrate Domain Specific Test Languages produced for the ACOVAS FUI project.		R. Bussenot; H. Leblanc; C. Percebois	2018 13th Annual Conference on System of Systems Engineering (SoSE)	An airplane is composed by many complexes and embedded systems. During the integration testing phase, the design office produces requirements of the targeted system, and the test center produces concrete test procedures to be executed on a test bench. In this context, integration tests are mostly written in natural language and manually executed step by step by a tester. In order to formalize integration tests procedures dedicated to each system with domain specific languages approved by testers, and in order to automatize integration tests, we have introduced agile practices in the integration testing phase. We have chosen a Behavior Driven Development (BDD) approach to orchestrate Domain Specific Test Languages produced for the ACOVAS FUI project.				Included	Included	new_screen			2						
23	Behave	Android Best Practices	Android Best Practices by Godfrey Nolan shows you how to make your Android apps stand out from the crowd with great reviews. Why settle for just making any Android app? Build a brilliant Android app instead that lets your users praise it for ease of use, better performance, and more. Using a series of example apps which gradually evolve throughout this book, Android Best Practices brings together current Android best practices from user interface (UI)/user experience (UX) design, test-driven development (TDD), and design patterns (e.g., MVC) to help you take your app to the next level. In this book youll learn how to: Use Android design patterns for consistent UI experience on many devices Use agile techniques such as test-driven development, behavior-driven development, and continuous integration Improve the speed and overall performance of your app Organize an Android app using design patterns such as MVC/MVP Create and consume REST and SOAP web servicesDesigning and developing an app that runs well on many if not all the leading Android smartphones and tablets today can be one of the most daunting challenges for Android developers. Well, this book takes much of the mystery out of that for you. After reading and using Android Best Practices, you'll become a much better Android app designer and developer, which in turn can make your apps better placed and more successful in the market place. What youll learn How to use Android design patterns for consistent UI experience on many devicesHow to use Agile techniques such as Test Driven Development, Behavior Driven Development and Continuous Integration How to test Android APKs on many devices and master device fragmentation Secure coding practices on Android How to organize an Android app using design patterns such as MVC/MVP etc. How to create and consume REST and SOAP web services Who this book is for This book is for Android developers looking to solidify their coding and overall app design and development skills.		Nolan, Godfrey; Cinar, Onur; Truxall, David		Android Best Practices by Godfrey Nolan shows you how to make your Android apps stand out from the crowd with great reviews. Why settle for just making any Android app? Build a brilliant Android app instead that lets your users praise it for ease of use, better performance, and more. Using a series of example apps which gradually evolve throughout this book, Android Best Practices brings together current Android best practices from user interface (UI)/user experience (UX) design, test-driven development (TDD), and design patterns (e.g., MVC) to help you take your app to the next level. In this book youll learn how to: Use Android design patterns for consistent UI experience on many devices Use agile techniques such as test-driven development, behavior-driven development, and continuous integration Improve the speed and overall performance of your app Organize an Android app using design patterns such as MVC/MVP Create and consume REST and SOAP web servicesDesigning and developing an app that runs well on many if not all the leading Android smartphones and tablets today can be one of the most daunting challenges for Android developers. Well, this book takes much of the mystery out of that for you. After reading and using Android Best Practices, you'll become a much better Android app designer and developer, which in turn can make your apps better placed and more successful in the market place. What youll learn How to use Android design patterns for consistent UI experience on many devicesHow to use Agile techniques such as Test Driven Development, Behavior Driven Development and Continuous Integration How to test Android APKs on many devices and master device fragmentation Secure coding practices on Android How to organize an Android app using design patterns such as MVC/MVP etc. How to create and consume REST and SOAP web services Who this book is for This book is for Android developers looking to solidify their coding and overall app design and development skills.				Excluded	Excluded	new_screen			2						
24	Behave	Smells in software test code: A survey of knowledge in industry and academia	As a type of anti-pattern, test smells are defined as poorly designed tests and their presence may negatively affect the quality of test suites and production code. Test smells are the subject of active discussions among practitioners and researchers, and various guidelines to handle smells are constantly offered for smell prevention, smell detection, and smell correction. Since there is a vast grey literature as well as a large body of research studies in this domain, it is not practical for practitioners and researchers to locate and synthesize such a large literature. Motivated by the above need and to find out what we, as the community, know about smells in test code, we conducted a ‘multivocal’ literature mapping (classification) on both the scientific literature and also practitioners’ grey literature. By surveying all the sources on test smells in both industry (120 sources) and academia (46 sources), 166 sources in total, our review presents the largest catalogue of test smells, along with the summary of guidelines/techniques and the tools to deal with those smells. This article aims to benefit the readers (both practitioners and researchers) by serving as an “index” to the vast body of knowledge in this important area, and by helping them develop high-quality test scripts, and minimize occurrences of test smells and their negative consequences in large test automation projects.	Software testing, Automated testing, Test automation, Test scripts, Test smells, Test anti-patterns, Multivocal literature mapping, Survey, Systematic mapping	Garousi, Vahid; Küçük, Barış	Journal of Systems and Software	As a type of anti-pattern, test smells are defined as poorly designed tests and their presence may negatively affect the quality of test suites and production code. Test smells are the subject of active discussions among practitioners and researchers, and various guidelines to handle smells are constantly offered for smell prevention, smell detection, and smell correction. Since there is a vast grey literature as well as a large body of research studies in this domain, it is not practical for practitioners and researchers to locate and synthesize such a large literature. Motivated by the above need and to find out what we, as the community, know about smells in test code, we conducted a ‘multivocal’ literature mapping (classification) on both the scientific literature and also practitioners’ grey literature. By surveying all the sources on test smells in both industry (120 sources) and academia (46 sources), 166 sources in total, our review presents the largest catalogue of test smells, along with the summary of guidelines/techniques and the tools to deal with those smells. This article aims to benefit the readers (both practitioners and researchers) by serving as an “index” to the vast body of knowledge in this important area, and by helping them develop high-quality test scripts, and minimize occurrences of test smells and their negative consequences in large test automation projects.				Excluded	Excluded	new_screen			2						
25	Behave	Omni-script: Device independent user interface development for omni-channel fintech applications	As the number of devices and platforms gradually increased that serve as a medium for online banking services, the number of replicated services for different platforms also increase. Each service has a different representation in a different platform even though targeting the same business objectives. This situation results in the problem of re-developing similar set of requirements for different devices and services which in turn results in multiplied effort in software development and degradation in the software quality because of the replicated code. The objective of this paper is to present a device independent user interface development approach that eliminates the replicated user interface development effort of the same set of services for different platforms/devices while increasing the presentation performance. In this context, we provide a basic technique that uses a json based user interface definition format, called omni-script, to separate the representation of banking services in different platforms/devices, so called channels. Omni-script is a pioneering solution being used in a real development environment in banking software domain that is experiencing a shift towards omni-channel user experience, where users are able to seamlessly continue using banking services in different platforms and devices. As the evaluation method, we have measured the actual development effort on a representative sample development team and a set of services. Additionally, we later deployed and measured the rendering time and the amount of data communication for the proposed approach in a real production environment. Production deployment resulted in a remarkable decrease in data communication and in loading times at the client side. As importantly, the proposed approach also resulted in a nearly 75% decrease in service development time by enabling analysts to produce user interface prototypes that can be integrated to service development with minimal effort.	Multimodal user interface definition, Omni-channel user experience, Omni-channel banking services	Ulusoy, Simge; Batıoğlu, Alper; Ovatman, Tolga	Computer Standards & Interfaces	As the number of devices and platforms gradually increased that serve as a medium for online banking services, the number of replicated services for different platforms also increase. Each service has a different representation in a different platform even though targeting the same business objectives. This situation results in the problem of re-developing similar set of requirements for different devices and services which in turn results in multiplied effort in software development and degradation in the software quality because of the replicated code. The objective of this paper is to present a device independent user interface development approach that eliminates the replicated user interface development effort of the same set of services for different platforms/devices while increasing the presentation performance. In this context, we provide a basic technique that uses a json based user interface definition format, called omni-script, to separate the representation of banking services in different platforms/devices, so called channels. Omni-script is a pioneering solution being used in a real development environment in banking software domain that is experiencing a shift towards omni-channel user experience, where users are able to seamlessly continue using banking services in different platforms and devices. As the evaluation method, we have measured the actual development effort on a representative sample development team and a set of services. Additionally, we later deployed and measured the rendering time and the amount of data communication for the proposed approach in a real production environment. Production deployment resulted in a remarkable decrease in data communication and in loading times at the client side. As importantly, the proposed approach also resulted in a nearly 75% decrease in service development time by enabling analysts to produce user interface prototypes that can be integrated to service development with minimal effort.				Excluded	Excluded	new_screen			2						
26	Behave	Validating enterprise architecture using ontology-based approach: A case study of student internship programme	As the practice of Enterprise Architecture (EA) diversifies, the schematic management of its objects, semantics and relationship continues to be complex. Given that EA provides support for the IT environment by simulating alignment between dynamic business architectures, heterogeneous application systems and incongruent technologies, the need to ensure validation of conceptualized EA models has become also critical. As a relatively new discipline, its disparate and widespread methodologies makes it even more challenging to adopt a generic approach in which models can be verified sequel to the unavailability of unified EA modelling languages able to describe a wide range of Information Technology domains. This paper seeks to present an approach for addressing this challenge through the use of ontologies and queries based on constraints specified in the model's motivation taxonomy. The paper is experimental research-based and grounds its hypothesis on initial model created using the ArchiMate modelling language. By transforming its conceptual metamodel into a model instance, a process which can be achieved irrespective of the modeling language used in the design of the EA, it represents extracted triples as resource description framework schema (RDFS) by mapping the model artefacts directly into classes and slots using a more conventional web ontology language. The generated RDF is then queried using Protocol and RDF Query Language (SPARQL) adopting the Behavior Driven Development (BDD) concept. A case study of the Student Internship Program (SIP) is deployed to translate information from business needs to IT solutions encapsulating a view of abstraction of the EA. The paper also proposes an implementation of the approach using an open source platform that allows construction of domain models and knowledge-based applications with ontologies and is a contribution towards effective validation of EA through taxonomy decomposition, systematic generation of testable EA artifacts, creation of structural triples of model elements and alignment of motivational goals to business behavior specifications.	Ontology;Enterprise Architecture;Metamodel;Model;Viewpoints;Resource Description Framework;Schema and Query Language;ArchiMate;Validation	S. Oussena; J. Essien	2013 3rd International Symposium ISKO-Maghreb	As the practice of Enterprise Architecture (EA) diversifies, the schematic management of its objects, semantics and relationship continues to be complex. Given that EA provides support for the IT environment by simulating alignment between dynamic business architectures, heterogeneous application systems and incongruent technologies, the need to ensure validation of conceptualized EA models has become also critical. As a relatively new discipline, its disparate and widespread methodologies makes it even more challenging to adopt a generic approach in which models can be verified sequel to the unavailability of unified EA modelling languages able to describe a wide range of Information Technology domains. This paper seeks to present an approach for addressing this challenge through the use of ontologies and queries based on constraints specified in the model's motivation taxonomy. The paper is experimental research-based and grounds its hypothesis on initial model created using the ArchiMate modelling language. By transforming its conceptual metamodel into a model instance, a process which can be achieved irrespective of the modeling language used in the design of the EA, it represents extracted triples as resource description framework schema (RDFS) by mapping the model artefacts directly into classes and slots using a more conventional web ontology language. The generated RDF is then queried using Protocol and RDF Query Language (SPARQL) adopting the Behavior Driven Development (BDD) concept. A case study of the Student Internship Program (SIP) is deployed to translate information from business needs to IT solutions encapsulating a view of abstraction of the EA. The paper also proposes an implementation of the approach using an open source platform that allows construction of domain models and knowledge-based applications with ontologies and is a contribution towards effective validation of EA through taxonomy decomposition, systematic generation of testable EA artifacts, creation of structural triples of model elements and alignment of motivational goals to business behavior specifications.				Excluded	Excluded	new_screen			2						
27	Behave	Did You Remember To Test Your Tokens?	"Authentication is a critical security feature for confirming the identity of a system's users, typically implemented with help from frameworks like Spring Security. It is a complex feature which should be robustly tested at all stages of development. Unit testing is an effective technique for fine-grained verification of feature behaviors that is not widely-used to test authentication. Part of the problem is that resources to help developers unit test security features are limited. Most security testing guides recommend test cases in a ""black box"" or penetration testing perspective. These resources are not easily applicable to developers writing new unit tests, or who want a security-focused perspective on coverage.In this paper, we address these issues by applying a grounded theory-based approach to identify common (unit) test cases for token authentication through analysis of 481 JUnit tests exercising Spring Security-based authentication implementations from 53 open source Java projects. The outcome of this study is a developer-friendly unit testing guide organized as a catalog of 53 test cases for token authentication, representing unique combinations of 17 scenarios, 40 conditions, and 30 expected outcomes learned from the data set in our analysis. We supplement the test guide with common test smells to avoid. To verify the accuracy and usefulness of our testing guide, we sought feedback from selected developers, some of whom authored unit tests in our dataset."	Unit Test; Java; Authentication; Repository Mining; Security Test	Gonzalez, Danielle; Rath, Michael; Mirakhorli, Mehdi	Proceedings of the 17th International Conference on Mining Software Repositories	"Authentication is a critical security feature for confirming the identity of a system's users, typically implemented with help from frameworks like Spring Security. It is a complex feature which should be robustly tested at all stages of development. Unit testing is an effective technique for fine-grained verification of feature behaviors that is not widely-used to test authentication. Part of the problem is that resources to help developers unit test security features are limited. Most security testing guides recommend test cases in a ""black box"" or penetration testing perspective. These resources are not easily applicable to developers writing new unit tests, or who want a security-focused perspective on coverage.In this paper, we address these issues by applying a grounded theory-based approach to identify common (unit) test cases for token authentication through analysis of 481 JUnit tests exercising Spring Security-based authentication implementations from 53 open source Java projects. The outcome of this study is a developer-friendly unit testing guide organized as a catalog of 53 test cases for token authentication, representing unique combinations of 17 scenarios, 40 conditions, and 30 expected outcomes learned from the data set in our analysis. We supplement the test guide with common test smells to avoid. To verify the accuracy and usefulness of our testing guide, we sought feedback from selected developers, some of whom authored unit tests in our dataset."				Excluded	Excluded	new_screen			2						
28	Behave	XUnit Test Patterns: Refactoring Test Code	"Automated testing is a cornerstone of agile development. An effective testing strategy will deliver new functionality more aggressively, accelerate user feedback, and improve quality. However, for many developers, creating effective automated tests is a unique and unfamiliar challenge.xUnit Test Patterns is the definitive guide to writing automated tests using xUnit, the most popular unit testing framework in use today. Agile coach and test automation expert Gerard Meszaros describes 68 proven patterns for making tests easier to write, understand, and maintain. He then shows you how to make them more robust and repeatable–and far more cost-effective.Loaded with information, this book feels like three books in one. The first part is a detailed tutorial on test automation that covers everything from test strategy to in-depth test coding. The second part, a catalog of 18 frequently encountered ""test smells,"" provides trouble-shooting guidelines to help you determine the root cause of problems and the most applicable patterns. The third part contains detailed descriptions of each pattern, including refactoring instructions illustrated by extensive code samples in multiple programming languages.Topics covered include Writing better tests–and writing them faster The four phases of automated tests: fixture setup, exercising the system under test, result verification, and fixture teardown Improving test coverage by isolating software from its environment using Test Stubs and Mock Objects Designing software for greater testability Using test ""smells"" (including code smells, behavior smells, and project smells) to spot problems and know when and how to eliminate them Refactoring tests for greater simplicity, robustness, and execution speedThis book will benefit developers, managers, and testers working with any agile or conventional development process, whether doing test-driven development or writing the tests last. While the patterns and smells are especially applicable to all members of the xUnit family, they also apply to next-generation behavior-driven development frameworks such as RSpec and JBehave and to other kinds of test automation tools, including recorded test tools and data-driven test tools such as Fit and FitNesse.Visual Summary of the Pattern Languageï Foreword Preface Acknowledgments Introduction Refactoring a TestPART I: The Narratives Chapter 1 A Brief Tour Chapter 2 Test Smells Chapter 3 Goals of Test Automation Chapter 4 Philosophy of Test Automation Chapter 5 Principles of Test Automation Chapter 6 Test Automation Strategy Chapter 7 xUnit Basics Chapter 8 Transient Fixture Management Chapter 9 Persistent Fixture Management Chapter 10 Result Verification Chapter 11 Using Test Doubles Chapter 12 Organizing Our Tests Chapter 13 Testing with Databases Chapter 14 A Roadmap to Effective Test Automation PART II: The Test Smellsï Chapter 15 Code Smells Chapter 16 Behavior Smells Chapter 17 Project Smells PART III: The Patternsï Chapter 18 Test Strategy Patterns Chapter 19 xUnit Basics Patterns Chapter 20 Fixture Setup Patterns Chapter 21 Result Verification Patterns Chapter 22 Fixture Teardown Patterns Chapter 23 Test Double Patterns Chapter 24 Test Organization Patterns Chapter 25 Database Patterns Chapter 26 Design-for-Testability Patterns Chapter 27 Value Patterns PART IV: Appendixes Appendix A Test Refactorings ï Appendix B xUnit Terminologyï Appendix C xUnit Family Members Appendix D Tools Appendix E Goals and Principles Appendix F Smells, Aliases, and Causes Appendix G Patterns, Aliases, and Variations Glossary Referencesï Indexï"		Meszaros, Gerard		"Automated testing is a cornerstone of agile development. An effective testing strategy will deliver new functionality more aggressively, accelerate user feedback, and improve quality. However, for many developers, creating effective automated tests is a unique and unfamiliar challenge.xUnit Test Patterns is the definitive guide to writing automated tests using xUnit, the most popular unit testing framework in use today. Agile coach and test automation expert Gerard Meszaros describes 68 proven patterns for making tests easier to write, understand, and maintain. He then shows you how to make them more robust and repeatable–and far more cost-effective.Loaded with information, this book feels like three books in one. The first part is a detailed tutorial on test automation that covers everything from test strategy to in-depth test coding. The second part, a catalog of 18 frequently encountered ""test smells,"" provides trouble-shooting guidelines to help you determine the root cause of problems and the most applicable patterns. The third part contains detailed descriptions of each pattern, including refactoring instructions illustrated by extensive code samples in multiple programming languages.Topics covered include Writing better tests–and writing them faster The four phases of automated tests: fixture setup, exercising the system under test, result verification, and fixture teardown Improving test coverage by isolating software from its environment using Test Stubs and Mock Objects Designing software for greater testability Using test ""smells"" (including code smells, behavior smells, and project smells) to spot problems and know when and how to eliminate them Refactoring tests for greater simplicity, robustness, and execution speedThis book will benefit developers, managers, and testers working with any agile or conventional development process, whether doing test-driven development or writing the tests last. While the patterns and smells are especially applicable to all members of the xUnit family, they also apply to next-generation behavior-driven development frameworks such as RSpec and JBehave and to other kinds of test automation tools, including recorded test tools and data-driven test tools such as Fit and FitNesse.Visual Summary of the Pattern Languageï Foreword Preface Acknowledgments Introduction Refactoring a TestPART I: The Narratives Chapter 1 A Brief Tour Chapter 2 Test Smells Chapter 3 Goals of Test Automation Chapter 4 Philosophy of Test Automation Chapter 5 Principles of Test Automation Chapter 6 Test Automation Strategy Chapter 7 xUnit Basics Chapter 8 Transient Fixture Management Chapter 9 Persistent Fixture Management Chapter 10 Result Verification Chapter 11 Using Test Doubles Chapter 12 Organizing Our Tests Chapter 13 Testing with Databases Chapter 14 A Roadmap to Effective Test Automation PART II: The Test Smellsï Chapter 15 Code Smells Chapter 16 Behavior Smells Chapter 17 Project Smells PART III: The Patternsï Chapter 18 Test Strategy Patterns Chapter 19 xUnit Basics Patterns Chapter 20 Fixture Setup Patterns Chapter 21 Result Verification Patterns Chapter 22 Fixture Teardown Patterns Chapter 23 Test Double Patterns Chapter 24 Test Organization Patterns Chapter 25 Database Patterns Chapter 26 Design-for-Testability Patterns Chapter 27 Value Patterns PART IV: Appendixes Appendix A Test Refactorings ï Appendix B xUnit Terminologyï Appendix C xUnit Family Members Appendix D Tools Appendix E Goals and Principles Appendix F Smells, Aliases, and Causes Appendix G Patterns, Aliases, and Variations Glossary Referencesï Indexï"				Excluded	Excluded	new_screen			2						
29	Behave	Visualizing data, encouraging change: Technical interventions in food purchasing	Baked Potato is a mobile web service geared at addressing the imbalance of power between those who market and those who consume food products. Food marketers rarely provide a detailed range of information about products that would allow consumers to understand how a product and its company connect to their cultural values. The main goal of this application is to connect people in a way that celebrates their differences and gives them agency by helping them make better decisions about their food purchases.	Behavior Driven Development;decision making;human-computer interaction;incentive design;social gaming	D. J. Sackey; N. Ullmann	2012 IEEE International Professional Communication Conference	Baked Potato is a mobile web service geared at addressing the imbalance of power between those who market and those who consume food products. Food marketers rarely provide a detailed range of information about products that would allow consumers to understand how a product and its company connect to their cultural values. The main goal of this application is to connect people in a way that celebrates their differences and gives them agency by helping them make better decisions about their food purchases.				Excluded	Excluded	new_screen			2						
30	Behave	Visualizing data, encouraging change: Technical interventions in food purchasing	Baked Potato is a mobile web service geared at addressing the imbalance of power between those who market and those who consume food products. Food marketers rarely provide a detailed range of information about products that would allow consumers to understand how a product and its company connect to their cultural values. The main goal of this application is to connect people in a way that celebrates their differences and gives them agency by helping them make better decisions about their food purchases. © 2012 IEEE.		Sackey D.J., Ullmann N.	IEEE International Professional Communication Conference	Baked Potato is a mobile web service geared at addressing the imbalance of power between those who market and those who consume food products. Food marketers rarely provide a detailed range of information about products that would allow consumers to understand how a product and its company connect to their cultural values. The main goal of this application is to connect people in a way that celebrates their differences and gives them agency by helping them make better decisions about their food purchases. © 2012 IEEE.				Excluded	Excluded	new_screen			2						
31	Behave	Behavior driven development for airborne software engineering	Behavior Driven Development (BDD) is a test driven development approach which aims at bridging the gap between the end-user and the software development. It promotes a semi-formal ubiquitous language for executable behavior specification and automated acceptance testing. The BDD infrastructure Cucumber and the language Gherkin have been established in many application domains. This paper discusses their utilization for airborne software engineering with an example application, Class C Terrain Awareness and Warning System, being developed using Rust language with Rust BDD infrastructure. © 2021, American Institute of Aeronautics and Astronautics Inc, AIAA. All rights reserved.		Zaeske W., Beck J., Torrens C., Durak U.	AIAA Scitech 2021 Forum	Behavior Driven Development (BDD) is a test driven development approach which aims at bridging the gap between the end-user and the software development. It promotes a semi-formal ubiquitous language for executable behavior specification and automated acceptance testing. The BDD infrastructure Cucumber and the language Gherkin have been established in many application domains. This paper discusses their utilization for airborne software engineering with an example application, Class C Terrain Awareness and Warning System, being developed using Rust language with Rust BDD infrastructure. © 2021, American Institute of Aeronautics and Astronautics Inc, AIAA. All rights reserved.				Included	Included	new_screen			2						
32	Behave	Predicting Co-Changes between Functionality Specifications and Source Code in Behavior Driven Development	Behavior Driven Development (BDD) is an agile approach that uses .feature files to describe the functionalities of a software system using natural language constructs (English-like phrases). Because of the English-like structure of .feature files, BDD specifications become an evolving documentation that helps all (even non-technical) stakeholders to understand and contribute to a software project. After specifying a .feature files, developers can use a BDD tool (e.g., Cucumber) to automatically generate test cases and implement the code of the specified functionality. However, maintaining traceability between .feature files and source code requires human efforts. Therefore, .feature files can be out-of-date, reducing the advantages of using BDD. Furthermore, existing research do not attempt to improve the traceability between .feature files and source code files. In this paper, we study the co-changes between .feature files and source code files to improve the traceability between .feature files and source code files. Due to the English-like syntax of .feature files, we use natural language processing to identify co-changes, with an accuracy of 79%. We study the characteristics of BDD co-changes and build random forest models to predict when a .feature files should be modified before committing a code change. The random forest model obtains an AUC of 0.77. The model can assist developers in identifying when a .feature files should be modified in code commits. Once the traceability is up-to-date, BDD developers can write test code more efficiently and keep the software documentation up-to-date.	behavior driven development; co-changes; empirical software engineering; traceability	Yang, Aidan Z. H.; da Costa, Daniel Alencar; Zou, Ying	Proceedings of the 16th International Conference on Mining Software Repositories	Behavior Driven Development (BDD) is an agile approach that uses .feature files to describe the functionalities of a software system using natural language constructs (English-like phrases). Because of the English-like structure of .feature files, BDD specifications become an evolving documentation that helps all (even non-technical) stakeholders to understand and contribute to a software project. After specifying a .feature files, developers can use a BDD tool (e.g., Cucumber) to automatically generate test cases and implement the code of the specified functionality. However, maintaining traceability between .feature files and source code requires human efforts. Therefore, .feature files can be out-of-date, reducing the advantages of using BDD. Furthermore, existing research do not attempt to improve the traceability between .feature files and source code files. In this paper, we study the co-changes between .feature files and source code files to improve the traceability between .feature files and source code files. Due to the English-like syntax of .feature files, we use natural language processing to identify co-changes, with an accuracy of 79%. We study the characteristics of BDD co-changes and build random forest models to predict when a .feature files should be modified before committing a code change. The random forest model obtains an AUC of 0.77. The model can assist developers in identifying when a .feature files should be modified in code commits. Once the traceability is up-to-date, BDD developers can write test code more efficiently and keep the software documentation up-to-date.				Included	Included	new_screen			2						
33	Behave	Theoretical Verification of Test Cases for Behavior Driven Development	Behavior Driven Development insists on generation of early test cases during requirements elicitation. These would form the basis for pseudo use cases in TDD. These early test cases for BDD, aka theoretical test cases, are developed using Named Entity Recognition approaches over expanded use cases. This paper proposes the algorithm for theoretical verification of obtaining the original reduced use case sequences from the obtained BDD test cases.	Reduced UC Sequence;Test cases;Usecase Dependency Graph	G. S. Mahalakshmi; V. Vani	2017 Second International Conference on Recent Trends and Challenges in Computational Models (ICRTCCM)	Behavior Driven Development insists on generation of early test cases during requirements elicitation. These would form the basis for pseudo use cases in TDD. These early test cases for BDD, aka theoretical test cases, are developed using Named Entity Recognition approaches over expanded use cases. This paper proposes the algorithm for theoretical verification of obtaining the original reduced use case sequences from the obtained BDD test cases.				Included	Included	new_screen			2						
34	Behave	A Model-Driven Approach for Behavior-Driven GUI Testing	Behavior-driven development (BDD) brings requirement specifications and their test cases closer together by using a ubiquitous language to describe requirements that are automatically mapped to test methods. Although industry-proven tools support this automated requirement mapping, the test methods need to be implemented manually. The approach presented in this paper transforms BDD-like requirement specifications and low fidelity graphical user interface (GUI) descriptions in the format of wireframes into automatically executable graphical user interface test cases. The requirement descriptions are defined in a domain-specific language (DSL) that obeys the rules of the ubiquitous language enhanced by references to screens and widgets in a graphical user interface model. The paper reports on a controlled AB/BA crossover experiment comparing the efficiency of our approach to the industry-proven JBehave tooling. The results show that the introduced approach on average takes 63% less time to specify automated tests and thereby diminishes the problem of graphical user interface test cases being expensive to write. The experimental results were supported by experience made applying the approach in three differently sized components at a large Swiss bank.	behavior-driven development; domain-specific language; GUI test case generation; model-driven engineering	Bünder, Hendrik; Kuchen, Herbert	Proceedings of the 34th ACM/SIGAPP Symposium on Applied Computing	Behavior-driven development (BDD) brings requirement specifications and their test cases closer together by using a ubiquitous language to describe requirements that are automatically mapped to test methods. Although industry-proven tools support this automated requirement mapping, the test methods need to be implemented manually. The approach presented in this paper transforms BDD-like requirement specifications and low fidelity graphical user interface (GUI) descriptions in the format of wireframes into automatically executable graphical user interface test cases. The requirement descriptions are defined in a domain-specific language (DSL) that obeys the rules of the ubiquitous language enhanced by references to screens and widgets in a graphical user interface model. The paper reports on a controlled AB/BA crossover experiment comparing the efficiency of our approach to the industry-proven JBehave tooling. The results show that the introduced approach on average takes 63% less time to specify automated tests and thereby diminishes the problem of graphical user interface test cases being expensive to write. The experimental results were supported by experience made applying the approach in three differently sized components at a large Swiss bank.				Included	Included	new_screen			2						
35	Behave	Evaluating the usage of predefined interactive behaviors for writing user stories: an empirical study with potential product owners	Behavior-driven development (BDD) has gained popularity in agile software development as a means of specifying user requirements through user stories and scenarios for interactive systems under construction. Templates for guiding the writing of such stories are widely employed and can be helpful to ensure that consistent information about the requirements is provided. With the aim of getting preliminary results about how product owners (POs) write their own user stories under a predefined template, we conducted a case study with potential POs at the department in charge of business trips in a French research institute. The participants were invited to write their own user stories to describe a feature they are used to perform. The resultant stories have been analyzed to check their adherence to a template including common interactive behaviors defined by an ontology for interactive systems. Although the participants have followed different specification strategies, we observed an overall high level of adherence to the proposed template (62.26%). The results also pointed out to a wide use of domain-dependent behaviors, with the interactive behaviors defined by the ontology being, to some extent, reproduced by the participants even without prior training in the adopted vocabulary. © 2019, Springer-Verlag London Ltd., part of Springer Nature.		Rocha Silva T., Winckler M., Bach C.	Cognition, Technology and Work	Behavior-driven development (BDD) has gained popularity in agile software development as a means of specifying user requirements through user stories and scenarios for interactive systems under construction. Templates for guiding the writing of such stories are widely employed and can be helpful to ensure that consistent information about the requirements is provided. With the aim of getting preliminary results about how product owners (POs) write their own user stories under a predefined template, we conducted a case study with potential POs at the department in charge of business trips in a French research institute. The participants were invited to write their own user stories to describe a feature they are used to perform. The resultant stories have been analyzed to check their adherence to a template including common interactive behaviors defined by an ontology for interactive systems. Although the participants have followed different specification strategies, we observed an overall high level of adherence to the proposed template (62.26%). The results also pointed out to a wide use of domain-dependent behaviors, with the interactive behaviors defined by the ontology being, to some extent, reproduced by the participants even without prior training in the adopted vocabulary. © 2019, Springer-Verlag London Ltd., part of Springer Nature.				Included	Included	new_screen			2						
36	Behave	On the Empirical Evaluation of BDD Scenarios Quality: Preliminary Findings of an Empirical Study	"Behavior-Driven Development (BDD) is a set of software engineering practices which uses a ubiquitous language, one that business and technical people can understand, to describe and model a system by a series of textual scenarios. However, we believe that the value of those textual scenarios is connected with how well they convey and document the details discussed by the team about the behaviors needed to fulfill customer needs. Thus, there is the need to define what would be a ""good"" BDD scenario and how to evaluate scenarios. On this research design paper, we describe a study designed to understand how known quality attributes from other types of requirements specifications (like use cases or user stories) can be used with BDD scenarios. We also report our preliminary findings after performing it with novice evaluators. Those findings indicate that some of those attributes can be used to support BDD scenarios assessments."	documentation quality;documentation evaluation;behavior-driven development;empirical study	G. Oliveira; S. Marczak	2017 IEEE 25th International Requirements Engineering Conference Workshops (REW)	"Behavior-Driven Development (BDD) is a set of software engineering practices which uses a ubiquitous language, one that business and technical people can understand, to describe and model a system by a series of textual scenarios. However, we believe that the value of those textual scenarios is connected with how well they convey and document the details discussed by the team about the behaviors needed to fulfill customer needs. Thus, there is the need to define what would be a ""good"" BDD scenario and how to evaluate scenarios. On this research design paper, we describe a study designed to understand how known quality attributes from other types of requirements specifications (like use cases or user stories) can be used with BDD scenarios. We also report our preliminary findings after performing it with novice evaluators. Those findings indicate that some of those attributes can be used to support BDD scenarios assessments."				Included	Included	new_screen			2						
37	Behave	On the Applicability of BDD in a Business Intelligence Project: Experience Report	Behavior-driven development (BDD) is a software development technique that in order to succeed relies heavily on the definition of clear acceptance criteria by software developers in the form of behavioral scenarios, later translated into acceptance tests. The adoption of BDD in Business Intelligence (BI) projects requires developers to have a broad acquaintance to business that often even customers themselves do not possess. This article presents an experience report on the use of BDD in the development of a large public health related BI project. Experience suggests that the use of BDD may not be appropriate for BI projects, especially during the early stages of development, when there is still insufficient clarity about business acceptance criteria. The need for broad maturity towards business understanding makes it complex to adopt the behavioral approach within the development process in projects of this nature.	behavior-driven development; business intelligence.; Software quality	Mello, Patrícia; Ximenes, Pablo; Lemos, Rousiany; Bessa, Ana Luíza; Cortés, Mariela I.; Rocha, Cleilton Lima	Proceedings of the 17th Brazilian Symposium on Software Quality	Behavior-driven development (BDD) is a software development technique that in order to succeed relies heavily on the definition of clear acceptance criteria by software developers in the form of behavioral scenarios, later translated into acceptance tests. The adoption of BDD in Business Intelligence (BI) projects requires developers to have a broad acquaintance to business that often even customers themselves do not possess. This article presents an experience report on the use of BDD in the development of a large public health related BI project. Experience suggests that the use of BDD may not be appropriate for BI projects, especially during the early stages of development, when there is still insufficient clarity about business acceptance criteria. The need for broad maturity towards business understanding makes it complex to adopt the behavioral approach within the development process in projects of this nature.				Included	Included	new_screen			2						
38	Behave	BHive: Behavior-Driven development meets B-Method	Behavior-Driven Development (BDD) is an “outside-in” approach to software development built upon semi-formal mediums for specifying the behavior of a system as it would be observed externally. Through the representation of a system as a collection of user stories and scenarios using BDD’s notation, practitioners automate acceptance tests using examples of desired behavior for the envisioned system. A formal model created in concert with BDD tests would provide valuable insight into test validity and enhance the visibility of the problem domain. This work called BHive builds upon the formal underpinnings of BDD scenarios by mapping their “Given,” “When,” and “Then” statements to “Precondition,” “Command,” and “Postcondition” constructs as introduced by Floyd-Hoare logic. We posit that this mapping allows for a B-Method representation to be created and that such a model is useful for exploring system behavior and exposing gaps in requirements and test plans. In this extension of previous work, we outline recent additions to BDD tooling required for the described integration, present a new strategy for test case generation from our approach, and expand on the benefits of the BHive approach to integrating formalism within a BDD project. © 2018, Springer International Publishing AG.		Carter J.D., Gardner W.B.	Advances in Intelligent Systems and Computing	Behavior-Driven Development (BDD) is an “outside-in” approach to software development built upon semi-formal mediums for specifying the behavior of a system as it would be observed externally. Through the representation of a system as a collection of user stories and scenarios using BDD’s notation, practitioners automate acceptance tests using examples of desired behavior for the envisioned system. A formal model created in concert with BDD tests would provide valuable insight into test validity and enhance the visibility of the problem domain. This work called BHive builds upon the formal underpinnings of BDD scenarios by mapping their “Given,” “When,” and “Then” statements to “Precondition,” “Command,” and “Postcondition” constructs as introduced by Floyd-Hoare logic. We posit that this mapping allows for a B-Method representation to be created and that such a model is useful for exploring system behavior and exposing gaps in requirements and test plans. In this extension of previous work, we outline recent additions to BDD tooling required for the described integration, present a new strategy for test case generation from our approach, and expand on the benefits of the BHive approach to integrating formalism within a BDD project. © 2018, Springer International Publishing AG.				Included	Included	new_screen			2						
39	Behave	Automatically generating tests from natural language descriptions of software behavior	"Behavior-Driven Development (BDD) is an emerging agile development approach where all stakeholders (including developers and customers) work together to write user stories in structured natural language to capture a software application's functionality in terms of required ""behaviors."" Developers can then manually write ""glue"" code so that these scenarios can be translated into executable software tests. This glue code represents individual steps within unit and acceptance test cases, and tools exist that automate the mapping from scenario descriptions to manually written code steps (typically using regular expressions). This paper takes the position that, instead of requiring programmers to write manual glue code, it is practical to convert natural language scenario descriptions into executable software tests fully automatically. To show feasibility, this paper presents preliminary results from a tool called Kirby that uses natural language processing techniques to automatically generate executable software tests from structured English scenario descriptions. Kirby relieves the developer from the laborious work of writing code for the individual steps described in scenarios, so that both developers and customers can both focus on the scenarios as pure behavior descriptions (understandable to all, not just programmers). Preliminary results from assessing the performance and accuracy of this technique are presented. Copyright © 2013 SCITEPRESS."		Kamalakar S., Edwards S.H., Dao T.M.	ENASE 2013 - Proceedings of the 8th International Conference on Evaluation of Novel Approaches to Software Engineering	"Behavior-Driven Development (BDD) is an emerging agile development approach where all stakeholders (including developers and customers) work together to write user stories in structured natural language to capture a software application's functionality in terms of required ""behaviors."" Developers can then manually write ""glue"" code so that these scenarios can be translated into executable software tests. This glue code represents individual steps within unit and acceptance test cases, and tools exist that automate the mapping from scenario descriptions to manually written code steps (typically using regular expressions). This paper takes the position that, instead of requiring programmers to write manual glue code, it is practical to convert natural language scenario descriptions into executable software tests fully automatically. To show feasibility, this paper presents preliminary results from a tool called Kirby that uses natural language processing techniques to automatically generate executable software tests from structured English scenario descriptions. Kirby relieves the developer from the laborious work of writing code for the individual steps described in scenarios, so that both developers and customers can both focus on the scenarios as pure behavior descriptions (understandable to all, not just programmers). Preliminary results from assessing the performance and accuracy of this technique are presented. Copyright © 2013 SCITEPRESS."				Included	Included	new_screen			2						
40	Behave	On the Understanding of How to Measure the Benefits of Behavior-Driven Development Adoption: Preliminary Literature Results from a Grey Literature Study	Behavior-Driven Development (BDD) is the integration of a ubiquitous language with Test-Driven Development and Automated Testing. From this integration, BDD supports software teams to build and deliver software. Although the perceived arguments of better results and of a more efficient development process, we still have no consolidated evidence of such benefits and how to measure them. Therefore, this long-term research aims to characterize how BDD adoption benefits can be measured. To do so, our research design includes a Multivocal Literature Review, composed of a Grey Literature to explore how industry tackles the topic and a Systematic Review to gather scientific evidences, followed of a Snowballing Review to supplement the search. Next, we will conduct empirical studies to characterize the topic from practice. This paper introduces our research and presents the results from our exploratory Grey Literature. We learned from these preliminary results that there are no models or frameworks defined to measure BDD adoption benefits but that teams indeed perceive improvements in software quality, communication, rework rates, among others. We also found that these teams also perceive that team engagement improves with the adoption of BDD and that although there is a certain cost (e.g., time and financial) involved, the investment pays off in the end. These results will inform the design of our Systematic Review and of our downstream empirical studies.	Behavior-Driven Development; BDD Adoption; Benefits; Grey Literature Review; Quality Measurement	Couto, Thiciane; Marczak, Sabrina; Gomes, Fabio	19th Brazilian Symposium on Software Quality	Behavior-Driven Development (BDD) is the integration of a ubiquitous language with Test-Driven Development and Automated Testing. From this integration, BDD supports software teams to build and deliver software. Although the perceived arguments of better results and of a more efficient development process, we still have no consolidated evidence of such benefits and how to measure them. Therefore, this long-term research aims to characterize how BDD adoption benefits can be measured. To do so, our research design includes a Multivocal Literature Review, composed of a Grey Literature to explore how industry tackles the topic and a Systematic Review to gather scientific evidences, followed of a Snowballing Review to supplement the search. Next, we will conduct empirical studies to characterize the topic from practice. This paper introduces our research and presents the results from our exploratory Grey Literature. We learned from these preliminary results that there are no models or frameworks defined to measure BDD adoption benefits but that teams indeed perceive improvements in software quality, communication, rework rates, among others. We also found that these teams also perceive that team engagement improves with the adoption of BDD and that although there is a certain cost (e.g., time and financial) involved, the investment pays off in the end. These results will inform the design of our Systematic Review and of our downstream empirical studies.				Excluded	Excluded	new_screen			2						
41	Behave	Behavior-Driven Development: Conference Tutorial	Behavior-driven development is a software development technique in which system behaviors are determined and made into test cases before the software itself is written. Benefits can include a richer and deeper understanding of system requirements in addition to making these requirements executable. Moreover, this technique helps guide software developers in knowing what to test as well as knowing how much to test. In this tutorial, we introduce the fundamentals of this approach, a language for expressing system behaviors, and explain how to use this technique effectively in the undergraduate computer science curriculum.		Kart, Michael	J. Comput. Sci. Coll.	Behavior-driven development is a software development technique in which system behaviors are determined and made into test cases before the software itself is written. Benefits can include a richer and deeper understanding of system requirements in addition to making these requirements executable. Moreover, this technique helps guide software developers in knowing what to test as well as knowing how much to test. In this tutorial, we introduce the fundamentals of this approach, a language for expressing system behaviors, and explain how to use this technique effectively in the undergraduate computer science curriculum.				Excluded	Excluded	new_screen			2						
42	Behave	A Study of the Characteristics of Behaviour Driven Development	Behaviour Driven Development (BDD) has gained increasing attention as an agile development approach in recent years. However, characteristics that constituite the BDD approach are not clearly defined. In this paper, we present a set of main BDD charactersitics identified through an analysis of relevant literature and current BDD toolkits. Our study can provide a basis for understanding BDD, as well as for extending the exisiting BDD toolkits or developing new ones.	Automated Acceptance Testing; Behaviour Driven Development; Test Driven Development; Ubiquitous Language	Solis, Carlos; Wang, Xiaofeng	Proceedings of the 2011 37th EUROMICRO Conference on Software Engineering and Advanced Applications	Behaviour Driven Development (BDD) has gained increasing attention as an agile development approach in recent years. However, characteristics that constituite the BDD approach are not clearly defined. In this paper, we present a set of main BDD charactersitics identified through an analysis of relevant literature and current BDD toolkits. Our study can provide a basis for understanding BDD, as well as for extending the exisiting BDD toolkits or developing new ones.				Included	Included	new_screen			2						
43	Behave	Behave nicely! automatic generation of code for behaviour driven development test suites	Behaviour driven development (BDD) has gained widespread use in the software industry. System specifications can be expressed as test scenarios, describing the circumstances, actions and expected outcomes. These scenarios are written in a structured natural language (Gherkin), with each step in the scenario associated with a corresponding step implementation function in the underlying programming language. A challenge recognised by industry is ensuring that the natural language scenarios, step implementation functions and underlying system implementation remain consistent with one another, requiring on-going maintenance effort as changes are made to a system. To address this, we have developed behave-nicely, a tool, for automatically generating step implementation functions from structured natural language steps, with the intention of eliminating the need for maintaining step implementation functions. We evaluated our approach on a sample of 20 white box and 50 black box projects using behaviour driven development, drawn from GitHub. Our results show that behave-nicely can generate step implementation functions for 80% of the white box and 17% of black box projects. We conclude that (a) there is significant potential for automating the process of code generation for BDD tests and (b) that the development of guidelines for writing tests in Gherkin would significantly improve the results. © 2019 IEEE.		Storer T., Bob R.	Proceedings - 19th IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM 2019	Behaviour driven development (BDD) has gained widespread use in the software industry. System specifications can be expressed as test scenarios, describing the circumstances, actions and expected outcomes. These scenarios are written in a structured natural language (Gherkin), with each step in the scenario associated with a corresponding step implementation function in the underlying programming language. A challenge recognised by industry is ensuring that the natural language scenarios, step implementation functions and underlying system implementation remain consistent with one another, requiring on-going maintenance effort as changes are made to a system. To address this, we have developed behave-nicely, a tool, for automatically generating step implementation functions from structured natural language steps, with the intention of eliminating the need for maintaining step implementation functions. We evaluated our approach on a sample of 20 white box and 50 black box projects using behaviour driven development, drawn from GitHub. Our results show that behave-nicely can generate step implementation functions for 80% of the white box and 17% of black box projects. We conclude that (a) there is significant potential for automating the process of code generation for BDD tests and (b) that the development of guidelines for writing tests in Gherkin would significantly improve the results. © 2019 IEEE.				Included	Included	new_screen			2						
44	Behave	Characterising the Quality of Behaviour Driven Development Specifications	Behaviour Driven Development (BDD) is an agile testing technique that enables software requirements to be specified as example interactions with the system, using structured natural language. While (in theory) being readable by non-technical stakeholders, the examples can also be executed against the code base to identify behaviours that are not yet correctly implemented. Writing good BDD suites, however, is challenging. A typical suite can contain hundreds of individual scenarios, that must correctly specify the system as a whole as well as individually. Despite much discussion amongst practitioners and in the blogosphere, as yet no formal definition of what makes for a high quality BDD suite has been given. To shed light on this, we surveyed BDD practitioners, asking for their opinions on the quality criteria that are important for BDD suites. We proposed, and asked for opinions on, four quality principles, and gave practitioners the option to add more principles of their own. This paper reports on the results of the survey, and presents an approach to defining BDD suite quality. © The Author(s) 2020.		Binamungu L.P., Embury S.M., Konstantinou N.	Lecture Notes in Business Information Processing	Behaviour Driven Development (BDD) is an agile testing technique that enables software requirements to be specified as example interactions with the system, using structured natural language. While (in theory) being readable by non-technical stakeholders, the examples can also be executed against the code base to identify behaviours that are not yet correctly implemented. Writing good BDD suites, however, is challenging. A typical suite can contain hundreds of individual scenarios, that must correctly specify the system as a whole as well as individually. Despite much discussion amongst practitioners and in the blogosphere, as yet no formal definition of what makes for a high quality BDD suite has been given. To shed light on this, we surveyed BDD practitioners, asking for their opinions on the quality criteria that are important for BDD suites. We proposed, and asked for opinions on, four quality principles, and gave practitioners the option to add more principles of their own. This paper reports on the results of the survey, and presents an approach to defining BDD suite quality. © The Author(s) 2020.				Included	Included	new_screen			2						
45	Behave	Behaviour-Driven Development of Foundational UML Components	Behaviour-Driven Development (BDD) focuses all development activities on the delivery of behaviours - what a system should do, described such that developers and domain experts speak the same language. BDD frameworks allow users to represent the required system behaviour as executable user stories and the acceptance criteria as executable scenarios attached to user stories. In this paper we define a UML profile that allows users to create executable Foundational UML (fUML) stories and scenarios. In order to easily construct scenarios we introduce a BDD model library which contains fUML activities for testing equalities and inclusions. We also present an Eclipse-based development tool that supports a BDD approach for developing fUML components. The tool provides developers a concrete syntax for defining executable scenarios, and automatically updates the project status based on verified delivered behaviorus.	acceptance criteria; behaviour-driven development; executable specification; executable UML; user story	Lazr, Ioan; Motogna, Simona; Pírv, Bazil	Electron. Notes Theor. Comput. Sci.	Behaviour-Driven Development (BDD) focuses all development activities on the delivery of behaviours - what a system should do, described such that developers and domain experts speak the same language. BDD frameworks allow users to represent the required system behaviour as executable user stories and the acceptance criteria as executable scenarios attached to user stories. In this paper we define a UML profile that allows users to create executable Foundational UML (fUML) stories and scenarios. In order to easily construct scenarios we introduce a BDD model library which contains fUML activities for testing equalities and inclusions. We also present an Eclipse-based development tool that supports a BDD approach for developing fUML components. The tool provides developers a concrete syntax for defining executable scenarios, and automatically updates the project status based on verified delivered behaviorus.				Included	Included	new_screen			2						
46	Behave	BHive: Towards Behaviour-Driven Development Supported by B-Method	"Behaviour-Driven Development (BDD) is an ""outside-in"" approach to software development built upon semi-formal mediums for specifying the behaviour of a system as it would be observed externally. Through the representation of a system as a collection of user stories and scenarios using BDD's notation, practitioners automate acceptance tests using examples of desired behaviour for the envisioned system. A formal model created in concert with BDD tests would provide valuable insight into test validity and enhance the visibility of the problem domain. This work called BHive builds upon the formal underpinnings of BDD scenarios by mapping their ""Given,"" ""When,"" and ""Then"" statements to ""Precondition,"" ""Command,"" and ""Postcondition"" constructs as introduced by Floyd-Hoare logic. We posit that this mapping allows for a B-Method representation to be created and that such a model is useful for exploring system behaviour and exposing gaps in requirements. We also outline extensions to BDD tooling required for the described integration and present benefits of the BHive approach to integrating formalism within a BDD project."		Carter, J.; Gardner, W. B.	2016 IEEE 17th International Conference on Information Reuse and Integration (IRI)	"Behaviour-Driven Development (BDD) is an ""outside-in"" approach to software development built upon semi-formal mediums for specifying the behaviour of a system as it would be observed externally. Through the representation of a system as a collection of user stories and scenarios using BDD's notation, practitioners automate acceptance tests using examples of desired behaviour for the envisioned system. A formal model created in concert with BDD tests would provide valuable insight into test validity and enhance the visibility of the problem domain. This work called BHive builds upon the formal underpinnings of BDD scenarios by mapping their ""Given,"" ""When,"" and ""Then"" statements to ""Precondition,"" ""Command,"" and ""Postcondition"" constructs as introduced by Floyd-Hoare logic. We posit that this mapping allows for a B-Method representation to be created and that such a model is useful for exploring system behaviour and exposing gaps in requirements. We also outline extensions to BDD tooling required for the described integration and present benefits of the BHive approach to integrating formalism within a BDD project."				Included	Included	new_screen			2						
47	Behave	Empirical Findings on BDD Story Parsing to Support Consistency Assurance between Requirements and Artifacts	Behaviour-Driven Development (BDD) stories have gained considerable attention in recent years as an effective way to specify and test user requirements in agile software development projects. External testing frameworks also allow developers to automate the execution of BDD stories and check whether a fully functional software system behaves as expected. However, other software artifacts may quite often lose synchronization with the stories, and many inconsistencies can arise with respect to requirements representation. This paper reports on preliminary empirical findings regarding the performance of two existing approaches in the literature intended to support consistency assurance between BDD stories and software artifacts. The first approach involves the parsing of BDD stories in order to identify conceptual elements to automatically generate consistent class diagrams, while the second approach seeks to identify interaction elements to automatically assess the consistency of task models and GUI prototypes. We report on the precision of these approaches when applied to a study with BDD stories previously written by Product Owners (POs). Based on the results, we also identify a set of challenges and opportunities for BDD stories in the consistency assurance of such artifacts.		Silva, Thiago Rocha; Fitzgerald, Brian	Evaluation and Assessment in Software Engineering	Behaviour-Driven Development (BDD) stories have gained considerable attention in recent years as an effective way to specify and test user requirements in agile software development projects. External testing frameworks also allow developers to automate the execution of BDD stories and check whether a fully functional software system behaves as expected. However, other software artifacts may quite often lose synchronization with the stories, and many inconsistencies can arise with respect to requirements representation. This paper reports on preliminary empirical findings regarding the performance of two existing approaches in the literature intended to support consistency assurance between BDD stories and software artifacts. The first approach involves the parsing of BDD stories in order to identify conceptual elements to automatically generate consistent class diagrams, while the second approach seeks to identify interaction elements to automatically assess the consistency of task models and GUI prototypes. We report on the precision of these approaches when applied to a study with BDD stories previously written by Product Owners (POs). Based on the results, we also identify a set of challenges and opportunities for BDD stories in the consistency assurance of such artifacts.				Included	Included	new_screen			2						
48	Behave	Blockchain smart contracts formalization: Approaches and challenges to address vulnerabilities	Blockchain as a distributed computing platform enables users to deploy pieces of software (known as smart contracts) for a wealth of next-generation decentralized applications without involving a trusted third-party. The advantages of smart contracts do, however, come at a price. As with most technologies, there are potential security threats, vulnerabilities and various other issues associated with smart contracts. Writing secure and safe smart contracts can be extremely difficult due to various business logics, as well as platform vulnerabilities and limitations. Formal methods have recently been advocated to mitigate these vulnerabilities. This paper aims to provide a first-time study on current formalization research on all smart contract-related platforms on blockchains, which is scarce in the literature. To this end, a timely and rigorous systematic review to examine the state-of-the-art research and achievements published between 2015 and July 2019 is provided. This study is based on a comprehensive review of a set of 35 research papers that have been extracted from eight major online digital databases. The results indicate that the most common formalization technique is theorem proving, which is most often used to verify security properties relating to smart contracts, while other techniques such as symbolic execution and model checking were also frequently used. These techniques were most commonly used to verify the functional correctness of smart contracts. From the language and automation point of views, there were 12 languages (domain specific/specification/general purpose) proposed or used for the formalization of smart contracts on blockchains, while 15 formal method-specific automated tools/frameworks were identified for mitigating various vulnerabilities of smart contracts. From the results of this work, we further highlight three open issues for future research in this emerging domain including: formal testing, automated verification of smart contracts, and domain specific languages (DSLs) for Ethereum. These issues suggest the need for additional, in-depth research. Our study also provides possible future research directions.	Blockchain, Smart contracts, Formal methods, Verification, Systematic review	Singh, Amritraj; Parizi, Reza M.; Zhang, Qi; Choo, Kim-Kwang Raymond; Dehghantanha, Ali	Computers & Security	Blockchain as a distributed computing platform enables users to deploy pieces of software (known as smart contracts) for a wealth of next-generation decentralized applications without involving a trusted third-party. The advantages of smart contracts do, however, come at a price. As with most technologies, there are potential security threats, vulnerabilities and various other issues associated with smart contracts. Writing secure and safe smart contracts can be extremely difficult due to various business logics, as well as platform vulnerabilities and limitations. Formal methods have recently been advocated to mitigate these vulnerabilities. This paper aims to provide a first-time study on current formalization research on all smart contract-related platforms on blockchains, which is scarce in the literature. To this end, a timely and rigorous systematic review to examine the state-of-the-art research and achievements published between 2015 and July 2019 is provided. This study is based on a comprehensive review of a set of 35 research papers that have been extracted from eight major online digital databases. The results indicate that the most common formalization technique is theorem proving, which is most often used to verify security properties relating to smart contracts, while other techniques such as symbolic execution and model checking were also frequently used. These techniques were most commonly used to verify the functional correctness of smart contracts. From the language and automation point of views, there were 12 languages (domain specific/specification/general purpose) proposed or used for the formalization of smart contracts on blockchains, while 15 formal method-specific automated tools/frameworks were identified for mitigating various vulnerabilities of smart contracts. From the results of this work, we further highlight three open issues for future research in this emerging domain including: formal testing, automated verification of smart contracts, and domain specific languages (DSLs) for Ethereum. These issues suggest the need for additional, in-depth research. Our study also provides possible future research directions.				Excluded	Excluded	new_screen			2						
49	Behave	Survey on blockchain based smart contracts: Applications, opportunities and challenges	Blockchain is one of the disruptive technical innovation in the recent computing paradigm. Many applications already notoriously hard and complex are fortunate to ameliorate the service with the blessings of blockchain and smart contracts. The decentralized and autonomous execution with in-built transparency of blockchain based smart contracts revolutionize most of the applications with optimum and effective functionality. The paper explores the significant applications which already benefited from the smart contracts. We also highlight the future potential of the blockchain based smart contracts in these applications perspective.	Blockchain, Smart contracts, Applications, DLT, Hyperledger Fabric, Ethereum, Corda, Stellar	Hewa, Tharaka; Ylianttila, Mika; Liyanage, Madhusanka	Journal of Network and Computer Applications	Blockchain is one of the disruptive technical innovation in the recent computing paradigm. Many applications already notoriously hard and complex are fortunate to ameliorate the service with the blessings of blockchain and smart contracts. The decentralized and autonomous execution with in-built transparency of blockchain based smart contracts revolutionize most of the applications with optimum and effective functionality. The paper explores the significant applications which already benefited from the smart contracts. We also highlight the future potential of the blockchain based smart contracts in these applications perspective.				Excluded	Excluded	new_screen			2						
50	Behave	End-to-End Automatic Business Process Validation	Business Process Testing is the act of validating that end-to-end transactions through enterprise systems continue to work correctly as the underlying packaged applications evolve. End-to-end automatic business process validation can be a challenging task, but an important way to check that business rules continue to work properly and that problems are detected and corrected as soon as possible. This paper presents the design of a test automation platform, ETAP-Pro, to test end-to-end business processes that aims to overcome some challenges in validating business processes.	Business Process Testing; End-to-end Process Testing; Model Based Testing; Software Testing	Paiva, Ana C.R.; Flores, Nuno H.; Faria, Joo P.; Marques, Jos M.G.	Procedia Comput. Sci.	Business Process Testing is the act of validating that end-to-end transactions through enterprise systems continue to work correctly as the underlying packaged applications evolve. End-to-end automatic business process validation can be a challenging task, but an important way to check that business rules continue to work properly and that problems are detected and corrected as soon as possible. This paper presents the design of a test automation platform, ETAP-Pro, to test end-to-end business processes that aims to overcome some challenges in validating business processes.				Excluded	Excluded	new_screen			2						
51	Behave	A Reusable Automated Acceptance Testing Architecture for Microservices in Behavior-Driven Development	Cloud Computing and Mobile Cloud Computing are reshaping the way applications are being developed and deployed due to their unique needs such as massive scalability, guaranteed fault tolerance, near zero downtime, etc. and also daunting challenges such as security, reliability, continuous deployment and update capability. Microservices architecture, where application is composed of a set of independently deployable services, is increasingly becoming popular due to its capability to address most of these needs and challenges. In recent years, the Behavior-Driven Development (BDD) has become one of the most popular agile software development processes, and frequently used in microservices development. The key to success of BDD is the executable acceptance tests that describe the expected behavior of a feature and its acceptance criteria in the form of scenarios using simple and business people readable syntax. The reusability, auditability, and maintainability become some of the major concerns when BDD test framework is applied for each microservice repository and no previous research addresses these concerns. In this paper, we present a reusable automated acceptance testing architecture to address all these concerns.	behavior-driven development; Gherkin; executable automated acceptance testing; functional testing; microservice	Rahman, Mazedur; Gao, Jerry	Proceedings of the 2015 IEEE Symposium on Service-Oriented System Engineering	Cloud Computing and Mobile Cloud Computing are reshaping the way applications are being developed and deployed due to their unique needs such as massive scalability, guaranteed fault tolerance, near zero downtime, etc. and also daunting challenges such as security, reliability, continuous deployment and update capability. Microservices architecture, where application is composed of a set of independently deployable services, is increasingly becoming popular due to its capability to address most of these needs and challenges. In recent years, the Behavior-Driven Development (BDD) has become one of the most popular agile software development processes, and frequently used in microservices development. The key to success of BDD is the executable acceptance tests that describe the expected behavior of a feature and its acceptance criteria in the form of scenarios using simple and business people readable syntax. The reusability, auditability, and maintainability become some of the major concerns when BDD test framework is applied for each microservice repository and no previous research addresses these concerns. In this paper, we present a reusable automated acceptance testing architecture to address all these concerns.				Excluded	Excluded	new_screen			2						
52	Behave	A reusable automated acceptance testing architecture for microservices in behavior-driven development	Cloud Computing and Mobile Cloud Computing are reshaping the way applications are being developed and deployed due to their unique needs such as massive scalability, guaranteed fault tolerance, near zero downtime, etc. and also daunting challenges such as security, reliability, continuous deployment and update capability. Microservices architecture, where application is composed of a set of independently deployable services, is increasingly becoming popular due to its capability to address most of these needs and challenges. In recent years, the Behavior-Driven Development (BDD) has become one of the most popular agile software development processes, and frequently used in microservices development. The key to success of BDD is the executable acceptance tests that describe the expected behavior of a feature and its acceptance criteria in the form of scenarios using simple and business people readable syntax. The reusability, auditability, and maintainability become some of the major concerns when BDD test framework is applied for each microservice repository and no previous research addresses these concerns. In this paper, we present a reusable automated acceptance testing architecture to address all these concerns. © 2015 IEEE.		Rahman M., Gao J.	Proceedings - 9th IEEE International Symposium on Service-Oriented System Engineering, IEEE SOSE 2015	Cloud Computing and Mobile Cloud Computing are reshaping the way applications are being developed and deployed due to their unique needs such as massive scalability, guaranteed fault tolerance, near zero downtime, etc. and also daunting challenges such as security, reliability, continuous deployment and update capability. Microservices architecture, where application is composed of a set of independently deployable services, is increasingly becoming popular due to its capability to address most of these needs and challenges. In recent years, the Behavior-Driven Development (BDD) has become one of the most popular agile software development processes, and frequently used in microservices development. The key to success of BDD is the executable acceptance tests that describe the expected behavior of a feature and its acceptance criteria in the form of scenarios using simple and business people readable syntax. The reusability, auditability, and maintainability become some of the major concerns when BDD test framework is applied for each microservice repository and no previous research addresses these concerns. In this paper, we present a reusable automated acceptance testing architecture to address all these concerns. © 2015 IEEE.				Included	Included	new_screen			2						
53	Behave	Generating educational mobile applications using UIDPs identified by artificial intelligence techniques	Commercial mobile devices vary in brand, size, and functionalities, but they all allow people to interact with educational applications. In software engineering, application development techniques, approaches, methodologies, and processes (e.g., BBD, FDD, RAD, DDD) are often time consuming, costly, or aim at expert developers – which implies that users outside the software development field (e.g., teachers) need great practice to become experienced application developers. This work proposes an artificial-intelligence-based process for generating educational mobile apps from freehand-generated images. The images’ design is based on User Interface Design Pattern (UIDP) representations. As a proof of concept, we introduce EduMatic, an application development tool. To test our process, we assessed Wiki-Comp, an application built with EduMatic, along with three other external educational applications: Khan Academy, Wiki encyclopedia, and Kiwix. According to the evaluation results, Wiki-Comp outstands in functionality, usability, and performance aspects.	Mobile development, Automatic code generation, Image processing, Educational apps, User interface design pattern	Sánchez-Morales, Laura Nely; Alor-Hernández, Giner; Rosales-Morales, Viviana Yarel; Cortes-Camarillo, Cesar Augusto; Sánchez-Cervantes, José Luis	Computer Standards & Interfaces	Commercial mobile devices vary in brand, size, and functionalities, but they all allow people to interact with educational applications. In software engineering, application development techniques, approaches, methodologies, and processes (e.g., BBD, FDD, RAD, DDD) are often time consuming, costly, or aim at expert developers – which implies that users outside the software development field (e.g., teachers) need great practice to become experienced application developers. This work proposes an artificial-intelligence-based process for generating educational mobile apps from freehand-generated images. The images’ design is based on User Interface Design Pattern (UIDP) representations. As a proof of concept, we introduce EduMatic, an application development tool. To test our process, we assessed Wiki-Comp, an application built with EduMatic, along with three other external educational applications: Khan Academy, Wiki encyclopedia, and Kiwix. According to the evaluation results, Wiki-Comp outstands in functionality, usability, and performance aspects.				Excluded	Excluded	new_screen			2						
54	Behave	Concurrent development and verification of an all-software baseband for satellite ground operations	Communication systems are adopting all-software architectures, because of their scalability, extensibility, flexibility, and cost-effectiveness. This paper introduces a concurrent approach to the development and verification of baseband systems for satellite ground operations based on the behaviour-driven development methodology. The open-source GNU Radio development kit is used for developing the software-defined radio baseband signal processing, as well as simulating the satellite and realistic channel impairments. The system performance at the end shows deviations of less than 1 dB with respect to the ideal performance and the Green Book standards specified by the Consultative Committee for Space Data Systems. © 2019 John Wiley & Sons, Ltd.		Mwakyanjala M.B., Nieto-Peroy C., Emami M.R., van de Beek J.	International Journal of Satellite Communications and Networking	Communication systems are adopting all-software architectures, because of their scalability, extensibility, flexibility, and cost-effectiveness. This paper introduces a concurrent approach to the development and verification of baseband systems for satellite ground operations based on the behaviour-driven development methodology. The open-source GNU Radio development kit is used for developing the software-defined radio baseband signal processing, as well as simulating the satellite and realistic channel impairments. The system performance at the end shows deviations of less than 1 dB with respect to the ideal performance and the Green Book standards specified by the Consultative Committee for Space Data Systems. © 2019 John Wiley & Sons, Ltd.				Included	Included	new_screen			2						
55	Behave	Automation Support for Mobile App Quality Assurance – A Tool Landscape	Competitive pressure in app stores, as well as direct and transparent feedback of app store reviews have resulted in an increased demand for outstanding app quality and user experience. At the same time, reduced time-to-market, decreased budgets and time available for quality assurance, and careful user experience design have to be considered. In response, an enormous market for mobile app quality and user experience measurement tools has grown around the mobile app store ecosystems. Developers following lean and agile development approaches continuously produce new features and ready-to-ship software increments. In those settings, budgets for evaluation and familiarization into new tools are very limited. Currently there are alone more than 28 tools and frameworks for functional test automation and more than 16 different device clouds available. For most of the software developing companies, it is impossible to evaluate and test all of them. In this paper, we present a classification in order to help navigation through the mobile app quality tools landscape for easier selection and more targeted evaluation of tools.	Mobile Applications, Quality, Quality Assurance, User Experience	Braun, Susanne; Elberzhager, Frank; Holl, Konstantin	Procedia Computer Science	Competitive pressure in app stores, as well as direct and transparent feedback of app store reviews have resulted in an increased demand for outstanding app quality and user experience. At the same time, reduced time-to-market, decreased budgets and time available for quality assurance, and careful user experience design have to be considered. In response, an enormous market for mobile app quality and user experience measurement tools has grown around the mobile app store ecosystems. Developers following lean and agile development approaches continuously produce new features and ready-to-ship software increments. In those settings, budgets for evaluation and familiarization into new tools are very limited. Currently there are alone more than 28 tools and frameworks for functional test automation and more than 16 different device clouds available. For most of the software developing companies, it is impossible to evaluate and test all of them. In this paper, we present a classification in order to help navigation through the mobile app quality tools landscape for easier selection and more targeted evaluation of tools.				Excluded	Excluded	new_screen			2						
56	Behave	CIaaS - computational intelligence as a service with Athena	Computational Intelligence (CI) is a sub-branch of Artificial Intelligence (AI) that focus on studying adaptive mechanisms to enable intelligent behavior in complex environments. CI techniques have been successful in solving complex problems in many different knowledge areas. However, despite their usefulness, developing solutions based on CI techniques is not a trivial activity, since it involves the codification/adaptation of algorithms to specific context and problems. In this paper, we present and validate through a quasi-experiment a new paradigm to develop CI-based solutions using a more mature version of Athena (2.0): Computational Intelligence as a Service (CIaaS). Using this tool, both researchers and practitioners can design and evaluate CI-based solutions by dragging and dropping components in a visual environment, in a cloud-based platform. The results of the quasi-experiment suggest that our approach can help researchers to design and evaluate CI-based systems in a simple, reliable and fast way.	Computational intelligence, Tool, Visual programming	Oliveira, Pedro; Santos Neto, Pedro; Britto, Ricardo; Rabêlo, Ricardo; Braga, Ronyerison; Souza, Matheus	Computer Languages, Systems & Structures	Computational Intelligence (CI) is a sub-branch of Artificial Intelligence (AI) that focus on studying adaptive mechanisms to enable intelligent behavior in complex environments. CI techniques have been successful in solving complex problems in many different knowledge areas. However, despite their usefulness, developing solutions based on CI techniques is not a trivial activity, since it involves the codification/adaptation of algorithms to specific context and problems. In this paper, we present and validate through a quasi-experiment a new paradigm to develop CI-based solutions using a more mature version of Athena (2.0): Computational Intelligence as a Service (CIaaS). Using this tool, both researchers and practitioners can design and evaluate CI-based solutions by dragging and dropping components in a visual environment, in a cloud-based platform. The results of the quasi-experiment suggest that our approach can help researchers to design and evaluate CI-based systems in a simple, reliable and fast way.				Excluded	Excluded	new_screen			2						
57	Behave	Optimizing stock assessment workflows by applying software development methodology	Considering that stock assessment requires iterative work including exploratory calculations and discussion, efficiency in completing projects is the key to a successful contribution to stock management. However, if the production speed of each process of the project is inconsistent, a faster process may be worse than a slower process because a large amount of information produced by a faster process induces human error. To coordinate the production speed of each process, we applied software development methodology to the whole assessment project, including small important tasks such as scenario selection, debugging, and yearly updates. First, we established a continuously integrated (CI) document system that monitors project files and triggers report generation when they are updated. The system is composed of four cloud services: a code hosting service, a cloud computing service, cloud storage, and a website hosting service. Because of the CI document system, all the following iterative work was reflected in the report without creating any unused output. The workflow benefited not only from the collaboration but also from the maintainability of the project because work progress and the discussion remained visible for all collaborators. We discuss the effectiveness of a workflow by Lean manufacturing that allows us to focus on the essential problem of the assessment project.	Continuous integration, Lean manufacturing, Open science, Reproducible research	Hayashi, Akira; Ichinokawa, Momoko; Kinoshita, Junji; Manabe, Akihiro	Fisheries Research	Considering that stock assessment requires iterative work including exploratory calculations and discussion, efficiency in completing projects is the key to a successful contribution to stock management. However, if the production speed of each process of the project is inconsistent, a faster process may be worse than a slower process because a large amount of information produced by a faster process induces human error. To coordinate the production speed of each process, we applied software development methodology to the whole assessment project, including small important tasks such as scenario selection, debugging, and yearly updates. First, we established a continuously integrated (CI) document system that monitors project files and triggers report generation when they are updated. The system is composed of four cloud services: a code hosting service, a cloud computing service, cloud storage, and a website hosting service. Because of the CI document system, all the following iterative work was reflected in the report without creating any unused output. The workflow benefited not only from the collaboration but also from the maintainability of the project because work progress and the discussion remained visible for all collaborators. We discuss the effectiveness of a workflow by Lean manufacturing that allows us to focus on the essential problem of the assessment project.				Excluded	Excluded	new_screen			2						
58	Behave	Architecting with microservices: A systematic mapping study	Context A microservice architecture is composed of a set of small services, each running in its own process and communicating with lightweight mechanisms. Many aspects on architecting with microservices are still unexplored and existing research is still far from being crispy clear. Objective We aim at identifying, classifying, and evaluating the state of the art on architecting with microservices from the following perspectives: publication trends, focus of research, and potential for industrial adoption. Method We apply the systematic mapping methodology. We rigorously selected 103 primary studies and we defined and applied a classification framework to them for extracting key information for subsequent analysis. We synthesized the obtained data and produced a clear overview of the state of the art. Results This work contributes with (i) a classification framework for research studies on architecting with microservices, (ii) a systematic map of current research of the field, (iii) an evaluation of the potential for industrial adoption of research results, and (iv) a discussion of emerging findings and implications for future research. Conclusion This study provides a solid, rigorous, and replicable picture of the state of the art on architecting with microservices. Its results can benefit both researchers and practitioners of the field.	Microservices, Software architecture, Systematic mapping study	Di Francesco, Paolo; Lago, Patricia; Malavolta, Ivano	Journal of Systems and Software	Context A microservice architecture is composed of a set of small services, each running in its own process and communicating with lightweight mechanisms. Many aspects on architecting with microservices are still unexplored and existing research is still far from being crispy clear. Objective We aim at identifying, classifying, and evaluating the state of the art on architecting with microservices from the following perspectives: publication trends, focus of research, and potential for industrial adoption. Method We apply the systematic mapping methodology. We rigorously selected 103 primary studies and we defined and applied a classification framework to them for extracting key information for subsequent analysis. We synthesized the obtained data and produced a clear overview of the state of the art. Results This work contributes with (i) a classification framework for research studies on architecting with microservices, (ii) a systematic map of current research of the field, (iii) an evaluation of the potential for industrial adoption of research results, and (iv) a discussion of emerging findings and implications for future research. Conclusion This study provides a solid, rigorous, and replicable picture of the state of the art on architecting with microservices. Its results can benefit both researchers and practitioners of the field.				Excluded	Excluded	new_screen			2						
59	Behave	Design from detail: Analyzing data from a global day of coderetreat	Context Coderetreats are reflective communities of practice, where participants congregate informally to apply their coding abilities to a clearly defined problem setting with the aim of developing their software design skills. One of these events is the global day of coderetreat (GDCR) involving more than two thousand software developers worldwide. Objective The GDCR provided an opportunity to explore the ways that the coderetreat activity is perceived by its participants as a medium for reflective practice, and to suggest ways that we can enhance the design of coderetreats for improving both the experience and learning outcomes. Method We conducted both quantitative and qualitative surveys from a number of participants in the GDCR to understand how software developers hone their craft in the context of a coderetreat. Results Our study indicates that future coderetreats, particularly those that are likely to attract less experienced developers, should consider providing more structural scaffolding to the initial processes of test driven development. Conclusion We believe that all coderetreats should more explicitly encourage practice and reflection on the four elements of simple design. We suggest a more sustained approach throughout the coderetreat with provision of more structural scaffolding. Accordingly, we have derived a set of recommended practices to make the coderetreat more effective for less experienced developers.	Global day of coderetreat, Survey, Simple design, Test driven development, Legacy coderetreat	Parsons, David; Susnjak, Teo; Mathrani, Anuradha	Information and Software Technology	Context Coderetreats are reflective communities of practice, where participants congregate informally to apply their coding abilities to a clearly defined problem setting with the aim of developing their software design skills. One of these events is the global day of coderetreat (GDCR) involving more than two thousand software developers worldwide. Objective The GDCR provided an opportunity to explore the ways that the coderetreat activity is perceived by its participants as a medium for reflective practice, and to suggest ways that we can enhance the design of coderetreats for improving both the experience and learning outcomes. Method We conducted both quantitative and qualitative surveys from a number of participants in the GDCR to understand how software developers hone their craft in the context of a coderetreat. Results Our study indicates that future coderetreats, particularly those that are likely to attract less experienced developers, should consider providing more structural scaffolding to the initial processes of test driven development. Conclusion We believe that all coderetreats should more explicitly encourage practice and reflection on the four elements of simple design. We suggest a more sustained approach throughout the coderetreat with provision of more structural scaffolding. Accordingly, we have derived a set of recommended practices to make the coderetreat more effective for less experienced developers.				Excluded	Excluded	new_screen			2						
60	Behave	A multi-case study of agile requirements engineering and the use of test cases as requirements	Context It is an enigma that agile projects can succeed ‘without requirements’ when weak requirements engineering is a known cause for project failures. While agile development projects often manage well without extensive requirements test cases are commonly viewed as requirements and detailed requirements are documented as test cases. Objective We have investigated this agile practice of using test cases as requirements to understand how test cases can support the main requirements activities, and how this practice varies. Method We performed an iterative case study at three companies and collected data through 14 interviews and two focus groups. Results The use of test cases as requirements poses both benefits and challenges when eliciting, validating, verifying, and managing requirements, and when used as a documented agreement. We have identified five variants of the test-cases-as-requirements practice, namely de facto, behaviour-driven, story-test driven, stand-alone strict and stand-alone manual for which the application of the practice varies concerning the time frame of requirements documentation, the requirements format, the extent to which the test cases are a machine executable specification and the use of tools which provide specific support for the practice of using test cases as requirements. Conclusions The findings provide empirical insight into how agile development projects manage and communicate requirements. The identified variants of the practice of using test cases as requirements can be used to perform in-depth investigations into agile requirements engineering. Practitioners can use the provided recommendations as a guide in designing and improving their agile requirements practices based on project characteristics such as number of stakeholders and rate of change. © 2016 Elsevier B.V.		Bjarnason E., Unterkalmsteiner M., Borg M., Engström E.	Information and Software Technology	Context It is an enigma that agile projects can succeed ‘without requirements’ when weak requirements engineering is a known cause for project failures. While agile development projects often manage well without extensive requirements test cases are commonly viewed as requirements and detailed requirements are documented as test cases. Objective We have investigated this agile practice of using test cases as requirements to understand how test cases can support the main requirements activities, and how this practice varies. Method We performed an iterative case study at three companies and collected data through 14 interviews and two focus groups. Results The use of test cases as requirements poses both benefits and challenges when eliciting, validating, verifying, and managing requirements, and when used as a documented agreement. We have identified five variants of the test-cases-as-requirements practice, namely de facto, behaviour-driven, story-test driven, stand-alone strict and stand-alone manual for which the application of the practice varies concerning the time frame of requirements documentation, the requirements format, the extent to which the test cases are a machine executable specification and the use of tools which provide specific support for the practice of using test cases as requirements. Conclusions The findings provide empirical insight into how agile development projects manage and communicate requirements. The identified variants of the practice of using test cases as requirements can be used to perform in-depth investigations into agile requirements engineering. Practitioners can use the provided recommendations as a guide in designing and improving their agile requirements practices based on project characteristics such as number of stakeholders and rate of change. © 2016 Elsevier B.V.				Excluded	Excluded	new_screen			2						
61	Behave	NLP-assisted software testing: A systematic mapping of the literature	Context To reduce manual effort of extracting test cases from natural-language requirements, many approaches based on Natural Language Processing (NLP) have been proposed in the literature. Given the large amount of approaches in this area, and since many practitioners are eager to utilize such techniques, it is important to synthesize and provide an overview of the state-of-the-art in this area. Objective Our objective is to summarize the state-of-the-art in NLP-assisted software testing which could benefit practitioners to potentially utilize those NLP-based techniques. Moreover, this can benefit researchers in providing an overview of the research landscape. Method To address the above need, we conducted a survey in the form of a systematic literature mapping (classification). After compiling an initial pool of 95 papers, we conducted a systematic voting, and our final pool included 67 technical papers. Results This review paper provides an overview of the contribution types presented in the papers, types of NLP approaches used to assist software testing, types of required input requirements, and a review of tool support in this area. Some key results we have detected are: (1) only four of the 38 tools (11%) presented in the papers are available for download; (2) a larger ratio of the papers (30 of 67) provided a shallow exposure to the NLP aspects (almost no details). Conclusion This paper would benefit both practitioners and researchers by serving as an “index” to the body of knowledge in this area. The results could help practitioners utilizing the existing NLP-based techniques; this in turn reduces the cost of test-case design and decreases the amount of human resources spent on test activities. After sharing this review with some of our industrial collaborators, initial insights show that this review can indeed be useful and beneficial to practitioners.	Software testing, Natural Language Processing (NLP), Systematic literature mapping, Systematic literature review	Garousi, Vahid; Bauer, Sara; Felderer, Michael	Information and Software Technology	Context To reduce manual effort of extracting test cases from natural-language requirements, many approaches based on Natural Language Processing (NLP) have been proposed in the literature. Given the large amount of approaches in this area, and since many practitioners are eager to utilize such techniques, it is important to synthesize and provide an overview of the state-of-the-art in this area. Objective Our objective is to summarize the state-of-the-art in NLP-assisted software testing which could benefit practitioners to potentially utilize those NLP-based techniques. Moreover, this can benefit researchers in providing an overview of the research landscape. Method To address the above need, we conducted a survey in the form of a systematic literature mapping (classification). After compiling an initial pool of 95 papers, we conducted a systematic voting, and our final pool included 67 technical papers. Results This review paper provides an overview of the contribution types presented in the papers, types of NLP approaches used to assist software testing, types of required input requirements, and a review of tool support in this area. Some key results we have detected are: (1) only four of the 38 tools (11%) presented in the papers are available for download; (2) a larger ratio of the papers (30 of 67) provided a shallow exposure to the NLP aspects (almost no details). Conclusion This paper would benefit both practitioners and researchers by serving as an “index” to the body of knowledge in this area. The results could help practitioners utilizing the existing NLP-based techniques; this in turn reduces the cost of test-case design and decreases the amount of human resources spent on test activities. After sharing this review with some of our industrial collaborators, initial insights show that this review can indeed be useful and beneficial to practitioners.				Excluded	Excluded	new_screen			2						
62	Behave	Speed up BDD for Safety Verification in Agile Development: A Partially Replicated Controlled Experiment	Context: Agile development has aroused interest in developing safety-critical systems. Problem statement: However, an increasingly changing architecture makes traditional safety assurance, especially safety analysis and verification, difficult to work. Recently, we proposed STPA-BDD (System-Theoretic Process Analysis-Behaviour Driven Development) for safety analysis and verification in agile development. It showed a good communication effectiveness in a controlled experiment with 44 undergraduate students. However, productivity, test thoroughness and fault detection effectiveness show no statistically significant difference in comparison with UAT (User Acceptance Testing). Objective: In this article, we aim to speed up STPA-BDD through improving productivity, test thoroughness and fault detection effectiveness of STPA-BDD. We develop a semi-automated tool to speed up BDD for safety verification. Method: We evaluate the semi-automated tool concerning productivity, test thoroughness and fault detection effectiveness in a replicated experiment with 11 additional undergraduate students by comparing them with the results from 22 students in the original experiment. Results: The results turn out that productivity is more than 7 times greater, while test thoroughness is more than 1.5 times greater and fault detection effectiveness is more than 2 times greater by using this semi-automated tool than without using it. Conclusion: BDD for safety verification has beed sped up by using this semi-automated tool. Using professionals instead of students as subjects might provide a clearer impact.	agile development; safety verification; controlled experiment	Wang, Yang; Degutis, Daniel Ryan; Wagner, Stefan	Proceedings of the 19th International Conference on Agile Software Development: Companion	Context: Agile development has aroused interest in developing safety-critical systems. Problem statement: However, an increasingly changing architecture makes traditional safety assurance, especially safety analysis and verification, difficult to work. Recently, we proposed STPA-BDD (System-Theoretic Process Analysis-Behaviour Driven Development) for safety analysis and verification in agile development. It showed a good communication effectiveness in a controlled experiment with 44 undergraduate students. However, productivity, test thoroughness and fault detection effectiveness show no statistically significant difference in comparison with UAT (User Acceptance Testing). Objective: In this article, we aim to speed up STPA-BDD through improving productivity, test thoroughness and fault detection effectiveness of STPA-BDD. We develop a semi-automated tool to speed up BDD for safety verification. Method: We evaluate the semi-automated tool concerning productivity, test thoroughness and fault detection effectiveness in a replicated experiment with 11 additional undergraduate students by comparing them with the results from 22 students in the original experiment. Results: The results turn out that productivity is more than 7 times greater, while test thoroughness is more than 1.5 times greater and fault detection effectiveness is more than 2 times greater by using this semi-automated tool than without using it. Conclusion: BDD for safety verification has beed sped up by using this semi-automated tool. Using professionals instead of students as subjects might provide a clearer impact.				Included	Included	new_screen			2						
63	Behave	Combining STPA and BDD for safety analysis and verification in agile development: A controlled experiment	Context: Agile development is in widespread use, even in safety-critical domains. Motivation: However, there is a lack of an appropriate safety analysis and verification method in agile development. Objective: In this paper, we investigate the use of Behavior Driven Development (BDD) instead of standard User Acceptance Testing (UAT) for safety verification with System-Theoretic Process Analysis (STPA) for safety analysis in agile development. Method: We evaluate the effect of this combination in a controlled experiment with 44 students in terms of productivity, test thoroughness, fault detection effectiveness and communication effectiveness. Results: The results show that BDD is more effective for safety verification regarding the impact on communication effectiveness than standard UAT, whereas productivity, test thoroughness and fault detection effectiveness show no statistically significant difference in our controlled experiment. Conclusion: The combination of BDD and STPA seems promising with an enhancement on communication, but its impact needs more research. © The Author(s) 2018.		Wang Y., Wagner S.	Lecture Notes in Business Information Processing	Context: Agile development is in widespread use, even in safety-critical domains. Motivation: However, there is a lack of an appropriate safety analysis and verification method in agile development. Objective: In this paper, we investigate the use of Behavior Driven Development (BDD) instead of standard User Acceptance Testing (UAT) for safety verification with System-Theoretic Process Analysis (STPA) for safety analysis in agile development. Method: We evaluate the effect of this combination in a controlled experiment with 44 students in terms of productivity, test thoroughness, fault detection effectiveness and communication effectiveness. Results: The results show that BDD is more effective for safety verification regarding the impact on communication effectiveness than standard UAT, whereas productivity, test thoroughness and fault detection effectiveness show no statistically significant difference in our controlled experiment. Conclusion: The combination of BDD and STPA seems promising with an enhancement on communication, but its impact needs more research. © The Author(s) 2018.				Included	Included	new_screen			2						
64	Behave	Is business domain language support beneficial for creating test case specifications: A controlled experiment	Context: Behavior Driven Development (BDD), widely used in modern software development, enables easy creation of acceptance test case specifications and serves as a communication basis between business- and technical-oriented stakeholders. BDD is largely facilitated through simple domain specific languages (DSL) and usually restricted to technical test domain concepts. Integrating business domain concepts to implement a ubiquitous language for all members of the development team is an appealing test language improvement issue. But the integration of business domain concepts into BDD toolkits has so far not been investigated. Objective: The objective of the study presented in this paper is to examine whether supporting the ubiquitous language features inside a DSL, by extending a DSL with business domain concepts, is beneficial over using a DSL without those concepts. In the context of the study, benefit is measured in terms of perceived quality, creation time and length of the created test case specifications. In addition, we analyze if participants feel supported when using predefined business domain concepts. Method: We investigate the creation of test case specifications, similar to BDD, in a controlled student experiment performed with graduate students based on a novel platform for DSL experimentation. The experiment was carried out by two groups, each solving a similar comparable test case, one with the simple DSL, the other one with the DSL that includes business domain concepts. A crossover design was chosen for evaluating the perceived quality of the resulting specifications. Results: Our experiment indicates that a business domain aware language allows significant faster creation of documents without lowering the perceived quality. Subjects felt better supported by the DSL with business concepts. Conclusion: Based on our findings we propose that existing BDD toolkits could be further improved by integrating business domain concepts.	Domain Specific Languages (DSL), Behavior driven development, Controlled experiment, Software testing, Student experiment	Häser, Florian; Felderer, Michael; Breu, Ruth	Information and Software Technology	Context: Behavior Driven Development (BDD), widely used in modern software development, enables easy creation of acceptance test case specifications and serves as a communication basis between business- and technical-oriented stakeholders. BDD is largely facilitated through simple domain specific languages (DSL) and usually restricted to technical test domain concepts. Integrating business domain concepts to implement a ubiquitous language for all members of the development team is an appealing test language improvement issue. But the integration of business domain concepts into BDD toolkits has so far not been investigated. Objective: The objective of the study presented in this paper is to examine whether supporting the ubiquitous language features inside a DSL, by extending a DSL with business domain concepts, is beneficial over using a DSL without those concepts. In the context of the study, benefit is measured in terms of perceived quality, creation time and length of the created test case specifications. In addition, we analyze if participants feel supported when using predefined business domain concepts. Method: We investigate the creation of test case specifications, similar to BDD, in a controlled student experiment performed with graduate students based on a novel platform for DSL experimentation. The experiment was carried out by two groups, each solving a similar comparable test case, one with the simple DSL, the other one with the DSL that includes business domain concepts. A crossover design was chosen for evaluating the perceived quality of the resulting specifications. Results: Our experiment indicates that a business domain aware language allows significant faster creation of documents without lowering the perceived quality. Subjects felt better supported by the DSL with business concepts. Conclusion: Based on our findings we propose that existing BDD toolkits could be further improved by integrating business domain concepts.				Included	Included	new_screen			2						
65	Behave	Supporting refactoring of BDD specifications—An empirical study	Context: Behavior-driven development (BDD) is a variant of test-driven development where specifications are described in a structured domain-specific natural language. Although refactoring is a crucial activity of BDD, little research is available on the topic. Objective: To support practitioners in refactoring BDD specifications by (1) proposing semi-automated approaches to identify refactoring candidates; (2) defining refactoring techniques for BDD specifications; and (3) evaluating the proposed identification approaches in an industry context. Method: Using Action Research, we have developed an approach for identifying refactoring candidates in BDD specifications based on two measures of similarity and applied the approach in two projects of a large software organization. The accuracy of the measures for identifying refactoring candidates was then evaluated against an approach based on machine learning and a manual approach based on practitioner perception. Results: We proposed two measures of similarity to support the identification of refactoring candidates in a BDD specification base; (1) normalized compression similarity (NCS) and (2) similarity ratio (SR). A semi-automated approach based on NCS and SR was developed and applied to two industrial cases to identify refactoring candidates. Our results show that our approach can identify candidates for refactoring 6o times faster than a manual approach. Our results furthermore showed that our measures accurately identified refactoring candidates compared with a manual identification by software practitioners and outperformed an ML-based text classification approach. We also described four types of refactoring techniques applicable to BDD specifications; merging candidates, restructuring candidates, deleting duplicates, and renaming specification titles. Conclusion: Our results show that NCS and SR can help practitioners in accurately identifying BDD specifications that are suitable candidates for refactoring, which also decreases the time for identifying refactoring candidates.	Refactoring, Normalized Compression Distance (NCD), Normalized Compression Similarity (NCS), Reuse, Similarity ratio (SR), BDD, Behavior-driven development, Specifications, Testing	Irshad, Mohsin; Börstler, Jürgen; Petersen, Kai	Information and Software Technology	Context: Behavior-driven development (BDD) is a variant of test-driven development where specifications are described in a structured domain-specific natural language. Although refactoring is a crucial activity of BDD, little research is available on the topic. Objective: To support practitioners in refactoring BDD specifications by (1) proposing semi-automated approaches to identify refactoring candidates; (2) defining refactoring techniques for BDD specifications; and (3) evaluating the proposed identification approaches in an industry context. Method: Using Action Research, we have developed an approach for identifying refactoring candidates in BDD specifications based on two measures of similarity and applied the approach in two projects of a large software organization. The accuracy of the measures for identifying refactoring candidates was then evaluated against an approach based on machine learning and a manual approach based on practitioner perception. Results: We proposed two measures of similarity to support the identification of refactoring candidates in a BDD specification base; (1) normalized compression similarity (NCS) and (2) similarity ratio (SR). A semi-automated approach based on NCS and SR was developed and applied to two industrial cases to identify refactoring candidates. Our results show that our approach can identify candidates for refactoring 6o times faster than a manual approach. Our results furthermore showed that our measures accurately identified refactoring candidates compared with a manual identification by software practitioners and outperformed an ML-based text classification approach. We also described four types of refactoring techniques applicable to BDD specifications; merging candidates, restructuring candidates, deleting duplicates, and renaming specification titles. Conclusion: Our results show that NCS and SR can help practitioners in accurately identifying BDD specifications that are suitable candidates for refactoring, which also decreases the time for identifying refactoring candidates.				Excluded	Excluded	new_screen			2						
66	Behave	B-Refactoring: Automatic test code refactoring to improve dynamic analysis	Context: Developers design test suites to verify that software meets its expected behaviors. Many dynamic analysis techniques are performed on the exploitation of execution traces from test cases. In practice, one test case may imply various behaviors. However, the execution of a test case only yields one trace, which can hide the others. Objective: In this article, we propose a new technique of test code refactoring, called B-Refactoring. The idea behind B-Refactoring is to split a test case into small test fragments, which cover a simpler part of the control flow to provide better support for dynamic analysis. Method: For a given dynamic analysis technique, B-Refactoring monitors the execution of test cases and constructs small test cases without loss of the testability. We apply B-Refactoring to assist two existing analysis tasks: automatic repair of if-condition bugs and automatic analysis of exception contracts. Results: Experimental results show that B-Refactoring can effectively improve the execution traces of the test suite. Real-world bugs that could not be previously fixed with the original test suites are fixed after applying B-Refactoring; meanwhile, exception contracts are better verified via applying B-Refactoring to original test suites. Conclusions: We conclude that applying B-Refactoring improves the execution traces of test cases for dynamic analysis. This improvement can enhance existing dynamic analysis tasks.		Xuan, Jifeng; Cornu, Benoit; Martinez, Matias; Baudry, Benoit; Seinturier, Lionel; Monperrus, Martin	Information and Software Technology	Context: Developers design test suites to verify that software meets its expected behaviors. Many dynamic analysis techniques are performed on the exploitation of execution traces from test cases. In practice, one test case may imply various behaviors. However, the execution of a test case only yields one trace, which can hide the others. Objective: In this article, we propose a new technique of test code refactoring, called B-Refactoring. The idea behind B-Refactoring is to split a test case into small test fragments, which cover a simpler part of the control flow to provide better support for dynamic analysis. Method: For a given dynamic analysis technique, B-Refactoring monitors the execution of test cases and constructs small test cases without loss of the testability. We apply B-Refactoring to assist two existing analysis tasks: automatic repair of if-condition bugs and automatic analysis of exception contracts. Results: Experimental results show that B-Refactoring can effectively improve the execution traces of the test suite. Real-world bugs that could not be previously fixed with the original test suites are fixed after applying B-Refactoring; meanwhile, exception contracts are better verified via applying B-Refactoring to original test suites. Conclusions: We conclude that applying B-Refactoring improves the execution traces of test cases for dynamic analysis. This improvement can enhance existing dynamic analysis tasks.				Excluded	Excluded	new_screen			2						
67	Behave	Adapting Behavior Driven Development (BDD) for large-scale software systems	Context: Large-scale software projects require interaction between many stakeholders. Behavior-driven development (BDD) facilitates collaboration between stakeholders, and an adapted BDD process can help improve cooperation in a large-scale project. Objective: The objective of this study is to propose and empirically evaluate a BDD based process adapted for large-scale projects. Method: A technology transfer model was used to propose a BDD based process for large-scale projects. We conducted six workshop sessions to understand the challenges and benefits of BDD. Later, an industrial evaluation was performed for the process with the help of practitioners. Results: From our investigations, understanding of a business aspect of requirements, their improved quality, a guide to system-level use-cases, reuse of artifacts, and help for test organization are found as benefits of BDD. Practitioners identified the following challenges: specification and ownership of behaviors, adoption of new tools, the software projects’ scale, and versioning of behaviors. We proposed a process to address these challenges and evaluated the process with the help of practitioners. Conclusion: The evaluation proved that BDD could be adapted and used to facilitate interaction in large-scale software projects in the software industry. The feedback from the practitioners helped in improving the proposed process.	Behavior-driven, Large-scale, BDD, Software processes, System of systems	Irshad, Mohsin; Britto, Ricardo; Petersen, Kai	Journal of Systems and Software	Context: Large-scale software projects require interaction between many stakeholders. Behavior-driven development (BDD) facilitates collaboration between stakeholders, and an adapted BDD process can help improve cooperation in a large-scale project. Objective: The objective of this study is to propose and empirically evaluate a BDD based process adapted for large-scale projects. Method: A technology transfer model was used to propose a BDD based process for large-scale projects. We conducted six workshop sessions to understand the challenges and benefits of BDD. Later, an industrial evaluation was performed for the process with the help of practitioners. Results: From our investigations, understanding of a business aspect of requirements, their improved quality, a guide to system-level use-cases, reuse of artifacts, and help for test organization are found as benefits of BDD. Practitioners identified the following challenges: specification and ownership of behaviors, adoption of new tools, the software projects’ scale, and versioning of behaviors. We proposed a process to address these challenges and evaluated the process with the help of practitioners. Conclusion: The evaluation proved that BDD could be adapted and used to facilitate interaction in large-scale software projects in the software industry. The feedback from the practitioners helped in improving the proposed process.				Included	Included	new_screen			2						
68	Behave	Design, monitoring, and testing of microservices systems: The practitioners’ perspective	Context: Microservices Architecture (MSA) has received significant attention in the software industry. However, little empirical evidence exists on design, monitoring, and testing of microservices systems. Objective: This research aims to gain a deep understanding of how microservices systems are designed, monitored, and tested in the industry. Methods: A mixed-methods study was conducted with 106 survey responses and 6 interviews from microservices practitioners. Results: The main findings are: (1) a combination of domain-driven design and business capability is the most used strategy to decompose an application into microservices, (2) over half of the participants used architecture evaluation and architecture implementation when designing microservices systems, (3) API gateway and Backend for frontend patterns are the most used MSA patterns, (4) resource usage and load balancing as monitoring metrics, log management and exception tracking as monitoring practices are widely used, (5) unit and end-to-end testing are the most used testing strategies, and (6) the complexity of microservices systems poses challenges for their design, monitoring, and testing, for which there are no dedicated solutions. Conclusions: Our findings reveal that more research is needed to (1) deal with microservices complexity at the design level, (2) handle security in microservices systems, and (3) address the monitoring and testing challenges through dedicated solutions.	Microservices architecture, Design, Monitoring, Testing, Industrial survey	Waseem, Muhammad; Liang, Peng; Shahin, Mojtaba; Di Salle, Amleto; Márquez, Gastón	Journal of Systems and Software	Context: Microservices Architecture (MSA) has received significant attention in the software industry. However, little empirical evidence exists on design, monitoring, and testing of microservices systems. Objective: This research aims to gain a deep understanding of how microservices systems are designed, monitored, and tested in the industry. Methods: A mixed-methods study was conducted with 106 survey responses and 6 interviews from microservices practitioners. Results: The main findings are: (1) a combination of domain-driven design and business capability is the most used strategy to decompose an application into microservices, (2) over half of the participants used architecture evaluation and architecture implementation when designing microservices systems, (3) API gateway and Backend for frontend patterns are the most used MSA patterns, (4) resource usage and load balancing as monitoring metrics, log management and exception tracking as monitoring practices are widely used, (5) unit and end-to-end testing are the most used testing strategies, and (6) the complexity of microservices systems poses challenges for their design, monitoring, and testing, for which there are no dedicated solutions. Conclusions: Our findings reveal that more research is needed to (1) deal with microservices complexity at the design level, (2) handle security in microservices systems, and (3) address the monitoring and testing challenges through dedicated solutions.				Excluded	Excluded	new_screen			2						
69	Behave	Big Data analytics in Agile software development: A systematic mapping study	Context: Over the last decade, Agile methods have changed the software development process in an unparalleled way and with the increasing popularity of Big Data, optimizing development cycles through data analytics is becoming a commodity. Objective: Although a myriad of research exists on software analytics as well as on Agile software development (ASD) practice on itself, there exists no systematic overview of the research done on ASD from a data analytics perspective. Therefore, the objective of this work is to make progress by linking ASD with Big Data analytics (BDA). Method: As the primary method to find relevant literature on the topic, we performed manual search and snowballing on papers published between 2011 and 2019. Results: In total, 88 primary studies were selected and analyzed. Our results show that BDA is employed throughout the whole ASD lifecycle. The results reveal that data-driven software development is focused on the following areas: code repository analytics, defects/bug fixing, testing, project management analytics, and application usage analytics. Conclusions: As BDA and ASD are fast-developing areas, improving the productivity of software development teams is one of the most important objectives BDA is facing in the industry. This study provides scholars with information about the state of software analytics research and the current trends as well as applications in the business environment. Whereas, thanks to this literature review, practitioners should be able to understand better how to obtain actionable insights from their software artifacts and on which aspects of data analytics to focus when investing in such initiatives.	Agile software development, Software analytics, Data analytics, Machine learning, Artificial intelligence, Literature review	Biesialska, Katarzyna; Franch, Xavier; Muntés-Mulero, Victor	Information and Software Technology	Context: Over the last decade, Agile methods have changed the software development process in an unparalleled way and with the increasing popularity of Big Data, optimizing development cycles through data analytics is becoming a commodity. Objective: Although a myriad of research exists on software analytics as well as on Agile software development (ASD) practice on itself, there exists no systematic overview of the research done on ASD from a data analytics perspective. Therefore, the objective of this work is to make progress by linking ASD with Big Data analytics (BDA). Method: As the primary method to find relevant literature on the topic, we performed manual search and snowballing on papers published between 2011 and 2019. Results: In total, 88 primary studies were selected and analyzed. Our results show that BDA is employed throughout the whole ASD lifecycle. The results reveal that data-driven software development is focused on the following areas: code repository analytics, defects/bug fixing, testing, project management analytics, and application usage analytics. Conclusions: As BDA and ASD are fast-developing areas, improving the productivity of software development teams is one of the most important objectives BDA is facing in the industry. This study provides scholars with information about the state of software analytics research and the current trends as well as applications in the business environment. Whereas, thanks to this literature review, practitioners should be able to understand better how to obtain actionable insights from their software artifacts and on which aspects of data analytics to focus when investing in such initiatives.				Excluded	Excluded	new_screen			2						
70	Behave	Documentation of Quality Requirements in Agile Software Development	Context: Quality requirements (QRs) have a significant role in the success of software projects. In agile software development (ASD), where working software is valued over comprehensive documentation, QRs are often under-specified or not documented. Consequently, they may be handled improperly and result in degraded software quality and increased maintenance costs. Investigating the documentation of QRs in ASD, would provide evidence on existing practices, tools and aspects considered in ASD that other practitioners might utilize to improve documentation and management of QRs in ASD. Although there are some studies examining documentation in ASD, those that specifically investigate the documentation of QRs in depth are lacking.Method: we conducted a multiple case study by interviewing 15 practitioners of four ASD cases, to provide empirical evidence on documentation of QRs in ASD. We also run workshops with two of the cases, to identify important aspects that ASD practitioners consider when documenting QRs in requirements management repositories.Result and conclusions: ASD companies approach documentation of QRs to fit the needs of their context. They used tools, backlogs, iterative prototypes, and artifacts such as epic, and stories to document QRs, or utilized face-face communication without documenting QRs. We observed that documentation of QRs in ASD is affected by factors such as context (e.g. product domain, and size) and the experience of practitioners. Some tools used to document QRs also enhanced customer collaboration, enabling customers report and document QRs. Aspects such as levels of abstraction, the traceability of QRs, optimal details of information of QRs and verification and validation are deemed important when documenting QRs in ASD requirements management repositories.	documentation; agile software development; non-functional requirements; Quality requirement	Behutiye, Woubshet; Seppänen, Pertti; Rodríguez, Pilar; Oivo, Markku	Proceedings of the Evaluation and Assessment in Software Engineering	Context: Quality requirements (QRs) have a significant role in the success of software projects. In agile software development (ASD), where working software is valued over comprehensive documentation, QRs are often under-specified or not documented. Consequently, they may be handled improperly and result in degraded software quality and increased maintenance costs. Investigating the documentation of QRs in ASD, would provide evidence on existing practices, tools and aspects considered in ASD that other practitioners might utilize to improve documentation and management of QRs in ASD. Although there are some studies examining documentation in ASD, those that specifically investigate the documentation of QRs in depth are lacking.Method: we conducted a multiple case study by interviewing 15 practitioners of four ASD cases, to provide empirical evidence on documentation of QRs in ASD. We also run workshops with two of the cases, to identify important aspects that ASD practitioners consider when documenting QRs in requirements management repositories.Result and conclusions: ASD companies approach documentation of QRs to fit the needs of their context. They used tools, backlogs, iterative prototypes, and artifacts such as epic, and stories to document QRs, or utilized face-face communication without documenting QRs. We observed that documentation of QRs in ASD is affected by factors such as context (e.g. product domain, and size) and the experience of practitioners. Some tools used to document QRs also enhanced customer collaboration, enabling customers report and document QRs. Aspects such as levels of abstraction, the traceability of QRs, optimal details of information of QRs and verification and validation are deemed important when documenting QRs in ASD requirements management repositories.				Excluded	Excluded	new_screen			2						
71	Behave	Improving the delivery cycle: A multiple-case study of the toolchains in Finnish software intensive enterprises	Context: Software companies seek to gain benefit from agile development approaches in order to meet evolving market needs without losing their innovative edge. Agile practices emphasize frequent releases with the help of an automated toolchain from code to delivery. Objective: We investigate, which tools are used in software delivery, what are the reasons omitting certain parts of the toolchain and what implications toolchains have on how rapidly software gets delivered to customers. Method: We present a multiple-case study of the toolchains currently in use in Finnish software-intensive organizations interested in improving their delivery frequency. We conducted qualitative semi-structured interviews in 18 case organizations from various software domains. The interviewees were key representatives of their organization, considering delivery activities. Results: Commodity tools, such as version control and continuous integration, were used in almost every organization. Modestly used tools, such as UI testing and performance testing, were more distinctly missing from some organizations. Uncommon tools, such as artifact repository and acceptance testing, were used only in a minority of the organizations. Tool usage is affected by the state of current workflows, manual work and relevancy of tools. Organizations whose toolchains were more automated and contained fewer manual steps were able to deploy software more rapidly. Conclusions: There is variety in the need for tool support in different development steps as there are domain-specific differences in the goals of the case organizations. Still, a well-founded toolchain supports speedy delivery of new software.	Continuous deployment, Continuous delivery, Software development tools, Deployment pipeline, Agile software development	Mäkinen, Simo; Leppänen, Marko; Kilamo, Terhi; Mattila, Anna-Liisa; Laukkanen, Eero; Pagels, Max; Männistö, Tomi	Information and Software Technology	Context: Software companies seek to gain benefit from agile development approaches in order to meet evolving market needs without losing their innovative edge. Agile practices emphasize frequent releases with the help of an automated toolchain from code to delivery. Objective: We investigate, which tools are used in software delivery, what are the reasons omitting certain parts of the toolchain and what implications toolchains have on how rapidly software gets delivered to customers. Method: We present a multiple-case study of the toolchains currently in use in Finnish software-intensive organizations interested in improving their delivery frequency. We conducted qualitative semi-structured interviews in 18 case organizations from various software domains. The interviewees were key representatives of their organization, considering delivery activities. Results: Commodity tools, such as version control and continuous integration, were used in almost every organization. Modestly used tools, such as UI testing and performance testing, were more distinctly missing from some organizations. Uncommon tools, such as artifact repository and acceptance testing, were used only in a minority of the organizations. Tool usage is affected by the state of current workflows, manual work and relevancy of tools. Organizations whose toolchains were more automated and contained fewer manual steps were able to deploy software more rapidly. Conclusions: There is variety in the need for tool support in different development steps as there are domain-specific differences in the goals of the case organizations. Still, a well-founded toolchain supports speedy delivery of new software.				Excluded	Excluded	new_screen			2						
72	Behave	Demystifying the adoption of behavior-driven development in open source projects	Context:Behavior-Driven Development (BDD) features the capability, through appropriate domain-specific languages, of specifying acceptance test cases and making them executable. The availability of frameworks such as Cucumber or RSpec makes the application of BDD possible in practice. However, it is unclear to what extent developers use such frameworks, and whether they use them for actually performing BDD, or, instead, for other purposes such as unit testing. Objective:In this paper, we conduct an empirical investigation about the use of BDD tools in open source, and how, when a BDD tool is in place, BDD specifications co-evolve with source code. Method:Our investigation includes three different phases: (i) a large-scale analysis to understand the extent to which BDD frameworks are used in 50,000 popular open-source projects written in five programming languages; (ii) a study on the co-evolution of scenarios, fixtures and production code in a sample of 20 Ruby projects, through the Granger’s causality test, and (iii) a survey with 31 developers to understand how they use BDD frameworks. Results:Results of the study indicate that  ≃  27% of the sampled projects use BDD frameworks, with a prevalence in Ruby projects (68%). In about 37% of the cases, we found a co-evolution between scenarios/fixtures and production code. Specifically, changes to scenarios and fixtures often happen together or after changes to source code. Moreover, survey respondents indicate that, while they understand the intended purpose of BDD frameworks, most of them write tests while/after coding rather than strictly applying BDD. Conclusions:Even if the BDD frameworks usage is widespread among open source projects, in many cases they are used for different purposes such as unit testing activities. This mainly happens because developers felt BDD remains quite effort-prone, and its application goes beyond the simple adoption of a BDD framework.	Behavior-driven development, Acceptance testing, Empirical study, Co-evolution	Zampetti, Fiorella; Di Sorbo, Andrea; Visaggio, Corrado Aaron; Canfora, Gerardo; Di Penta, Massimiliano	Information and Software Technology	Context:Behavior-Driven Development (BDD) features the capability, through appropriate domain-specific languages, of specifying acceptance test cases and making them executable. The availability of frameworks such as Cucumber or RSpec makes the application of BDD possible in practice. However, it is unclear to what extent developers use such frameworks, and whether they use them for actually performing BDD, or, instead, for other purposes such as unit testing. Objective:In this paper, we conduct an empirical investigation about the use of BDD tools in open source, and how, when a BDD tool is in place, BDD specifications co-evolve with source code. Method:Our investigation includes three different phases: (i) a large-scale analysis to understand the extent to which BDD frameworks are used in 50,000 popular open-source projects written in five programming languages; (ii) a study on the co-evolution of scenarios, fixtures and production code in a sample of 20 Ruby projects, through the Granger’s causality test, and (iii) a survey with 31 developers to understand how they use BDD frameworks. Results:Results of the study indicate that  ≃  27% of the sampled projects use BDD frameworks, with a prevalence in Ruby projects (68%). In about 37% of the cases, we found a co-evolution between scenarios/fixtures and production code. Specifically, changes to scenarios and fixtures often happen together or after changes to source code. Moreover, survey respondents indicate that, while they understand the intended purpose of BDD frameworks, most of them write tests while/after coding rather than strictly applying BDD. Conclusions:Even if the BDD frameworks usage is widespread among open source projects, in many cases they are used for different purposes such as unit testing activities. This mainly happens because developers felt BDD remains quite effort-prone, and its application goes beyond the simple adoption of a BDD framework.				Included	Included	new_screen			2						
73	Behave	A Multi-Case Study of Agile Requirements Engineering and the Use of Test Cases as Requirements	ContextIt is an enigma that agile projects can succeed 'without requirements' when weak requirements engineering is a known cause for project failures. While agile development projects often manage well without extensive requirements test cases are commonly viewed as requirements and detailed requirements are documented as test cases. ObjectiveWe have investigated this agile practice of using test cases as requirements to understand how test cases can support the main requirements activities, and how this practice varies. MethodWe performed an iterative case study at three companies and collected data through 14 interviews and two focus groups. ResultsThe use of test cases as requirements poses both benefits and challenges when eliciting, validating, verifying, and managing requirements, and when used as a documented agreement. We have identified five variants of the test-cases-as-requirements practice, namely de facto, behaviour-driven, story-test driven, stand-alone strict and stand-alone manual for which the application of the practice varies concerning the time frame of requirements documentation, the requirements format, the extent to which the test cases are a machine executable specification and the use of tools which provide specific support for the practice of using test cases as requirements. ConclusionsThe findings provide empirical insight into how agile development projects manage and communicate requirements. The identified variants of the practice of using test cases as requirements can be used to perform in-depth investigations into agile requirements engineering. Practitioners can use the provided recommendations as a guide in designing and improving their agile requirements practices based on project characteristics such as number of stakeholders and rate of change.	Acceptance test; Agile development; Behaviour-driven development; Case study; Empirical software engineering; Requirements; Test-driven development; Test-first development; Testing	Bjarnason, Elizabeth; Unterkalmsteiner, Michael; Borg, Markus; Engström, Emelie	Inf. Softw. Technol.	ContextIt is an enigma that agile projects can succeed 'without requirements' when weak requirements engineering is a known cause for project failures. While agile development projects often manage well without extensive requirements test cases are commonly viewed as requirements and detailed requirements are documented as test cases. ObjectiveWe have investigated this agile practice of using test cases as requirements to understand how test cases can support the main requirements activities, and how this practice varies. MethodWe performed an iterative case study at three companies and collected data through 14 interviews and two focus groups. ResultsThe use of test cases as requirements poses both benefits and challenges when eliciting, validating, verifying, and managing requirements, and when used as a documented agreement. We have identified five variants of the test-cases-as-requirements practice, namely de facto, behaviour-driven, story-test driven, stand-alone strict and stand-alone manual for which the application of the practice varies concerning the time frame of requirements documentation, the requirements format, the extent to which the test cases are a machine executable specification and the use of tools which provide specific support for the practice of using test cases as requirements. ConclusionsThe findings provide empirical insight into how agile development projects manage and communicate requirements. The identified variants of the practice of using test cases as requirements can be used to perform in-depth investigations into agile requirements engineering. Practitioners can use the provided recommendations as a guide in designing and improving their agile requirements practices based on project characteristics such as number of stakeholders and rate of change.				Included	Included	new_screen			2						
74	Behave	Continuous Delivery: Overcoming adoption challenges	Continuous Delivery (CD) is a relatively new software development approach. Companies that have adopted CD have reported significant benefits. Motivated by these benefits, many companies would like to adopt CD. However, adopting CD can be very challenging for a number of reasons, such as obtaining buy-in from a wide range of stakeholders whose goals may seemingly be different from—or even conflict with—our own; gaining sustained support in a dynamic complex enterprise environment; maintaining an application development team's momentum when their application's migration to CD requires an additional strenuous effort over a long period of time; and so on. To help overcome the adoption challenges, I present six strategies: (1) selling CD as a painkiller; (2) establishing a dedicated team with multi-disciplinary members; (3) continuous delivery of continuous delivery; (4) starting with the easy but important applications; (5) visual CD pipeline skeleton; (6) expert drop. These strategies were derived from four years of experience in implementing CD at a multi-billion-euro company. Additionally, our experience led to the identification of eight further challenges for research. The information contributes toward building a body of knowledge for CD adoption.	Agile Software Development, Continuous Delivery, Continuous Deployment, Continuous Software Engineering, DevOps, Adoption	Chen, Lianping	Journal of Systems and Software	Continuous Delivery (CD) is a relatively new software development approach. Companies that have adopted CD have reported significant benefits. Motivated by these benefits, many companies would like to adopt CD. However, adopting CD can be very challenging for a number of reasons, such as obtaining buy-in from a wide range of stakeholders whose goals may seemingly be different from—or even conflict with—our own; gaining sustained support in a dynamic complex enterprise environment; maintaining an application development team's momentum when their application's migration to CD requires an additional strenuous effort over a long period of time; and so on. To help overcome the adoption challenges, I present six strategies: (1) selling CD as a painkiller; (2) establishing a dedicated team with multi-disciplinary members; (3) continuous delivery of continuous delivery; (4) starting with the easy but important applications; (5) visual CD pipeline skeleton; (6) expert drop. These strategies were derived from four years of experience in implementing CD at a multi-billion-euro company. Additionally, our experience led to the identification of eight further challenges for research. The information contributes toward building a body of knowledge for CD adoption.				Excluded	Excluded	new_screen			2						
75	Behave	Transition towards Continuous Delivery in the Healthcare Domain	Continuous Delivery is meanwhile well-established in many parts of the software industry. In a transition towards continuous delivery in the healthcare domain, there are a number of additional challenges that should be addressed. We present how we have addressed some of these challenges and highlight some potential research topics that could be addressed in this space to make further progress in this important area. Although our focus is on the healthcare domain, the approach and the research topics are applicable also to a broad range of other application domains.	behavior-driven development; agile; continuous delivery; deployment pipeline; domain-driven design; pair-programming; test automation; test-driven development	Giorgi, Fabio; Paulisch, Frances	Proceedings of the 41st International Conference on Software Engineering: Software Engineering in Practice	Continuous Delivery is meanwhile well-established in many parts of the software industry. In a transition towards continuous delivery in the healthcare domain, there are a number of additional challenges that should be addressed. We present how we have addressed some of these challenges and highlight some potential research topics that could be addressed in this space to make further progress in this important area. Although our focus is on the healthcare domain, the approach and the research topics are applicable also to a broad range of other application domains.				Excluded	Excluded	new_screen			2						
76	Behave	Transition Towards Continuous Delivery in the Healthcare Domain	Continuous Delivery is meanwhile well-established in many parts of the software industry. In a transition towards continuous delivery in the healthcare domain, there are a number of additional challenges that should be addressed. We present how we have addressed some of these challenges and highlight some potential research topics that could be addressed in this space to make further progress in this important area. Although our focus is on the healthcare domain, the approach and the research topics are applicable also to a broad range of other application domains.	continuous delivery, agile, test-driven development, behavior-driven development, domain-driven design, test automation, pair-programming, deployment pipeline	F. Giorgi; F. Paulisch	2019 IEEE/ACM 41st International Conference on Software Engineering: Software Engineering in Practice (ICSE-SEIP)	Continuous Delivery is meanwhile well-established in many parts of the software industry. In a transition towards continuous delivery in the healthcare domain, there are a number of additional challenges that should be addressed. We present how we have addressed some of these challenges and highlight some potential research topics that could be addressed in this space to make further progress in this important area. Although our focus is on the healthcare domain, the approach and the research topics are applicable also to a broad range of other application domains.				Included	Included	new_screen			2						
77	Behave	Learning Behavior-Driven Development with JavaScript	Create powerful yet simple-to-code BDD test suites in JavaScript using the most popular tools in the community About This BookMaster the most popular testing tools in the JavaScript ecosystem, such as CucumberJS, Mocha, SinonJS, and more.Learn how Behavior-driven development can help you to write software that is more modular and has less defects.Avoid common mistakes in testing, simplify your test suites, and make them more maintainable using a very pragmatic approach to BDD.Who This Book Is ForTThis book is ideal for any JavaScript developer who is interested in producing well-tested code. If you have no prior experience with testing, Node.js, or any other tool, do not worry, as they will be explained from scratch. In Detail JavaScript is not only widely used to create attractive user interfaces for the Web, but with the advent of Node.js, it is also becoming a very popular and powerful language to write server-side applications. Using behavior-driven development and some common testing patterns and best practices, you will be able to avoid these traps.This book will show you how to do BDD in a practical way. We will start with a basic introduction of what BDD is and why the classical approach to testing has failed. Afterwards, we will dive directly into an introduction to Node.js, Mocha, and Sinon.JS. Finally, we will cover more advanced subjects such as how to write a fast and effective test suite for a RESTful web API, and how to do the same with a rich UI using Cucumber.js and Protractor.This book will give you great insight into how to architect your system to make it more testable and modular, but at the same time avoid the nightmare of abusing mock objects.		Amodeo, Enrique		Create powerful yet simple-to-code BDD test suites in JavaScript using the most popular tools in the community About This BookMaster the most popular testing tools in the JavaScript ecosystem, such as CucumberJS, Mocha, SinonJS, and more.Learn how Behavior-driven development can help you to write software that is more modular and has less defects.Avoid common mistakes in testing, simplify your test suites, and make them more maintainable using a very pragmatic approach to BDD.Who This Book Is ForTThis book is ideal for any JavaScript developer who is interested in producing well-tested code. If you have no prior experience with testing, Node.js, or any other tool, do not worry, as they will be explained from scratch. In Detail JavaScript is not only widely used to create attractive user interfaces for the Web, but with the advent of Node.js, it is also becoming a very popular and powerful language to write server-side applications. Using behavior-driven development and some common testing patterns and best practices, you will be able to avoid these traps.This book will show you how to do BDD in a practical way. We will start with a basic introduction of what BDD is and why the classical approach to testing has failed. Afterwards, we will dive directly into an introduction to Node.js, Mocha, and Sinon.JS. Finally, we will cover more advanced subjects such as how to write a fast and effective test suite for a RESTful web API, and how to do the same with a rich UI using Cucumber.js and Protractor.This book will give you great insight into how to architect your system to make it more testable and modular, but at the same time avoid the nightmare of abusing mock objects.				Excluded	Excluded	new_screen			2						
78	Behave	SS-BDD: Automated Acceptance Testing for Spreadsheets	Current Spreadsheet Applications, such as Excel and Google Sheets, provide innumerous built-in facilities, including arithmetic, financial and statistical operations, as well as conditional expressions. Thus, users with little or no formal training in programming can use Spreadsheet Applications to implement their own Spreadsheet Programs. In fact, Spreadsheet Applications have become one of the most popular end-user programming environments nowadays. However, these applications also ease the introduction of errors in Spreadsheet Programs. Minor mistakes in formulas can mislead decisionmaking processes, resulting in uncountable costs to organizations. In general, end-user programmers are unaware of the potential risks that the uncontrolled construction of Spreadsheet Programs can cause. Therefore, a major focus of this paper is to offer an automated approach that makes programmers aware of introduced faults, so that they can build high quality Spreadsheet Programs. In particular, we propose SS-BDD, a framework for building and running Spreadsheets test scenarios, which relies on the use of Behavior Driven Development (BDD). We used SS-BDD to test three different Spreadsheet Programs. Our experience shows that SS-BDD can be used to build end-user friendly test scenarios which can achieve high fault-detection effectiveness.	Behavior Driven Development; Software Testing Tool; Spreadsheet Testing	Almeida, Lara; Cirilo, Elder; Barbosa, Eiji Adachi	Proceedings of the 1st Brazilian Symposium on Systematic and Automated Software Testing	Current Spreadsheet Applications, such as Excel and Google Sheets, provide innumerous built-in facilities, including arithmetic, financial and statistical operations, as well as conditional expressions. Thus, users with little or no formal training in programming can use Spreadsheet Applications to implement their own Spreadsheet Programs. In fact, Spreadsheet Applications have become one of the most popular end-user programming environments nowadays. However, these applications also ease the introduction of errors in Spreadsheet Programs. Minor mistakes in formulas can mislead decisionmaking processes, resulting in uncountable costs to organizations. In general, end-user programmers are unaware of the potential risks that the uncontrolled construction of Spreadsheet Programs can cause. Therefore, a major focus of this paper is to offer an automated approach that makes programmers aware of introduced faults, so that they can build high quality Spreadsheet Programs. In particular, we propose SS-BDD, a framework for building and running Spreadsheets test scenarios, which relies on the use of Behavior Driven Development (BDD). We used SS-BDD to test three different Spreadsheet Programs. Our experience shows that SS-BDD can be used to build end-user friendly test scenarios which can achieve high fault-detection effectiveness.				Included	Included	new_screen			2						
79	Behave	BMT: Behavior Driven Development-based Metamorphic Testing for Autonomous Driving Models	Deep Neural Network based models are widely used for perception and control in autonomous driving. Recent work leverages metamorphic testing to improve defect detection but is limited to using only an equality-based metamorphic relation. Thus, it does not provide sufficient expressiveness for users to define custom metamorphic relations nor means to automatically generate meaningful inputs based on such expressive metamorphic relations that reflect real-world traffic behaviors. In this paper, we preliminarily design and evaluate a declarative Behaviour-Driven Development (BDD)-based metamorphic testing framework BMT, which enables domain experts to specify custom traffic behaviors-a car shall decelerate by x% when a bicycle is in front, etc. It then automatically translates a human-written behavior to a corresponding metamorphic relation and synthesizes meaningful test inputs using a variety of image and graphics processing techniques. Our preliminary evaluation shows that BMT can detect a significant number of erroneous predictions of three driving models for speed predictions. These detected erroneous predictions are manually examined and confirmed by six human judges as meaningful traffic violations. By automating test generation from custom behaviors, BMT enables experts to easily express domain-specific constraints and finds violations of such constraints.	Metamorphic Testing;Autonomous Driving;Deep Learning Models;Software Testing and Verification	Y. Deng; G. Lou; X. Zheng; T. Zhang; M. Kim; H. Liu; C. Wang; T. Y. Chen	2021 IEEE/ACM 6th International Workshop on Metamorphic Testing (MET)	Deep Neural Network based models are widely used for perception and control in autonomous driving. Recent work leverages metamorphic testing to improve defect detection but is limited to using only an equality-based metamorphic relation. Thus, it does not provide sufficient expressiveness for users to define custom metamorphic relations nor means to automatically generate meaningful inputs based on such expressive metamorphic relations that reflect real-world traffic behaviors. In this paper, we preliminarily design and evaluate a declarative Behaviour-Driven Development (BDD)-based metamorphic testing framework BMT, which enables domain experts to specify custom traffic behaviors-a car shall decelerate by x% when a bicycle is in front, etc. It then automatically translates a human-written behavior to a corresponding metamorphic relation and synthesizes meaningful test inputs using a variety of image and graphics processing techniques. Our preliminary evaluation shows that BMT can detect a significant number of erroneous predictions of three driving models for speed predictions. These detected erroneous predictions are manually examined and confirmed by six human judges as meaningful traffic violations. By automating test generation from custom behaviors, BMT enables experts to easily express domain-specific constraints and finds violations of such constraints.				Included	Included	new_screen			2						
80	Behave	3DEvent: A Framework Using Event-Sourcing Approach for 3D Web-Based Collaborative Design in P2P	Despite recent advances, especially in web-based Collaborative Virtual Environments (CVEs) using real-time 3D content, Web technology still requires an efficient way to distribute and stream large-scale 3D data. In this paper, we present 3DEvent: an event-driven framework to collaboratively manipulate predesigned 3D content in real-time on a web-based platform. This work introduces a new approach in achieving 3D object manipulation tasks during collaborative design stages using event-sourcing. Usually, a client-server architecture supports updates to the 3D environment state. Peer-to-peer (P2P) allows direct communication between teammates reducing response times during collaboration and decreasing server load, reducing the costs of providers. 3DEvent enables P2P-assisted delivery of 3D dynamic content in a web browser via WebRTC. By combining concepts from distributed event-processing and mesh-processing, 3D independent rendering and event-based synchronization, we present 3DEvent framework and potential uses associated that support history-aware 3D applications into a unified distributed processing solution for 3D web-based CVEs.	collaborative manipulation; distributed application; event-driven architecture; Web 3D; WebRTC	Desprat, Caroline; Jessel, Jean-Pierre; Luga, Hervé	Proceedings of the 21st International Conference on Web3D Technology	Despite recent advances, especially in web-based Collaborative Virtual Environments (CVEs) using real-time 3D content, Web technology still requires an efficient way to distribute and stream large-scale 3D data. In this paper, we present 3DEvent: an event-driven framework to collaboratively manipulate predesigned 3D content in real-time on a web-based platform. This work introduces a new approach in achieving 3D object manipulation tasks during collaborative design stages using event-sourcing. Usually, a client-server architecture supports updates to the 3D environment state. Peer-to-peer (P2P) allows direct communication between teammates reducing response times during collaboration and decreasing server load, reducing the costs of providers. 3DEvent enables P2P-assisted delivery of 3D dynamic content in a web browser via WebRTC. By combining concepts from distributed event-processing and mesh-processing, 3D independent rendering and event-based synchronization, we present 3DEvent framework and potential uses associated that support history-aware 3D applications into a unified distributed processing solution for 3D web-based CVEs.				Excluded	Excluded	new_screen			2						
81	Behave	Test-Driven Development of Relational Databases	Developers can use a test-driven development with database schema just as they use it with application code. Implementing test-driven database development (TDDD) involves three relatively simple steps: database refactoring, database regression testing, and continuous database integration. In database refactoring, developers make a simple change to a database to improve the design without changing its semantics. In database regression testing, they run a comprehensive test suite that validates the database regularly-ideally, whenever developers change the database schema or access the database in a different way. In continuous database integration, developers rebuild and retest the database schema whenever it changes. From a technical viewpoint, TDDD is straightforward. However, cultural challenges can make it difficult to adopt.	BDD; behavior-driven development; test-driven development; database refactoring; database testing; relational database; TDD; test-driven database design	Ambler, Scott W.	IEEE Softw.	Developers can use a test-driven development with database schema just as they use it with application code. Implementing test-driven database development (TDDD) involves three relatively simple steps: database refactoring, database regression testing, and continuous database integration. In database refactoring, developers make a simple change to a database to improve the design without changing its semantics. In database regression testing, they run a comprehensive test suite that validates the database regularly-ideally, whenever developers change the database schema or access the database in a different way. In continuous database integration, developers rebuild and retest the database schema whenever it changes. From a technical viewpoint, TDDD is straightforward. However, cultural challenges can make it difficult to adopt.				Excluded	Excluded	new_screen			2						
82	Behave	Automatic production of end user documentation for DSLs	Domain-specific languages (DSL) are developed for answering specific problems by leveraging the expertise of domain stakeholders. The development of DSLs requires a significant software engineering effort: editors, code generators, etc, must be developed to make a DSL usable. Documenting a DSL is also a major and time-consuming task required to promote it and address its learning curve. Recent research work in software language engineering focus on easing the development of DSLs. This work focuses on easing the production of documentation of textual DSLs. The API documentation domain identified challenges we adapted to DSL documentation. Based on these challenges we propose a model-driven approach that relies on DSL artifacts to extract information required to build documentation. Our implementation, called Docywood, targets two platforms: Markdown documentation for static web sites and Xtext code fragments for live documentation while modeling. We used Docywood on two DSLs, namely ThingML and Target Platform Definition. Feedback from end users and language designers exhibits qualitative benefits of the proposal with regard to the DSL documentation challenges. End user experiments conducted on ThingML and Target Platform Definition show benefits on the correctness of the created models when using Docywood on ThingML.	Software documentation, Domain-specific language, Model slicing	Le Moulec, Gwendal; Blouin, Arnaud; Gouranton, Valérie; Arnaldi, Bruno	Computer Languages, Systems & Structures	Domain-specific languages (DSL) are developed for answering specific problems by leveraging the expertise of domain stakeholders. The development of DSLs requires a significant software engineering effort: editors, code generators, etc, must be developed to make a DSL usable. Documenting a DSL is also a major and time-consuming task required to promote it and address its learning curve. Recent research work in software language engineering focus on easing the development of DSLs. This work focuses on easing the production of documentation of textual DSLs. The API documentation domain identified challenges we adapted to DSL documentation. Based on these challenges we propose a model-driven approach that relies on DSL artifacts to extract information required to build documentation. Our implementation, called Docywood, targets two platforms: Markdown documentation for static web sites and Xtext code fragments for live documentation while modeling. We used Docywood on two DSLs, namely ThingML and Target Platform Definition. Feedback from end users and language designers exhibits qualitative benefits of the proposal with regard to the DSL documentation challenges. End user experiments conducted on ThingML and Target Platform Definition show benefits on the correctness of the created models when using Docywood on ThingML.				Excluded	Excluded	new_screen			2						
83	Behave	A Process for Evidence-Based Engineering of Domain-Specific Languages	Domain-specific languages (DSLs) are mainly designed ad-hoc and gut feeling resulting in languages that are often not well suited for their users and engineers. In this paper we develop a process for evidence-based language engineering to design domain-specific languages based on empirical evidence to support decision in language engineering. The developed process comprises an iterative execution of the phases DSL engineering, issue identification, data collection and evidence appraisal. We exemplify the concept by designing a DSL for Gherkin, a language test-driven acceptance testing in Xtext. The required evidence is derived by mining and analyzing all GitHub projects until July 1, 2017 that apply Gherkin.	domain-specific languages; DSL engineering; empirical research; evidence-based software engineering; repository mining	Felderer, Michael; Jeschko, Fabian	Proceedings of the 22nd International Conference on Evaluation and Assessment in Software Engineering 2018	Domain-specific languages (DSLs) are mainly designed ad-hoc and gut feeling resulting in languages that are often not well suited for their users and engineers. In this paper we develop a process for evidence-based language engineering to design domain-specific languages based on empirical evidence to support decision in language engineering. The developed process comprises an iterative execution of the phases DSL engineering, issue identification, data collection and evidence appraisal. We exemplify the concept by designing a DSL for Gherkin, a language test-driven acceptance testing in Xtext. The required evidence is derived by mining and analyzing all GitHub projects until July 1, 2017 that apply Gherkin.				Excluded	Excluded	new_screen			2						
84	Behave	Reproducing Failures Based on Semiformal Failure Scenario Descriptions	Due to the increasing size and complexity of software systems, it becomes hard to test these systems exhaustively. As a result, some faults can be left undetected. Undetected faults can lead to failures in deployed systems. Such failures are usually reported by the users from the field or test engineers back to developers. It requires considerable time and effort to analyze and reproduce the reported failures because their descriptions are not always complete, structured and formal. In this paper, we introduce a novel approach for automatically reproducing failures to aid their debugging. Our approach relies on semi-structured failure scenario descriptions that employ a set of keywords. These descriptions are preprocessed and mapped to a set of predefined test case templates with valid input sets. Then, test cases are generated and executed to reproduce the reported failure scenarios. The approach is evaluated with an industrial case study performed in a company from the telecommunications domain. Several failures were successfully reproduced. The approach is also adopted in the quality assurance process of the company. After one-time preparation of reusable test case templates and training of test engineers, 24.9 % of the reported failures (and 40 % of those that were manually reproducible) could be reproduced without any manual effort.	Behavior-driven development; Automated test case generation; Failure reproduction; Industrial case study	Karagöz, Gün; Sözer, Hasan	Software Quality Journal	Due to the increasing size and complexity of software systems, it becomes hard to test these systems exhaustively. As a result, some faults can be left undetected. Undetected faults can lead to failures in deployed systems. Such failures are usually reported by the users from the field or test engineers back to developers. It requires considerable time and effort to analyze and reproduce the reported failures because their descriptions are not always complete, structured and formal. In this paper, we introduce a novel approach for automatically reproducing failures to aid their debugging. Our approach relies on semi-structured failure scenario descriptions that employ a set of keywords. These descriptions are preprocessed and mapped to a set of predefined test case templates with valid input sets. Then, test cases are generated and executed to reproduce the reported failure scenarios. The approach is evaluated with an industrial case study performed in a company from the telecommunications domain. Several failures were successfully reproduced. The approach is also adopted in the quality assurance process of the company. After one-time preparation of reusable test case templates and training of test engineers, 24.9 % of the reported failures (and 40 % of those that were manually reproducible) could be reproduced without any manual effort.				Included	Included	new_screen			2						
85	Behave	Behaviour-driven requirements engineering for agile product line engineering	Due to the need of the software development community to integrate the flexibility and the high responsiveness of agile software development with the economic advantages, of reuse and mass customisation, offered by product lines, agile product line engineering has been gaining a momentum of attention from both researchers and practitioners. Developing and managing the different requirements engineering phases of product lines present is a dilemma that the efforts done in the literature was not able to effectively and efficiently resolve. To realise the full potential of agile product line engineering in practice, a complete, consistent, correct, and unambiguous user requirements must be produced without investing that huge amount of time in the upfront domain engineering phase of a traditional software product line. In this proposal, a behaviour-driven cloud-based framework is introduced to develop and maintain software product lines in an agile-based environment. The approach relies on upfront automated testing to derive and manage core assets and variations of an agile-based software product line. The model is validated through an empirical study and the preliminary results are very promising. © 2019 IEEE.		Elshandidy H.	Proceedings of the IEEE International Conference on Requirements Engineering	Due to the need of the software development community to integrate the flexibility and the high responsiveness of agile software development with the economic advantages, of reuse and mass customisation, offered by product lines, agile product line engineering has been gaining a momentum of attention from both researchers and practitioners. Developing and managing the different requirements engineering phases of product lines present is a dilemma that the efforts done in the literature was not able to effectively and efficiently resolve. To realise the full potential of agile product line engineering in practice, a complete, consistent, correct, and unambiguous user requirements must be produced without investing that huge amount of time in the upfront domain engineering phase of a traditional software product line. In this proposal, a behaviour-driven cloud-based framework is introduced to develop and maintain software product lines in an agile-based environment. The approach relies on upfront automated testing to derive and manage core assets and variations of an agile-based software product line. The model is validated through an empirical study and the preliminary results are very promising. © 2019 IEEE.				Included	Included	new_screen			2						
86	Behave	From Requirements to Source Code: A Model-Driven Engineering Approach for RESTful Web Services	During the last few years, the REST architectural style has drastically changed the way web services are developed. Due to its transparent resource-oriented model, the RESTful paradigm has been incorporated into several development frameworks that allow rapid development and aspire to automate parts of the development process. However, most of the frameworks lack automation of essential web service functionality, such as authentication or database searching, while the end product is usually not fully compliant to REST. Furthermore, most frameworks rely heavily on domain specific modeling and require developers to be familiar with the employed modeling technologies. In this paper, we present a Model-Driven Engineering (MDE) engine that supports fast design and implementation of web services with advanced functionality. Our engine provides a front-end interface that allows developers to design their envisioned system through software requirements in multimodal formats. Input in the form of textual requirements and graphical storyboards is analyzed using natural language processing techniques and semantics, to semi-automatically construct the input model for the MDE engine. The engine subsequently applies model-to-model transformations to produce a RESTful, ready-to-deploy web service. The procedure is traceable, ensuring that changes in software requirements propagate to the underlying software artefacts and models. Upon assessing our methodology through a case study and measuring the effort reduction of using our tools, we conclude that our system can be effective for the fast design and implementation of web services, while it allows easy wrapping of services that have been engineered with traditional methods to the MDE realm.	Automated Software Engineering; Model-Driven Engineering; RESTful web services; Software requirements	Zolotas, Christoforos; Diamantopoulos, Themistoklis; Chatzidimitriou, Kyriakos C.; Symeonidis, Andreas L.	Automated Software Engg.	During the last few years, the REST architectural style has drastically changed the way web services are developed. Due to its transparent resource-oriented model, the RESTful paradigm has been incorporated into several development frameworks that allow rapid development and aspire to automate parts of the development process. However, most of the frameworks lack automation of essential web service functionality, such as authentication or database searching, while the end product is usually not fully compliant to REST. Furthermore, most frameworks rely heavily on domain specific modeling and require developers to be familiar with the employed modeling technologies. In this paper, we present a Model-Driven Engineering (MDE) engine that supports fast design and implementation of web services with advanced functionality. Our engine provides a front-end interface that allows developers to design their envisioned system through software requirements in multimodal formats. Input in the form of textual requirements and graphical storyboards is analyzed using natural language processing techniques and semantics, to semi-automatically construct the input model for the MDE engine. The engine subsequently applies model-to-model transformations to produce a RESTful, ready-to-deploy web service. The procedure is traceable, ensuring that changes in software requirements propagate to the underlying software artefacts and models. Upon assessing our methodology through a case study and measuring the effort reduction of using our tools, we conclude that our system can be effective for the fast design and implementation of web services, while it allows easy wrapping of services that have been engineered with traditional methods to the MDE realm.				Excluded	Excluded	new_screen			2						
87	Behave	Analysing Requirements Communication Using Use Case Specification and User Stories	Effective requirements communication is essential in software development projects due to the importance of understanding the requirements throughout the software development cycle. Software requirements can be specified in different formats, for instance using free texts or more structured forms, such as use cases and user stories used in Behavior Driven Development (BDD). We present a comparative analysis on the requirements communication dynamics using use case specification and user stories as the basis for mockups creation. We carried out an exploratory empirical study involving 16 students. The study comprised 3 steps: requirements specification, mockups construction, and inspection to investigate whether the mockups were in accordance with the specifications. Results show that there is no significant difference in using use case specification or user stories to communicate software requirements. Our findings suggest that different specification formats can provide similar results while communicating requirements, nonetheless the human factor should not be neglected.	Behavior Driven Development; experimental study; Requirements communication; requirements specification; use case	Oran, Ana Carolina; Nascimento, Elizamary; Santos, Gleison; Conte, Tayana	Proceedings of the 31st Brazilian Symposium on Software Engineering	Effective requirements communication is essential in software development projects due to the importance of understanding the requirements throughout the software development cycle. Software requirements can be specified in different formats, for instance using free texts or more structured forms, such as use cases and user stories used in Behavior Driven Development (BDD). We present a comparative analysis on the requirements communication dynamics using use case specification and user stories as the basis for mockups creation. We carried out an exploratory empirical study involving 16 students. The study comprised 3 steps: requirements specification, mockups construction, and inspection to investigate whether the mockups were in accordance with the specifications. Results show that there is no significant difference in using use case specification or user stories to communicate software requirements. Our findings suggest that different specification formats can provide similar results while communicating requirements, nonetheless the human factor should not be neglected.				Included	Included	new_screen			2						
88	Behave	Generating Testing Codes for Behavior-Driven Development from Problem Diagrams: A Tool-Based Approach	Eliciting requirements in their real-world contexts and creating and transforming visual models which can help lead to early designs of software is a challenging and time-consuming step in software engineering processes. In order to support the creation of these models and generate artifacts useful for software designs, we have developed the Problem-to-Design tool (PROD) based on Jackson's Problem Frames approach. The tool has been inspired by the work in the behavior-driven development community, which recommends that testing codes be generated as early as in the requirements engineering phase. The tool provides an open portal where multiple stakeholders can draw their own problem diagrams online, which can be used to generate use case narratives and testing codes for further behavior-driven development.	Problem Frames;problem progression;behavior-driven development	N. Gao; Z. Li	2016 IEEE 24th International Requirements Engineering Conference (RE)	Eliciting requirements in their real-world contexts and creating and transforming visual models which can help lead to early designs of software is a challenging and time-consuming step in software engineering processes. In order to support the creation of these models and generate artifacts useful for software designs, we have developed the Problem-to-Design tool (PROD) based on Jackson's Problem Frames approach. The tool has been inspired by the work in the behavior-driven development community, which recommends that testing codes be generated as early as in the requirements engineering phase. The tool provides an open portal where multiple stakeholders can draw their own problem diagrams online, which can be used to generate use case narratives and testing codes for further behavior-driven development.				Included	Included	new_screen			2						
89	Behave	Behavior-driven Development for Real-time Embedded Systems	Embedded systems are a class of computer systems that are typically characterized by a tight interaction with the physical environment. Various methodologies have been adopted for the development of such systems, ranging from traditional waterfall to modern agile techniques. One of the agile techniques that has recently attracted increasing attention is Behavior-Driven Development (BDD). BDD promotes the engagement of all stakeholders in every development iteration to minimize the misunderstanding between technical and non-technical stakeholders and, consequently, to speed up the development process and lower the costs. In this paper, we investigate the application of BDD to the development of embedded systems, especially focusing on the testing of timing requirements for real-time embedded software. In particular, we extend BDD with time-related concepts and propose an approach to generate test code for the verification of timing behavior of real-time embedded systems. Our approach offers more automation for the development of test code compared to existing BDD tools, thus minimizing the risk of timing faults and reducing development costs and time-to-market.		A. S. Nezhad; J. J. Lukkien; R. H. Mak	2018 IEEE 23rd International Conference on Emerging Technologies and Factory Automation (ETFA)	Embedded systems are a class of computer systems that are typically characterized by a tight interaction with the physical environment. Various methodologies have been adopted for the development of such systems, ranging from traditional waterfall to modern agile techniques. One of the agile techniques that has recently attracted increasing attention is Behavior-Driven Development (BDD). BDD promotes the engagement of all stakeholders in every development iteration to minimize the misunderstanding between technical and non-technical stakeholders and, consequently, to speed up the development process and lower the costs. In this paper, we investigate the application of BDD to the development of embedded systems, especially focusing on the testing of timing requirements for real-time embedded software. In particular, we extend BDD with time-related concepts and propose an approach to generate test code for the verification of timing behavior of real-time embedded systems. Our approach offers more automation for the development of test code compared to existing BDD tools, thus minimizing the risk of timing faults and reducing development costs and time-to-market.				Included	Included	new_screen			2						
90	Behave	Benchmark Driven Framework for Development of Emotion Sensing Support Systems	Emotion sensing support system to assist human decision making during interview scenario is a developing research field. This paper presents a new framework for the development of emotion sensing support systems that is a complete, easily extendible, flexible, and configurable environment with intensive benchmark capabilities. The design of the framework was inspired by behavior-driven development, agile software development technique. It provides: 1) effective collaboration platform between technological and psychological researches, and 2) intensive benchmarking capabilities to test the performance of the entire system as well as individual algorithms.	behavior-driven development; affect; emotion detection; sensor fusion	Polikovsky, Senya; Quiros-Ramirez, Maria Alejandra; Kameda, Yoshinori; Ohta, Yuichi; Burgoon, Judee	Proceedings of the 2012 European Intelligence and Security Informatics Conference	Emotion sensing support system to assist human decision making during interview scenario is a developing research field. This paper presents a new framework for the development of emotion sensing support systems that is a complete, easily extendible, flexible, and configurable environment with intensive benchmark capabilities. The design of the framework was inspired by behavior-driven development, agile software development technique. It provides: 1) effective collaboration platform between technological and psychological researches, and 2) intensive benchmarking capabilities to test the performance of the entire system as well as individual algorithms.				Excluded	Excluded	new_screen			2						
91	Behave	Benchmark Driven Framework for Development of Emotion Sensing Support Systems	Emotion sensing support system to assist human decision making during interview scenario is a developing research field. This paper presents a new framework for the development of emotion sensing support systems that is a complete, easily extendible, flexible, and configurable environment with intensive benchmark capabilities. The design of the framework was inspired by behavior-driven development, agile software development technique. It provides: (1) effective collaboration platform between technological and psychological researches, and (2) intensive benchmarking capabilities to test the performance of the entire system as well as individual algorithms.	affect;emotion detection;behavior-driven development;sensor fusion	S. Polikovsky; M. A. Quiros-Ramirez; Y. Kameda; Y. Ohta; J. Burgoon	2012 European Intelligence and Security Informatics Conference	Emotion sensing support system to assist human decision making during interview scenario is a developing research field. This paper presents a new framework for the development of emotion sensing support systems that is a complete, easily extendible, flexible, and configurable environment with intensive benchmark capabilities. The design of the framework was inspired by behavior-driven development, agile software development technique. It provides: (1) effective collaboration platform between technological and psychological researches, and (2) intensive benchmarking capabilities to test the performance of the entire system as well as individual algorithms.				Excluded	Excluded	new_screen			2						
92	Behave	Beyond Page Objects: Testing Web Applications with State Objects: Use States to Drive Your Tests	End-to-end testing of Web applications typically involves tricky interactions with Web pages by means of a framework such as Selenium WebDriver. The recommended method for hiding such Web-page intricacies is to use page objects, but there are questions to answer first: Which page objects should you create when testing Web applications? What actions should you include in a page object? Which test scenarios should you specify, given your page objects?		van Deursen, Arie	Queue	End-to-end testing of Web applications typically involves tricky interactions with Web pages by means of a framework such as Selenium WebDriver. The recommended method for hiding such Web-page intricacies is to use page objects, but there are questions to answer first: Which page objects should you create when testing Web applications? What actions should you include in a page object? Which test scenarios should you specify, given your page objects?				Excluded	Excluded	new_screen			2						
93	Behave	Ensuring the Consistency Between User Requirements and Graphical User Interfaces: A Behavior-Based Automated Approach	Ensuring the consistency between Graphical User Interfaces (GUIs) and user requirements is a critical aspect of the design process since it is through the GUIs that users perceive the system and experience the available features in order to achieve their goals. This paper presents an approach based on Behavior-Driven Development (BDD) which employs an ontology in order to provide automated assessment for web GUIs. The approach has been evaluated by exploiting user requirements described by a group of experts in the flight tickets e-commerce domain. Such requirements gave rise to a set of User Stories that have been used to automatically assess the GUIs of an existing web system for booking business trips. The results have shown our approach was able to identify different types of inconsistencies in the set of GUIs analyzed, allowing to build an effective correspondence between user requirements and their representation on the GUI. © 2019, Springer Nature Switzerland AG.		Rocha Silva T., Winckler M., Trætteberg H.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	Ensuring the consistency between Graphical User Interfaces (GUIs) and user requirements is a critical aspect of the design process since it is through the GUIs that users perceive the system and experience the available features in order to achieve their goals. This paper presents an approach based on Behavior-Driven Development (BDD) which employs an ontology in order to provide automated assessment for web GUIs. The approach has been evaluated by exploiting user requirements described by a group of experts in the flight tickets e-commerce domain. Such requirements gave rise to a set of User Stories that have been used to automatically assess the GUIs of an existing web system for booking business trips. The results have shown our approach was able to identify different types of inconsistencies in the set of GUIs analyzed, allowing to build an effective correspondence between user requirements and their representation on the GUI. © 2019, Springer Nature Switzerland AG.				Included	Included	new_screen			2						
94	Behave	A Practical Method for API Testing in the Context of Continuous Delivery and Behavior Driven Development	Enterprises are increasingly adopting an API-first approach to connect and expose software services. Saxo Bank is no exception to this. Crafting test suites for such APIs can seem straight forward due to the headless nature, but our experience shows that test suites often have two problems. The first problem is that execution of tests tends to fail and pass in seemingly nondeterministic ways (tests are flaky). The second problem is that functional coverage is not clearly documented. We have found that both problems stem from a lack of explicit focus on initial context (IC), a concept from behavior driven development. When a test is flaky it is often because actual IC in the test environment is not as required by the test. When functional coverage is not clear, it is most often because a systematic analysis involving IC was not performed. We propose a method for test analysis in which we include IC in the input space when analyzing functional coverage for an API, thereby including anything which can influence the outcome of test cases. Establishing IC is in general a hard problem. We have found that focus on the bounded context, a concept from domain driven design, of the system under test is a practical way to establish relevant IC. Experience with Saxo Bank's Open API shows that this method allows testers and developers to cooperate continuously, producing test plan documents which include the reasoning behind functional coverage. Explicit focus on IC in automated test case implementations turns flaky tests into tests which report on required IC in a test environment. The method easily generalizes to all levels of API tests.	Combinatorial Testing;API Testing;Behavior Driven Development;Domain Driven Design;Continuous Delivery;Industry;Application	B. E. Bennett	2021 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW)	Enterprises are increasingly adopting an API-first approach to connect and expose software services. Saxo Bank is no exception to this. Crafting test suites for such APIs can seem straight forward due to the headless nature, but our experience shows that test suites often have two problems. The first problem is that execution of tests tends to fail and pass in seemingly nondeterministic ways (tests are flaky). The second problem is that functional coverage is not clearly documented. We have found that both problems stem from a lack of explicit focus on initial context (IC), a concept from behavior driven development. When a test is flaky it is often because actual IC in the test environment is not as required by the test. When functional coverage is not clear, it is most often because a systematic analysis involving IC was not performed. We propose a method for test analysis in which we include IC in the input space when analyzing functional coverage for an API, thereby including anything which can influence the outcome of test cases. Establishing IC is in general a hard problem. We have found that focus on the bounded context, a concept from domain driven design, of the system under test is a practical way to establish relevant IC. Experience with Saxo Bank's Open API shows that this method allows testers and developers to cooperate continuously, producing test plan documents which include the reasoning behind functional coverage. Explicit focus on IC in automated test case implementations turns flaky tests into tests which report on required IC in a test environment. The method easily generalizes to all levels of API tests.				Excluded	Excluded	new_screen			2						
95	Behave	Ensuring the Consistency between User Requirements and Task Models: A Behavior-Based Automated Approach	Evaluating and ensuring the consistency between user requirements and modeling artifacts is a long-time issue for model-based software design. Conflicts in requirements specifications can lead to many design errors and have a decisive impact on the quality of systems under development. This article presents an approach based on Behavior-Driven Development (BDD) to provide automated assessment for task models, which are intended to model the flow of user and system tasks in an interactive system. The approach has been evaluated by exploiting user requirements described by a group of experts in the domain of business trips. Such requirements gave rise to a set of BDD stories that have been used to automatically assess scenarios extracted from task models that were reengineered from an existing web system for booking business trips. The results have shown our approach, by performing a static analysis of the source files, was able to identify different types of inconsistencies between the user requirements and the set of task models analyzed.	automated requirements assessment; behavior-driven development (BDD); task models; user stories	Rocha Silva, Thiago; Winckler, Marco; Trætteberg, Hallvard	Proc. ACM Hum.-Comput. Interact.	Evaluating and ensuring the consistency between user requirements and modeling artifacts is a long-time issue for model-based software design. Conflicts in requirements specifications can lead to many design errors and have a decisive impact on the quality of systems under development. This article presents an approach based on Behavior-Driven Development (BDD) to provide automated assessment for task models, which are intended to model the flow of user and system tasks in an interactive system. The approach has been evaluated by exploiting user requirements described by a group of experts in the domain of business trips. Such requirements gave rise to a set of BDD stories that have been used to automatically assess scenarios extracted from task models that were reengineered from an existing web system for booking business trips. The results have shown our approach, by performing a static analysis of the source files, was able to identify different types of inconsistencies between the user requirements and the set of task models analyzed.				Included	Included	new_screen			2						
96	Behave	Ensuring the Consistency between User Requirements and Task Models: A Behavior-Based Automated Approach	Evaluating and ensuring the consistency between user requirements and modeling artifacts is a long-time issue for model-based software design. Conflicts in requirements specifications can lead to many design errors and have a decisive impact on the quality of systems under development. This article presents an approach based on Behavior-Driven Development (BDD) to provide automated assessment for task models, which are intended to model the flow of user and system tasks in an interactive system. The approach has been evaluated by exploiting user requirements described by a group of experts in the domain of business trips. Such requirements gave rise to a set of BDD stories that have been used to automatically assess scenarios extracted from task models that were reengineered from an existing web system for booking business trips. The results have shown our approach, by performing a static analysis of the source files, was able to identify different types of inconsistencies between the user requirements and the set of task models analyzed. © 2020 ACM.		Rocha Silva T., Winckler M., Trætteberg H.	Proceedings of the ACM on Human-Computer Interaction	Evaluating and ensuring the consistency between user requirements and modeling artifacts is a long-time issue for model-based software design. Conflicts in requirements specifications can lead to many design errors and have a decisive impact on the quality of systems under development. This article presents an approach based on Behavior-Driven Development (BDD) to provide automated assessment for task models, which are intended to model the flow of user and system tasks in an interactive system. The approach has been evaluated by exploiting user requirements described by a group of experts in the domain of business trips. Such requirements gave rise to a set of BDD stories that have been used to automatically assess scenarios extracted from task models that were reengineered from an existing web system for booking business trips. The results have shown our approach, by performing a static analysis of the source files, was able to identify different types of inconsistencies between the user requirements and the set of task models analyzed. © 2020 ACM.				Included	Included	new_screen			2						
97	Behave	A Study of Value in Agile Software Development Organizations	Examines how Value is interpreted in 14 agile software development organizations.Data is collected from 13 project managers and 10 product owners.Sixteen categories of Value Aspects are identified and prioritized.The most important Value Aspect is Delivery process w.r.t. time.The most used activity to achieve Value is activities related to agile practices. The Agile manifesto focuses on the delivery of valuable software. In Lean, the principles emphasise value, where every activity that does not add value is seen as waste. Despite the strong focus on value, and that the primary critical success factor for software intensive product development lies in the value domain, no empirical study has investigated specifically what value is. This paper presents an empirical study that investigates how value is interpreted and prioritised, and how value is assured and measured. Data was collected through semi-structured interviews with 23 participants from 14 agile software development organisations. The contribution of this study is fourfold. First, it examines how value is perceived amongst agile software development organisations. Second, it compares the perceptions and priorities of the perceived values by domains and roles. Third, it includes an examination of what practices are used to achieve value in industry, and what hinders the achievement of value. Fourth, it characterises what measurements are used to assure, and evaluate value-creation activities.	Agile software development; Empirical; Value	Alahyari, Hiva; Berntsson Svensson, Richard; Gorschek, Tony	J. Syst. Softw.	Examines how Value is interpreted in 14 agile software development organizations.Data is collected from 13 project managers and 10 product owners.Sixteen categories of Value Aspects are identified and prioritized.The most important Value Aspect is Delivery process w.r.t. time.The most used activity to achieve Value is activities related to agile practices. The Agile manifesto focuses on the delivery of valuable software. In Lean, the principles emphasise value, where every activity that does not add value is seen as waste. Despite the strong focus on value, and that the primary critical success factor for software intensive product development lies in the value domain, no empirical study has investigated specifically what value is. This paper presents an empirical study that investigates how value is interpreted and prioritised, and how value is assured and measured. Data was collected through semi-structured interviews with 23 participants from 14 agile software development organisations. The contribution of this study is fourfold. First, it examines how value is perceived amongst agile software development organisations. Second, it compares the perceptions and priorities of the perceived values by domains and roles. Third, it includes an examination of what practices are used to achieve value in industry, and what hinders the achievement of value. Fourth, it characterises what measurements are used to assure, and evaluate value-creation activities.				Excluded	Excluded	new_screen			2						
98	Behave	Domain-specific scenarios for refinement-based methods	Formal methods use abstraction and rigorously verified refinement to manage the design of complex systems, ensuring that they satisfy important invariant properties. However, formal verification is not sufficient: models must also be tested to ensure that they behave according to the informal requirements and validated by domain experts who may not be expert in formal modelling. This can be satisfied by scenarios that complement the requirements specification. The model can be animated to check whether the scenario is feasible in the model and that the model reaches the states expected in the scenario. However, there are two problems with this approach. 1) The natural language used to describe the scenarios is often verbose, ambiguous and therefore difficult to understand; especially if the modeller is not a domain expert. 2) Provided scenarios are typically at the most concrete level corresponding to the full requirements and cannot be used until all the refinements have been completed in the model. We show by example how a precise and concise domain specific language can be used for writing these abstract scenarios in a style that can be easily understood by the domain expert (for validation purposes) as well as the modeller (for behavioural verification) and can be used as the persistence for automated tool support. We propose two alternative approaches to using scenarios during formal modelling: A method of refining scenarios before the model is refined so that the scenarios guide the modelling, and a method of abstracting scenarios from provided concrete ones so that they can be used to test early refinements of the model. We illustrate the two approaches on the ‘Tokeneer’ secure enclave example and the ERTMS/ETCS Hybrid Level 3 specification for railway controls. We base our approach on the Cucumber framework for scenarios and the Event-B modelling language and tool set. We have developed a new ‘Scenario Checker’ plugin to manage the animation of scenarios.11The example model and scenario scripts supporting this paper are openly available at https://doi.org/10.5258/SOTON/D1026.	Event-B, Cucumber, Validation, Domain specific language	Snook, Colin; Hoang, Thai Son; Dghaym, Dana; Fathabadi, Asieh Salehi; Butler, Michael	Journal of Systems Architecture	Formal methods use abstraction and rigorously verified refinement to manage the design of complex systems, ensuring that they satisfy important invariant properties. However, formal verification is not sufficient: models must also be tested to ensure that they behave according to the informal requirements and validated by domain experts who may not be expert in formal modelling. This can be satisfied by scenarios that complement the requirements specification. The model can be animated to check whether the scenario is feasible in the model and that the model reaches the states expected in the scenario. However, there are two problems with this approach. 1) The natural language used to describe the scenarios is often verbose, ambiguous and therefore difficult to understand; especially if the modeller is not a domain expert. 2) Provided scenarios are typically at the most concrete level corresponding to the full requirements and cannot be used until all the refinements have been completed in the model. We show by example how a precise and concise domain specific language can be used for writing these abstract scenarios in a style that can be easily understood by the domain expert (for validation purposes) as well as the modeller (for behavioural verification) and can be used as the persistence for automated tool support. We propose two alternative approaches to using scenarios during formal modelling: A method of refining scenarios before the model is refined so that the scenarios guide the modelling, and a method of abstracting scenarios from provided concrete ones so that they can be used to test early refinements of the model. We illustrate the two approaches on the ‘Tokeneer’ secure enclave example and the ERTMS/ETCS Hybrid Level 3 specification for railway controls. We base our approach on the Cucumber framework for scenarios and the Event-B modelling language and tool set. We have developed a new ‘Scenario Checker’ plugin to manage the animation of scenarios.11The example model and scenario scripts supporting this paper are openly available at https://doi.org/10.5258/SOTON/D1026.				Excluded	Excluded	new_screen			2						
99	Behave	Behaviour-driven formal model development	Formal systems modelling offers a rigorous system-level analysis resulting in a precise and reliable specification. However, some issues remain: Modellers need to understand the requirements in order to formulate the models, formal verification may focus on safety properties rather than temporal behaviour, domain experts need to validate the final models to ensure they fit the needs of stakeholders. In this paper we discuss how the principles of Behaviour-Driven Development (BDD) can be applied to formal systems modelling and validation. We propose a process where manually authored scenarios are used initially to support the requirements and help the modeller. The same scenarios are used to verify behavioural properties of the model. The model is then mutated to automatically generate scenarios that have a more complete coverage than the manual ones. These automatically generated scenarios are used to animate the model in a final acceptance stage. For this acceptance stage, it is important that a domain expert decides whether or not the behaviour is useful. © Springer Nature Switzerland AG 2018.		Snook C., Hoang T.S., Dghyam D., Butler M., Fischer T., Schlick R., Wang K.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	Formal systems modelling offers a rigorous system-level analysis resulting in a precise and reliable specification. However, some issues remain: Modellers need to understand the requirements in order to formulate the models, formal verification may focus on safety properties rather than temporal behaviour, domain experts need to validate the final models to ensure they fit the needs of stakeholders. In this paper we discuss how the principles of Behaviour-Driven Development (BDD) can be applied to formal systems modelling and validation. We propose a process where manually authored scenarios are used initially to support the requirements and help the modeller. The same scenarios are used to verify behavioural properties of the model. The model is then mutated to automatically generate scenarios that have a more complete coverage than the manual ones. These automatically generated scenarios are used to animate the model in a final acceptance stage. For this acceptance stage, it is important that a domain expert decides whether or not the behaviour is useful. © Springer Nature Switzerland AG 2018.				Included	Included	new_screen			2						
100	Behave	The Merb Way	Foy is a gifted writer and his descriptions of the philosophies that( impacted the design and implementation of Merb are definitely useful to( everyone affected by the changes in Rails 3. Obie Fernandez, Series Editor The Expert Guide to Building Merb Applications Thousands of Ruby and Rails developers are discovering the extraordinary scalability, agility, flexibility, and performance offered by the new Merb MVC framework. The Merb Way is the first comprehensive guide to using, extending, and deploying Merb. Like the bestseller The Rails Way (Addison-Wesley, 2008), this book can either be read cover-to-cover as a tutorial or used for modular coverage that makes it an ideal task reference. Foy Savas systematically covers everything developers need to know to build production-quality Merb applications, offering detailed code examples for jumpstarting virtually any project. Savas is not only involved in the Merb project as an open source contributor: He uses Merb every day as a professional developer. Drawing on his extensive practical expertise, he delves deeply into the Merb frameworks architecture and source code, revealing its elegance and offering powerful best practices for using it. To maximize this books practical value, he also covers the tools most widely used alongside Merb, including the DataMapper ORM, the RSpec tester (and associated behavior-driven development techniques), and several leading Merb plugins. The Merb Way will help you Master Merb innovations that will be incorporated into Rails 3 Understand the fundamentals of Merb development, one step at a time Use Merbs sophisticated application router to guide incoming requests Explore the Merb stack, master its configuration options, and dive into its internals Use Merb controllers to integrate application code, handle responses, and manage sessions, filters, and exceptions Build templates with both ERB (Erubis) and HAML Use the DataMapper ORM to represent object properties and behaviors Learn best practices for RESTful development with Merb Leverage Helpers to simplify many common development tasks Refactor code, encapsulate it in gems, and share it across multiple applications Customize the responses your application sends to each user Gain a deep, practical understanding of Merb plugins and extensibility Authenticate users with Merbs modular authentication plugin Configure, generate, describe, and test Merb mailers Use the merb-parts gem to create component-like regions on Web pages Cache content to relieve stress on Web servers Make the most of Behavior Driven Development and testing with RSpec		Savas, Foy		Foy is a gifted writer and his descriptions of the philosophies that( impacted the design and implementation of Merb are definitely useful to( everyone affected by the changes in Rails 3. Obie Fernandez, Series Editor The Expert Guide to Building Merb Applications Thousands of Ruby and Rails developers are discovering the extraordinary scalability, agility, flexibility, and performance offered by the new Merb MVC framework. The Merb Way is the first comprehensive guide to using, extending, and deploying Merb. Like the bestseller The Rails Way (Addison-Wesley, 2008), this book can either be read cover-to-cover as a tutorial or used for modular coverage that makes it an ideal task reference. Foy Savas systematically covers everything developers need to know to build production-quality Merb applications, offering detailed code examples for jumpstarting virtually any project. Savas is not only involved in the Merb project as an open source contributor: He uses Merb every day as a professional developer. Drawing on his extensive practical expertise, he delves deeply into the Merb frameworks architecture and source code, revealing its elegance and offering powerful best practices for using it. To maximize this books practical value, he also covers the tools most widely used alongside Merb, including the DataMapper ORM, the RSpec tester (and associated behavior-driven development techniques), and several leading Merb plugins. The Merb Way will help you Master Merb innovations that will be incorporated into Rails 3 Understand the fundamentals of Merb development, one step at a time Use Merbs sophisticated application router to guide incoming requests Explore the Merb stack, master its configuration options, and dive into its internals Use Merb controllers to integrate application code, handle responses, and manage sessions, filters, and exceptions Build templates with both ERB (Erubis) and HAML Use the DataMapper ORM to represent object properties and behaviors Learn best practices for RESTful development with Merb Leverage Helpers to simplify many common development tasks Refactor code, encapsulate it in gems, and share it across multiple applications Customize the responses your application sends to each user Gain a deep, practical understanding of Merb plugins and extensibility Authenticate users with Merbs modular authentication plugin Configure, generate, describe, and test Merb mailers Use the merb-parts gem to create component-like regions on Web pages Cache content to relieve stress on Web servers Make the most of Behavior Driven Development and testing with RSpec				Excluded	Excluded	new_screen			2						
101	Behave	“BDD Assemble!”: A Paper-Based Game Proposal for Behavior Driven Development Design Learning	Game-based learning represents a promising alternative to teach computing in higher education. This paper presents “BDD Assemble!”, a paper-based game proposal for teaching Behavior Driven Development (BDD) competences. For this, the proposed game and the evaluation approach with software engineering students are described. As a result, a simple, interactive and colaborative game was provided, able to teach BDD concepts in a practical, competitive and fun way. © IFIP International Federation for Information Processing, 2019.		Sarinho V.T.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	Game-based learning represents a promising alternative to teach computing in higher education. This paper presents “BDD Assemble!”, a paper-based game proposal for teaching Behavior Driven Development (BDD) competences. For this, the proposed game and the evaluation approach with software engineering students are described. As a result, a simple, interactive and colaborative game was provided, able to teach BDD concepts in a practical, competitive and fun way. © IFIP International Federation for Information Processing, 2019.				Excluded	Excluded	new_screen			2						
102	Behave	JavaScript Testing with Jasmine: JavaScript Behavior-Driven Development	Get a concise introduction to Jasmine, the popular behavior-driven testing framework for JavaScript. This practical guide shows you how to write unit tests with Jasmine that automatically check for bugs in your application. Learn how to write specifications for individual components, and then use those specs to test the code you write.Throughout the book, author Evan Hahn focuses primarily on methods for testing browser-based JavaScript applications, but youll also discover how to use Jasmine with CoffeeScript, Node.js, Ruby on Rails, and Ruby without Rails. You wont find a more in-depth source for Jasmine anywhere.Get an overview of both test-driven and behavior-driven development Write useful specs by determining what you need to testand what you dont Test the behavior of new and existing code against the specs you create Apply Jasmine matchers and discover how to build your own Organize code suites into groups and subgroups as your code becomes more complex Use a Jasmine spy in place of a function or an objectand learn why its valuable		Hahn, Evan		Get a concise introduction to Jasmine, the popular behavior-driven testing framework for JavaScript. This practical guide shows you how to write unit tests with Jasmine that automatically check for bugs in your application. Learn how to write specifications for individual components, and then use those specs to test the code you write.Throughout the book, author Evan Hahn focuses primarily on methods for testing browser-based JavaScript applications, but youll also discover how to use Jasmine with CoffeeScript, Node.js, Ruby on Rails, and Ruby without Rails. You wont find a more in-depth source for Jasmine anywhere.Get an overview of both test-driven and behavior-driven development Write useful specs by determining what you need to testand what you dont Test the behavior of new and existing code against the specs you create Apply Jasmine matchers and discover how to build your own Organize code suites into groups and subgroups as your code becomes more complex Use a Jasmine spy in place of a function or an objectand learn why its valuable				Excluded	Excluded	new_screen			2						
103	Behave	A real-life application of multi-agent systems for fault diagnosis in the provision of an Internet business service	Given that telecommunications networks are constantly growing in complexity and heterogeneity, management systems have to work with incomplete data, handle uncertain situations and deal with dynamic environments. In addition, the high competitiveness in the telecommunications market requires cost cutting and customer retention by providing reliable systems. Thus, improving fault diagnosis systems and reducing the mean time to repair with automatic systems is an important area of research for telecommunications companies. This paper presents a Fault Diagnosis Multi-Agent System (MAS) applied for the management of a business service of Telefónica Czech Republic. The proposed MAS is based on an extended Belief-Desire-Intention (BDI) model that combines heterogeneous reasoning processes, ontology-based reasoning and Bayesian reasoning. This hybrid diagnostic technique is described in detail in the paper. The system has been evaluated with data collected during one and a half years of system operation on a live network. The main benefits of the system have been a significant reduction in both the average incident solution time and the mean diagnosis time.	Network management, Agent, Bayesian network, Diagnosis, Uncertainty, BDI	Carrera, Álvaro; Iglesias, Carlos A.; García-Algarra, Javier; Kolařík, Dušan	Journal of Network and Computer Applications	Given that telecommunications networks are constantly growing in complexity and heterogeneity, management systems have to work with incomplete data, handle uncertain situations and deal with dynamic environments. In addition, the high competitiveness in the telecommunications market requires cost cutting and customer retention by providing reliable systems. Thus, improving fault diagnosis systems and reducing the mean time to repair with automatic systems is an important area of research for telecommunications companies. This paper presents a Fault Diagnosis Multi-Agent System (MAS) applied for the management of a business service of Telefónica Czech Republic. The proposed MAS is based on an extended Belief-Desire-Intention (BDI) model that combines heterogeneous reasoning processes, ontology-based reasoning and Bayesian reasoning. This hybrid diagnostic technique is described in detail in the paper. The system has been evaluated with data collected during one and a half years of system operation on a live network. The main benefits of the system have been a significant reduction in both the average incident solution time and the mean diagnosis time.				Excluded	Excluded	new_screen			2						
104	Behave	Behavior-driven development (BDD) Cucumber Katalon for Automation GUI testing case CURA and Swag Labs	Graphical user interface (GUI) is widely used in software applications. About 50% of the application code is for GUI implementation. Because labor costs are high and demands for high-quality software are increasing, automation GUI testing will be a good investment for any software company. We will apply the Behavior-driven development (BDD) method for automation GUI testing with the Cucumber framework on the CURA and Swag Labs web applications. The BDD methodology used is based on the NLP (natural language program) concept. Where the information of semi-automatically produce a step definition and code framework. The scenarios are given on the natural language and then applied to Software Testing. Class diagrams and sequence diagrams are also applied to each represent a code framework automatically. The author uses Katalon Studio software. It was found that the results of the test case automation GUI testing on the CURA website with 210 steps passed, 3 step warnings with average responses times in the test case were 1.92 minutes. The results of the test case automation GUI testing on the Swag Labs web with 87 where 36 steps failed, 4 step warning and 44 step passed with an average responses times in the test case are 2,122 minutes.	Empirical Software Engineering;Software Testing Automation;GUI Testing;Behavior-driven Development;Cucumber	R. Broer Bahaweres; E. Oktaviani; L. Kesuma Wardhani; I. Hermadi; A. Suroso; I. Permana Solihin; Y. Arkeman	2020 International Conference on Informatics, Multimedia, Cyber and Information System (ICIMCIS)	Graphical user interface (GUI) is widely used in software applications. About 50% of the application code is for GUI implementation. Because labor costs are high and demands for high-quality software are increasing, automation GUI testing will be a good investment for any software company. We will apply the Behavior-driven development (BDD) method for automation GUI testing with the Cucumber framework on the CURA and Swag Labs web applications. The BDD methodology used is based on the NLP (natural language program) concept. Where the information of semi-automatically produce a step definition and code framework. The scenarios are given on the natural language and then applied to Software Testing. Class diagrams and sequence diagrams are also applied to each represent a code framework automatically. The author uses Katalon Studio software. It was found that the results of the test case automation GUI testing on the CURA website with 210 steps passed, 3 step warnings with average responses times in the test case were 1.92 minutes. The results of the test case automation GUI testing on the Swag Labs web with 87 where 36 steps failed, 4 step warning and 44 step passed with an average responses times in the test case are 2,122 minutes.				Included	Included	new_screen			2						
105	Behave	Behaviour driven development for hardware design	Hardware verification requires a lot of effort. A recent study showed that on average, there are more verification engineers working on a project than design engineers. Hence, one of the biggest challenges in design and verification today is to find new ways to increase the productivity. For software development the agile methodology as an incremental approach has been proposed and is heavily used. Behavior Driven Development (BDD) as an agile technique additionally enables a direct link to natural language based testing. In this article, we show how BDD can be extended to make it viable for hardware design. In addition, we present a two-fold strategy which allows to specify textual acceptance tests and textual formal properties. Finally, this strategy is complemented by methods to generalize tests to properties, and to enhance design understanding by presenting debug and witness scenarios in natural language. © 2018 Information Processing Society of Japan.		Diepenbeck M., Kühne U., Soeken M., Grosse D., Drechsler R.	IPSJ Transactions on System LSI Design Methodology	Hardware verification requires a lot of effort. A recent study showed that on average, there are more verification engineers working on a project than design engineers. Hence, one of the biggest challenges in design and verification today is to find new ways to increase the productivity. For software development the agile methodology as an incremental approach has been proposed and is heavily used. Behavior Driven Development (BDD) as an agile technique additionally enables a direct link to natural language based testing. In this article, we show how BDD can be extended to make it viable for hardware design. In addition, we present a two-fold strategy which allows to specify textual acceptance tests and textual formal properties. Finally, this strategy is complemented by methods to generalize tests to properties, and to enhance design understanding by presenting debug and witness scenarios in natural language. © 2018 Information Processing Society of Japan.				Included	Included	new_screen			2						
106	Behave	Using acceptance tests to predict files changed by programming tasks	In a collaborative development context, conflicting code changes might compromise software quality and developers productivity. To reduce conflicts, one could avoid the parallel execution of potentially conflicting tasks. Although hopeful, this strategy is challenging because it relies on the prediction of the required file changes to complete a task. As predicting such file changes is hard, we investigate its feasibility for BDD (Behaviour-Driven Development) projects, which write automated acceptance tests before implementing features. We develop a tool that, for a given task, statically analyzes Cucumber tests and infers test-based interfaces (files that could be executed by the tests), approximating files that would be changed by the task. To assess the accuracy of this approximation, we measure precision and recall of test-based interfaces of 513 tasks from 18 Rails projects on GitHub. We also compare such interfaces with randomly defined interfaces, interfaces obtained by textual similarity of test specifications with past tasks, and interfaces computed by executing tests. Our results give evidence that, in the specific context of BDD, Cucumber tests might help to predict files changed by tasks. We find that the better the test coverage, the better the predictive power. A hybrid approach for computing test-based interfaces is promising.	Collaborative development, Task scheduling, Behaviour-driven development, File change prediction	Rocha, Thaís; Borba, Paulo; Santos, João Pedro	Journal of Systems and Software	In a collaborative development context, conflicting code changes might compromise software quality and developers productivity. To reduce conflicts, one could avoid the parallel execution of potentially conflicting tasks. Although hopeful, this strategy is challenging because it relies on the prediction of the required file changes to complete a task. As predicting such file changes is hard, we investigate its feasibility for BDD (Behaviour-Driven Development) projects, which write automated acceptance tests before implementing features. We develop a tool that, for a given task, statically analyzes Cucumber tests and infers test-based interfaces (files that could be executed by the tests), approximating files that would be changed by the task. To assess the accuracy of this approximation, we measure precision and recall of test-based interfaces of 513 tasks from 18 Rails projects on GitHub. We also compare such interfaces with randomly defined interfaces, interfaces obtained by textual similarity of test specifications with past tasks, and interfaces computed by executing tests. Our results give evidence that, in the specific context of BDD, Cucumber tests might help to predict files changed by tasks. We find that the better the test coverage, the better the predictive power. A hybrid approach for computing test-based interfaces is promising.				Included	Included	new_screen			2						
107	Behave	Ensuring the Consistency Between User Requirements and GUI Prototypes: A Behavior-Based Automated Approach	In a user-centered design process, graphical user interface (GUI) prototypes may be seen as an important early artifact to design and validate user requirements before making strong commitments with a full-fledged version of the user interface. Ensuring the consistency of GUI prototypes with other representations of the user requirements is then a critical aspect of the design process. This paper presents an approach which extends Behavior-Driven Development (BDD) by employing an ontology in order to provide automated assessment for GUI prototypes as design artifacts. The approach has been evaluated by exploiting user requirements described by a group of experts in the flight tickets e-commerce domain. Such requirements gave rise to a set of User Stories that have been used to automatically check the consistency of Balsamiq prototypes which were reengineered from an existing web system for booking business trips. The results have shown our approach was able to identify different types of inconsistencies in the set of analyzed artifacts, allowing to build an effective correspondence between user requirements and their representation in GUI prototypes. © IFIP International Federation for Information Processing 2019.		Rocha Silva T., Winckler M., Trætteberg H.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	In a user-centered design process, graphical user interface (GUI) prototypes may be seen as an important early artifact to design and validate user requirements before making strong commitments with a full-fledged version of the user interface. Ensuring the consistency of GUI prototypes with other representations of the user requirements is then a critical aspect of the design process. This paper presents an approach which extends Behavior-Driven Development (BDD) by employing an ontology in order to provide automated assessment for GUI prototypes as design artifacts. The approach has been evaluated by exploiting user requirements described by a group of experts in the flight tickets e-commerce domain. Such requirements gave rise to a set of User Stories that have been used to automatically check the consistency of Balsamiq prototypes which were reengineered from an existing web system for booking business trips. The results have shown our approach was able to identify different types of inconsistencies in the set of analyzed artifacts, allowing to build an effective correspondence between user requirements and their representation in GUI prototypes. © IFIP International Federation for Information Processing 2019.				Included	Included	new_screen			2						
108	Behave	Definition of a Behavior-Driven Model for Requirements Specification and Testing of Interactive Systems	In a user-centered development process, artifacts are aimed to evolve in iterative cycles until they meet users' requirements and then become the final product. Every cycle gives the opportunity to revise the design and to introduce new requirements which might affect the specification of artifacts that have been set in former development phases. Testing the consistency of multiple artifacts used to develop interactive systems every time that a new requirement is introduced it is a cumbersome and time consuming activity, especially if it should be done manually. For that we propose an approach based on Behavior-Driven Development (BDD) to support the automated assessment of artifacts along the development process of interactive systems. In order to prevent that test should be written to every type of artifact, we investigate the use of ontologies for specifying the test once and then run it in all artifacts sharing the ontological concepts.	Automated Requirements Checking;Behavior-Driven Development;Ontological Modeling;Prototyping;Multi-Artifact Testing	T. R. Silva	2016 IEEE 24th International Requirements Engineering Conference (RE)	In a user-centered development process, artifacts are aimed to evolve in iterative cycles until they meet users' requirements and then become the final product. Every cycle gives the opportunity to revise the design and to introduce new requirements which might affect the specification of artifacts that have been set in former development phases. Testing the consistency of multiple artifacts used to develop interactive systems every time that a new requirement is introduced it is a cumbersome and time consuming activity, especially if it should be done manually. For that we propose an approach based on Behavior-Driven Development (BDD) to support the automated assessment of artifacts along the development process of interactive systems. In order to prevent that test should be written to every type of artifact, we investigate the use of ontologies for specifying the test once and then run it in all artifacts sharing the ontological concepts.				Excluded	Excluded	new_screen			2						
109	Behave	Testing prototypes and final user interfaces through an ontological perspective for behavior-driven development	In a user-centered development process, prototypes evolve in iterative cycles until they meet users’ requirements and then become the final product. Every cycle gives the opportunity to revise the design and to introduce new requirements which might affect the specification of artifacts that have been set in former development phases. Testing the consistency of multiple artifacts used to develop interactive systems every time that a new requirement is introduced is a cumbersome activity, especially if it is done manually. This paper proposes an approach based on Behavior-Driven Development (BDD) to support the automated assessment of artifacts along the development process of interactive systems. The paper uses an ontology for specifying tests that can run over multiple artifacts sharing similar concepts. A case study testing Prototypes and Final User Interfaces is presented to demonstrate the feasibility of this approach in early phases of the design process, providing a continuous quality assurance of requirements, and helping clients and development teams to identify potential problems and inconsistencies before commitments with software implementation. © IFIP International Federation for Information Processing 2016.		Silva T.R., Hak J.-L., Winckler M.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	In a user-centered development process, prototypes evolve in iterative cycles until they meet users’ requirements and then become the final product. Every cycle gives the opportunity to revise the design and to introduce new requirements which might affect the specification of artifacts that have been set in former development phases. Testing the consistency of multiple artifacts used to develop interactive systems every time that a new requirement is introduced is a cumbersome activity, especially if it is done manually. This paper proposes an approach based on Behavior-Driven Development (BDD) to support the automated assessment of artifacts along the development process of interactive systems. The paper uses an ontology for specifying tests that can run over multiple artifacts sharing similar concepts. A case study testing Prototypes and Final User Interfaces is presented to demonstrate the feasibility of this approach in early phases of the design process, providing a continuous quality assurance of requirements, and helping clients and development teams to identify potential problems and inconsistencies before commitments with software implementation. © IFIP International Federation for Information Processing 2016.				Included	Included	new_screen			2						
110	Behave	A Domain Specific Test Language for Systems Integration	In avionic context, systems are complex, embedded, critical, reactive and real time. In this context, testing activities are predominant in a V development process. We propose to bring in some features coming from agile methods. System integration testing that means systems are tested individually and together in order to ensure that they all operate correctly. We focus on functional and system integration testing just before the ground testing phase. Nowadays, test procedures and test plans we studied are described in textual manner and are executed manually. We aim to provide a common specific language that improves communications for the team of test designers and between test designers and test performers. In the same manner as agile test frameworks, this language allows to structure the test procedures. Moreover, this language tends to facilitate the automatic execution of some parts of the procedures. We choose a domain specific language approach to design a first domain specific test language dedicated to networks system integration.	Domain Specific Language; Test procedure; Test system	Bussenot, Robin; Leblanc, Hervé; Percebois, Christian	Proceedings of the Scientific Workshop Proceedings of XP2016	In avionic context, systems are complex, embedded, critical, reactive and real time. In this context, testing activities are predominant in a V development process. We propose to bring in some features coming from agile methods. System integration testing that means systems are tested individually and together in order to ensure that they all operate correctly. We focus on functional and system integration testing just before the ground testing phase. Nowadays, test procedures and test plans we studied are described in textual manner and are executed manually. We aim to provide a common specific language that improves communications for the team of test designers and between test designers and test performers. In the same manner as agile test frameworks, this language allows to structure the test procedures. Moreover, this language tends to facilitate the automatic execution of some parts of the procedures. We choose a domain specific language approach to design a first domain specific test language dedicated to networks system integration.				Excluded	Excluded	new_screen			2						
111	Behave	Assisted Behavior Driven Development Using Natural Language Processing	In Behavior Driven Development (BDD), acceptance tests provide the starting point for the software design flow and serve as a basis for the communication between designers and stakeholders. In this agile software development technique, acceptance tests are written in natural language in order to ensure a common understanding between all members of the project. As a consequence, mapping the sentences to actual source code is the first step of the design flow, which is usually done manually.However, the scenarios described by the acceptance tests provide enough information in order to automatize the extraction of both the structure of the implementation and the test cases. In this work, we propose an assisted flow for BDD where the user enters into a dialog with the computer which suggests code pieces extracted from the sentences. For this purpose, natural language processing techniques are exploited. This allows for a semi-automatic transformation from acceptance tests to source code stubs and thus provides a first step towards an automatization of BDD.		Soeken, Mathias; Wille, Robert; Drechsler, Rolf	Proceedings of the 50th International Conference on Objects, Models, Components, Patterns	In Behavior Driven Development (BDD), acceptance tests provide the starting point for the software design flow and serve as a basis for the communication between designers and stakeholders. In this agile software development technique, acceptance tests are written in natural language in order to ensure a common understanding between all members of the project. As a consequence, mapping the sentences to actual source code is the first step of the design flow, which is usually done manually.However, the scenarios described by the acceptance tests provide enough information in order to automatize the extraction of both the structure of the implementation and the test cases. In this work, we propose an assisted flow for BDD where the user enters into a dialog with the computer which suggests code pieces extracted from the sentences. For this purpose, natural language processing techniques are exploited. This allows for a semi-automatic transformation from acceptance tests to source code stubs and thus provides a first step towards an automatization of BDD.				Included	Included	new_screen			2						
112	Behave	Maintaining behaviour driven development specifications: Challenges and opportunities	"In Behaviour-Driven Development (BDD) the behaviour of a software system is specified as a set of example interactions with the system using a ""Given-When-Then"" structure. These examples are expressed in high level domain-specific terms, and are executable. They thus act both as a specification of requirements and as tests that can verify whether the current system implementation provides the desired behaviour or not. This approach has many advantages but also presents some problems. When the number of examples grows, BDD specifications can become costly to maintain and extend. Some teams find that parts of the system are effectively frozen due to the challenges of finding and modifying the examples associated with them. We surveyed 75 BDD practitioners from 26 countries to understand the extent of BDD use, its benefits and challenges, and specifically the challenges of maintaining BDD specifications in practice. We found that BDD is in active use amongst respondents, and that the use of domain specific terms, improving communication among stakeholders, the executable nature of BDD specifications, and facilitating comprehension of code intentions are the main benefits of BDD. The results also showed that BDD specifications suffer the same maintenance challenges found in automated test suites more generally. We map the survey results to the literature, and propose 10 research opportunities in this area."	behaviour-driven development;test suite maintenance;test suite evolution	L. P. Binamungu; S. M. Embury; N. Konstantinou	2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER)	"In Behaviour-Driven Development (BDD) the behaviour of a software system is specified as a set of example interactions with the system using a ""Given-When-Then"" structure. These examples are expressed in high level domain-specific terms, and are executable. They thus act both as a specification of requirements and as tests that can verify whether the current system implementation provides the desired behaviour or not. This approach has many advantages but also presents some problems. When the number of examples grows, BDD specifications can become costly to maintain and extend. Some teams find that parts of the system are effectively frozen due to the challenges of finding and modifying the examples associated with them. We surveyed 75 BDD practitioners from 26 countries to understand the extent of BDD use, its benefits and challenges, and specifically the challenges of maintaining BDD specifications in practice. We found that BDD is in active use amongst respondents, and that the use of domain specific terms, improving communication among stakeholders, the executable nature of BDD specifications, and facilitating comprehension of code intentions are the main benefits of BDD. The results also showed that BDD specifications suffer the same maintenance challenges found in automated test suites more generally. We map the survey results to the literature, and propose 10 research opportunities in this area."				Included	Included	new_screen			2						
113	Behave	Detecting duplicate examples in behaviour driven development specifications	In Behaviour-Driven Development (BDD), the behaviour of the software to be built is specified as a set of example interactions with the system, expressed using a “Given-When-Then” structure. The examples are written using customer language, and are readable by end-users. They are also executable, and act as tests that determine whether the implementation matches the desired behaviour or not. This approach can be effective in building a common understanding of the requirements, but it can also face problems. When the suites of examples grow large, they can be difficult and expensive to change. Duplication can creep in, and can be challenging to detect manually. Current tools for detecting duplication in code are also not effective for BDD examples. Moreover, human concerns of readability and clarity can rise. We present an approach for detecting duplication in BDD suites that is based around dynamic tracing, and describe an evaluation based on three open source systems.	behaviour-driven development;duplication detection;dynamic tracing	L. P. Binamungu; S. M. Embury; N. Konstantinou	2018 IEEE Workshop on Validation, Analysis and Evolution of Software Tests (VST)	In Behaviour-Driven Development (BDD), the behaviour of the software to be built is specified as a set of example interactions with the system, expressed using a “Given-When-Then” structure. The examples are written using customer language, and are readable by end-users. They are also executable, and act as tests that determine whether the implementation matches the desired behaviour or not. This approach can be effective in building a common understanding of the requirements, but it can also face problems. When the suites of examples grow large, they can be difficult and expensive to change. Duplication can creep in, and can be challenging to detect manually. Current tools for detecting duplication in code are also not effective for BDD examples. Moreover, human concerns of readability and clarity can rise. We present an approach for detecting duplication in BDD suites that is based around dynamic tracing, and describe an evaluation based on three open source systems.				Included	Included	new_screen			2						
114	Behave	Integrating Behavior Driven Development and Programming by Contract to Improve Correctness in Computer Programs	"In many professional development settings, Test Driven Development (TDD), and its evolutionary descendent, Behavior Driven Development (BDD) are increasingly being used to improve code quality and reducing error rates. While very valuable, they are considerably less rigorous than formal methodologies of program correctness via formal logic. A less rigorous methodology utilizing the ideas of formal methods but without requiring an actual full proof are also in use called ""Design by Contract"" (DBC) or ""Programming by Contract."" (PBC) This thesis will examine extending and combining the ideas behind TDD, BDD and DBC to improve the overall stability and quality of a system. It will examine using both TDD/BDD (hereinafter referred to as TDD) and PBC to enhance the quality of development throughout the software development life cycle, while aiding in the development and stabilization of sound architecture. A result of this examination is a tool that attempts to derive unit tests automatically by analyzing human written specifications for preconditions and post-conditions when coupled with data definitions. These results will be used to generate code to be run by a unit testing framework before deployment, either as part of a continuous integration environment or by individual developers. The tool will also attempt to generate wireframe classes implementing pre and post-conditions within the code and using runtime contract analysis to generate information when an exception occurs, thereby helping to automate verification of bug fixes. Ultimately, the tool produced would be useful in a non-academic environment as a utility to extend the benefit of design by contract combined with TDD to the agile space."		Schoeneman, Larry		"In many professional development settings, Test Driven Development (TDD), and its evolutionary descendent, Behavior Driven Development (BDD) are increasingly being used to improve code quality and reducing error rates. While very valuable, they are considerably less rigorous than formal methodologies of program correctness via formal logic. A less rigorous methodology utilizing the ideas of formal methods but without requiring an actual full proof are also in use called ""Design by Contract"" (DBC) or ""Programming by Contract."" (PBC) This thesis will examine extending and combining the ideas behind TDD, BDD and DBC to improve the overall stability and quality of a system. It will examine using both TDD/BDD (hereinafter referred to as TDD) and PBC to enhance the quality of development throughout the software development life cycle, while aiding in the development and stabilization of sound architecture. A result of this examination is a tool that attempts to derive unit tests automatically by analyzing human written specifications for preconditions and post-conditions when coupled with data definitions. These results will be used to generate code to be run by a unit testing framework before deployment, either as part of a continuous integration environment or by individual developers. The tool will also attempt to generate wireframe classes implementing pre and post-conditions within the code and using runtime contract analysis to generate information when an exception occurs, thereby helping to automate verification of bug fixes. Ultimately, the tool produced would be useful in a non-academic environment as a utility to extend the benefit of design by contract combined with TDD to the agile space."				Excluded	Excluded	new_screen			2						
115	Behave	Leveraging Natural-Language Requirements for Deriving Better Acceptance Criteria from Models	In many software and systems development projects, analysts specify requirements using a combination of modeling and natural language (NL). In such situations, systematic acceptance testing poses a challenge because defining the acceptance criteria (AC) to be met by the system under test has to account not only for the information in the (requirements) model but also that in the NL requirements. In other words, neither models nor NL requirements per se provide a complete picture of the information content relevant to AC. Our work in this paper is prompted by the observation that a reconciliation of the information content in NL requirements and models is necessary for obtaining precise AC. We perform such reconciliation by devising an approach that automatically extracts AC-related information from NL requirements and helps modelers enrich their model with the extracted information. An existing AC derivation technique is then applied to the model that has now been enriched by the information extracted from NL requirements.Using a real case study from the financial domain, we evaluate the usefulness of the AC-related model enrichments recommended by our approach. Our evaluation results are very promising: Over our case study system, a group of five domain experts found 89% of the recommended enrichments relevant to AC and yet absent from the original model (precision of 89%). Furthermore, the experts could not pinpoint any additional information in the NL requirements which was relevant to AC but which had not already been brought to their attention by our approach (recall of 100%).	acceptance criteria; gherkin; UML; acceptance testing; controlled natural language; requirements validation and verification	Veizaga, Alvaro; Alferez, Mauricio; Torre, Damiano; Sabetzadeh, Mehrdad; Briand, Lionel; Pitskhelauri, Elene	Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems	In many software and systems development projects, analysts specify requirements using a combination of modeling and natural language (NL). In such situations, systematic acceptance testing poses a challenge because defining the acceptance criteria (AC) to be met by the system under test has to account not only for the information in the (requirements) model but also that in the NL requirements. In other words, neither models nor NL requirements per se provide a complete picture of the information content relevant to AC. Our work in this paper is prompted by the observation that a reconciliation of the information content in NL requirements and models is necessary for obtaining precise AC. We perform such reconciliation by devising an approach that automatically extracts AC-related information from NL requirements and helps modelers enrich their model with the extracted information. An existing AC derivation technique is then applied to the model that has now been enriched by the information extracted from NL requirements.Using a real case study from the financial domain, we evaluate the usefulness of the AC-related model enrichments recommended by our approach. Our evaluation results are very promising: Over our case study system, a group of five domain experts found 89% of the recommended enrichments relevant to AC and yet absent from the original model (precision of 89%). Furthermore, the experts could not pinpoint any additional information in the NL requirements which was relevant to AC but which had not already been brought to their attention by our approach (recall of 100%).				Excluded	Excluded	new_screen			2						
116	Behave	Toward A Service Platform for Developing Smart Contracts on Blockchain in BDD and TDD Styles	In recent years, Blockchain technology has been highly valued, and the related applications have begun to be developed in large numbers. A smart contract is a software component encompass business logics and transactions that run on a blockchain. Thus, verifying whether the contract logics fully reflect the business requirements are one of the most important software engineering issues in blockchain application development. Currently, developing smart contracts is still a challenging task even for experienced programmers due to the lacking of an integrated tool for developing and testing. In response to this challenge, this paper presents a service platform that supports BDD-style (Behavior-Driven Development) smart contract development, testing, and deployment for the Ethereum-based blockchains. This platform focuses on providing and resolving the cross-cutting concerns across the life-cycle of smart contract development. The feasibility of this platform is shown by demonstrating how an application scenario, namely, loyalty points exchange, can be implemented using the proposed platform. Our experiences indicate that the burdens of developers when developing smart contracts can be effectively reduced and thus increases the quality of contracts.	Blockchain;Smart contract;Behavior-Driven Development;Test-Driven Development	C. Liao; C. Cheng; K. Chen; C. Lai; T. Chiu; C. Wu-Lee	2017 IEEE 10th Conference on Service-Oriented Computing and Applications (SOCA)	In recent years, Blockchain technology has been highly valued, and the related applications have begun to be developed in large numbers. A smart contract is a software component encompass business logics and transactions that run on a blockchain. Thus, verifying whether the contract logics fully reflect the business requirements are one of the most important software engineering issues in blockchain application development. Currently, developing smart contracts is still a challenging task even for experienced programmers due to the lacking of an integrated tool for developing and testing. In response to this challenge, this paper presents a service platform that supports BDD-style (Behavior-Driven Development) smart contract development, testing, and deployment for the Ethereum-based blockchains. This platform focuses on providing and resolving the cross-cutting concerns across the life-cycle of smart contract development. The feasibility of this platform is shown by demonstrating how an application scenario, namely, loyalty points exchange, can be implemented using the proposed platform. Our experiences indicate that the burdens of developers when developing smart contracts can be effectively reduced and thus increases the quality of contracts.				Included	Included	new_screen			2						
117	Behave	Proposing Regulatory-Driven Automated Test Suites for Electronic Health Record Systems	In regulated domains such as finance and health care, failure to comply with regulation can lead to financial, civil and criminal penalties. While systems vary from organization to organization, regulations apply across organizations. We propose the use of Behavior-Driven-Development (BDD) scenarios as the basis of an automated compliance test suite for standards such as regulation and interoperability. Such test suites could become a shared asset for use by all systems subject to these regulations and standards. Each system, then, need only create their own system-specific test driver code to automate their compliance checks. The goal of this research is to enable organizations to compare their systems to regulation in a repeatable and traceable way through the use of BDD. To evaluate our proposal, we developed an abbreviated HIPAA test suite and applied it to three open-source electronic health record systems. The scenarios covered all security behavior defined by the selected regulation. The system-specific test driver code covered all security behavior defined in the scenarios, and identified where the tested system lacked such behavior.	software engineering; behavior-driven-development; healthcare it; regulatory compliance; security; software testing	Morrison, Patrick; Holmgreen, Casper; Massey, Aaron; Williams, Laurie	Proceedings of the 5th International Workshop on Software Engineering in Health Care	In regulated domains such as finance and health care, failure to comply with regulation can lead to financial, civil and criminal penalties. While systems vary from organization to organization, regulations apply across organizations. We propose the use of Behavior-Driven-Development (BDD) scenarios as the basis of an automated compliance test suite for standards such as regulation and interoperability. Such test suites could become a shared asset for use by all systems subject to these regulations and standards. Each system, then, need only create their own system-specific test driver code to automate their compliance checks. The goal of this research is to enable organizations to compare their systems to regulation in a repeatable and traceable way through the use of BDD. To evaluate our proposal, we developed an abbreviated HIPAA test suite and applied it to three open-source electronic health record systems. The scenarios covered all security behavior defined by the selected regulation. The system-specific test driver code covered all security behavior defined in the scenarios, and identified where the tested system lacked such behavior.				Included	Included	new_screen			2						
118	Behave	Proposing Regulatory-Driven Automated Test Suites	In regulated domains such as finance and health care, failure to comply with regulation can lead to financial, civil and criminal penalties. While systems vary from organization to organization, the same regulations apply for all systems. As a result, efficiencies could be gained if the commonalities between systems could be captured in public, shared, test suites for regulations. We propose the use of Behavior-Driven-Development (BDD) technology to create these test suites. With BDD, desired system behavior with respect to regulatory requirements can be captured as constrained natural language 'scenarios'. The scenarios can then be automated through system-specific test drivers. The goal of this research is to enable organizations to compare their systems to regulation in a repeatable and traceable way through the use of BDD. To evaluate our approach, we developed seven scenarios based on the HITECH Act Meaningful Use (MU) regulations for healthcare. We then created system-specific code for three open-source electronic health record systems. We found that it was possible to create scenarios and system-specific code supporting scenario execution on three systems, that iTrust can be shown to be noncompliant, and that emergency access procedures are not defined clearly enough by the regulation to determine compliance or non-compliance.	Software Testing; Security; Software Engineering; Behavior-Driven-Development; Healthcare IT; Regulatory Compliance	Morrison, Patrick; Holmgreen, Casper; Massey, Aaron; Williams, Laurie	Proceedings of the 2013 Agile Conference	In regulated domains such as finance and health care, failure to comply with regulation can lead to financial, civil and criminal penalties. While systems vary from organization to organization, the same regulations apply for all systems. As a result, efficiencies could be gained if the commonalities between systems could be captured in public, shared, test suites for regulations. We propose the use of Behavior-Driven-Development (BDD) technology to create these test suites. With BDD, desired system behavior with respect to regulatory requirements can be captured as constrained natural language 'scenarios'. The scenarios can then be automated through system-specific test drivers. The goal of this research is to enable organizations to compare their systems to regulation in a repeatable and traceable way through the use of BDD. To evaluate our approach, we developed seven scenarios based on the HITECH Act Meaningful Use (MU) regulations for healthcare. We then created system-specific code for three open-source electronic health record systems. We found that it was possible to create scenarios and system-specific code supporting scenario execution on three systems, that iTrust can be shown to be noncompliant, and that emergency access procedures are not defined clearly enough by the regulation to determine compliance or non-compliance.				Included	Included	new_screen			2						
119	Behave	Combining IID with BDD to Enhance the Critical Quality of Security Functional Requirements	In software system, functional requirements are primary system requirements. Client cannot explicitly depicted security requirements and the development team is hard to understand security requirements, makes security requirements difficult to specific implant software system. In software system development process, security requirements often neglected and ignored. However, the cost of correcting security flaws in maintenance phase is over 100 times in requirements phase. Can't effectively improve the system security, enterprises loss is bound to continue to expand. In order to enhance the security of software system, this paper combines the popular software development methodology IID (Interactive and Incremental Development) with BDD (Behavior Driven Development), institutionalized requires functional requirements must be integrated into security requirements. And, using BDD process features to evaluate the major quality of security functional requirements. Timely identifies and modifies the quality defects of security functional requirements item, effectively enhance the security of software systems.	BDD; functional requirements; IID; security functional requirements; security requirements	Lai, Sen-Tarng; Leu, Fang-Yie; Chu, William Cheng-Chung	Proceedings of the 2014 Ninth International Conference on Broadband and Wireless Computing, Communication and Applications	In software system, functional requirements are primary system requirements. Client cannot explicitly depicted security requirements and the development team is hard to understand security requirements, makes security requirements difficult to specific implant software system. In software system development process, security requirements often neglected and ignored. However, the cost of correcting security flaws in maintenance phase is over 100 times in requirements phase. Can't effectively improve the system security, enterprises loss is bound to continue to expand. In order to enhance the security of software system, this paper combines the popular software development methodology IID (Interactive and Incremental Development) with BDD (Behavior Driven Development), institutionalized requires functional requirements must be integrated into security requirements. And, using BDD process features to evaluate the major quality of security functional requirements. Timely identifies and modifies the quality defects of security functional requirements item, effectively enhance the security of software systems.				Included	Included	new_screen			2						
120	Behave	Test-Driven Development of Relational Databases	In test-first development, developers formulate and implement a detailed design iteratively, one test at a time. Test-driven development (also called test-driven design) combines TFD with refactoring, wherein developers make small changes (refactorings) to improve code design without changing the code's semantics. When developers decide to use TDD to implement a new feature, they must first ask whether the current design is the easiest possible design to enable the feature's addition. Implementing test-driven database design involves database refactoring, regression testing, and continuous integration. TDDD is an integrated part of the overall development process, not a standalone activity that data professionals perform in parallel with application TDD. Although from a technical view point, TDDD is relatively straightforward, we must overcome several challenges to its whole sale adoption throughout the IT community	test-driven development;TDD;database refactoring;database testing;test-driven database design;TDD;relational database;behavior-driven development;BDD	S. W. Ambler	IEEE Software	In test-first development, developers formulate and implement a detailed design iteratively, one test at a time. Test-driven development (also called test-driven design) combines TFD with refactoring, wherein developers make small changes (refactorings) to improve code design without changing the code's semantics. When developers decide to use TDD to implement a new feature, they must first ask whether the current design is the easiest possible design to enable the feature's addition. Implementing test-driven database design involves database refactoring, regression testing, and continuous integration. TDDD is an integrated part of the overall development process, not a standalone activity that data professionals perform in parallel with application TDD. Although from a technical view point, TDDD is relatively straightforward, we must overcome several challenges to its whole sale adoption throughout the IT community				Excluded	Excluded	new_screen			2						
121	Behave	Mobile Application Development: Automated Test Input Generation Via Model Inference based on User Story and Acceptance Criteria	In the past few years, there has been observed explosive growth in the development of Mobile Applications across Android and iOS operating system which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of the developers to devote time and sufficient efforts towards testing to make the Apps bug free and operational in the hands of end users without any hiccup. In order to test the mobile apps, manual testing procedures takes prolonged amount of time in writing test cases and even the full testing requirements are not met. In addition to this, lack of sufficient knowledge by the tester also impacts overall quality and assurance that app is bug free. To overcome all the issues of testing, and to assure that apps designed by developers are almost bug free, we propose a new testing methodology cum tool 'AgileUATM' which works primarily towards white-box and black-box testing. With this tool, all the test cases are generated automatically based on user stories and acceptance criteria by using formal specification and Z3 SMT solvers. To test the validity of the proposed tool, we applied the tool in real-time operational environment with regard to test Mobile apps. Using this tool, all the acceptance criteria is determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. From the results, it is observed that the proposed tool i.e. AgileUATM generated effective and accurate test cases, test input, and expected output was generated in a unified fashion from the user stories to meet acceptance criteria. In addition to this, the tool also reduced the development time to identify test data as compared to manual Behavior Driven Development (BDD) methodologies. With this tool, the developers got better idea with regard to required tests and able to translate the customers natural languages to the computer language as well. © 2019 IEEE.		Iqbal H.	Proceeding of 2019 International Conference on Digitization: Landscaping Artificial Intelligence, ICD 2019	In the past few years, there has been observed explosive growth in the development of Mobile Applications across Android and iOS operating system which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of the developers to devote time and sufficient efforts towards testing to make the Apps bug free and operational in the hands of end users without any hiccup. In order to test the mobile apps, manual testing procedures takes prolonged amount of time in writing test cases and even the full testing requirements are not met. In addition to this, lack of sufficient knowledge by the tester also impacts overall quality and assurance that app is bug free. To overcome all the issues of testing, and to assure that apps designed by developers are almost bug free, we propose a new testing methodology cum tool 'AgileUATM' which works primarily towards white-box and black-box testing. With this tool, all the test cases are generated automatically based on user stories and acceptance criteria by using formal specification and Z3 SMT solvers. To test the validity of the proposed tool, we applied the tool in real-time operational environment with regard to test Mobile apps. Using this tool, all the acceptance criteria is determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. From the results, it is observed that the proposed tool i.e. AgileUATM generated effective and accurate test cases, test input, and expected output was generated in a unified fashion from the user stories to meet acceptance criteria. In addition to this, the tool also reduced the development time to identify test data as compared to manual Behavior Driven Development (BDD) methodologies. With this tool, the developers got better idea with regard to required tests and able to translate the customers natural languages to the computer language as well. © 2019 IEEE.				Included	Included	new_screen			2						
122	Behave	Notice of Violation of IEEE Publication Principles: Mobile Application Development: Automated Test Input Generation Via Model Inference based on User Story and Acceptance Criteria	In the past few years, there has been observed explosive growth in the development of Mobile Applications across Android and iOS operating system which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of the developers to devote time and sufficient efforts towards testing to make the Apps bug free and operational in the hands of end users without any hiccup. In order to test the mobile apps, manual testing procedures takes prolonged amount of time in writing test cases and even the full testing requirements are not met. In addition to this, lack of sufficient knowledge by the tester also impacts overall quality and assurance that app is bug free. To overcome all the issues of testing, and to assure that apps designed by developers are almost bug free, we propose a new testing methodology cum tool “AgileUATM” which works primarily towards white-box and black-box testing. With this tool, all the test cases are generated automatically based on user stories and acceptance criteria by using formal specification and Z3 SMT solvers. To test the validity of the proposed tool, we applied the tool in real-time operational environment with regard to test Mobile apps. Using this tool, all the acceptance criteria is determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. From the results, it is observed that the proposed tool i.e. AgileUATM generated effective and accurate test cases, test input, and expected output was generated in a unified fashion from the user stories to meet acceptance criteria. In addition to this, the tool also reduced the development time to identify test data as compared to manual Behavior Driven Development (BDD) methodologies. With this tool, the developers got better idea with regard to required tests and able to translate the customers natural languages to the computer language as well.;Notice of Violation of IEEE Publication Principles <br><br> “Mobile Application Development: Automated Test Input Generation Via Model Inference based on User Story and Acceptance Criteria” <br> by Hena Iqbal <br> in the Proceedings of the International Conference on Digitization (ICD), November 2019, pp. 92-103 <br><br> After careful and considered review of the content and authorship of this paper by a duly constituted expert committee, this paper has been found to be in violation of IEEE’s Publication Principles. <br><br> This paper is a near duplication of the original text from the paper cited below. The original text was copied without attribution (including appropriate references to the original author(s) and/or paper title) and without permission. <br><br> Due to the nature of this violation, reasonable effort should be made to remove all past references to this paper, and future references should be made to the following article: <br><br> “Automated Test Input Generation via Model Inference Based on User Story and Acceptance Criteria for Mobile Application Development” <br> by Duc-Man Nguyen, Quyet-Thang Huynh, Nhu-Hang Ha and Thanh-Hung Nguyen <br> in the International Journal of Software Engineering and Knowledge Engineering, Vol. 30, No. 3 2020, pp. 399-425 <br><br>		H. Iqbal	2019 International Conference on Digitization (ICD)	In the past few years, there has been observed explosive growth in the development of Mobile Applications across Android and iOS operating system which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of the developers to devote time and sufficient efforts towards testing to make the Apps bug free and operational in the hands of end users without any hiccup. In order to test the mobile apps, manual testing procedures takes prolonged amount of time in writing test cases and even the full testing requirements are not met. In addition to this, lack of sufficient knowledge by the tester also impacts overall quality and assurance that app is bug free. To overcome all the issues of testing, and to assure that apps designed by developers are almost bug free, we propose a new testing methodology cum tool “AgileUATM” which works primarily towards white-box and black-box testing. With this tool, all the test cases are generated automatically based on user stories and acceptance criteria by using formal specification and Z3 SMT solvers. To test the validity of the proposed tool, we applied the tool in real-time operational environment with regard to test Mobile apps. Using this tool, all the acceptance criteria is determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. From the results, it is observed that the proposed tool i.e. AgileUATM generated effective and accurate test cases, test input, and expected output was generated in a unified fashion from the user stories to meet acceptance criteria. In addition to this, the tool also reduced the development time to identify test data as compared to manual Behavior Driven Development (BDD) methodologies. With this tool, the developers got better idea with regard to required tests and able to translate the customers natural languages to the computer language as well.;Notice of Violation of IEEE Publication Principles <br><br> “Mobile Application Development: Automated Test Input Generation Via Model Inference based on User Story and Acceptance Criteria” <br> by Hena Iqbal <br> in the Proceedings of the International Conference on Digitization (ICD), November 2019, pp. 92-103 <br><br> After careful and considered review of the content and authorship of this paper by a duly constituted expert committee, this paper has been found to be in violation of IEEE’s Publication Principles. <br><br> This paper is a near duplication of the original text from the paper cited below. The original text was copied without attribution (including appropriate references to the original author(s) and/or paper title) and without permission. <br><br> Due to the nature of this violation, reasonable effort should be made to remove all past references to this paper, and future references should be made to the following article: <br><br> “Automated Test Input Generation via Model Inference Based on User Story and Acceptance Criteria for Mobile Application Development” <br> by Duc-Man Nguyen, Quyet-Thang Huynh, Nhu-Hang Ha and Thanh-Hung Nguyen <br> in the International Journal of Software Engineering and Knowledge Engineering, Vol. 30, No. 3 2020, pp. 399-425 <br><br>				Excluded	Excluded	new_screen			2						
123	Behave	Combination of Test-Driven Development and Behavior-Driven Development for Improving Backend Testing Performance	In the process of software development, a testing phase is an important step for detecting the errors. In order to produce a reliable application, this paper discusses the utilization of a combination from two different testing methods, Test- Driven Development (TDD) and Behavior Driven Development (BDD). TDD testing method is a process with a high percentage of code which is tested automatically. However, it could lead to an error when the parameters of the features are changed. Meanwhile, the BDD testing method is a testing method that could perform successfully despite changes to the parameters of the features. This paper discusses the combination of TDD and BDD testing methods, which is called as T-BDD method. By implementing T-BDD into the Vixio backend system, this paper successfully shows that it could be performed to achieve a high percentage of test-coverage while it could also adapt when the parameters of the features were changed. This paper also shows that the T-BDD testing method performed better compared to using the TDD testing method only.	Unit Test, Test-Driven Development (TDD), Behavior-Driven Development(BDD), Backend, Web Application	Kerthyayana Manuaba, Ida Bagus	Procedia Computer Science	In the process of software development, a testing phase is an important step for detecting the errors. In order to produce a reliable application, this paper discusses the utilization of a combination from two different testing methods, Test- Driven Development (TDD) and Behavior Driven Development (BDD). TDD testing method is a process with a high percentage of code which is tested automatically. However, it could lead to an error when the parameters of the features are changed. Meanwhile, the BDD testing method is a testing method that could perform successfully despite changes to the parameters of the features. This paper discusses the combination of TDD and BDD testing methods, which is called as T-BDD method. By implementing T-BDD into the Vixio backend system, this paper successfully shows that it could be performed to achieve a high percentage of test-coverage while it could also adapt when the parameters of the features were changed. This paper also shows that the T-BDD testing method performed better compared to using the TDD testing method only.				Included	Included	new_screen			2						
124	Behave	Requirements behaviour analysis for ontology testing	In the software engineering field, every software product is delivered with its pertinent associated tests which verify its correct behaviour. Besides, there are several approaches which, integrated in the software development process, deal with software testing, such as unit testing or behaviour-driven development. However, in the ontology engineering field there is a lack of clearly defined testing processes that can be integrated into the ontology development process. In this paper we propose a testing framework composed by a set of activities (i.e., test design, implementation and execution), with the goal of checking whether the requirements identified are satisfied by the formalization and analysis of their expected behaviour. This testing framework can be used in different types of ontology development life-cycles, or concerning other goals such as conformance testing between ontologies. In addition to this, we propose an RDF vocabulary to store, publish and reuse these test cases and their results, in order to allow traceability between the ontology, the test cases and their requirements. We validate our approach by integrating the testing framework into an ontology engineering process where an ontology network has been developed following agile principles. © Springer Nature Switzerland AG 2018.		Fernández-Izquierdo A., García-Castro R.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	In the software engineering field, every software product is delivered with its pertinent associated tests which verify its correct behaviour. Besides, there are several approaches which, integrated in the software development process, deal with software testing, such as unit testing or behaviour-driven development. However, in the ontology engineering field there is a lack of clearly defined testing processes that can be integrated into the ontology development process. In this paper we propose a testing framework composed by a set of activities (i.e., test design, implementation and execution), with the goal of checking whether the requirements identified are satisfied by the formalization and analysis of their expected behaviour. This testing framework can be used in different types of ontology development life-cycles, or concerning other goals such as conformance testing between ontologies. In addition to this, we propose an RDF vocabulary to store, publish and reuse these test cases and their results, in order to allow traceability between the ontology, the test cases and their requirements. We validate our approach by integrating the testing framework into an ontology engineering process where an ontology network has been developed following agile principles. © Springer Nature Switzerland AG 2018.				Excluded	Excluded	new_screen			2						
125	Behave	Skyfire: Model-Based Testing with Cucumber	In the software industry, a Behavior-Driven Development (BDD) tool, Cucumber, has been widely used by practitioners. Usually product analysts, developers, and testers manually write BDD test scenarios that describe system behaviors. Testers write implementation for the BDD scenarios by hand and execute the Cucumber tests. Cucumber provides transparency about what test scenarios are covered and how the test scenarios are mapped to executable tests. One drawback of the Cucumber BDD approach is that test scenarios are generated manually. Thus, the test scenarios are usually weak. More importantly, practitioners do not have a metric to measure test coverage. In this paper, we present a Model-Based Testing (MBT) tool, skyfire. Skyfire can automatically generate effective Cucumber test scenarios to replace manually generated test scenarios. Skyfire reads a behavioral UML diagram (e.g., a state machine diagram), identifies all necessary elements (e.g., transitions) of the diagram, generates effective tests to satisfy various graph coverage criteria, and converts the tests into Cucumber scenarios. Then testers write Cucumber mappings for the generated scenarios. Skyfire does not only generate effective tests but is also completely compatible with the existing agile development and continuous integration (CI) rhythm. We present the design architecture and implementation of skyfire, as well as an industrial case study to show how skyfire is used in practice.		N. Li; A. Escalona; T. Kamal	2016 IEEE International Conference on Software Testing, Verification and Validation (ICST)	In the software industry, a Behavior-Driven Development (BDD) tool, Cucumber, has been widely used by practitioners. Usually product analysts, developers, and testers manually write BDD test scenarios that describe system behaviors. Testers write implementation for the BDD scenarios by hand and execute the Cucumber tests. Cucumber provides transparency about what test scenarios are covered and how the test scenarios are mapped to executable tests. One drawback of the Cucumber BDD approach is that test scenarios are generated manually. Thus, the test scenarios are usually weak. More importantly, practitioners do not have a metric to measure test coverage. In this paper, we present a Model-Based Testing (MBT) tool, skyfire. Skyfire can automatically generate effective Cucumber test scenarios to replace manually generated test scenarios. Skyfire reads a behavioral UML diagram (e.g., a state machine diagram), identifies all necessary elements (e.g., transitions) of the diagram, generates effective tests to satisfy various graph coverage criteria, and converts the tests into Cucumber scenarios. Then testers write Cucumber mappings for the generated scenarios. Skyfire does not only generate effective tests but is also completely compatible with the existing agile development and continuous integration (CI) rhythm. We present the design architecture and implementation of skyfire, as well as an industrial case study to show how skyfire is used in practice.				Included	Included	new_screen			2						
126	Behave	Systematic verification and testing	In this chapter, we present a process pattern for model based specification, verification and testing. It combines concepts of behaviour driven development (BDD), graphical and formal, mathematical modelling, formal verification techniques, acceptance testing and model based testing. The rigorous approach helps to ensure that for highly dependable systems, dependability (e.g. safety) requirements are fulfilled and both the specified and the implemented behaviour are as desired. It helps bridging the gap between natural language or semi-formal requirements and mathematical abstraction. Furthermore, it addresses the issue that formal modelling expertise and domain knowledge are rarely held by the same set of people. © Springer Nature Switzerland AG 2020.		Dghaym D., Fischer T., Hoang T.S., Reichl K., Snook C., Schlick R., Tummeltshammer P.	Validation and Verification of Automated Systems: Results of the ENABLE-S3 Project	In this chapter, we present a process pattern for model based specification, verification and testing. It combines concepts of behaviour driven development (BDD), graphical and formal, mathematical modelling, formal verification techniques, acceptance testing and model based testing. The rigorous approach helps to ensure that for highly dependable systems, dependability (e.g. safety) requirements are fulfilled and both the specified and the implemented behaviour are as desired. It helps bridging the gap between natural language or semi-formal requirements and mathematical abstraction. Furthermore, it addresses the issue that formal modelling expertise and domain knowledge are rarely held by the same set of people. © Springer Nature Switzerland AG 2020.				Excluded	Excluded	new_screen			2						
127	Behave	BDD by Example: Russian Bylina Written in Gherkin Language	"In this paper is presented the User Stories technique within the Behaviour-Driven Development process by example of the famous Russian bylina (epic poem) ""Three trips of Ilya Muromets"" written in Gherkin language. In the first part are given explanations about the choice of the bylina as a good example for presentation of this technique and about the choice of GitHub as a good environment for this presentation. In the second part is placed the text of the presentation divided by the stages of the Story development and fitted with the links to the corresponding commits and file versions in the educational repository. A distinct advantage of this presentation is that it reflects a Story in its evolution, as a process. It reflects a more complex and changeable behaviour than in static trivial examples, which are usually used. Also, there are presented the main features of using the User Stories technique in Russian language, which have not been previously covered nowhere. Besides that, the using of the educational repository can significantly increase the possibilities for further spreading and development of the example."	behaviour-driven development; Gherkin; Agile; user stories; byliny; cucumber; epic poetry; examples; extreme programming; GitHub; JBehave; Scrum	Mustyatsa, Vadim	Proceedings of the 11th Central &amp; Eastern European Software Engineering Conference in Russia	"In this paper is presented the User Stories technique within the Behaviour-Driven Development process by example of the famous Russian bylina (epic poem) ""Three trips of Ilya Muromets"" written in Gherkin language. In the first part are given explanations about the choice of the bylina as a good example for presentation of this technique and about the choice of GitHub as a good environment for this presentation. In the second part is placed the text of the presentation divided by the stages of the Story development and fitted with the links to the corresponding commits and file versions in the educational repository. A distinct advantage of this presentation is that it reflects a Story in its evolution, as a process. It reflects a more complex and changeable behaviour than in static trivial examples, which are usually used. Also, there are presented the main features of using the User Stories technique in Russian language, which have not been previously covered nowhere. Besides that, the using of the educational repository can significantly increase the possibilities for further spreading and development of the example."				Excluded	Excluded	new_screen			2						
128	Behave	Satisfaction and its correlates in agile software development	In this paper we address the topic of software development team members satisfaction with their development process. We present an in-depth analysis of the results of a nationwide survey about software development in Switzerland. We wanted to find out if satisfaction relates to the applied development method, and to the use of various practices, and impacts on business, team and software issues. We found that higher satisfaction is reported more by those using Agile development than with plan-driven processes. We explored the different perspectives of developers and those with a management role and found a high consistency of satisfaction between Agile developers and Agile management, and differences with those using working plan-driven methods. We found that certain practices and impacts have high correlations to satisfaction, and that collaborative processes are closely related to satisfaction. We then explored the relationship between satisfaction and various other perspectives. Our results in this analysis are principally descriptive, but we think they can be a relevant contribution to understand the challenges for everyone involved in Agile development.		Kropp, Martin; Meier, Andreas; Anslow, Craig; Biddle, Robert	Journal of Systems and Software	In this paper we address the topic of software development team members satisfaction with their development process. We present an in-depth analysis of the results of a nationwide survey about software development in Switzerland. We wanted to find out if satisfaction relates to the applied development method, and to the use of various practices, and impacts on business, team and software issues. We found that higher satisfaction is reported more by those using Agile development than with plan-driven processes. We explored the different perspectives of developers and those with a management role and found a high consistency of satisfaction between Agile developers and Agile management, and differences with those using working plan-driven methods. We found that certain practices and impacts have high correlations to satisfaction, and that collaborative processes are closely related to satisfaction. We then explored the relationship between satisfaction and various other perspectives. Our results in this analysis are principally descriptive, but we think they can be a relevant contribution to understand the challenges for everyone involved in Agile development.				Excluded	Excluded	new_screen			2						
129	Behave	Compliance checking on building models with the gherkin language and continuous integration	In this paper we document our approach on applying Behaviour-Driven Development (BDD) and Continuous Integration (CI) from the software industry to the construction sector. We have provided a freely available open software toolset for the application of rules in the Gherkin syntax to an IFC building model. A prominent aspect of BDD and contrary to mvdXML, the formalization of rules in plain-test human-readable scenarios provides a basis for collaborative formalization of rules among stakeholders. At the same time our approach includes imperative program code that is fully extensible to incorporate for example external data sources and geometrical reasoning. Runnings test on every model revision (the CI concept) as opposed to, for example, upon model delivery ensures a proactive approach to compliance. Reusing existing open source frameworks allowed us to build a comprehensive solution for continuous and automated model checking, visualization and reporting in several hundred lines of program code. © EG-ICE 2020 Workshop on Intelligent Computing in Engineering, Proceedings. All rights reserved.		Moult D., Krijnen T.	EG-ICE 2020 Workshop on Intelligent Computing in Engineering, Proceedings	In this paper we document our approach on applying Behaviour-Driven Development (BDD) and Continuous Integration (CI) from the software industry to the construction sector. We have provided a freely available open software toolset for the application of rules in the Gherkin syntax to an IFC building model. A prominent aspect of BDD and contrary to mvdXML, the formalization of rules in plain-test human-readable scenarios provides a basis for collaborative formalization of rules among stakeholders. At the same time our approach includes imperative program code that is fully extensible to incorporate for example external data sources and geometrical reasoning. Runnings test on every model revision (the CI concept) as opposed to, for example, upon model delivery ensures a proactive approach to compliance. Reusing existing open source frameworks allowed us to build a comprehensive solution for continuous and automated model checking, visualization and reporting in several hundred lines of program code. © EG-ICE 2020 Workshop on Intelligent Computing in Engineering, Proceedings. All rights reserved.				Included	Included	new_screen			2						
130	Behave	Improving Agile Software Development with Domain Ontologies	In this paper we propose to apply domain ontologies in agile software development to reduce the ambiguity caused by using natural language as ubiquitous language to report user stories. To justify and demonstrate our approach, we present a case study that combines Scrum and Behaviour-Driven Development (BDD) in the development of an educational support system, which was built to support the activities of the Medicine Programme of Federal University of São Carlos (UFSCar) in Brazil. Starting from a reference ontology for the Higher Education domain, we gradually specialized this ontology for this programme. Since we selected the Evaluation Management module of this system for our case study, we applied the Evaluation Process Ontology to that programme, and defined user stories to identify the feature set to be implemented. For evaluation and validation purposes, we assessed the quality of all ontologies used in this work according to structural and functional dimensions. © 2018, Springer International Publishing AG, part of Springer Nature.		de Souza P.L., do Prado A.F., de Souza W.L., dos Santos Forghieri Pereira S.M., Pires L.F.	Advances in Intelligent Systems and Computing	In this paper we propose to apply domain ontologies in agile software development to reduce the ambiguity caused by using natural language as ubiquitous language to report user stories. To justify and demonstrate our approach, we present a case study that combines Scrum and Behaviour-Driven Development (BDD) in the development of an educational support system, which was built to support the activities of the Medicine Programme of Federal University of São Carlos (UFSCar) in Brazil. Starting from a reference ontology for the Higher Education domain, we gradually specialized this ontology for this programme. Since we selected the Evaluation Management module of this system for our case study, we applied the Evaluation Process Ontology to that programme, and defined user stories to identify the feature set to be implemented. For evaluation and validation purposes, we assessed the quality of all ontologies used in this work according to structural and functional dimensions. © 2018, Springer International Publishing AG, part of Springer Nature.				Included	Included	new_screen			2						
131	Behave	Agile testing practices in software quality: State of the art review	In this paper you can find a review of articles related to agile testing practices in software quality, looking for theoretical information and real cases applied to testing inside a modern context, comparing them with the standard procedures taking into account their advantages and relevant features. As final result, we determine that agile practices in software quality have wide acceptance and many companies have chosen their use for all their benefits and impact on development software processes in several real applications, not necessarily IT governance ones, since other kind of technical applications have shown excellent results on testing. © 2005 - 2016 JATIT & LLS. All rights reserved.		Gil C., Diaz J., Orozco M., de la Hoz A., de la Hoz E., Morales R.	Journal of Theoretical and Applied Information Technology	In this paper you can find a review of articles related to agile testing practices in software quality, looking for theoretical information and real cases applied to testing inside a modern context, comparing them with the standard procedures taking into account their advantages and relevant features. As final result, we determine that agile practices in software quality have wide acceptance and many companies have chosen their use for all their benefits and impact on development software processes in several real applications, not necessarily IT governance ones, since other kind of technical applications have shown excellent results on testing. © 2005 - 2016 JATIT & LLS. All rights reserved.				Excluded	Excluded	new_screen			2						
132	Behave	Consistency Reflection for Automatic Update of Testing Environment	In this paper, we present an approach for maintaining consistency among design models, system under test, and test components. Our approach provides an automatic updating technique to deal with changes that happen frequently in agile software development. Consistency reflection by automatic updating allows us to cut off manual tasks required in maintaining automated tests and speed up testing process which is a bottleneck in service development lifecycle. We introduce the use of metadata, the data structure that describes structural behavior of the system, in our automatic updating technique. Metadata is used as a common medium for communicating changes to keep consistency among design, system under test, and test components. We present an example of testing process to show how we apply this approach in practice.	behavior-driven development; agile software development; automated software testing; automatic update; consistency reflection; design models; metadata	Sathawornwichit, Chaiwat; Hosono, Shigeru	Proceedings of the 2012 IEEE Asia-Pacific Services Computing Conference)	In this paper, we present an approach for maintaining consistency among design models, system under test, and test components. Our approach provides an automatic updating technique to deal with changes that happen frequently in agile software development. Consistency reflection by automatic updating allows us to cut off manual tasks required in maintaining automated tests and speed up testing process which is a bottleneck in service development lifecycle. We introduce the use of metadata, the data structure that describes structural behavior of the system, in our automatic updating technique. Metadata is used as a common medium for communicating changes to keep consistency among design, system under test, and test components. We present an example of testing process to show how we apply this approach in practice.				Included	Included	new_screen			2						
133	Behave	Generation of behavior-driven development C++ tests from abstract state machine scenarios	In this paper, we present the AsmetaVBDD tool that automatically translates the scenarios written in the AValLa language (used by the asmeta validator (AsmetaV)) into Behavior-Driven Development scenarios for C++. © Springer Nature Switzerland AG 2018.		Bonfanti S., Gargantini A., Mashkoor A.	Communications in Computer and Information Science	In this paper, we present the AsmetaVBDD tool that automatically translates the scenarios written in the AValLa language (used by the asmeta validator (AsmetaV)) into Behavior-Driven Development scenarios for C++. © Springer Nature Switzerland AG 2018.				Included	Included	new_screen			2						
134	Behave	Behaviour-Driven Development for Computer-Interpretable Clinical Guidelines	In this paper, we propose an approach for specification and analysis of Computer-Interpretable Clinical Guidelines (CIGs) that was inspired by Behaviour-Driven Development. The expected behaviour of a CIG is specified by requirements in natural language. On the one hand, those requirements are used as design input for guideline development. On the other hand, they can be checked against time-oriented data recorded during testing sessions of the implemented CIG.		Hatko, Reinhard; Mersmann, Stefan; Puppe, Prank	Proceedings of the 10th International Conference on Knowledge Engineering and Software Engineering - Volume 1289	In this paper, we propose an approach for specification and analysis of Computer-Interpretable Clinical Guidelines (CIGs) that was inspired by Behaviour-Driven Development. The expected behaviour of a CIG is specified by requirements in natural language. On the one hand, those requirements are used as design input for guideline development. On the other hand, they can be checked against time-oriented data recorded during testing sessions of the implemented CIG.				Included	Included	new_screen			2						
135	Behave	A preliminary study on using acceptance tests for representing business requirements of smart contracts	"In this work, we address the following question: ""Which acceptance testing techniques are being used for representing business requirements of smart contracts?"" To answer this question we performed a systematic mapping to determine whether acceptance tests for smart contracts and blockchain are being utilized to represent requirements and which acceptance testing techniques are being applied. This systematic mapping shows that, in fact, acceptance testing techniques are still not commonly used to represent the business requirements of smart contracts. We only found two studies using acceptance testing techniques with smart contracts. Moreover, only one of them uses an acceptance testing technique, the BDD (Behavior-Driven Development) notation, to represent the business requirements. In order to confirm that it is possible to represent business requirements of smart contracts, we developed an example that uses the BDD notation to represent requirements of a smart contract deployed in the Hyperledger blockchain. Preliminary results show that it is possible to use acceptance tests to represent business requirements."	acceptance testing;acceptance test;smart contract;business requirement;blockchain	P. Vilain; J. Mylopoulos; H. -A. Jacobsen	2020 IEEE International Conference on Blockchain and Cryptocurrency (ICBC)	"In this work, we address the following question: ""Which acceptance testing techniques are being used for representing business requirements of smart contracts?"" To answer this question we performed a systematic mapping to determine whether acceptance tests for smart contracts and blockchain are being utilized to represent requirements and which acceptance testing techniques are being applied. This systematic mapping shows that, in fact, acceptance testing techniques are still not commonly used to represent the business requirements of smart contracts. We only found two studies using acceptance testing techniques with smart contracts. Moreover, only one of them uses an acceptance testing technique, the BDD (Behavior-Driven Development) notation, to represent the business requirements. In order to confirm that it is possible to represent business requirements of smart contracts, we developed an example that uses the BDD notation to represent requirements of a smart contract deployed in the Hyperledger blockchain. Preliminary results show that it is possible to use acceptance tests to represent business requirements."				Excluded	Excluded	new_screen			2						
136	Behave	Behavior-Driven Development as an Approach to Improve Software Quality and Communication across Remote Business Stakeholders, Developers and QA: Two Case Studies	In this work, we describe two of our experiences applying BDD: one at a large publisher of financial information and business news, and the other in a secure collaboration platform vendor. The team composition involves both a local team and an external service provider. We analyze two adoption processes, one driven by the product team, and the other driven by the development team. We cover the communication benefits and impacts on areas such as stakeholder alignment, software design, code refactoring, and bug fixing. We also discuss lessons learned, caveats and how we plan to expand this practice in the future.	distributed agile teams; industrial offshoring and outsourcing experiences; methods and processes; social and human aspects of software development	Scandaroli, André; Leite, Rodrigo; Kiosia, Aléxis H.; Coelho, Sandro A.	Proceedings of the 14th International Conference on Global Software Engineering	In this work, we describe two of our experiences applying BDD: one at a large publisher of financial information and business news, and the other in a secure collaboration platform vendor. The team composition involves both a local team and an external service provider. We analyze two adoption processes, one driven by the product team, and the other driven by the development team. We cover the communication benefits and impacts on areas such as stakeholder alignment, software design, code refactoring, and bug fixing. We also discuss lessons learned, caveats and how we plan to expand this practice in the future.				Excluded	Excluded	new_screen			2						
137	Behave	Behavior-Driven Development as an Approach to Improve Software Quality and Communication Across Remote Business Stakeholders, Developers and QA: Two Case Studies	In this work, we describe two of our experiences applying BDD: one at a large publisher of financial information and business news, and the other in a secure collaboration platform vendor. The team composition involves both a local team and an external service provider. We analyze two adoption processes, one driven by the product team, and the other driven by the development team. We cover the communication benefits and impacts on areas such as stakeholder alignment, software design, code refactoring, and bug fixing. We also discuss lessons learned, caveats and how we plan to expand this practice in the future. © 2019 IEEE.		Scandaroli A., Leite R., Kiosia A.H., Coelho S.A.	Proceedings - 2019 ACM/IEEE 14th International Conference on Global Software Engineering, ICGSE 2019	In this work, we describe two of our experiences applying BDD: one at a large publisher of financial information and business news, and the other in a secure collaboration platform vendor. The team composition involves both a local team and an external service provider. We analyze two adoption processes, one driven by the product team, and the other driven by the development team. We cover the communication benefits and impacts on areas such as stakeholder alignment, software design, code refactoring, and bug fixing. We also discuss lessons learned, caveats and how we plan to expand this practice in the future. © 2019 IEEE.				Included	Included	new_screen			2						
138	Behave	Towards a Behavior-Oriented Specification and Testing Language for Multimodal Applications	Initiated by the ubiquity of mobile devices, human computer interaction has evolved beyond the classic PCs' mouse and keyboard setup. Smartphones and tablets introduced new interaction modalities to the mass market and created the need for specialized software engineering methods. While more and more powerful SDKs are released to develop interactive applications, specifying user interaction is still ambiguous and error-prone, causing software defects as well as misunderstandings and frustration among project team members and stakeholders. We present an approach addressing this problems by demonstrating how to incorporate multimodal interaction into user acceptance tests written in near-natural language using Gherkin and formal gesture descriptions.	software engineering; multimodal user interfaces; specification	Hesenius, Marc; Griebe, Tobias; Gruhn, Volker	Proceedings of the 2014 ACM SIGCHI Symposium on Engineering Interactive Computing Systems	Initiated by the ubiquity of mobile devices, human computer interaction has evolved beyond the classic PCs' mouse and keyboard setup. Smartphones and tablets introduced new interaction modalities to the mass market and created the need for specialized software engineering methods. While more and more powerful SDKs are released to develop interactive applications, specifying user interaction is still ambiguous and error-prone, causing software defects as well as misunderstandings and frustration among project team members and stakeholders. We present an approach addressing this problems by demonstrating how to incorporate multimodal interaction into user acceptance tests written in near-natural language using Gherkin and formal gesture descriptions.				Included	Included	new_screen			2						
139	Behave	Improving the Prediction of Files Changed by Programming Tasks	Integration conflicts often damage software quality and developers' productivity in a collaborative development environment. For reducing merge conflicts, we could avoid asking developers to execute potentially conflicting tasks in parallel, as long as we can predict the files to be changed by each task. As manually predicting that is hard, the TAITI tool tries to do that in the context of BDD (Behaviour-Driven Development) projects, by statically analysing the automated acceptance tests that validate each task. TAITI computes the set of files that might be executed by the tests of a task (a so called test-based task interface), approximating the files that developers will change when performing the task. Although TAITI performs better than a random task interface, there is space for accuracy improvements. In this paper, we extend the interfaces computed by TAITI by including the dependences of the application files reached by the task tests. To understand the potential benefits of our extension, we evaluate precision and recall of 60 task interfaces from 8 Rails GitHub projects. The results bring evidence that the extended interface improves recall by slightly compromising precision.	Collaborative development; File change prediction; Behaviour-Driven Development	Santos, João Pedro; Rocha, Thaís; Borba, Paulo	Proceedings of the XIII Brazilian Symposium on Software Components, Architectures, and Reuse	Integration conflicts often damage software quality and developers' productivity in a collaborative development environment. For reducing merge conflicts, we could avoid asking developers to execute potentially conflicting tasks in parallel, as long as we can predict the files to be changed by each task. As manually predicting that is hard, the TAITI tool tries to do that in the context of BDD (Behaviour-Driven Development) projects, by statically analysing the automated acceptance tests that validate each task. TAITI computes the set of files that might be executed by the tests of a task (a so called test-based task interface), approximating the files that developers will change when performing the task. Although TAITI performs better than a random task interface, there is space for accuracy improvements. In this paper, we extend the interfaces computed by TAITI by including the dependences of the application files reached by the task tests. To understand the potential benefits of our extension, we evaluate precision and recall of 60 task interfaces from 8 Rails GitHub projects. The results bring evidence that the extended interface improves recall by slightly compromising precision.				Included	Included	new_screen			2						
140	Behave	Test-Driven Java Development	Invoke TDD principles for end-to-end application development with JavaAbout This BookExplore the most popular TDD tools and frameworks and become more proficient in building applicationsCreate applications with better code design, fewer bugs, and higher test coverage, enabling you to get them to market quicklyImplement test-driven programming methods into your development workflowsWho This Book Is ForIf you're an experienced Java developer and want to implement more effective methods of programming systems and applications, then this book is for you.What You Will LearnExplore the tools and frameworks required for effective TDD developmentPerform the Red-Green-Refactor process efficiently, the pillar around which all other TDD procedures are basedMaster effective unit testing in isolation from the rest of your codeDesign simple and easily maintainable codes by implementing different techniquesUse mocking frameworks and techniques to easily write and quickly execute testsDevelop an application to implement behaviour-driven development in conjunction with unit testingEnable and disable features using Feature TogglesIn DetailTest-driven development (TDD) is a development approach that relies on a test-first procedure that emphasises writing a test before writing the necessary code, and then refactoring the code to optimize it.The value of performing TDD with Java, one of the most established programming languages, is to improve the productivity of programmers, the maintainability and performance of code, and develop a deeper understanding of the language and how to employ it effectively.Starting with the basics of TDD and reasons why its adoption is beneficial, this book will take you from the first steps of TDD with Java until you are confident enough to embrace the practice in your day-to-day routine.You'll be guided through setting up tools, frameworks, and the environment you need, and will dive right in to hands-on exercises with the goal of mastering one practice, tool, or framework at a time. You'll learn about the Red-Green-Refactor procedure, how to write unit tests, and how to use them as executable documentation.With this book you'll also discover how to design simple and easily maintainable code, work with mocks, utilise behaviour-driven development, refactor old legacy code, and release a half-finished feature to production with feature toggles.You will finish this book with a deep understanding of the test-driven development methodology and the confidence to apply it to application programming with Java.Style and approachAn easy-to-follow, hands-on guide to building applications through effective coding practices. This book covers practical examples by introducing different problems, each one designed as a learning exercise to help you understand each aspect of TDD.		Farcic, Viktor; Garcia, Alex		Invoke TDD principles for end-to-end application development with JavaAbout This BookExplore the most popular TDD tools and frameworks and become more proficient in building applicationsCreate applications with better code design, fewer bugs, and higher test coverage, enabling you to get them to market quicklyImplement test-driven programming methods into your development workflowsWho This Book Is ForIf you're an experienced Java developer and want to implement more effective methods of programming systems and applications, then this book is for you.What You Will LearnExplore the tools and frameworks required for effective TDD developmentPerform the Red-Green-Refactor process efficiently, the pillar around which all other TDD procedures are basedMaster effective unit testing in isolation from the rest of your codeDesign simple and easily maintainable codes by implementing different techniquesUse mocking frameworks and techniques to easily write and quickly execute testsDevelop an application to implement behaviour-driven development in conjunction with unit testingEnable and disable features using Feature TogglesIn DetailTest-driven development (TDD) is a development approach that relies on a test-first procedure that emphasises writing a test before writing the necessary code, and then refactoring the code to optimize it.The value of performing TDD with Java, one of the most established programming languages, is to improve the productivity of programmers, the maintainability and performance of code, and develop a deeper understanding of the language and how to employ it effectively.Starting with the basics of TDD and reasons why its adoption is beneficial, this book will take you from the first steps of TDD with Java until you are confident enough to embrace the practice in your day-to-day routine.You'll be guided through setting up tools, frameworks, and the environment you need, and will dive right in to hands-on exercises with the goal of mastering one practice, tool, or framework at a time. You'll learn about the Red-Green-Refactor procedure, how to write unit tests, and how to use them as executable documentation.With this book you'll also discover how to design simple and easily maintainable code, work with mocks, utilise behaviour-driven development, refactor old legacy code, and release a half-finished feature to production with feature toggles.You will finish this book with a deep understanding of the test-driven development methodology and the confidence to apply it to application programming with Java.Style and approachAn easy-to-follow, hands-on guide to building applications through effective coding practices. This book covers practical examples by introducing different problems, each one designed as a learning exercise to help you understand each aspect of TDD.				Excluded	Excluded	new_screen			2						
141	Behave	An industrial case study on test cases as requirements	It is a conundrum that agile projects can succeed ‘without requirements’ when weak requirements engineering is a known cause for project failures. While Agile development projects often manage well without extensive requirements documentation, test cases are commonly used as requirements. We have investigated this agile practice at three companies in order to understand how test cases can fill the role of requirements. We performed a case study based on twelve interviews performed in a previous study. The findings include a range of benefits and challenges in using test cases for eliciting, validating, verifying, tracing and managing requirements. In addition, we identified three scenarios for applying the practice, namely as a mature practice, as a de facto practice and as part of an agile transition. The findings provide insights into how the role of requirements may be met in agile development including challenges to consider. © Springer International Publishing Switzerland 2015.		Bjarnason E., Unterkalmsteiner M., Engström E., Borg M.	Lecture Notes in Business Information Processing	It is a conundrum that agile projects can succeed ‘without requirements’ when weak requirements engineering is a known cause for project failures. While Agile development projects often manage well without extensive requirements documentation, test cases are commonly used as requirements. We have investigated this agile practice at three companies in order to understand how test cases can fill the role of requirements. We performed a case study based on twelve interviews performed in a previous study. The findings include a range of benefits and challenges in using test cases for eliciting, validating, verifying, tracing and managing requirements. In addition, we identified three scenarios for applying the practice, namely as a mature practice, as a de facto practice and as part of an agile transition. The findings provide insights into how the role of requirements may be met in agile development including challenges to consider. © Springer International Publishing Switzerland 2015.				Included	Included	new_screen			2						
142	Behave	Chapter Five - Advances in Testing JavaScript-Based Web Applications	JavaScript is a flexible and expressive prototype-based scripting language that is used by developers to create interactive web applications. The language is interpreted, dynamic, weakly typed, and has first-class functions. It also interacts extensively with other web languages such as CSS and HTML at runtime. All these characteristics make JavaScript code particularly error-prone and challenging to analyze and test. In this chapter, we explore recent advances made in analysis and testing techniques geared toward JavaScript-based web applications. In particular, we look at recent empirical studies, testing techniques, test oracle automation approaches, test adequacy assessment methods, fault localization and repair, and Integrated Development Environment support to help programmers write better JavaScript code.	JavaScript, Testing, Dynamic analysis, Web applications, Test adequacy, Oracles	Mesbah, Ali		JavaScript is a flexible and expressive prototype-based scripting language that is used by developers to create interactive web applications. The language is interpreted, dynamic, weakly typed, and has first-class functions. It also interacts extensively with other web languages such as CSS and HTML at runtime. All these characteristics make JavaScript code particularly error-prone and challenging to analyze and test. In this chapter, we explore recent advances made in analysis and testing techniques geared toward JavaScript-based web applications. In particular, we look at recent empirical studies, testing techniques, test oracle automation approaches, test adequacy assessment methods, fault localization and repair, and Integrated Development Environment support to help programmers write better JavaScript code.				Excluded	Excluded	new_screen			2						
143	Behave	Mastering Symfony	Key FeaturesCreate a robust and reliable Symfony development pipeline using Amazon's cloud platformCut development and maintenance costs by defining crystal clear features and possible scenarios for each feature before implementationFollow detailed examples provided in each chapter to create a task management applicationBook DescriptionIn this book, you will learn some lesser known aspects of development with Symfony, and you will see how to use Symfony as a framework to create reliable and effective applications. You might have developed some impressive PHP libraries in other projects, but what is the point when your library is tied to one particular project? With Symfony, you can turn your code into a service and reuse it in other projects.This book starts with Symfony concepts such as bundles, routing, twig, doctrine, and more, taking you through the request/response life cycle. You will then proceed to set up development, test, and deployment environments in AWS. Then you will create reliable projects using Behat and Mink, and design business logic, cover authentication, and authorization steps in a security checking process. You will be walked through concepts such as DependencyInjection, service containers, and services, and go through steps to create customized commands for Symfony's console. Finally, the book covers performance optimization and the use of Varnish and Memcached in our project, and you are treated with the creation of database agnostic bundles and best practices.What you will learnInstall and configure Symfony and required third-party bundles to develop a task management applicationSet up a continuous integration server to orchestrate automatic builds every time you add a new feature to your projectReduce maintenance costs dramatically using Behaviour Driven Development (BDD)Create a slick user interface using the Bootstrap frameworkDesign robust business logic using DoctrineBuild a comprehensive dashboard and secure your project using the Sonata projectImprove performance using Redis, Memcache, and VarnishCreate customized Symfony commands and add them to your consoleAbout the AuthorSohail Salehi is a full stack web developer who is constantly seeking creative solutions for complex problems. He believes that what has been taught as universalities should be considered as a basic stepping stone to real-life challenges. They cannot be used as practical solutions. He learned that a one-size-fits-all solution does not work in the IT world. Every business, every coding challenge, and every environment setup has its own signature and requires some tweaking on basic principals to make sure that it receives a reliable cost-effective solution.When he is not staring at his computer screen, he is watching sunsets and sunrises, swimming and surfing in the ocean, and putting his subconscious mind at work by asking creative questions while facing life's ups and downs on a daily basis.Table of ContentsInstalling and Configuring SymfonyThe Request and Response Life CycleSetting Up the EnvironmentUsing Behavior-Driven Development in SymfonyBusiness LogicDashboard and SecurityThe Presentation LayerProject ReviewServices and Service ContainersCustom User CommandsMore about Dev, Test and Prod EnvironmentsCaching in Symfony		Salehi, Sohail		Key FeaturesCreate a robust and reliable Symfony development pipeline using Amazon's cloud platformCut development and maintenance costs by defining crystal clear features and possible scenarios for each feature before implementationFollow detailed examples provided in each chapter to create a task management applicationBook DescriptionIn this book, you will learn some lesser known aspects of development with Symfony, and you will see how to use Symfony as a framework to create reliable and effective applications. You might have developed some impressive PHP libraries in other projects, but what is the point when your library is tied to one particular project? With Symfony, you can turn your code into a service and reuse it in other projects.This book starts with Symfony concepts such as bundles, routing, twig, doctrine, and more, taking you through the request/response life cycle. You will then proceed to set up development, test, and deployment environments in AWS. Then you will create reliable projects using Behat and Mink, and design business logic, cover authentication, and authorization steps in a security checking process. You will be walked through concepts such as DependencyInjection, service containers, and services, and go through steps to create customized commands for Symfony's console. Finally, the book covers performance optimization and the use of Varnish and Memcached in our project, and you are treated with the creation of database agnostic bundles and best practices.What you will learnInstall and configure Symfony and required third-party bundles to develop a task management applicationSet up a continuous integration server to orchestrate automatic builds every time you add a new feature to your projectReduce maintenance costs dramatically using Behaviour Driven Development (BDD)Create a slick user interface using the Bootstrap frameworkDesign robust business logic using DoctrineBuild a comprehensive dashboard and secure your project using the Sonata projectImprove performance using Redis, Memcache, and VarnishCreate customized Symfony commands and add them to your consoleAbout the AuthorSohail Salehi is a full stack web developer who is constantly seeking creative solutions for complex problems. He believes that what has been taught as universalities should be considered as a basic stepping stone to real-life challenges. They cannot be used as practical solutions. He learned that a one-size-fits-all solution does not work in the IT world. Every business, every coding challenge, and every environment setup has its own signature and requires some tweaking on basic principals to make sure that it receives a reliable cost-effective solution.When he is not staring at his computer screen, he is watching sunsets and sunrises, swimming and surfing in the ocean, and putting his subconscious mind at work by asking creative questions while facing life's ups and downs on a daily basis.Table of ContentsInstalling and Configuring SymfonyThe Request and Response Life CycleSetting Up the EnvironmentUsing Behavior-Driven Development in SymfonyBusiness LogicDashboard and SecurityThe Presentation LayerProject ReviewServices and Service ContainersCustom User CommandsMore about Dev, Test and Prod EnvironmentsCaching in Symfony				Excluded	Excluded	new_screen			2						
144	Behave	RSpec Essentials	Key FeaturesExplore the concept of testability and how to implement tests that deliver the most valueMaximize the quality of your Ruby code through a wide variety of testsMaster the real-world tradeoffs of testing through detailed examples supported by in-depth discussionBook DescriptionThis book will teach you how to use RSpec to write high-value tests for real-world code. We start with the key concepts of the unit and testability, followed by hands-on exploration of key features. From the beginning, we learn how to integrate tests into the overall development process to help create high-quality code, avoiding the dangers of testing for its own sake.We build up sample applications and their corresponding tests step by step, from simple beginnings to more sophisticated versions that include databases and external web services. We devote three chapters to web applications with rich JavaScript user interfaces, building one from the ground up using behavior-driven development (BDD) and test-driven development (TDD).The code examples are detailed enough to be realistic while simple enough to be easily understood. Testing concepts, development methodologies, and engineering tradeoffs are discussed in detail as they arise. This approach is designed to foster the reader's ability to make well-informed decisions on their own.What you will learnIdentify a unit of software for the purposes of testingManage test states with hooks, fixtures, and mocksHandle external web services in tests using various techniquesConfigure RSpec flexibly and cleanly using support code and environment variablesInteract with rich web apps in tests using CapybaraBuild the right feature with behavior-driven developmentCustomize matchers and failure messagesVerify correct development and production environmentsAbout the AuthorMani Tadayon first learned to program as a shy 7th grader on an Apple IIe using BASIC. He went on to learn Pascal, C++, Java, JavaScript, Visual Basic, and PHP before becoming a Ruby developer in 2008. With 15 years of experience in the software industry, he has developed expertise in web development, infrastructure, and testing. Mani's interests and education are broad, with degrees in foreign languages, computer science, and geography. He lives just far enough from Silicon Valley with his family and their many, many Shiba Inus.Table of ContentsExploring Testability from Unit Tests to Behavior-Driven DevelopmentSpecifying Behavior with Examples and MatchersTaking Control of State with Doubles and HooksSetting Up and Cleaning UpSimulating External ServicesDriving a Web Browser with CapybaraBuilding an App from the Outside In with Behavior-Driven DevelopmentTackling the Challenges of End-to-end TestingConfigurabilityOdds and Ends		Tadayon, Mani		Key FeaturesExplore the concept of testability and how to implement tests that deliver the most valueMaximize the quality of your Ruby code through a wide variety of testsMaster the real-world tradeoffs of testing through detailed examples supported by in-depth discussionBook DescriptionThis book will teach you how to use RSpec to write high-value tests for real-world code. We start with the key concepts of the unit and testability, followed by hands-on exploration of key features. From the beginning, we learn how to integrate tests into the overall development process to help create high-quality code, avoiding the dangers of testing for its own sake.We build up sample applications and their corresponding tests step by step, from simple beginnings to more sophisticated versions that include databases and external web services. We devote three chapters to web applications with rich JavaScript user interfaces, building one from the ground up using behavior-driven development (BDD) and test-driven development (TDD).The code examples are detailed enough to be realistic while simple enough to be easily understood. Testing concepts, development methodologies, and engineering tradeoffs are discussed in detail as they arise. This approach is designed to foster the reader's ability to make well-informed decisions on their own.What you will learnIdentify a unit of software for the purposes of testingManage test states with hooks, fixtures, and mocksHandle external web services in tests using various techniquesConfigure RSpec flexibly and cleanly using support code and environment variablesInteract with rich web apps in tests using CapybaraBuild the right feature with behavior-driven developmentCustomize matchers and failure messagesVerify correct development and production environmentsAbout the AuthorMani Tadayon first learned to program as a shy 7th grader on an Apple IIe using BASIC. He went on to learn Pascal, C++, Java, JavaScript, Visual Basic, and PHP before becoming a Ruby developer in 2008. With 15 years of experience in the software industry, he has developed expertise in web development, infrastructure, and testing. Mani's interests and education are broad, with degrees in foreign languages, computer science, and geography. He lives just far enough from Silicon Valley with his family and their many, many Shiba Inus.Table of ContentsExploring Testability from Unit Tests to Behavior-Driven DevelopmentSpecifying Behavior with Examples and MatchersTaking Control of State with Doubles and HooksSetting Up and Cleaning UpSimulating External ServicesDriving a Web Browser with CapybaraBuilding an App from the Outside In with Behavior-Driven DevelopmentTackling the Challenges of End-to-end TestingConfigurabilityOdds and Ends				Excluded	Excluded	new_screen			2						
145	Behave	Crowdsourced Behavior-Driven Development	Key to the effectiveness of crowdsourcing approaches for software engineering is workflow design, describing how complex work is organized into small, relatively independent microtasks. This paper, we introduce a Behavior-Driven Development (BDD) workflow for accomplishing programming work through self-contained microtasks, implemented as a preconfigured environment called CrowdMicroservices. In our approach, a client, acting on behalf of a software team, describes a microservice as a set of endpoints with paths, requests, and responses. A crowd then implements the endpoints, identifying individual endpoint behaviors that they test, implement, debug, create new functions, and interact with persistence APIs as needed. To evaluate our approach, we conducted a feasibility study in which a small crowd worked to implement a small ToDo microservice. The crowd created an implementation with only four defects, completing 350 microtasks and implementing 13 functions. We discuss the implications of these findings for incorporating crowdsourced programming contributions into traditional software projects.	Microtask programming, Programming environments, Behavior-Driven Development, Crowdsourcing, Workflow, Microservices	Aghayi, Emad; LaToza, Thomas D.; Surendra, Paurav; Abolghasemi, Seyedmeysam	Journal of Systems and Software	Key to the effectiveness of crowdsourcing approaches for software engineering is workflow design, describing how complex work is organized into small, relatively independent microtasks. This paper, we introduce a Behavior-Driven Development (BDD) workflow for accomplishing programming work through self-contained microtasks, implemented as a preconfigured environment called CrowdMicroservices. In our approach, a client, acting on behalf of a software team, describes a microservice as a set of endpoints with paths, requests, and responses. A crowd then implements the endpoints, identifying individual endpoint behaviors that they test, implement, debug, create new functions, and interact with persistence APIs as needed. To evaluate our approach, we conducted a feasibility study in which a small crowd worked to implement a small ToDo microservice. The crowd created an implementation with only four defects, completing 350 microtasks and implementing 13 functions. We discuss the implications of these findings for incorporating crowdsourced programming contributions into traditional software projects.				Included	Included	new_screen			2						
146	Behave	Using Language Workbenches and Domain-Specific Languages for Safety-Critical Software Development	Language workbenches support the efficient creation, integration, and use of domain-specific languages. Typically, they execute models by code generation to programming language code. This can lead to increased productivity and higher quality. However, in safety-/mission-critical environments, generated code may not be considered trustworthy, because of the lack of trust in the generation mechanisms. This makes it harder to justify the use of language workbenches in such an environment. In this paper, we demonstrate an approach to use such tools in critical environments. We argue that models created with domain-specific languages are easier to validate and that the additional risk resulting from the transformation to code can be mitigated by a suitably designed transformation and verification architecture. We validate the approach with an industrial case study from the healthcare domain. We also discuss the degree to which the approach is appropriate for critical software in space, automotive, and robotics systems.	Case study; Domain-specific languages; Language workbenches; Safety-critical software development	Voelter, Markus; Kolb, Bernd; Birken, Klaus; Tomassetti, Federico; Alff, Patrick; Wiart, Laurent; Wortmann, Andreas; Nordmann, Arne	Softw. Syst. Model.	Language workbenches support the efficient creation, integration, and use of domain-specific languages. Typically, they execute models by code generation to programming language code. This can lead to increased productivity and higher quality. However, in safety-/mission-critical environments, generated code may not be considered trustworthy, because of the lack of trust in the generation mechanisms. This makes it harder to justify the use of language workbenches in such an environment. In this paper, we demonstrate an approach to use such tools in critical environments. We argue that models created with domain-specific languages are easier to validate and that the additional risk resulting from the transformation to code can be mitigated by a suitably designed transformation and verification architecture. We validate the approach with an industrial case study from the healthcare domain. We also discuss the degree to which the approach is appropriate for critical software in space, automotive, and robotics systems.				Excluded	Excluded	new_screen			2						
147	Behave	Instant RSpec Test - Driven Development How-To	Learn RSpec and redefine your approach towards software development Overview Learn something new in an Instant! A short, fast, focused guide delivering immediate results Learn how to use RSpec with Rails Easy to read and grok examples Write idiomatic specifications In Detail RSpec is a behaviour driven development framework for Ruby programmers. It comes integrated with its own mocking framework based on Jmock. This book introduces you to RSpec helping you to write idiomatic specifications for Ruby code in a test first approach. Instant RSpec Test-Driven Development How-to is filled with examples of actual code accompanied by explanations and covers general Ruby, Rails, and RSpec use cases plus a few of the more advanced topics. RSpec Test Driven Development is written on the premise that you will need no experience with RSpec and limited experience with Ruby, Rails, and TDD fundamentals. Youll begin by writing a very simple Ruby library in true TDD fashion and and use the red, green, refactor tools to migrate this library into a Rails application. Instant RSpec Test-Driven Development How-to will teach you the actual steps performed in writing an idiomatic specification. You will be able to write a test for the code you wish you had, and learn to write only the minimum code necessary to pass a test, and write more specifications to drive out the production functionality your application will need. Through the course of the book, you will convert a Ruby program into a new Rails application, test Rails specifics such as file uploads, cookies, and model validation and even learn how to use Capybara. RSpec Test Driven Development will help you build confidence in the code they you write and spend less time dealing with bugs and maintenance headaches. What you will learn from this book RSpec fundamentals How to use RSpec and Rails together Modify your behavior to create tests first and run your specs with every code change How to work with the rspec command line tool Using mocks and stubs to decouple tests from the database How to refactor code to improve readability Approach Filled with practical, step-by-step instructions and clear explanations for the most important and useful tasks. A concise guide that delivers immediate results with practical recipes on learning practical hints. Who this book is written for This book is aimed at Ruby developers with beginner level expertise who want to use RSpec and test driven development methodology to improve the code they write. Experienced programmers new to Ruby will also benefit from this book which also covers creating testable, idiomatic Ruby code.		Feduke, Charles		Learn RSpec and redefine your approach towards software development Overview Learn something new in an Instant! A short, fast, focused guide delivering immediate results Learn how to use RSpec with Rails Easy to read and grok examples Write idiomatic specifications In Detail RSpec is a behaviour driven development framework for Ruby programmers. It comes integrated with its own mocking framework based on Jmock. This book introduces you to RSpec helping you to write idiomatic specifications for Ruby code in a test first approach. Instant RSpec Test-Driven Development How-to is filled with examples of actual code accompanied by explanations and covers general Ruby, Rails, and RSpec use cases plus a few of the more advanced topics. RSpec Test Driven Development is written on the premise that you will need no experience with RSpec and limited experience with Ruby, Rails, and TDD fundamentals. Youll begin by writing a very simple Ruby library in true TDD fashion and and use the red, green, refactor tools to migrate this library into a Rails application. Instant RSpec Test-Driven Development How-to will teach you the actual steps performed in writing an idiomatic specification. You will be able to write a test for the code you wish you had, and learn to write only the minimum code necessary to pass a test, and write more specifications to drive out the production functionality your application will need. Through the course of the book, you will convert a Ruby program into a new Rails application, test Rails specifics such as file uploads, cookies, and model validation and even learn how to use Capybara. RSpec Test Driven Development will help you build confidence in the code they you write and spend less time dealing with bugs and maintenance headaches. What you will learn from this book RSpec fundamentals How to use RSpec and Rails together Modify your behavior to create tests first and run your specs with every code change How to work with the rspec command line tool Using mocks and stubs to decouple tests from the database How to refactor code to improve readability Approach Filled with practical, step-by-step instructions and clear explanations for the most important and useful tasks. A concise guide that delivers immediate results with practical recipes on learning practical hints. Who this book is written for This book is aimed at Ruby developers with beginner level expertise who want to use RSpec and test driven development methodology to improve the code they write. Experienced programmers new to Ruby will also benefit from this book which also covers creating testable, idiomatic Ruby code.				Excluded	Excluded	new_screen			2						
148	Behave	Behavior-Driven Load Testing Using Contextual Knowledge - Approach and Experiences	Load testing is widely considered a meaningful technique for performance quality assurance. However, empirical studies reveal that in practice, load testing is not applied systematically, due to the sound expert knowledge required to specify, implement, and execute load tests.Our Behavior-driven Load Testing (BDLT) approach eases load test specification and execution for users with no or little expert knowledge. It allows a user to describe a load test in a template-based natural language and to rely on an automated framework to execute the test. Utilizing the system's contextual knowledge such as workload-influencing events, the framework automatically determines the workload and test configuration. We investigated the applicability of our approach in an industrial case study, where we were able to express four load test concerns using BDLT and received positive feedback from our industrial partner. They understood the BDLT definitions well and proposed further applications, such as the usage for software quality acceptance criteria.	behavior-driven testing; declarative performance engineering; load testing	Schulz, Henning; Okanović, Dušan; van Hoorn, André; Ferme, Vincenzo; Pautasso, Cesare	Proceedings of the 2019 ACM/SPEC International Conference on Performance Engineering	Load testing is widely considered a meaningful technique for performance quality assurance. However, empirical studies reveal that in practice, load testing is not applied systematically, due to the sound expert knowledge required to specify, implement, and execute load tests.Our Behavior-driven Load Testing (BDLT) approach eases load test specification and execution for users with no or little expert knowledge. It allows a user to describe a load test in a template-based natural language and to rely on an automated framework to execute the test. Utilizing the system's contextual knowledge such as workload-influencing events, the framework automatically determines the workload and test configuration. We investigated the applicability of our approach in an industrial case study, where we were able to express four load test concerns using BDLT and received positive feedback from our industrial partner. They understood the BDLT definitions well and proposed further applications, such as the usage for software quality acceptance criteria.				Included	Included	new_screen			2						
149	Behave	Challenges &amp; Opportunities in Low-Code Testing	Low-code is a growing development approach supported by many platforms. It fills the gap between business and IT by supporting the active involvement of non-technical domain experts, named Citizen Developer, in the application development lifecycle.Low-code introduces new concepts and characteristics. However, it is not investigated yet in academic research to point out the existing challenges and opportunities when testing low-code software. This shortage of resources motivates this research to provide an explicit definition to this area that we call it Low-Code Testing.In this paper, we initially conduct an analysis of the testing components of five commercial Low-Code Development Platforms (LCDP) to present low-code testing advancements from a business point of view. Based on the low-code principles as well as the result of our analysis, we propose a feature list for low-code testing along with possible values for them. This feature list can be used as a baseline for comparing low-code testing components and as a guideline for building new ones. Accordingly, we specify the status of the testing components of investigated LCDPs based on the proposed features. Finally, the challenges of low-code testing are introduced considering three concerns: the role of citizen developer in testing, the need for high-level test automation, and cloud testing. We provide references to the state-of-the-art to specify the difficulties and opportunities from an academic perspective. The results of this research can be used as a starting point for future research in low-code testing area.	testing; citizen developer; low-code; low-code development platform	Khorram, Faezeh; Mottu, Jean-Marie; Sunyé, Gerson	Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems: Companion Proceedings	Low-code is a growing development approach supported by many platforms. It fills the gap between business and IT by supporting the active involvement of non-technical domain experts, named Citizen Developer, in the application development lifecycle.Low-code introduces new concepts and characteristics. However, it is not investigated yet in academic research to point out the existing challenges and opportunities when testing low-code software. This shortage of resources motivates this research to provide an explicit definition to this area that we call it Low-Code Testing.In this paper, we initially conduct an analysis of the testing components of five commercial Low-Code Development Platforms (LCDP) to present low-code testing advancements from a business point of view. Based on the low-code principles as well as the result of our analysis, we propose a feature list for low-code testing along with possible values for them. This feature list can be used as a baseline for comparing low-code testing components and as a guideline for building new ones. Accordingly, we specify the status of the testing components of investigated LCDPs based on the proposed features. Finally, the challenges of low-code testing are introduced considering three concerns: the role of citizen developer in testing, the need for high-level test automation, and cloud testing. We provide references to the state-of-the-art to specify the difficulties and opportunities from an academic perspective. The results of this research can be used as a starting point for future research in low-code testing area.				Excluded	Excluded	new_screen			2						
150	Behave	Toward leveraging Gherkin Controlled Natural Language and Machine Translation for Global Product Information Development	Machine Translation (MT) already plays an important part in software development process at McAfee where the technology can be leveraged to provide early builds for localization and internationalization testing teams. Behavior Driven Development (BDD) has been growing in usage as a development methodology in McAfee. Within BDD, the Gherkin Controlled Natural Language (CNL) is a syntax and common terminology set that is used to describe the software or business process in a User Story. Given there exists this control on the language to describe User Stories for software features using Gherkin, we seek to use Machine Translation to Globalize it at high accuracy and without Post-Editing and reuse it as Product Information. This enables global product information development to happen as part of the Software Development Life Cycle (SDLC) and at low cost. © 2018 Morgan O’Brien, McAfee LLC.		O’Brien M.	EAMT 2018 - Proceedings of the 21st Annual Conference of the European Association for Machine Translation	Machine Translation (MT) already plays an important part in software development process at McAfee where the technology can be leveraged to provide early builds for localization and internationalization testing teams. Behavior Driven Development (BDD) has been growing in usage as a development methodology in McAfee. Within BDD, the Gherkin Controlled Natural Language (CNL) is a syntax and common terminology set that is used to describe the software or business process in a User Story. Given there exists this control on the language to describe User Stories for software features using Gherkin, we seek to use Machine Translation to Globalize it at high accuracy and without Post-Editing and reuse it as Product Information. This enables global product information development to happen as part of the Software Development Life Cycle (SDLC) and at low cost. © 2018 Morgan O’Brien, McAfee LLC.				Included	Included	new_screen			2						
151	Behave	Automating test oracles from restricted natural language agile requirements	Manual testing of software requirements written in natural language for agile or any other methodology requires more time and human resources. This leaves the testing process error prone and time consuming. For satisfied end users with bug-free software delivered on time, there is a need to automate the test oracle process for natural language or informal requirements. The automation of the test oracle is relatively easier with formal requirements, but this task is difficult to achieve with natural language requirements. This study proposes an approach called Restricted Natural Language Agile Requirements Testing (ReNaLART) to automate the test oracle from restricted natural language agile requirements. For this purpose, it uses an existing user story template with some modifications for writing user stories. This helps in identifying test input and expected output for a user story. For comparison of expected and observed outputs it makes use of a regex pattern and string distance functions. It is capable of assigning different types of verdicts automatically depending upon the similarity/dissimilarity between observed and expected outputs of user stories. ReNaLART is validated using several case studies of different domains, namely, OLX Pakistan, Mental Health Tests, McDelivery Pakistan, BlueStacks, Power Searching with Google, TensorFlow Playground, w3Schools 2018 offline and Touch'D. It revealed several faults in five of the above listed eight applications. Plus, the proposed test oracle on an average took 0.02 s for test data generation, expected output generation and verdict assignment. Both these facts show the fault revealing effectiveness and efficiency of ReNaLART. © 2020 John Wiley & Sons, Ltd		Malik M.I., Sindhu M.A., Khattak A.S., Abbasi R.A., Saleem K.	Expert Systems	Manual testing of software requirements written in natural language for agile or any other methodology requires more time and human resources. This leaves the testing process error prone and time consuming. For satisfied end users with bug-free software delivered on time, there is a need to automate the test oracle process for natural language or informal requirements. The automation of the test oracle is relatively easier with formal requirements, but this task is difficult to achieve with natural language requirements. This study proposes an approach called Restricted Natural Language Agile Requirements Testing (ReNaLART) to automate the test oracle from restricted natural language agile requirements. For this purpose, it uses an existing user story template with some modifications for writing user stories. This helps in identifying test input and expected output for a user story. For comparison of expected and observed outputs it makes use of a regex pattern and string distance functions. It is capable of assigning different types of verdicts automatically depending upon the similarity/dissimilarity between observed and expected outputs of user stories. ReNaLART is validated using several case studies of different domains, namely, OLX Pakistan, Mental Health Tests, McDelivery Pakistan, BlueStacks, Power Searching with Google, TensorFlow Playground, w3Schools 2018 offline and Touch'D. It revealed several faults in five of the above listed eight applications. Plus, the proposed test oracle on an average took 0.02 s for test data generation, expected output generation and verdict assignment. Both these facts show the fault revealing effectiveness and efficiency of ReNaLART. © 2020 John Wiley & Sons, Ltd				Included	Included	new_screen			2						
152	Behave	Scenario-Based Microservice Retrieval Using Word2Vec	Microservice architecture (MSA) is an emerging software architectural style, which differs fundamentally from the monolithic, layered architecture. During the development and maintenance of microservice systems, how to provide an effective service retrieval mechanism is a critical challenge to avoid the problems of rework and duplicate code. Meanwhile, nowadays, using the BDD (Behavior-Driven Development) method to develop microservices becomes more and more popular due to its agility and domain-driven characteristics. BDD is an agile software development approach emphasizing that test cases are written in a common language to include scenarios that describe the features of a target system. In this paper, we propose an approach, referred to as SMSR (Scenario-based MicroService Retrieval), to recommend appropriate microservices to users based on the user-written BDD test scenarios. The proposed service retrieval algorithm is based on word2vec, a widely-used machine learning method in NLP (Natural Language Processing), to perform service filtering and service similarity calculation. Experiment results show that SMSR is able to effectively retrieve appropriate microservices from the service repository.	Microservice, Microservice Retrieval, Requirement Scenario, Behavior-Driven Development, word2vec	S. Ma; Y. Chuang; C. Lan; H. Chen; C. Huang; C. Li	2018 IEEE 15th International Conference on e-Business Engineering (ICEBE)	Microservice architecture (MSA) is an emerging software architectural style, which differs fundamentally from the monolithic, layered architecture. During the development and maintenance of microservice systems, how to provide an effective service retrieval mechanism is a critical challenge to avoid the problems of rework and duplicate code. Meanwhile, nowadays, using the BDD (Behavior-Driven Development) method to develop microservices becomes more and more popular due to its agility and domain-driven characteristics. BDD is an agile software development approach emphasizing that test cases are written in a common language to include scenarios that describe the features of a target system. In this paper, we propose an approach, referred to as SMSR (Scenario-based MicroService Retrieval), to recommend appropriate microservices to users based on the user-written BDD test scenarios. The proposed service retrieval algorithm is based on word2vec, a widely-used machine learning method in NLP (Natural Language Processing), to perform service filtering and service similarity calculation. Experiment results show that SMSR is able to effectively retrieve appropriate microservices from the service repository.				Included	Included	new_screen			2						
153	Behave	Agile development cycle: Approach to design an effective Model Based Testing with Behaviour driven automation framework	Model Based Testing (MBT) is a relatively an approach widely discussed in software testing. It extends test automation from test design to test execution using automatic test generation from models. The effective use of this approach requires new skills, technology and knowledge, such as test modelling skills, but also good programs and tool support. This paper explores a design of a Behaviour driven test automation framework using MBT and how it can be effectively used during Agile Development. The automation framework is experimented upon the integration of the Graphwalker, a Model Based Graphical User Interface test generator with behaviour driven development framework and Robot Framework. © 2014 IEEE.		Sivanandan S., Yogeesha C.B.	2014 20th Annual International Conference on Advanced Computing and Communications, ADCOM 2014 - Proceedings	Model Based Testing (MBT) is a relatively an approach widely discussed in software testing. It extends test automation from test design to test execution using automatic test generation from models. The effective use of this approach requires new skills, technology and knowledge, such as test modelling skills, but also good programs and tool support. This paper explores a design of a Behaviour driven test automation framework using MBT and how it can be effectively used during Agile Development. The automation framework is experimented upon the integration of the Graphwalker, a Model Based Graphical User Interface test generator with behaviour driven development framework and Robot Framework. © 2014 IEEE.				Included	Included	new_screen			2						
154	Behave	Automated Test Case Generation from Domain Specific Models of High-Level Requirements	Model-based software development has been shown to improve productivity and quality of software through automation. This involves using abstractions or models at several stages of development. This work reports on preliminary attempts to automate the generation of test cases from software requirement models using an industrial case study. The requirements are represented using a modeling notation and test cases are automatically generated using model to text transformation techniques.	domain specific languages; model-based testing	Olajubu, Oyindamola; Ajit, Suraj; Johnson, Mark; Turner, Scott; Thomson, Scott; Edwards, Mark	Proceedings of the 2015 Conference on Research in Adaptive and Convergent Systems	Model-based software development has been shown to improve productivity and quality of software through automation. This involves using abstractions or models at several stages of development. This work reports on preliminary attempts to automate the generation of test cases from software requirement models using an industrial case study. The requirements are represented using a modeling notation and test cases are automatically generated using model to text transformation techniques.				Excluded	Excluded	new_screen			2						
155	Behave	Towards a Workflow for Model-Based Testing of Embedded Systems	Model-based testing (MBT) has been previously used to validate embedded systems. However, (i) creation of a model conforming to the behavioural aspects of an embedded system, (ii) generation of executable test scripts and (iii) assessment of test verdict, re-quires a systematic process. In this paper, we have presented a three-phase tool-supported MBT workflow for the testing of an embedded system, that spans from requirements specification to test verdict assessment. The workflow starts with a simplistic, yet practical, application of a Domain-Specific Language (DSL) based on Gherkin-like style, which allows the requirements engineer to specify requirements and to extract information about model elements(i.e. states and transitions). This is done to assist the graphical modelling of the complete system under test (SUT). Later stages of the workflow generates an executable test script that runs on a domain-specific simulation platform. We have evaluated this tool-supported workflow by specifying the requirements, extracting information from the DSL and developing a model of a subsystem of the train control management system developed at Alstom Transport AB in Sweden. The C# test script generated from the SUT model is successfully executed at the Software-in-the-Loop (SIL) execution platform and test verdicts are visualized as a sequence of passed and failed test steps.	Domain-Specific Language; Model-Based Testing; Software-in-the-Loop	Zafar, Muhammad Nouman; Afzal, Wasif; Enoiu, Eduard	Proceedings of the 12th International Workshop on Automating TEST Case Design, Selection, and Evaluation	Model-based testing (MBT) has been previously used to validate embedded systems. However, (i) creation of a model conforming to the behavioural aspects of an embedded system, (ii) generation of executable test scripts and (iii) assessment of test verdict, re-quires a systematic process. In this paper, we have presented a three-phase tool-supported MBT workflow for the testing of an embedded system, that spans from requirements specification to test verdict assessment. The workflow starts with a simplistic, yet practical, application of a Domain-Specific Language (DSL) based on Gherkin-like style, which allows the requirements engineer to specify requirements and to extract information about model elements(i.e. states and transitions). This is done to assist the graphical modelling of the complete system under test (SUT). Later stages of the workflow generates an executable test script that runs on a domain-specific simulation platform. We have evaluated this tool-supported workflow by specifying the requirements, extracting information from the DSL and developing a model of a subsystem of the train control management system developed at Alstom Transport AB in Sweden. The C# test script generated from the SUT model is successfully executed at the Software-in-the-Loop (SIL) execution platform and test verdicts are visualized as a sequence of passed and failed test steps.				Included	Included	new_screen			2						
156	Behave	Model-Based Testing in Practice: An Industrial Case Study Using GraphWalker	Model-based testing (MBT) is a test design technique that supports the automation of software testing processes and generates test artefacts based on a system model representing behavioural aspects of the system under test (SUT). Previous research has shown some positive aspects of MBT such as low-cost test case generation and fault detection effectiveness. However, it is still a challenge for both practitioners and researchers to evaluate MBT tools and techniques in real, industrial settings. Consequently, the empirical evidence regarding the mainstream use, including the modelling and test case generation using MBT tools, is limited. In this paper, we report the results of a case study on applying GraphWalker, an open-source tool for MBT, on an industrial cyber-physical system (i.e., a Train Control Management System developed by Bombardier Transportation in Sweden), from modelling of real-world requirements and test specifications to test case generation. We evaluate the models of the SUT for completeness and representativeness, compare MBT with manual test cases written by practitioners using multiple attributes as well as share our experiences of selecting and using GraphWalker for industrial application. The results show that a model of the SUT created using both requirements and test specifications provides better understanding of the SUT from testers’ perspective, making it more complete and representative than the model created based only on the requirements specification alone. The generated model-based test cases are longer in terms of the number of test steps, achieve better edge coverage and can cover requirements more frequently in different orders while achieving the same level of requirements coverage as manually created test cases.		Zafar, Muhammad Nouman; Afzal, Wasif; Enoiu, Eduard; Stratis, Athanasios; Arrieta, Aitor; Sagardui, Goiuria	14th Innovations in Software Engineering Conference (Formerly Known as India Software Engineering Conference)	Model-based testing (MBT) is a test design technique that supports the automation of software testing processes and generates test artefacts based on a system model representing behavioural aspects of the system under test (SUT). Previous research has shown some positive aspects of MBT such as low-cost test case generation and fault detection effectiveness. However, it is still a challenge for both practitioners and researchers to evaluate MBT tools and techniques in real, industrial settings. Consequently, the empirical evidence regarding the mainstream use, including the modelling and test case generation using MBT tools, is limited. In this paper, we report the results of a case study on applying GraphWalker, an open-source tool for MBT, on an industrial cyber-physical system (i.e., a Train Control Management System developed by Bombardier Transportation in Sweden), from modelling of real-world requirements and test specifications to test case generation. We evaluate the models of the SUT for completeness and representativeness, compare MBT with manual test cases written by practitioners using multiple attributes as well as share our experiences of selecting and using GraphWalker for industrial application. The results show that a model of the SUT created using both requirements and test specifications provides better understanding of the SUT from testers’ perspective, making it more complete and representative than the model created based only on the requirements specification alone. The generated model-based test cases are longer in terms of the number of test steps, achieve better edge coverage and can cover requirements more frequently in different orders while achieving the same level of requirements coverage as manually created test cases.				Excluded	Excluded	new_screen			2						
157	Behave	Towards behavior driven operations (BDOps)	Modern Enterprise Software Systems entail many challenges such as availability, scalability, complexity and providing business agility. Ensuring the systems to be up and running for 24 × 7 has become a mandate for operations. Agile development has been adopted to keep pace with the demands of business and IT. Test Driven Development (TDD) and Behavior Driven Development (BDD) are practices, which enable agile development. So far the agile approach has been limited to development. For ensuring business to be truly agile, we need to take forward the agile approach to operations. In this paper, we discuss the behavior driven approach for operations specifically on the core sub-systems like infrastructure provisioning, deployment and monitoring. We share our explorations and experiments with Behavior Driven Monitoring (BDM) and how the same can be adopted for infrastructure provisioning and deployment. We used Cucumber-Nagios to detect behavior of an enterprise application. We close this paper with a note on the benefits to busmess and IT showing its relevance to DevOps, Continuous Delivery and Cloud Computing.	Behavior Driven Development;Behavior Driven Operations;Behavior Driven Monitoring;Cucumber-Nagios;Behavior Driven Infrastructure	K. Gohil; N. Alapati; S. Joglekar	3rd International Conference on Advances in Recent Technologies in Communication and Computing (ARTCom 2011)	Modern Enterprise Software Systems entail many challenges such as availability, scalability, complexity and providing business agility. Ensuring the systems to be up and running for 24 × 7 has become a mandate for operations. Agile development has been adopted to keep pace with the demands of business and IT. Test Driven Development (TDD) and Behavior Driven Development (BDD) are practices, which enable agile development. So far the agile approach has been limited to development. For ensuring business to be truly agile, we need to take forward the agile approach to operations. In this paper, we discuss the behavior driven approach for operations specifically on the core sub-systems like infrastructure provisioning, deployment and monitoring. We share our explorations and experiments with Behavior Driven Monitoring (BDM) and how the same can be adopted for infrastructure provisioning and deployment. We used Cucumber-Nagios to detect behavior of an enterprise application. We close this paper with a note on the benefits to busmess and IT showing its relevance to DevOps, Continuous Delivery and Cloud Computing.				Included	Included	new_screen			2						
158	Behave	Combining behaviour-driven development with scrum for software development in the education domain	Most of the Brazilian universities employ teaching-learning methodologies based on classic frontal lectures. The Medicine Programme of the Federal University of São Carlos (UFSCar) is an exception, since it employs active learning methodologies. The Educational and Academic Management System for Courses Based on Active Learning Methodologies (EAMS-CBALM) was built and it is currently used to support this programme, and has been made available for other programmes as well. This system was developed using Scrum, but during its development project it was often necessary to reconsider system behaviour scenarios, and consequently the product backlog items, mainly due to poor communication between the Product Owner (PO) and the development team. This paper discusses a case study in which Behaviour-Driven Development (BDD) has been used in combination with Scrum to redesign some EAMS-CBALM components. The paper demonstrates that the communication between the PO and the development team can be improved by using BDD as a communication platform to unambiguously define system requirements and automatically generate test suites. ©2017 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.		De Souza P.L., Do Prado A.F., De Souza W.L., Dos Santos Forghieri Pereira S.M., Pires L.F.	ICEIS 2017 - Proceedings of the 19th International Conference on Enterprise Information Systems	Most of the Brazilian universities employ teaching-learning methodologies based on classic frontal lectures. The Medicine Programme of the Federal University of São Carlos (UFSCar) is an exception, since it employs active learning methodologies. The Educational and Academic Management System for Courses Based on Active Learning Methodologies (EAMS-CBALM) was built and it is currently used to support this programme, and has been made available for other programmes as well. This system was developed using Scrum, but during its development project it was often necessary to reconsider system behaviour scenarios, and consequently the product backlog items, mainly due to poor communication between the Product Owner (PO) and the development team. This paper discusses a case study in which Behaviour-Driven Development (BDD) has been used in combination with Scrum to redesign some EAMS-CBALM components. The paper demonstrates that the communication between the PO and the development team can be improved by using BDD as a communication platform to unambiguously define system requirements and automatically generate test suites. ©2017 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.				Included	Included	new_screen			2						
159	Behave	Enterprise ontology-driven development	Most of the current techniques and approaches for user requirements specification have problems with capturing the appropriate context for development of enterprise information systems. Primarily, they are designed to capture the functional aspects of software rather than its relevancy to an enterprise. Transactions defined in the DEMO (Design & Engineering Methodology for Organizations) represent business activities in their existential essence without implementation details. Therefore, they are great candidates to be utilized for the initial development phase of enterprise information systems. The paper exemplifies how to specify software specification the using the DEMO transaction pattern and BDD (Behaviour-Driven Development) technique. This proposal resulted from a significant lack of direct utilization of ontology for enterprise information systems development. The major part of the paper gives a step-by-step explanation of how to integrate DEMO transaction patterns into initial BDD scenarios for the development of enterprise information systems. Such created scenarios provide a perfect guideline in the initial phase of information system development for enterprises. The created scenarios were verified using the domain specific language Gherkin and BDD framework Behat. © Springer Nature Switzerland AG 2018.		Matula J., Hunka F.	Lecture Notes in Business Information Processing	Most of the current techniques and approaches for user requirements specification have problems with capturing the appropriate context for development of enterprise information systems. Primarily, they are designed to capture the functional aspects of software rather than its relevancy to an enterprise. Transactions defined in the DEMO (Design & Engineering Methodology for Organizations) represent business activities in their existential essence without implementation details. Therefore, they are great candidates to be utilized for the initial development phase of enterprise information systems. The paper exemplifies how to specify software specification the using the DEMO transaction pattern and BDD (Behaviour-Driven Development) technique. This proposal resulted from a significant lack of direct utilization of ontology for enterprise information systems development. The major part of the paper gives a step-by-step explanation of how to integrate DEMO transaction patterns into initial BDD scenarios for the development of enterprise information systems. Such created scenarios provide a perfect guideline in the initial phase of information system development for enterprises. The created scenarios were verified using the domain specific language Gherkin and BDD framework Behat. © Springer Nature Switzerland AG 2018.				Included	Included	new_screen			2						
160	Behave	A Behavior-Based Ontology for Supporting Automated Assessment of Interactive Systems	Nowadays many software development frameworks implement Behavior-Driven Development (BDD) as a mean of automating the test of interactive systems under construction. Automated testing helps to simulate user's action on the User Interface and therefore check if the system behaves properly and in accordance to Scenarios that describe functional requirements. However, most of tools supporting BDD requires that tests should be written using low-level events and components that only exist when the system is already implemented. As a consequence of such low-level of abstraction, BDD tests can hardly be reused with diverse artifacts and with versions of the system. To address this problem, this paper proposes to raise the abstraction level by the means of a behavior-based ontology that is aimed at supporting test automation. The paper presents an ontology and an ontology-based approach for automating the test of functional requirements of interactive systems. With the help of a case study for the flight tickets e-commerce domain, we demonstrate how tests written using our ontology can be used to assess functional requirements using different artifacts, from low-fidelity to full-fledged UI Prototypes.	Automated Requirements Assessment;Behavior-Driven Development;Ontological Modeling;Testing of Interactive Systems	T. R. Silva; J. Hak; M. Winckler	2017 IEEE 11th International Conference on Semantic Computing (ICSC)	Nowadays many software development frameworks implement Behavior-Driven Development (BDD) as a mean of automating the test of interactive systems under construction. Automated testing helps to simulate user's action on the User Interface and therefore check if the system behaves properly and in accordance to Scenarios that describe functional requirements. However, most of tools supporting BDD requires that tests should be written using low-level events and components that only exist when the system is already implemented. As a consequence of such low-level of abstraction, BDD tests can hardly be reused with diverse artifacts and with versions of the system. To address this problem, this paper proposes to raise the abstraction level by the means of a behavior-based ontology that is aimed at supporting test automation. The paper presents an ontology and an ontology-based approach for automating the test of functional requirements of interactive systems. With the help of a case study for the flight tickets e-commerce domain, we demonstrate how tests written using our ontology can be used to assess functional requirements using different artifacts, from low-fidelity to full-fledged UI Prototypes.				Included	Included	new_screen			2						
161	Behave	A Formal Ontology for Describing Interactive Behaviors and Supporting Automated Testing on User Interfaces	Nowadays many software development frameworks implement Behavior-Driven Development (BDD) as a mean of automating the test of interactive systems under construction. Automated testing helps to simulate user's actions on the User Interface and therefore check if the system behaves properly and in accordance to scenarios that describe functional requirements. However, tools supporting BDD run tests on implemented User Interfaces and are a suitable alternative for assessing functional requirements in later phases of the development process. However, even when BDD tests can be written in early phases of the development process they can hardly be used with specifications of User Interfaces such as prototypes. To address this problem, this paper proposes to raise the abstraction level of both system interactive behaviors and User Interfaces by means of a formal ontology that is aimed at supporting test automation using BDD. The paper presents an ontology and an ontology-based approach for automating the test of functional requirements of interactive systems. We demonstrate the feasibility of this ontology-based approach to assess functional requirements in prototypes and full-fledge applications through an illustrative case study of e-commerce applications for buying flight tickets. © 2017 World Scientific Publishing Company.		Silva T.R., Hak J.-L., Winckler M.	International Journal of Semantic Computing	Nowadays many software development frameworks implement Behavior-Driven Development (BDD) as a mean of automating the test of interactive systems under construction. Automated testing helps to simulate user's actions on the User Interface and therefore check if the system behaves properly and in accordance to scenarios that describe functional requirements. However, tools supporting BDD run tests on implemented User Interfaces and are a suitable alternative for assessing functional requirements in later phases of the development process. However, even when BDD tests can be written in early phases of the development process they can hardly be used with specifications of User Interfaces such as prototypes. To address this problem, this paper proposes to raise the abstraction level of both system interactive behaviors and User Interfaces by means of a formal ontology that is aimed at supporting test automation using BDD. The paper presents an ontology and an ontology-based approach for automating the test of functional requirements of interactive systems. We demonstrate the feasibility of this ontology-based approach to assess functional requirements in prototypes and full-fledge applications through an illustrative case study of e-commerce applications for buying flight tickets. © 2017 World Scientific Publishing Company.				Included	Included	new_screen			2						
162	Behave	Behavior Driven Development: Tools and Challenges	Nowadays testing usually applies Test Driven Development (TDD) which is an approach to software development in which developers write tests first which initially fail and by adding more application codes tests pass. However, the latest development in this field is an extension to Test Driven Development (TDD) which usually referred as Behavior Driven Development (BDD). As being a modified version of TDD, both the technologies have various similarities. Nevertheless, the differences are also not unnoticeable. Where BDD is more about communication and collaboration TDD is more about coders and coding. This paper focuses on the advantages and glitches of TDD which led to the development of along with the method of working of BDD and several tools along with their features and a comparison of their functionalities.	Manual Testing;Test Driven Development (TDD);Behavior Driven Development (BDD);Collaboration	R. K. Lenka; S. Kumar; S. Mamgain	2018 International Conference on Advances in Computing, Communication Control and Networking (ICACCCN)	Nowadays testing usually applies Test Driven Development (TDD) which is an approach to software development in which developers write tests first which initially fail and by adding more application codes tests pass. However, the latest development in this field is an extension to Test Driven Development (TDD) which usually referred as Behavior Driven Development (BDD). As being a modified version of TDD, both the technologies have various similarities. Nevertheless, the differences are also not unnoticeable. Where BDD is more about communication and collaboration TDD is more about coders and coding. This paper focuses on the advantages and glitches of TDD which led to the development of along with the method of working of BDD and several tools along with their features and a comparison of their functionalities.				Included	Included	new_screen			2						
163	Behave	Behavior Driven Development Approach in the Modern Quality Control Process	Nowadays usually the Behavior Driven Development is the approach of choice for the quality control engineers, especially for the long-term projects with the big amount of the audits, because of its main advantage - clear test scenarios visualization and understanding for the not involved persons. However, this approach could not reach its maximum efficiency without proper usage, but the documentation covers only the high-level practices which are not always enough to write the good test scenarios. That is why it is needed to describe the best practices and techniques of the usage of behavior-driven development, formed with the experience of its use. These practices would help to create correct and well understandable behavior scenarios, with the ability to use them as part of the technical documentation. Behavior-driven development would be considered in the comparison with the test-driven development and the domain-driven design approaches - the other important strategies in the quality assurance process.	behaviour driven development;test driven development;quality control;gherkin;practice;technique;scenario;feature;keyword;step	O. Bezsmertnyi; N. Golian; V. Golian; I. Afanasieva	2020 IEEE International Conference on Problems of Infocommunications. Science and Technology (PIC S&T)	Nowadays usually the Behavior Driven Development is the approach of choice for the quality control engineers, especially for the long-term projects with the big amount of the audits, because of its main advantage - clear test scenarios visualization and understanding for the not involved persons. However, this approach could not reach its maximum efficiency without proper usage, but the documentation covers only the high-level practices which are not always enough to write the good test scenarios. That is why it is needed to describe the best practices and techniques of the usage of behavior-driven development, formed with the experience of its use. These practices would help to create correct and well understandable behavior scenarios, with the ability to use them as part of the technical documentation. Behavior-driven development would be considered in the comparison with the test-driven development and the domain-driven design approaches - the other important strategies in the quality assurance process.				Included	Included	new_screen			2						
164	Behave	Behavior driven development for tests and verification	Nowadays, hardware is usually tested and verified at postdesign time. The bottom line is that more effort is spend in the validation phases than in the implementation, because it is harder to fix bugs in later design stages than during the implementation of the design. In contrast, test-first approaches such as test driven development (TDD) have become increasingly important for software development. Behavior driven development (BDD) extends TDD by using natural language style scenarios to describe tests. But both approaches miss formal verification methods which are very important in hardware design. This research project presents a new approach based on BDD that combines testing and verification seamlessly. © Springer Fachmedien Wiesbaden 2015. All rights reserved.		Diepenbeck M.	Formal Modeling and Verification of Cyber-Physical Systems: 1st International Summer School on Methods and Tools for the Design of Digital Systems, Bremen, Germany, September 2015	Nowadays, hardware is usually tested and verified at postdesign time. The bottom line is that more effort is spend in the validation phases than in the implementation, because it is harder to fix bugs in later design stages than during the implementation of the design. In contrast, test-first approaches such as test driven development (TDD) have become increasingly important for software development. Behavior driven development (BDD) extends TDD by using natural language style scenarios to describe tests. But both approaches miss formal verification methods which are very important in hardware design. This research project presents a new approach based on BDD that combines testing and verification seamlessly. © Springer Fachmedien Wiesbaden 2015. All rights reserved.				Excluded	Excluded	new_screen			2						
165	Behave	Towards Automatic Scenario Generation from Coverage Information	Nowadays, the design of software systems is pushed towards agile development practices. One of its most fundamental approaches is Test Driven Development (TDD). This procedure is based on test cases which are incrementally written prior to the implementation. Recently, Behavior Driven Development (BDD) has been introduced as an extension of TDD, in which natural language scenarios are the starting point for the test cases. This description offers a ubiquitous communication mean for both the software developers and stakeholders.Following the BDD methodology thoroughly, one would expect 100% code coverage, since code is only written to make the test cases pass. However, as we show in an empirical study this expectation is not valid in practice. It becomes even worse in the process of development, i.e. the coverage decreases over time. To close the coverage gap, we sketch an algorithm that generates BDD-style scenarios based on uncovered code.		Diepenbeck, Melanie; Soeken, Mathias; Große, Daniel; Drechsler, Rolf	Proceedings of the 8th International Workshop on Automation of Software Test	Nowadays, the design of software systems is pushed towards agile development practices. One of its most fundamental approaches is Test Driven Development (TDD). This procedure is based on test cases which are incrementally written prior to the implementation. Recently, Behavior Driven Development (BDD) has been introduced as an extension of TDD, in which natural language scenarios are the starting point for the test cases. This description offers a ubiquitous communication mean for both the software developers and stakeholders.Following the BDD methodology thoroughly, one would expect 100% code coverage, since code is only written to make the test cases pass. However, as we show in an empirical study this expectation is not valid in practice. It becomes even worse in the process of development, i.e. the coverage decreases over time. To close the coverage gap, we sketch an algorithm that generates BDD-style scenarios based on uncovered code.				Included	Included	new_screen			2						
166	Behave	Towards automatic scenario generation from coverage information	Nowadays, the design of software systems is pushed towards agile development practices. One of its most fundamental approaches is Test Driven Development (TDD). This procedure is based on test cases which are incrementally written prior to the implementation. Recently, Behavior Driven Development (BDD) has been introduced as an extension of TDD, in which natural language scenarios are the starting point for the test cases. This description offers a ubiquitous communication mean for both the software developers and stakeholders. Following the BDD methodology thoroughly, one would expect 100 % code coverage, since code is only written to make the test cases pass. However, as we show in an empirical study this expectation is not valid in practice. It becomes even worse in the process of development, i.e. the coverage decreases over time. To close the coverage gap, we sketch an algorithm that generates BDD-style scenarios based on uncovered code.		M. Diepenbeck; M. Soeken; D. Grobe; R. Drechsler	2013 8th International Workshop on Automation of Software Test (AST)	Nowadays, the design of software systems is pushed towards agile development practices. One of its most fundamental approaches is Test Driven Development (TDD). This procedure is based on test cases which are incrementally written prior to the implementation. Recently, Behavior Driven Development (BDD) has been introduced as an extension of TDD, in which natural language scenarios are the starting point for the test cases. This description offers a ubiquitous communication mean for both the software developers and stakeholders. Following the BDD methodology thoroughly, one would expect 100 % code coverage, since code is only written to make the test cases pass. However, as we show in an empirical study this expectation is not valid in practice. It becomes even worse in the process of development, i.e. the coverage decreases over time. To close the coverage gap, we sketch an algorithm that generates BDD-style scenarios based on uncovered code.				Excluded	Excluded	new_screen			2						
167	Behave	Using Gherkin to Extract Tests and Monitors for Safer Medical Device Interaction Design	Number entry systems on medical devices are safety critical and it is important to get them right. Interaction design teams can be multidisciplinary, and in this work we present a process where the requirements of the system are drawn up using a Controlled Natural Language (CNL) that is understandable by non-technical experts or clients. These CNL requirements can also be directly used by the Quality Assurance (QA) team to test the system and monitor whether or not the system runs as it should once deployed. Since commonly, systems are too complex to test all possible execution paths before deployment, monitoring the system at runtime is useful in order to check that the system is running correctly. If at runtime, it is discovered that an anomaly is detected, the relevant personnel is notified through a report in natural language.	testing; medical devices; runtime verification; user interfaces	Cauchi, Abigail; Colombo, Christian; Francalanza, Adrian; Micallef, Mark; Pace, Gordon	Proceedings of the 8th ACM SIGCHI Symposium on Engineering Interactive Computing Systems	Number entry systems on medical devices are safety critical and it is important to get them right. Interaction design teams can be multidisciplinary, and in this work we present a process where the requirements of the system are drawn up using a Controlled Natural Language (CNL) that is understandable by non-technical experts or clients. These CNL requirements can also be directly used by the Quality Assurance (QA) team to test the system and monitor whether or not the system runs as it should once deployed. Since commonly, systems are too complex to test all possible execution paths before deployment, monitoring the system at runtime is useful in order to check that the system is running correctly. If at runtime, it is discovered that an anomaly is detected, the relevant personnel is notified through a report in natural language.				Included	Included	new_screen			2						
168	Behave	A Behavior-Driven Approach to Intent Specification for Software-Defined Infrastructure Management	"One of the goals of Software-Defined Networking (SDN) is to allow users to specify high-level policies into lower level network rules. Managing a network and decide what policy set is appropriate requires, however, expertise and low level know-how. An emerging SDN paradigm is to allow higher-level network level decisions wishes in the form of ""intents"". Despite its importance in simplifying network management, intent specification is not yet standardized. In this work, we propose a northbound interface (NBI) for intent declaration, based on Behavior-Driven Development. In our approach, intents are specified in plain English and translated by our system into pre-compiled network policies, that are in turn, converted into low-level rules by the software-defined infrastructure e.g. an SDN controller. We demonstrated our behavior-driven approach with two practical use cases: service function chaining deployed on OpenStack, supported by both ONOS and Ryu controllers, and dynamic firewall programming. We also measured the overhead and response time of our NBI. We believe that our approach is far more general and paves the way for a more expressive and simplified northbound interface for intent-driven networking."		F. Esposito; J. Wang; C. Contoli; G. Davoli; W. Cerroni; F. Callegati	2018 IEEE Conference on Network Function Virtualization and Software Defined Networks (NFV-SDN)	"One of the goals of Software-Defined Networking (SDN) is to allow users to specify high-level policies into lower level network rules. Managing a network and decide what policy set is appropriate requires, however, expertise and low level know-how. An emerging SDN paradigm is to allow higher-level network level decisions wishes in the form of ""intents"". Despite its importance in simplifying network management, intent specification is not yet standardized. In this work, we propose a northbound interface (NBI) for intent declaration, based on Behavior-Driven Development. In our approach, intents are specified in plain English and translated by our system into pre-compiled network policies, that are in turn, converted into low-level rules by the software-defined infrastructure e.g. an SDN controller. We demonstrated our behavior-driven approach with two practical use cases: service function chaining deployed on OpenStack, supported by both ONOS and Ryu controllers, and dynamic firewall programming. We also measured the overhead and response time of our NBI. We believe that our approach is far more general and paves the way for a more expressive and simplified northbound interface for intent-driven networking."				Included	Included	new_screen			2						
169	Behave	Feature-Trace: Generating Operational Profile and Supporting Testing Prioritization from BDD Features	Operational Profiles provide quantitative information about how the software will be used, which supports highlighting those software components more sensitive to reliability based on their profile usage. However, the generation of Operational Profiles usually requires a considerable team effort to liaise requirements specification until their reification into expected software artifacts. In this sense, it becomes paramount in the software life cycle the ability to seamlessly or efficiently perform traceability from requirement to code, embracing the testing process as a means to ensure that the requirements are satisfiably covered and addressed. In this work, we propose the Feature-Trace approach which merges the advantages of the Operational Profile and the benefits of the requirements-to-code traceability present in the BDD (Behavior-Driven Development) approach. The primary goal of our work is to use the BDD approach as an information source for the semi-automated generation of the Operational Profile. The proposed approach was evaluated on the Diaspora software, on a GitHub open source software. The case study revealed that the Feature-Trace approach is capable of extracting the operational profile seamlessly from the specified Diaspora's BDD features as well as obtaining and presenting vital information to guide the process of test cases prioritization.	behavior-driven development; operational profile; requirements traceability; testing	Fazzolino, Rafael; Rodrigues, Genaína Nunes	Proceedings of the XXXIII Brazilian Symposium on Software Engineering	Operational Profiles provide quantitative information about how the software will be used, which supports highlighting those software components more sensitive to reliability based on their profile usage. However, the generation of Operational Profiles usually requires a considerable team effort to liaise requirements specification until their reification into expected software artifacts. In this sense, it becomes paramount in the software life cycle the ability to seamlessly or efficiently perform traceability from requirement to code, embracing the testing process as a means to ensure that the requirements are satisfiably covered and addressed. In this work, we propose the Feature-Trace approach which merges the advantages of the Operational Profile and the benefits of the requirements-to-code traceability present in the BDD (Behavior-Driven Development) approach. The primary goal of our work is to use the BDD approach as an information source for the semi-automated generation of the Operational Profile. The proposed approach was evaluated on the Diaspora software, on a GitHub open source software. The case study revealed that the Feature-Trace approach is capable of extracting the operational profile seamlessly from the specified Diaspora's BDD features as well as obtaining and presenting vital information to guide the process of test cases prioritization.				Included	Included	new_screen			2						
170	Behave	Cucumber Cookbook	"Over 35 hands-on recipes to efficiently master the art of behaviour-driven development using Cucumber-JVM About This BookCreate a test automation framework to handle web, REST, and native mobile application automationDiscover Glue code, Hooks, Tags, and Cucumber's integration with Maven, Jenkins, and GitComprehensive recipes in Cucumber for behaviour-driven development and test automationWho This Book Is ForThis book is intended for business and development personnel who want to use Cucumber for behavior-driven development and test automation. Readers with some familiarity with Cucumber will find this book of most benefit.Since the main objective of this book is to create test automation frameworks, previous experience in automation will be helpful.What You Will Learn Explore the usage of the Gherkin Language to write meaningful and smart Feature files Understand Scenario, Steps, Backgrounds, Scenario Outlines, and Data Tables Discover the concepts of Glue Code and Step Definitions in detail Gain insights into the different types of Step Definitions, Regular Expressions, Doc Strings, Data Table transformations, and Capture Groups Master the advanced concepts of implementing Tags and Hooks Override default Cucumber options and settings along with different output report formats Run Jenkins and Cucumber from Terminal while running various Cucumber Scenarios in parallel In DetailToday, behaviour-driven development (BDD) is gaining popularity around the world. Cucumber-JVM is one of the fastest growing tools and offers a cutting-edge platform for conceptualizing and implementing BDD. The variety of features available within Cucumber enhances the experience of implementing BDD for both business and development teams.This book provides you with the skills you need to successfully create, customize, and configure the Cucumber framework. You will discover how to create Feature files, and Step Definitions, and enable various configurations, such as ""Before"" and ""After"" functions, with fun exercises. You'll round off your learning by creating automation frameworks to automate Web, REST, and Mobile apps."		Garg, Shankar		"Over 35 hands-on recipes to efficiently master the art of behaviour-driven development using Cucumber-JVM About This BookCreate a test automation framework to handle web, REST, and native mobile application automationDiscover Glue code, Hooks, Tags, and Cucumber's integration with Maven, Jenkins, and GitComprehensive recipes in Cucumber for behaviour-driven development and test automationWho This Book Is ForThis book is intended for business and development personnel who want to use Cucumber for behavior-driven development and test automation. Readers with some familiarity with Cucumber will find this book of most benefit.Since the main objective of this book is to create test automation frameworks, previous experience in automation will be helpful.What You Will Learn Explore the usage of the Gherkin Language to write meaningful and smart Feature files Understand Scenario, Steps, Backgrounds, Scenario Outlines, and Data Tables Discover the concepts of Glue Code and Step Definitions in detail Gain insights into the different types of Step Definitions, Regular Expressions, Doc Strings, Data Table transformations, and Capture Groups Master the advanced concepts of implementing Tags and Hooks Override default Cucumber options and settings along with different output report formats Run Jenkins and Cucumber from Terminal while running various Cucumber Scenarios in parallel In DetailToday, behaviour-driven development (BDD) is gaining popularity around the world. Cucumber-JVM is one of the fastest growing tools and offers a cutting-edge platform for conceptualizing and implementing BDD. The variety of features available within Cucumber enhances the experience of implementing BDD for both business and development teams.This book provides you with the skills you need to successfully create, customize, and configure the Cucumber framework. You will discover how to create Feature files, and Step Definitions, and enable various configurations, such as ""Before"" and ""After"" functions, with fun exercises. You'll round off your learning by creating automation frameworks to automate Web, REST, and Mobile apps."				Excluded	Excluded	new_screen			2						
171	Behave	A semantic wiki approach to enable behaviour driven requirements management	Poorly managed requirements are considered as one of the principal causes of projects failure and consequently companies struggle to find an effective solution for requirements elicitation and further management. The adoption of such solution becomes even more difficult when the collaboration between different departments (e.g. marketing and development) is necessary. To address this challenge, the authors propose a methodology for requirements management based on Semantic Wiki and Behaviour Driven Development (BDD). BDD allows developers and end-users to interoperate and encourages seamless collaboration between all project participants. It also certifies that requirements are treated properly by their associated developments through the connection of textual descriptions to functional tests. Semantic wikis can be an added value in requirements management due to their enhanced browser interface and collaborative knowledge sharing capability. They allow stakeholders to participate in requirements management independently of their location. This is of major importance to reduce the problem of lack of inputs from interested parties. Moreover, with semantic wikis adoption, end-users and ontologies can coexist in one system since wiki pages are presented in a human-readable format in parallel to their formal representation in ontologies. This knowledge representation supports companies' decision-making by allowing managers to prioritize implementations, to keep a trace of requirements evolution, and reuse implementations when new requirements enter the system.		Marques-Lucena C., Agostinho C., Sarraipa J., Jardim-Goncalves R.	Control Engineering and Applied Informatics	Poorly managed requirements are considered as one of the principal causes of projects failure and consequently companies struggle to find an effective solution for requirements elicitation and further management. The adoption of such solution becomes even more difficult when the collaboration between different departments (e.g. marketing and development) is necessary. To address this challenge, the authors propose a methodology for requirements management based on Semantic Wiki and Behaviour Driven Development (BDD). BDD allows developers and end-users to interoperate and encourages seamless collaboration between all project participants. It also certifies that requirements are treated properly by their associated developments through the connection of textual descriptions to functional tests. Semantic wikis can be an added value in requirements management due to their enhanced browser interface and collaborative knowledge sharing capability. They allow stakeholders to participate in requirements management independently of their location. This is of major importance to reduce the problem of lack of inputs from interested parties. Moreover, with semantic wikis adoption, end-users and ontologies can coexist in one system since wiki pages are presented in a human-readable format in parallel to their formal representation in ontologies. This knowledge representation supports companies' decision-making by allowing managers to prioritize implementations, to keep a trace of requirements evolution, and reuse implementations when new requirements enter the system.				Included	Included	new_screen			2						
172	Behave	Dynamic signal driving strategy based high speed and low powered dual edge triggered flip flop design used memory applications	Power utilization assumes a massive part in any of the integrated circuits, and it’s rundown as a standout amongst essential difficulties in the universal innovation guide into semiconductors. Generally in integrated circuit, flip-flop and clock distribution system consume a lot of energy since they make and utilize the most extreme number of internal transitions. In the clock distribution system, the clock signal circulates from a typical point to every one of the components that required for the circuit. However this capacity is more important to the synchronous framework, much consideration needs to provide for the attributes of these clock signals. In the sequential circuits, a clock distribution system spends a lot of power given the high operating frequency of high capacitance. An existing approach to reducing the limits of a clock signal is based on the quantity of clocked transistors. In this, an advanced procedure is proposed and evaluated by utilizing Dual-Edge Triggered Flip-Flop (DETFF) depends on the Dynamic Signal Driving (DSD) strategy. This DETFF is executed in sequential circuits that have been ordered using Tanner Electronic Design Automation (EDA) tool which is used to simulate and examine control by using Dynamic Signal Driving (DSD) strategy. The outcomes demonstrate that the total power utilization is decreased in sequential benchmark circuit design. A number of Flip flops have been designed by various technologies such as reducing area, delay, and power, but this proposed dynamic signal driving scheme can be used for any integrated circuit- that can be reduced to all these three parameters to give the best trade-off for a particular ASIC platform.	Flip flop, Clock distribution system, Clocked transistor, Tanner, ASIC	Prithivi Raj, M.; Kavithaa, G.	Microprocessors and Microsystems	Power utilization assumes a massive part in any of the integrated circuits, and it’s rundown as a standout amongst essential difficulties in the universal innovation guide into semiconductors. Generally in integrated circuit, flip-flop and clock distribution system consume a lot of energy since they make and utilize the most extreme number of internal transitions. In the clock distribution system, the clock signal circulates from a typical point to every one of the components that required for the circuit. However this capacity is more important to the synchronous framework, much consideration needs to provide for the attributes of these clock signals. In the sequential circuits, a clock distribution system spends a lot of power given the high operating frequency of high capacitance. An existing approach to reducing the limits of a clock signal is based on the quantity of clocked transistors. In this, an advanced procedure is proposed and evaluated by utilizing Dual-Edge Triggered Flip-Flop (DETFF) depends on the Dynamic Signal Driving (DSD) strategy. This DETFF is executed in sequential circuits that have been ordered using Tanner Electronic Design Automation (EDA) tool which is used to simulate and examine control by using Dynamic Signal Driving (DSD) strategy. The outcomes demonstrate that the total power utilization is decreased in sequential benchmark circuit design. A number of Flip flops have been designed by various technologies such as reducing area, delay, and power, but this proposed dynamic signal driving scheme can be used for any integrated circuit- that can be reduced to all these three parameters to give the best trade-off for a particular ASIC platform.				Excluded	Excluded	new_screen			2						
173	Behave	Pro Agile .NET Development with SCRUM	Pro Agile .NET Development with SCRUMguides youthrough a real-world ASP.NET project and shows how agile methodology is put into practice. There is plenty of literature on the theory behind agile methodologies, but no book on the market takes the concepts of agile practices and applies these in a practical manner to an end-to-end ASP.NET project, especially the estimating, requirements and management aspects of a project. Pro Agile .NET Development with SCRUM takes you through the initial stages of a project–gathering requirementsand setting up an environment–through to the development and deployment stages using an agile iterative approach: namely, Scrum. In the book,you'll focuson delivering an enterprise-level ASP.NET project. Each chapter is in iterations or sprints, putting into practice the features of agile–user stories, test-driven development (TDD), behavior-driven development (BDD), continuous integration, user acceptance testing, extreme programming, Scrum, design patterns and principles, inside-out development, lean developent, KanBan boards, and more. An appendix features code katas designed for the reader to get up-to-speed with some of the features of extreme programming, while also showcasing popular open-source frameworks to assist in automated testing and mocking. What you'll learn Gain practical knowledge on employing the Scrum project methodology using a real-world ASP.NET project Seehow extreme programming features in real world .NET projects Learnbest-practice tools foruser interfaceanduser acceptance testing, such as waitiN Discoverdetails on how to capture requirements and drive development using user stories Learnhow to estimate and plan agile projects and work with business stakeholders through a practical example Uncover tips for developing using the outside-in, TDD and BDD methodologies Gain information on tracking the progress of a project through burn down charts, iterations and retrospectives Who this book is for Experienced .NET developers who are looking to see how the Scrum agile project methodology and extreme programming features are employed in a real-world .NET application.		Blankenship, Jerrel; Bussa, Matthew; Millett, Scott		Pro Agile .NET Development with SCRUMguides youthrough a real-world ASP.NET project and shows how agile methodology is put into practice. There is plenty of literature on the theory behind agile methodologies, but no book on the market takes the concepts of agile practices and applies these in a practical manner to an end-to-end ASP.NET project, especially the estimating, requirements and management aspects of a project. Pro Agile .NET Development with SCRUM takes you through the initial stages of a project–gathering requirementsand setting up an environment–through to the development and deployment stages using an agile iterative approach: namely, Scrum. In the book,you'll focuson delivering an enterprise-level ASP.NET project. Each chapter is in iterations or sprints, putting into practice the features of agile–user stories, test-driven development (TDD), behavior-driven development (BDD), continuous integration, user acceptance testing, extreme programming, Scrum, design patterns and principles, inside-out development, lean developent, KanBan boards, and more. An appendix features code katas designed for the reader to get up-to-speed with some of the features of extreme programming, while also showcasing popular open-source frameworks to assist in automated testing and mocking. What you'll learn Gain practical knowledge on employing the Scrum project methodology using a real-world ASP.NET project Seehow extreme programming features in real world .NET projects Learnbest-practice tools foruser interfaceanduser acceptance testing, such as waitiN Discoverdetails on how to capture requirements and drive development using user stories Learnhow to estimate and plan agile projects and work with business stakeholders through a practical example Uncover tips for developing using the outside-in, TDD and BDD methodologies Gain information on tracking the progress of a project through burn down charts, iterations and retrospectives Who this book is for Experienced .NET developers who are looking to see how the Scrum agile project methodology and extreme programming features are employed in a real-world .NET application.				Excluded	Excluded	new_screen			2						
174	Behave	Behavior-driven development in product configuration systems	Product Configuration Systems (PCS) are increasingly used by companies to automate the performance of the sales and engineering processes. Since the benefits from such projects have huge variations, it is crucial to make the right decisions when scoping and developing PCSs. The development of PCS is influenced by both business interests and technical insights. Developers of PCS face various challenges while working in team, including different stakeholders such as business owners, developers, project managers, and product experts. The more diverse the team is, the more significant are the challenges. This paper suggests that Behavior-driven Development (BDD) may provide configuration teams with a specific structure to express scenarios (and thus constraints) on PCS in natural language. BDD may yield benefits such as a better expression of PCS constraints, more efficient communication of requirements and incorporation of the expressed rules in a software transformation process. In other words, applying BDD may eliminate unnecessary tasks when gathering knowledge, developing, and testing PCS projects. In this paper, we present a novel approach from an ongoing project on how to relate BDD to the development process of PCS while using Scrum-based methods. © 2018 CEUR-WS. All rights reserved.		Shafiee S., Hvam L., Haug A., Wautelet Y.	CEUR Workshop Proceedings	Product Configuration Systems (PCS) are increasingly used by companies to automate the performance of the sales and engineering processes. Since the benefits from such projects have huge variations, it is crucial to make the right decisions when scoping and developing PCSs. The development of PCS is influenced by both business interests and technical insights. Developers of PCS face various challenges while working in team, including different stakeholders such as business owners, developers, project managers, and product experts. The more diverse the team is, the more significant are the challenges. This paper suggests that Behavior-driven Development (BDD) may provide configuration teams with a specific structure to express scenarios (and thus constraints) on PCS in natural language. BDD may yield benefits such as a better expression of PCS constraints, more efficient communication of requirements and incorporation of the expressed rules in a software transformation process. In other words, applying BDD may eliminate unnecessary tasks when gathering knowledge, developing, and testing PCS projects. In this paper, we present a novel approach from an ongoing project on how to relate BDD to the development process of PCS while using Scrum-based methods. © 2018 CEUR-WS. All rights reserved.				Included	Included	new_screen			2						
175	Behave	Light-Weight Software Product Lines for Small and Medium-Sized Enterprises (SMEs)	Product line engineering practices promote the idea of systematic reuse of core assets and have been reported to decrease time-to-market and development costs for new products. However, our recent efforts to transfer our product line engineering knowledge to several of our small and medium-size enterprise industrial partner showed that there are challenges that need to be addressed before core product line engineering ideas can be deployed in SME context. These challenges include upfront investment costs, business traceability, levels of abstraction of functional features and semantic distinction between functional and non-functional software aspects. In order to address these challenges within the context of SMEs, we adopt and extend the behavior-driven development methodology in a way to not only offer agility in practice but also to equip software developers with the means to capture and manage software variability within the behavior-driven development process. We introduce the details of the extended methodology and discuss its advantages and disadvantages in detail.		Bagheri, Ebrahim; Ensan, Faezeh	Proceedings of the 2013 Conference of the Center for Advanced Studies on Collaborative Research	Product line engineering practices promote the idea of systematic reuse of core assets and have been reported to decrease time-to-market and development costs for new products. However, our recent efforts to transfer our product line engineering knowledge to several of our small and medium-size enterprise industrial partner showed that there are challenges that need to be addressed before core product line engineering ideas can be deployed in SME context. These challenges include upfront investment costs, business traceability, levels of abstraction of functional features and semantic distinction between functional and non-functional software aspects. In order to address these challenges within the context of SMEs, we adopt and extend the behavior-driven development methodology in a way to not only offer agility in practice but also to equip software developers with the means to capture and manage software variability within the behavior-driven development process. We introduce the details of the extended methodology and discuss its advantages and disadvantages in detail.				Included	Included	new_screen			2						
176	Behave	Chapter 8 - Integrating Automation into Your Development Process	Publisher Summary The concept of continuous integration has been around for quite a while now. There are many tools to provide continuous integration and surprisingly, some even work together. Any investment in continuous integration will pay off but it requires discipline that few developers, QA resources, or management actually have at the start of the process. The challenge is to train the development staff and the QA to use continuous integration to work smarter, not harder. There is much interest in continuous integration, and many organizations are implementing continuous integration tools as part of their move to agile development. Difficulty surrounds this move because not only do developers have to change some working habits, but also there typically is a large investment required matching the capabilities of the tool to the organization itself and for that reason alone it is daunting. Many tools, whether they are open source or commercial products, exist for performing automation. The platform in use for development, including the operating system or the development environment platform, as well as the delivery platform of the end product, may restrict the selection of tools. Additionally, the software development language in use may dictate a narrow selection of tools. Some development shops may have restrictions regarding what software can be brought in due to security concerns.		Holtsnider, Bill; Wheeler, Tom; Stragand, George; Gee, Joseph		Publisher Summary The concept of continuous integration has been around for quite a while now. There are many tools to provide continuous integration and surprisingly, some even work together. Any investment in continuous integration will pay off but it requires discipline that few developers, QA resources, or management actually have at the start of the process. The challenge is to train the development staff and the QA to use continuous integration to work smarter, not harder. There is much interest in continuous integration, and many organizations are implementing continuous integration tools as part of their move to agile development. Difficulty surrounds this move because not only do developers have to change some working habits, but also there typically is a large investment required matching the capabilities of the tool to the organization itself and for that reason alone it is daunting. Many tools, whether they are open source or commercial products, exist for performing automation. The platform in use for development, including the operating system or the development environment platform, as well as the delivery platform of the end product, may restrict the selection of tools. Additionally, the software development language in use may dictate a narrow selection of tools. Some development shops may have restrictions regarding what software can be brought in due to security concerns.				Excluded	Excluded	new_screen			2						
177	Behave	Chapter 4.1 - The Psychology of Programming in the Large: Team and Organizational Behaviour	Publisher Summary This chapter focuses on the psychology of programming in relation to team and organizational behavior. Software development must be studied at several behavioural levels. Organizing programmers into teams superimposes a layer of social behavior on the cognitive requirements of programming tasks. Two structures have been proposed for programming teams based on the centralized versus decentralized team organizations often studied in group dynamics research. A hybrid approach to structuring programming teams might be taken on large projects that have characteristics favourable to different types of programming teams. Programming team activities offer many opportunities for peer review activities that may be formal or informal components of the development process. On the other hand, team methodologies must focus on coordinating the tasks and product concept. The structure of programming teams should reflect the nature of the task rather than the organization, allow members to speak as if with one mind, and determine the tasks the team can effectively handle.		Curtis, Bill; Walz, Diane		Publisher Summary This chapter focuses on the psychology of programming in relation to team and organizational behavior. Software development must be studied at several behavioural levels. Organizing programmers into teams superimposes a layer of social behavior on the cognitive requirements of programming tasks. Two structures have been proposed for programming teams based on the centralized versus decentralized team organizations often studied in group dynamics research. A hybrid approach to structuring programming teams might be taken on large projects that have characteristics favourable to different types of programming teams. Programming team activities offer many opportunities for peer review activities that may be formal or informal components of the development process. On the other hand, team methodologies must focus on coordinating the tasks and product concept. The structure of programming teams should reflect the nature of the task rather than the organization, allow members to speak as if with one mind, and determine the tasks the team can effectively handle.				Excluded	Excluded	new_screen			2						
178	Behave	Intuitive design: framing a software test system as a status reporting tool for business	Purpose: This paper aims to present a conceptual framework of how software teams can leverage the implicit information of implemented acceptance tests to cater to the needs of decision makers. The research questions on this framework were how business stakeholders can receive project status information in an intuitive way and how this framework can guarantee the traceability of tests to requirements. Design/methodology/approach: The conceptual framework delineates the design of an acceptance test framework in three aspects: how the requirements model reflects the evolving states of requirement maturity over a project, how the acceptance test model becomes synchronized with the requirements model without a traceability matrix and how the acceptance test model communicates business value to the decision makers. Findings: In an industrial case study, the presented framework yielded the positive effects of intuitive understanding by business stakeholders, high test coverage of requirements and distinctly reduced manual quality assurance (QA) work by automated testing for browsers and mobile devices. Practical implications: The presented framework can help to convince business stakeholders to approve the budget for building a testing framework because it delivers them value as a status reporting tool. Originality/value: This paper is the first to describe a step-by-step approach to solving a critical problem that IT departments frequently face. The solution consists in a new way of transforming the perception of a technical framework into a reporting tool for business information by intuitive design. The idea of mapping hierarchically corresponding abstraction layers can be transferred to other engineering domains. © 2017, © Emerald Publishing Limited.		So C.	Journal of Engineering, Design and Technology	Purpose: This paper aims to present a conceptual framework of how software teams can leverage the implicit information of implemented acceptance tests to cater to the needs of decision makers. The research questions on this framework were how business stakeholders can receive project status information in an intuitive way and how this framework can guarantee the traceability of tests to requirements. Design/methodology/approach: The conceptual framework delineates the design of an acceptance test framework in three aspects: how the requirements model reflects the evolving states of requirement maturity over a project, how the acceptance test model becomes synchronized with the requirements model without a traceability matrix and how the acceptance test model communicates business value to the decision makers. Findings: In an industrial case study, the presented framework yielded the positive effects of intuitive understanding by business stakeholders, high test coverage of requirements and distinctly reduced manual quality assurance (QA) work by automated testing for browsers and mobile devices. Practical implications: The presented framework can help to convince business stakeholders to approve the budget for building a testing framework because it delivers them value as a status reporting tool. Originality/value: This paper is the first to describe a step-by-step approach to solving a critical problem that IT departments frequently face. The solution consists in a new way of transforming the perception of a technical framework into a reporting tool for business information by intuitive design. The idea of mapping hierarchically corresponding abstraction layers can be transferred to other engineering domains. © 2017, © Emerald Publishing Limited.				Included	Included	new_screen			2						
179	Behave	IOS Code Testing: Test-Driven Development and Behavior-Driven Development with Swift	Put into motion practical examples to master Test-Driven Development (TDD) and acceptance testing in Swift. This book uses a pragmatic approach to writing well-tested code and provides techniques that can be used to retrofit tests to legacy code bases. You'll be introduced to basic principles of TDD, such as Test First, Red-Green-Refactor, Remove Duplicate code, Dependency Injection, and Single Responsibility. Approaches covered include TDD, behavior-driven development (BDD), UI, and acceptance testing with common standard/open source frameworks. iOS Code Testing offers helpful instruction to teach iOS developers to retrospectively fit tests to legacy code, refactor legacy code so as to make the code more testable, install and configure a popular Swift BDD framework, practice BDD with Xcode, and create automated UI tests with Xcode. Additionally, many projects have legacy code bases. Legacy code is often seen as a blocker when it comes to implementing any kind of testing. What You Will Learn Fit test to legacy code retrospectively Install and configure popular Swift BDD frameworks Practice BDD with Xcode Who This Book Is For Software practitioners, such as Swift developers and mobile app testers.		Mishra, Abhishek		Put into motion practical examples to master Test-Driven Development (TDD) and acceptance testing in Swift. This book uses a pragmatic approach to writing well-tested code and provides techniques that can be used to retrofit tests to legacy code bases. You'll be introduced to basic principles of TDD, such as Test First, Red-Green-Refactor, Remove Duplicate code, Dependency Injection, and Single Responsibility. Approaches covered include TDD, behavior-driven development (BDD), UI, and acceptance testing with common standard/open source frameworks. iOS Code Testing offers helpful instruction to teach iOS developers to retrospectively fit tests to legacy code, refactor legacy code so as to make the code more testable, install and configure a popular Swift BDD framework, practice BDD with Xcode, and create automated UI tests with Xcode. Additionally, many projects have legacy code bases. Legacy code is often seen as a blocker when it comes to implementing any kind of testing. What You Will Learn Fit test to legacy code retrospectively Install and configure popular Swift BDD frameworks Practice BDD with Xcode Who This Book Is For Software practitioners, such as Swift developers and mobile app testers.				Excluded	Excluded	new_screen			2						
180	Behave	Modern and Responsive Mobile-enabled Web Applications	Rapid web technology improvements in the last few years have powered software developers to quickly write responsive mobile-friendly applications. The innovative web frameworks and libraries make it easy to have same software code base for desktop and mobile devices. Single-page applications offer a more-native-app-like experience to the user. This also means a web application can easily be converted to a native mobile application if desired. This allows software products to be evolved continuously at a much faster pace with features added on daily basis. The software companies who can adopt these technologies will most likely see the benefit in the long run as they can offer new and modified products faster than their competitors. In this paper, we review some of the state-of-the-art web technologies, third-party libraries, and frameworks for quick interactive web development. Finally, we present a simple interactive browser-based, mobile friendly web application which was developed using one of the latest web development framework.	Web-based Applications, JavaScript, Web Framework, Mobile-friendly Application, Single-Page Applications	Shahzad, Farrukh	Procedia Computer Science	Rapid web technology improvements in the last few years have powered software developers to quickly write responsive mobile-friendly applications. The innovative web frameworks and libraries make it easy to have same software code base for desktop and mobile devices. Single-page applications offer a more-native-app-like experience to the user. This also means a web application can easily be converted to a native mobile application if desired. This allows software products to be evolved continuously at a much faster pace with features added on daily basis. The software companies who can adopt these technologies will most likely see the benefit in the long run as they can offer new and modified products faster than their competitors. In this paper, we review some of the state-of-the-art web technologies, third-party libraries, and frameworks for quick interactive web development. Finally, we present a simple interactive browser-based, mobile friendly web application which was developed using one of the latest web development framework.				Excluded	Excluded	new_screen			2						
181	Behave	Reengineering legacy systems with transaction model	Reengineering of legacy systems is one of trickiest challenges in software development. The paper addresses methodologies applicable to re-engineering legacy information systems. Specifically, it points out a possibility to couple ontological descriptions of the enterprise with information systems features. Such interconnection verifies whether a functionality implemented in the information system relates to business tasks or not. Business processes formulated as DEMO transaction patterns together with Behavior-Driven Development technique enable to link existing businesses processes to production codebase. © 2018 Author(s).		Matula J., Zacek J.	AIP Conference Proceedings	Reengineering of legacy systems is one of trickiest challenges in software development. The paper addresses methodologies applicable to re-engineering legacy information systems. Specifically, it points out a possibility to couple ontological descriptions of the enterprise with information systems features. Such interconnection verifies whether a functionality implemented in the information system relates to business tasks or not. Business processes formulated as DEMO transaction patterns together with Behavior-Driven Development technique enable to link existing businesses processes to production codebase. © 2018 Author(s).				Included	Included	new_screen			2						
182	Behave	A Requirement-based Regression Test Selection Technique in Behavior-Driven Development	Regression testing is an essential software maintenance activity before the release of a new version implementing a bug fix or a new feature. A regression test selection (RTS) technique chooses a subset of existing test cases to ensure that the system will not be adversely affected by the latest modifications. With the rise of DevOps, behavior-driven development (BDD) is growing in popularity as it is in close alignment with agile practices, for example, continuous integration. Hence, it is necessary to propose a novel and effective RTS technique for BDD specifically to accelerate the development process while ensuring software quality. Since most existing techniques for RTS are code-based and thus subject to some limitations, we present a requirement-based technique which uses the requirements in BDD to select test cases in both high-level (acceptance testing) and low-level (unit testing). Our technique firstly illustrates the new requirement with a scenario, and subsequently computes the semantic similarity of the new scenario and all existing scenarios with the vector space model. According to the results, the modification-traversing regression test cases can be selected in a semi-automated way. We also conduct an experimental study to evaluate our technique in terms of inclusiveness, precision, efficiency and generality. The study shows that our technique is applicable for BDD and effective in practice.	regression test selection;behavior-driven development;requirement-based technique;vector space model	J. Xu; Q. Du; X. Li	2021 IEEE 45th Annual Computers, Software, and Applications Conference (COMPSAC)	Regression testing is an essential software maintenance activity before the release of a new version implementing a bug fix or a new feature. A regression test selection (RTS) technique chooses a subset of existing test cases to ensure that the system will not be adversely affected by the latest modifications. With the rise of DevOps, behavior-driven development (BDD) is growing in popularity as it is in close alignment with agile practices, for example, continuous integration. Hence, it is necessary to propose a novel and effective RTS technique for BDD specifically to accelerate the development process while ensuring software quality. Since most existing techniques for RTS are code-based and thus subject to some limitations, we present a requirement-based technique which uses the requirements in BDD to select test cases in both high-level (acceptance testing) and low-level (unit testing). Our technique firstly illustrates the new requirement with a scenario, and subsequently computes the semantic similarity of the new scenario and all existing scenarios with the vector space model. According to the results, the modification-traversing regression test cases can be selected in a semi-automated way. We also conduct an experimental study to evaluate our technique in terms of inclusiveness, precision, efficiency and generality. The study shows that our technique is applicable for BDD and effective in practice.				Included	Included	new_screen			2						
183	Behave	Interface Responsibility Patterns: Processing Resources and Operation Responsibilities	Remote Application Programming Interfaces (APIs), as for instance offered in microservices architectures, are used in almost any distributed system today and are thus enablers for many digitalization efforts. It is hard to design such APIs so that they are easy and effective to use; maintaining their runtime qualities while preserving backward compatibility is equally challenging. Finding well suited granularities in terms of the architectural capabilities of endpoints and the read-write semantics of their operations are particularly important design concerns. Existing pattern languages have dealt with local APIs in object-oriented programming, with remote objects, with queue-based messaging and with service-oriented computing platforms. However, patterns or equivalent guidances for the architectural design of API endpoints, operations and their request and response message structures are still missing. In this paper, we extend our microservice API pattern language (MAP) and introduce endpoint role and operation responsibility patterns, namely Processing Resource, Computation Function, State Creation Operation, Retrieval Operation, and State Transition Operation. Known uses and examples of the patterns are drawn from public Web APIs, as well as application development and system integration projects the authors have been involved in.		Zimmermann, Olaf; Lübke, Daniel; Zdun, Uwe; Pautasso, Cesare; Stocker, Mirko	Proceedings of the European Conference on Pattern Languages of Programs 2020	Remote Application Programming Interfaces (APIs), as for instance offered in microservices architectures, are used in almost any distributed system today and are thus enablers for many digitalization efforts. It is hard to design such APIs so that they are easy and effective to use; maintaining their runtime qualities while preserving backward compatibility is equally challenging. Finding well suited granularities in terms of the architectural capabilities of endpoints and the read-write semantics of their operations are particularly important design concerns. Existing pattern languages have dealt with local APIs in object-oriented programming, with remote objects, with queue-based messaging and with service-oriented computing platforms. However, patterns or equivalent guidances for the architectural design of API endpoints, operations and their request and response message structures are still missing. In this paper, we extend our microservice API pattern language (MAP) and introduce endpoint role and operation responsibility patterns, namely Processing Resource, Computation Function, State Creation Operation, Retrieval Operation, and State Transition Operation. Known uses and examples of the patterns are drawn from public Web APIs, as well as application development and system integration projects the authors have been involved in.				Excluded	Excluded	new_screen			2						
184	Behave	A Conceptual Metamodel to Bridging Requirement Patterns to Test Patterns	Requirement patterns represent an abstraction of an application's behaviors and services that, in turn, may be replicated in similar applications. However, there has been a lack of efforts exploiting the benefits of requirement patterns in other phases of the software development life cycle, besides the requirements engineering itself. To address this gap, we propose the Software Pattern MetaModel (SoPaMM) that bridges requirement patterns to groups of scenarios with similar behaviors in the form of test patterns. SoPaMM allows the description of the behavior of a requirement pattern through a time executable and easy-to-use language aiming at the automatic generation of test patterns. Using SoPaMM, we model and implement a behavior-driven functional requirement pattern for a web-based user authentication application. Our preliminary results point out that a requirement pattern can be an executable specification capable of generating automated tests.	behavior; metamodeling; requirement pattern; reuse; test pattern	Kudo, Taciana Novo; Bulcão-Neto, Renato F.; Vincenzi, Auri M. R.	Proceedings of the XXXIII Brazilian Symposium on Software Engineering	Requirement patterns represent an abstraction of an application's behaviors and services that, in turn, may be replicated in similar applications. However, there has been a lack of efforts exploiting the benefits of requirement patterns in other phases of the software development life cycle, besides the requirements engineering itself. To address this gap, we propose the Software Pattern MetaModel (SoPaMM) that bridges requirement patterns to groups of scenarios with similar behaviors in the form of test patterns. SoPaMM allows the description of the behavior of a requirement pattern through a time executable and easy-to-use language aiming at the automatic generation of test patterns. Using SoPaMM, we model and implement a behavior-driven functional requirement pattern for a web-based user authentication application. Our preliminary results point out that a requirement pattern can be an executable specification capable of generating automated tests.				Included	Included	new_screen			2						
185	Behave	A Framework to Diminish the Gap between the Business Specialist and the Software Designer	"Requirements Engineering establishes the process for defining requirements as one in which elicitation, modeling and analysis are tasks which must be carried out. This process should involve different stakeholders and their different viewpoints. Among these stakeholders, there is the software designer, responsible for creating models based on the information gathered by business specialists. However, this communication channel may create some ""noise"" that leads to information being lost. This loss produces a semantic gap between what is desired and what will be developed. The semantic gap is characterized by inconsistencies in the requirements represented by scenarios–user stories in a behavior-driven context–and by the conceptual model. This paper presents an interactive approach to the agile requirements modeling, thus fostering greater consistency between the artifacts of the scenarios and the conceptual model. This consistency is ensured by using a mind model specification which will serve as a basis for transforming the definitions of the scenario and generating a conceptual model represented by a UML class diagram. The mind model represents the main role of this approach, and functions as a bond that represents the business entities, thus enabling the requirements to be more consistent with the reality of the business."	Behaviour Driven Development; Agile Modeling Requirements; Domain Model; Mind Map Modeling; UML	Wanderley, Fernando; da Silveria, Denis Silva	Proceedings of the 2012 Eighth International Conference on the Quality of Information and Communications Technology	"Requirements Engineering establishes the process for defining requirements as one in which elicitation, modeling and analysis are tasks which must be carried out. This process should involve different stakeholders and their different viewpoints. Among these stakeholders, there is the software designer, responsible for creating models based on the information gathered by business specialists. However, this communication channel may create some ""noise"" that leads to information being lost. This loss produces a semantic gap between what is desired and what will be developed. The semantic gap is characterized by inconsistencies in the requirements represented by scenarios–user stories in a behavior-driven context–and by the conceptual model. This paper presents an interactive approach to the agile requirements modeling, thus fostering greater consistency between the artifacts of the scenarios and the conceptual model. This consistency is ensured by using a mind model specification which will serve as a basis for transforming the definitions of the scenario and generating a conceptual model represented by a UML class diagram. The mind model represents the main role of this approach, and functions as a bond that represents the business entities, thus enabling the requirements to be more consistent with the reality of the business."				Included	Included	new_screen			2						
186	Behave	Using Behaviour-driven Requirements Engineering for Establishing and Managing Agile Product Lines: An Observational Study	Requirements engineering in agile product line engineering refers to both common and variability components establishing a software. Although it is conventional for the requirements engineering to take place in a dedicated upfront domain analysis phase, agile-based environments denounce such a proactive behaviour. This paper provides an observational study examining a reactive incremental requirement engineering approach called behaviour-driven requirements engineering. The proposed approach uses behaviour-driven development to establish and maintain agile product lines. The findings of the study are very promising and suggest the following: the approach is easy to understand and quick to learn; the approach supports the constantly changing nature of software development; and using behaviour-driven requirements engineering produces reliable and coherent requirements. In practice, the observational study showed that using the proposed approach saved time for development team and customers, decreased costs, improved the software quality, and shortened the time-to-market. © 2021. All Rights Reserved.		Elshandidy H., Mazen S., Hassanein E., Nasr E.	International Journal of Advanced Computer Science and Applications	Requirements engineering in agile product line engineering refers to both common and variability components establishing a software. Although it is conventional for the requirements engineering to take place in a dedicated upfront domain analysis phase, agile-based environments denounce such a proactive behaviour. This paper provides an observational study examining a reactive incremental requirement engineering approach called behaviour-driven requirements engineering. The proposed approach uses behaviour-driven development to establish and maintain agile product lines. The findings of the study are very promising and suggest the following: the approach is easy to understand and quick to learn; the approach supports the constantly changing nature of software development; and using behaviour-driven requirements engineering produces reliable and coherent requirements. In practice, the observational study showed that using the proposed approach saved time for development team and customers, decreased costs, improved the software quality, and shortened the time-to-market. © 2021. All Rights Reserved.				Included	Included	new_screen			2						
187	Behave	Towards Automated Testing of RPA Implementations	Robotic Process Automation (RPA) is a technology that has grown tremendously in the last years, due to its usability in the area of process automation. An essential part of any software development process is quality assurance, so testing will be very important for RPA processes. However, the classical software techniques are not always suitable for the RPA software robots due to the mix of the graphical description of the robots and their implementations. In this short paper, we describe the state of the practice for testing of software robots and propose some ideas of test automation using model-based testing.	Test automation; Model-based testing; Robotic Process Automation (RPA); RPA testing	Cernat, Marina; Staicu, Adelina Nicoleta; Stefanescu, Alin	Proceedings of the 11th ACM SIGSOFT International Workshop on Automating TEST Case Design, Selection, and Evaluation	Robotic Process Automation (RPA) is a technology that has grown tremendously in the last years, due to its usability in the area of process automation. An essential part of any software development process is quality assurance, so testing will be very important for RPA processes. However, the classical software techniques are not always suitable for the RPA software robots due to the mix of the graphical description of the robots and their implementations. In this short paper, we describe the state of the practice for testing of software robots and propose some ideas of test automation using model-based testing.				Excluded	Excluded	new_screen			2						
188	Behave	Agent-oriented software patterns for rapid and affordable robot programming	Robotic systems are often quite complex to develop; they are huge, heavily constrained from the non-functional point of view and they implement challenging algorithms. The lack of integrated methods with reuse approaches leads robotic developers to reinvent the wheel each time a new project starts. This paper proposes to reuse the experience done when building robotic applications, by catching it into design patterns. These represent a general mean for (i) reusing proved solutions increasing the final quality, (ii) communicating the knowledge about a domain and (iii) reducing the development time and effort. Despite of this generality, the proposed repository of patterns is specific for multi-agent robotic systems. These patterns are documented by a set of design diagrams and the corresponding implementing code is obtained through a series of automatic transformations. Some patterns extracted from an existing and freely available repository are presented. The paper also discusses an experimental set-up based on the construction of a complete robotic application obtained by composing some highly reusable patterns.	Multi-agent systems, Design patterns, Pattern oriented design, Robotics systems	Chella, Antonio; Cossentino, Massimo; Gaglio, Salvatore; Sabatucci, Luca; Seidita, Valeria	Journal of Systems and Software	Robotic systems are often quite complex to develop; they are huge, heavily constrained from the non-functional point of view and they implement challenging algorithms. The lack of integrated methods with reuse approaches leads robotic developers to reinvent the wheel each time a new project starts. This paper proposes to reuse the experience done when building robotic applications, by catching it into design patterns. These represent a general mean for (i) reusing proved solutions increasing the final quality, (ii) communicating the knowledge about a domain and (iii) reducing the development time and effort. Despite of this generality, the proposed repository of patterns is specific for multi-agent robotic systems. These patterns are documented by a set of design diagrams and the corresponding implementing code is obtained through a series of automatic transformations. Some patterns extracted from an existing and freely available repository are presented. The paper also discusses an experimental set-up based on the construction of a complete robotic application obtained by composing some highly reusable patterns.				Excluded	Excluded	new_screen			2						
189	Behave	Ruby on Rails Tutorial: Learn Web Development with Rails	Ruby on Rails Tutorial by Michael Hartl has become a must-read for developers learning how to build Rails apps. Peter Cooper, Editor of Ruby Inside Using Rails, developers can build web applications of exceptional elegance and power. Although its remarkable capabilities have made Ruby on Rails one of the worlds most popular web development frameworks, it can be challenging to learn and use. Ruby on Rails Tutorial, Second Edition, is the solution. Best-selling author and leading Rails developer Michael Hartl teaches Rails by guiding you through the development of your own complete sample application using the latest techniques in Rails web development. The updates to this edition include all-new site design using Twitters Bootstrap; coverage of the new asset pipeline, including Sprockets and Sass; behavior-driven development (BDD) with Capybara and RSpec; better automated testing with Guard and Spork; roll your own authentication with has_secure_password; and an introduction to Gherkin and Cucumber. Youll find integrated tutorials not only for Rails, but also for the essential Ruby, HTML, CSS, JavaScript, and SQL skills youll need when developing web applications. Hartl explains how each new technique solves a real-world problem, and he demonstrates this with bite-sized code thats simple enough to understand, yet novel enough to be useful. Whatever your previous web development experience, this book will guide you to true Rails mastery. This book will help you Install and set up your Rails development environment Go beyond generated code to truly understand how to build Rails applications from scratch Learn test-driven development (TDD) with RSpec Effectively use the Model-View-Controller (MVC) pattern Structure applications using the REST architecture Build static pages and transform them into dynamic ones Master the Ruby programming skills all Rails developers need Define high-quality site layouts and data models Implement registration and authentication systems, including validation and secure passwords Update, display, and delete users Add social features and microblogging, including an introduction to Ajax Record version changes with Git and share code at GitHub Simplify application deployment with Heroku		Hartl, Michael		Ruby on Rails Tutorial by Michael Hartl has become a must-read for developers learning how to build Rails apps. Peter Cooper, Editor of Ruby Inside Using Rails, developers can build web applications of exceptional elegance and power. Although its remarkable capabilities have made Ruby on Rails one of the worlds most popular web development frameworks, it can be challenging to learn and use. Ruby on Rails Tutorial, Second Edition, is the solution. Best-selling author and leading Rails developer Michael Hartl teaches Rails by guiding you through the development of your own complete sample application using the latest techniques in Rails web development. The updates to this edition include all-new site design using Twitters Bootstrap; coverage of the new asset pipeline, including Sprockets and Sass; behavior-driven development (BDD) with Capybara and RSpec; better automated testing with Guard and Spork; roll your own authentication with has_secure_password; and an introduction to Gherkin and Cucumber. Youll find integrated tutorials not only for Rails, but also for the essential Ruby, HTML, CSS, JavaScript, and SQL skills youll need when developing web applications. Hartl explains how each new technique solves a real-world problem, and he demonstrates this with bite-sized code thats simple enough to understand, yet novel enough to be useful. Whatever your previous web development experience, this book will guide you to true Rails mastery. This book will help you Install and set up your Rails development environment Go beyond generated code to truly understand how to build Rails applications from scratch Learn test-driven development (TDD) with RSpec Effectively use the Model-View-Controller (MVC) pattern Structure applications using the REST architecture Build static pages and transform them into dynamic ones Master the Ruby programming skills all Rails developers need Define high-quality site layouts and data models Implement registration and authentication systems, including validation and secure passwords Update, display, and delete users Add social features and microblogging, including an introduction to Ajax Record version changes with Git and share code at GitHub Simplify application deployment with Heroku				Excluded	Excluded	new_screen			2						
190	Behave	Offshore Development Center Management in Action	Serving as a virtual extension of the Customer's IT Department, the Offshore Development Center (ODC) model provides certain benefits in comparison with in-house teams including reduced development complexity, reduced operating expense, and access to a larger pool of talents. Nevertheless, ODCs are prone to problems in Scope, Schedule, Quality, Human Resources, and Communication. From the experiences of Project Managers who have worked in Offshore Development Centers set up by FPT Software- a leading IT Outsourcing Service provider, this paper offers a look at actual problems encountered in ODCs. We then provide a reference ODC Management Framework, which consists of Best Practices that we have applied into an ODC serving a Media Industry customer over the last 4 years. The results of applying the model are discussed to prove its effectiveness.	Offshore; Offshore development center; Outsourcing	Hung, Phan Duy; Cuong, Le Gia; Bach, Nguyen Luu	Proceedings of the 2020 5th International Conference on Intelligent Information Technology	Serving as a virtual extension of the Customer's IT Department, the Offshore Development Center (ODC) model provides certain benefits in comparison with in-house teams including reduced development complexity, reduced operating expense, and access to a larger pool of talents. Nevertheless, ODCs are prone to problems in Scope, Schedule, Quality, Human Resources, and Communication. From the experiences of Project Managers who have worked in Offshore Development Centers set up by FPT Software- a leading IT Outsourcing Service provider, this paper offers a look at actual problems encountered in ODCs. We then provide a reference ODC Management Framework, which consists of Best Practices that we have applied into an ODC serving a Media Industry customer over the last 4 years. The results of applying the model are discussed to prove its effectiveness.				Excluded	Excluded	new_screen			2						
191	Behave	Test-Driven Infrastructure with Chef: Bring Behavior-Driven Development to Infrastructure as Code	Since Test-Driven Infrastructure with Chef first appeared in mid-2011, infrastructure testing has begun to flourish in the web ops world. In this revised and expanded edition, author Stephen Nelson-Smith brings you up to date on this rapidly evolving discipline, including the philosophy driving it and a growing array of tools. Youll get a hands-on introduction to the Chef framework, and a recommended toolchain and workflow for developing your own test-driven production infrastructure. Several exercises and examples throughout the book help you gain experience with Chef and the entire infrastructure-testing ecosystem. Learn how this test-first approach provides increased security, code quality, and peace of mind.Explore the underpinning philosophy that infrastructure can and should be treated as code Become familiar with the MASCOT approach to test-driven infrastructure Understand the basics of test-driven and behavior-driven development for managing change Dive into Chef fundamentals by building an infrastructure with real examples Discover how Chef works with tools such as Virtualbox and Vagrant Get a deeper understanding of Chef by learning Ruby language basics Learn the tools and workflow necessary to conduct unit, integration, and acceptance tests		Nelson-Smith, Stephen		Since Test-Driven Infrastructure with Chef first appeared in mid-2011, infrastructure testing has begun to flourish in the web ops world. In this revised and expanded edition, author Stephen Nelson-Smith brings you up to date on this rapidly evolving discipline, including the philosophy driving it and a growing array of tools. Youll get a hands-on introduction to the Chef framework, and a recommended toolchain and workflow for developing your own test-driven production infrastructure. Several exercises and examples throughout the book help you gain experience with Chef and the entire infrastructure-testing ecosystem. Learn how this test-first approach provides increased security, code quality, and peace of mind.Explore the underpinning philosophy that infrastructure can and should be treated as code Become familiar with the MASCOT approach to test-driven infrastructure Understand the basics of test-driven and behavior-driven development for managing change Dive into Chef fundamentals by building an infrastructure with real examples Discover how Chef works with tools such as Virtualbox and Vagrant Get a deeper understanding of Chef by learning Ruby language basics Learn the tools and workflow necessary to conduct unit, integration, and acceptance tests				Excluded	Excluded	new_screen			2						
192	Behave	A permissioned blockchain-based implementation of LMSR prediction markets	Since the seminal work by Hanson (2003), the Logarithmic Market Scoring Rule (LMSR) has become the de facto market-maker mechanism for prediction markets. We suggest in this paper three potential issues with centralized implementations of LMSR, which we refer to as the availability, security, and privacy problems. We also explain how a permissioned blockchain-based implementation of LMSR effectively solves all the above problems. Following the design science research framework (Peffers et al., 2007), our main contribution is a fully functional permissioned blockchain-based implementation of LMSR that is ready to be deployed. We believe our results are of great value not only to prediction market researchers and practitioners looking for LMSR implementations, but also to blockchain professionals looking for fully developed solutions as well as applications of suitable research frameworks to guide blockchain research and development.	Blockchain, Design science, Logarithmic Market Scoring Rule, Prediction markets	Carvalho, Arthur	Decision Support Systems	Since the seminal work by Hanson (2003), the Logarithmic Market Scoring Rule (LMSR) has become the de facto market-maker mechanism for prediction markets. We suggest in this paper three potential issues with centralized implementations of LMSR, which we refer to as the availability, security, and privacy problems. We also explain how a permissioned blockchain-based implementation of LMSR effectively solves all the above problems. Following the design science research framework (Peffers et al., 2007), our main contribution is a fully functional permissioned blockchain-based implementation of LMSR that is ready to be deployed. We believe our results are of great value not only to prediction market researchers and practitioners looking for LMSR implementations, but also to blockchain professionals looking for fully developed solutions as well as applications of suitable research frameworks to guide blockchain research and development.				Excluded	Excluded	new_screen			2						
193	Behave	Introducing continuous experimentation in large software-intensive product and service organisations	Software development in highly dynamic environments imposes high risks to development organizations. One such risk is that the developed software may be of only little or no value to customers, wasting the invested development efforts. Continuous experimentation, as an experiment-driven development approach, may reduce such development risks by iteratively testing product and service assumptions that are critical to the success of the software. Although several experiment-driven development approaches are available, there is little guidance available on how to introduce continuous experimentation into an organization. This article presents a multiple-case study that aims at better understanding the process of introducing continuous experimentation into an organization with an already established development process. The results from the study show that companies are open to adopting such an approach and learning throughout the introduction process. Several benefits were obtained, such as reduced development efforts, deeper customer insights, and better support for development decisions. Challenges included complex stakeholder structures, difficulties in defining success criteria, and building experimentation skills. Our findings indicate that organizational factors may limit the benefits of experimentation. Moreover, introducing continuous experimentation requires fundamental changes in how companies operate, and a systematic introduction process can increase the chances of a successful start.	Continuous experimentation, Experiment-driven software development, Product management, Agile software development, Lean software development, Lean startup	Yaman, Sezin Gizem; Munezero, Myriam; Münch, Jürgen; Fagerholm, Fabian; Syd, Ossi; Aaltola, Mika; Palmu, Christina; Männistö, Tomi	Journal of Systems and Software	Software development in highly dynamic environments imposes high risks to development organizations. One such risk is that the developed software may be of only little or no value to customers, wasting the invested development efforts. Continuous experimentation, as an experiment-driven development approach, may reduce such development risks by iteratively testing product and service assumptions that are critical to the success of the software. Although several experiment-driven development approaches are available, there is little guidance available on how to introduce continuous experimentation into an organization. This article presents a multiple-case study that aims at better understanding the process of introducing continuous experimentation into an organization with an already established development process. The results from the study show that companies are open to adopting such an approach and learning throughout the introduction process. Several benefits were obtained, such as reduced development efforts, deeper customer insights, and better support for development decisions. Challenges included complex stakeholder structures, difficulties in defining success criteria, and building experimentation skills. Our findings indicate that organizational factors may limit the benefits of experimentation. Moreover, introducing continuous experimentation requires fundamental changes in how companies operate, and a systematic introduction process can increase the chances of a successful start.				Excluded	Excluded	new_screen			2						
194	Behave	Investigating Agile Practices in Software Startups	Software development practices have smoothly shifted from traditional software development to new approaches that fit better to the real and unpredictable world. Agile practices might help practitioners respond quickly to customer change requests and deliver a working software on-schedule. Software startups are companies that develop innovative and software-intensive products and services in a dynamic and fast-growing market. This study aims to investigate the use of agile practices in software startups. We conducted 14 in-depth semi-structured interviews with the CEO and CTO from early-stage software startups. The results indicate that DevOps, Fundamentals, Design and Extreme Programming are the most used agile practice areas. Our results open up an opportunity to improve software engineering practices in early-stage software startups.	Software engineering; Agile practices; Interview; Software startups	Souza, Renata; Rocha, Larissa; Silva, Franklin; Machado, Ivan	Proceedings of the XXXIII Brazilian Symposium on Software Engineering	Software development practices have smoothly shifted from traditional software development to new approaches that fit better to the real and unpredictable world. Agile practices might help practitioners respond quickly to customer change requests and deliver a working software on-schedule. Software startups are companies that develop innovative and software-intensive products and services in a dynamic and fast-growing market. This study aims to investigate the use of agile practices in software startups. We conducted 14 in-depth semi-structured interviews with the CEO and CTO from early-stage software startups. The results indicate that DevOps, Fundamentals, Design and Extreme Programming are the most used agile practice areas. Our results open up an opportunity to improve software engineering practices in early-stage software startups.				Excluded	Excluded	new_screen			2						
195	Behave	Behavior-Driven Development: A Case Study on Its Impacts on Agile Development Teams	Software development practices which enhance software quality and help teams better develop collaboratively have received attention by the academic community. Among these techniques is Behavior-Driven Development (BDD), a development method which proposes software to be developed focusing primarily on its expected behavior. In this context, this paper investigates how BDD impacts agile software development teams. In order to achieve this, we have conducted a case study on a mobile application development environment which develops software using agile. In total, 42 interviews were performed. Our results indicate that BDD can have positive impacts, increasing collaboration among team members, and negative impacts, like difficulties in writing unit tests. We concluded that BDD has more positive than negative outcomes.	Behavior-Driven Development; Agile Development; Challenge Based Learning; Software Engineering	Nascimento, Nicolas; Santos, Alan R.; Sales, Afonso; Chanin, Rafael	Proceedings of the IEEE/ACM 42nd International Conference on Software Engineering Workshops	Software development practices which enhance software quality and help teams better develop collaboratively have received attention by the academic community. Among these techniques is Behavior-Driven Development (BDD), a development method which proposes software to be developed focusing primarily on its expected behavior. In this context, this paper investigates how BDD impacts agile software development teams. In order to achieve this, we have conducted a case study on a mobile application development environment which develops software using agile. In total, 42 interviews were performed. Our results indicate that BDD can have positive impacts, increasing collaboration among team members, and negative impacts, like difficulties in writing unit tests. We concluded that BDD has more positive than negative outcomes.				Included	Included	new_screen			2						
196	Behave	Using grounded theory to understand software process improvement: A study of Irish software product companies	Software process improvement (SPI) aims to understand the software process as it is used within an organisation and thus drive the implementation of changes to that process to achieve specific goals such as increasing development speed, achieving higher product quality or reducing costs. Accordingly, SPI researchers must be equipped with the methodologies and tools to enable them to look within organisations and understand the state of practice with respect to software process and process improvement initiatives, in addition to investigating the relevant literature. Having examined a number of potentially suitable research methodologies, we have chosen Grounded Theory as a suitable approach to determine what was happening in actual practice in relation to software process and SPI, using the indigenous Irish software product industry as a test-bed. The outcome of this study is a theory, grounded in the field data, that explains when and why SPI is undertaken by the software industry. The objective of this paper is to describe both the selection and usage of grounded theory in this study and evaluate its effectiveness as a research methodology for software process researchers. Accordingly, this paper will focus on the selection and usage of grounded theory, rather than results of the SPI study itself.	Software engineering, Software process improvement, Qualitative research methods, Grounded theory	Coleman, Gerry; O’Connor, Rory	Information and Software Technology	Software process improvement (SPI) aims to understand the software process as it is used within an organisation and thus drive the implementation of changes to that process to achieve specific goals such as increasing development speed, achieving higher product quality or reducing costs. Accordingly, SPI researchers must be equipped with the methodologies and tools to enable them to look within organisations and understand the state of practice with respect to software process and process improvement initiatives, in addition to investigating the relevant literature. Having examined a number of potentially suitable research methodologies, we have chosen Grounded Theory as a suitable approach to determine what was happening in actual practice in relation to software process and SPI, using the indigenous Irish software product industry as a test-bed. The outcome of this study is a theory, grounded in the field data, that explains when and why SPI is undertaken by the software industry. The objective of this paper is to describe both the selection and usage of grounded theory in this study and evaluate its effectiveness as a research methodology for software process researchers. Accordingly, this paper will focus on the selection and usage of grounded theory, rather than results of the SPI study itself.				Excluded	Excluded	new_screen			2						
197	Behave	Using Spring Roo for the Test-Driven Development of Web Applications	Software should be developed in a way that achieves high external and internal quality. Most programs have to be maintained or are extended. They should not only adhere to their requirements but allow to be efficiently changed. Model-driven software development (MDSD) and test-driven development (TDD) are techniques that help to satisfy this demand. We present a novel approach combining MDSD and TDD while using the Spring Roo Web development framework. Besides discussing existing work and the background, we sketch a test-driven Web development process. We then evaluate its feasibility in an exemplary scenario. Thereby, we contribute to the body of scientific knowledge on Web development frameworks in the field of MDSD and TDD.	test-driven development; TDD; spring; spring roo; web application; web development	Majchrzak, Tim A.; Simon, Andreas	Proceedings of the 27th Annual ACM Symposium on Applied Computing	Software should be developed in a way that achieves high external and internal quality. Most programs have to be maintained or are extended. They should not only adhere to their requirements but allow to be efficiently changed. Model-driven software development (MDSD) and test-driven development (TDD) are techniques that help to satisfy this demand. We present a novel approach combining MDSD and TDD while using the Spring Roo Web development framework. Besides discussing existing work and the background, we sketch a test-driven Web development process. We then evaluate its feasibility in an exemplary scenario. Thereby, we contribute to the body of scientific knowledge on Web development frameworks in the field of MDSD and TDD.				Excluded	Excluded	new_screen			2						
198	Behave	A Survey of Software Testing Practices in Canada	Software testing is an important activity in the software development life-cycle. In an earlier study in 2009, we reported the results of a regional survey of software testing practices among practitioners in the Canadian province of Alberta. To get a larger nationwide view on this topic (across Canada), we conducted a newer survey with a revised list of questions in 2010. Compared to our previous Alberta-wide survey (53 software practitioners), the nation-wide survey had larger number of participants (246 practitioners). We report the survey design, execution and results in this article. The survey results reveal important and interesting findings about software testing practices in Canada. Whenever possible, we also compare the results of this survey to other similar studies, such as the ones conducted in the US, Sweden and Australia, and also two previous Alberta-wide surveys, including our 2009 survey. The results of our survey will be of interest to testing professionals both in Canada and world-wide. It will also benefit researchers in observing the latest trends in software testing industry identifying the areas of strength and weakness, which would then hopefully encourage further industry-academia collaborations in this area. Among the findings are the followings: (1) the importance of testing-related training is increasing, (2) functional and unit testing are two common test types that receive the most attention and efforts spent on them, (3) usage of the mutation testing approach is getting attention among Canadian firms, (4) traditional Test-last Development (TLD) style is still dominating and a few companies are attempting the new development approaches such as Test-Driven Development (TDD), and Behavior-Driven Development (BDD), (5) in terms of the most popular test tools, NUnit and Web application testing tools overtook JUnit and IBM Rational tools, (6) most Canadian companies use a combination of two coverage metrics: decision (branch) and condition coverage, (7) number of passing user acceptance tests and number of defects found per day (week or month) are regarded as the most important quality assurance metrics and decision factors to release, (8) in most Canadian companies, testers are out-numbered by developers, with ratios ranging from 1:2 to 1:5, (9) the majority of Canadian firms spent less than 40% of their efforts (budget and time) on testing during development, and (10) more than 70% of respondents participated in online discussion forums related to testing on a regular basis.	Software testing; Survey; Canada; Industry practices	Garousi, Vahid; Zhi, Junji	J. Syst. Softw.	Software testing is an important activity in the software development life-cycle. In an earlier study in 2009, we reported the results of a regional survey of software testing practices among practitioners in the Canadian province of Alberta. To get a larger nationwide view on this topic (across Canada), we conducted a newer survey with a revised list of questions in 2010. Compared to our previous Alberta-wide survey (53 software practitioners), the nation-wide survey had larger number of participants (246 practitioners). We report the survey design, execution and results in this article. The survey results reveal important and interesting findings about software testing practices in Canada. Whenever possible, we also compare the results of this survey to other similar studies, such as the ones conducted in the US, Sweden and Australia, and also two previous Alberta-wide surveys, including our 2009 survey. The results of our survey will be of interest to testing professionals both in Canada and world-wide. It will also benefit researchers in observing the latest trends in software testing industry identifying the areas of strength and weakness, which would then hopefully encourage further industry-academia collaborations in this area. Among the findings are the followings: (1) the importance of testing-related training is increasing, (2) functional and unit testing are two common test types that receive the most attention and efforts spent on them, (3) usage of the mutation testing approach is getting attention among Canadian firms, (4) traditional Test-last Development (TLD) style is still dominating and a few companies are attempting the new development approaches such as Test-Driven Development (TDD), and Behavior-Driven Development (BDD), (5) in terms of the most popular test tools, NUnit and Web application testing tools overtook JUnit and IBM Rational tools, (6) most Canadian companies use a combination of two coverage metrics: decision (branch) and condition coverage, (7) number of passing user acceptance tests and number of defects found per day (week or month) are regarded as the most important quality assurance metrics and decision factors to release, (8) in most Canadian companies, testers are out-numbered by developers, with ratios ranging from 1:2 to 1:5, (9) the majority of Canadian firms spent less than 40% of their efforts (budget and time) on testing during development, and (10) more than 70% of respondents participated in online discussion forums related to testing on a regular basis.				Excluded	Excluded	new_screen			2						
199	Behave	Software Testing: High-Impact Strategies - What You Need to Know Definitions, Adoptions, Impact, Benefits, Maturity, Vendors	Software testing is an investigation conducted to provide stakeholders with information about the quality of the product or service under test. Software testing also provides an objective, independent view of the software to allow the business to appreciate and understand the risks of software implementation. Test techniques include, but are not limited to, the process of executing a program or application with the intent of finding software bugs (errors or other defects). This book is your ultimate resource for Software Testing. Here you will find the most up-to-date information, analysis, background and everything you need to know. In easy to read chapters, with extensive references and links to get you to know all there is to know about Software Testing right away, covering: Software testing, Acceptance testing, Ad hoc testing, Agile testing, All-pairs testing, American Software Testing Qualifications Board, Api Sanity Autotest, Association for Software Testing, Attack patterns, Augmented Reality-based testing, Australian and New Zealand Testing Board, Automated Testing Framework, Avalanche (dynamic analysis tool), Bebugging, Behavior Driven Development, Black-box testing, Block design, Boundary case, Boundary testing, Boundary-value analysis, Browser speed test, Bs 7925-1, Bs 7925-2, Bug bash, Build verification test, Ca/Eztest, Cause-effect graph, Centercode, Characterization test, Cloud testing, Code coverage, Code integrity, Codenomicon, Compatibility testing, Component-Based Usability Testing, Conference Room Pilot, Conformance testing, Core Security, Corner case, Daikon (system), Data-driven testing, Decision table, Decision-to-decision path, Design predicates, Development, testing, acceptance and production, DeviceAnywhere, Dry run (testing), Dynamic program analysis, Dynamic testing, Edge case, Endeavour Software Project Management,		Roebuck, Kevin		Software testing is an investigation conducted to provide stakeholders with information about the quality of the product or service under test. Software testing also provides an objective, independent view of the software to allow the business to appreciate and understand the risks of software implementation. Test techniques include, but are not limited to, the process of executing a program or application with the intent of finding software bugs (errors or other defects). This book is your ultimate resource for Software Testing. Here you will find the most up-to-date information, analysis, background and everything you need to know. In easy to read chapters, with extensive references and links to get you to know all there is to know about Software Testing right away, covering: Software testing, Acceptance testing, Ad hoc testing, Agile testing, All-pairs testing, American Software Testing Qualifications Board, Api Sanity Autotest, Association for Software Testing, Attack patterns, Augmented Reality-based testing, Australian and New Zealand Testing Board, Automated Testing Framework, Avalanche (dynamic analysis tool), Bebugging, Behavior Driven Development, Black-box testing, Block design, Boundary case, Boundary testing, Boundary-value analysis, Browser speed test, Bs 7925-1, Bs 7925-2, Bug bash, Build verification test, Ca/Eztest, Cause-effect graph, Centercode, Characterization test, Cloud testing, Code coverage, Code integrity, Codenomicon, Compatibility testing, Component-Based Usability Testing, Conference Room Pilot, Conformance testing, Core Security, Corner case, Daikon (system), Data-driven testing, Decision table, Decision-to-decision path, Design predicates, Development, testing, acceptance and production, DeviceAnywhere, Dry run (testing), Dynamic program analysis, Dynamic testing, Edge case, Endeavour Software Project Management,				Excluded	Excluded	new_screen			2						
200	Behave	The implementation of ATDD and BDD from Testing Perspectives	Software testing is one of the stages in software development that aims to ensure that the software is built to meet the specifications. Selection of selective test cases has a great chance of finding failure. Black box testing approach is done based on the requirement specification where this approach does not pay attention to the program code but the specification of a software. This approach can be used for testing a software using ATDD (Acceptance Test Driven Development) and BDD (Behavior Driven Development) methods. ATDD is a method of building a software created based on agile principle, acceptance test created by customer, developer and tester. BDD is a growing agile development approach in recent years. Behavior Driven Development (BDD) is built on Test-Driven Development (TDD). This Final Project focuses on the application of ATDD and BDD methods to testing the final three projects of IT Del students tested using the Roboy Framework and Cucumber Framework to find out whether these two methods are effective and be able to improve the software development process. The results obtained are that the application of ATDD and BDD methods are effective and helping to remove the error as soon as possible. © Published under licence by IOP Publishing Ltd.		Christy Barus A.	Journal of Physics: Conference Series	Software testing is one of the stages in software development that aims to ensure that the software is built to meet the specifications. Selection of selective test cases has a great chance of finding failure. Black box testing approach is done based on the requirement specification where this approach does not pay attention to the program code but the specification of a software. This approach can be used for testing a software using ATDD (Acceptance Test Driven Development) and BDD (Behavior Driven Development) methods. ATDD is a method of building a software created based on agile principle, acceptance test created by customer, developer and tester. BDD is a growing agile development approach in recent years. Behavior Driven Development (BDD) is built on Test-Driven Development (TDD). This Final Project focuses on the application of ATDD and BDD methods to testing the final three projects of IT Del students tested using the Roboy Framework and Cucumber Framework to find out whether these two methods are effective and be able to improve the software development process. The results obtained are that the application of ATDD and BDD methods are effective and helping to remove the error as soon as possible. © Published under licence by IOP Publishing Ltd.				Included	Included	new_screen			2						
201	Behave	Impacts of behavioral driven development in the improvement of quality software deliverables	Sometimes, the software deliverables do not exactly match with the requirements. This mismatch requirement can be captured during the testing. Even then if it is missing it is because of non-coverage of the testing and test cases. This could be resolved by creating the unit test cases / Integration test cases from the requirements. This paper focuses on BDD requirements which generates the test cases as well as report executed. With aid of automation testing, the test cases of BDD can be explained. This paper deals with such test cases, the next version binaries to get the proper deliverables.	BDD - Behavior Driven Development;TDD – Test Driven Development;QA – Quality Assurance;BD – Behavior Driven	A. Sheshasaayee; P. Banumathi	2018 3rd International Conference on Inventive Computation Technologies (ICICT)	Sometimes, the software deliverables do not exactly match with the requirements. This mismatch requirement can be captured during the testing. Even then if it is missing it is because of non-coverage of the testing and test cases. This could be resolved by creating the unit test cases / Integration test cases from the requirements. This paper focuses on BDD requirements which generates the test cases as well as report executed. With aid of automation testing, the test cases of BDD can be explained. This paper deals with such test cases, the next version binaries to get the proper deliverables.				Excluded	Excluded	new_screen			2						
202	Behave	A Natural Language Driven Approach for Automated Web API Development: Gherkin2OAS	"Speeding up the development process of Web Services, while adhering to high quality software standards is a typical requirement in the software industry. This is why industry specialists usually suggest ""driven by"" development approaches to tackle this problem. In this paper, we propose such a methodology that employs Specification Driven Development and Behavior Driven Development in order to facilitate the phases of Web Service requirements elicitation and specification. Furthermore, we introduce gherkin2OAS, a software tool that aspires to bridge the aforementioned development approaches. Through the suggested methodology and tool, one may design and build RESTful services fast, while ensuring proper functionality."	behavior driven development; gherkin; open API specification; restful API	Dimanidis, Anastasios; Chatzidimitriou, Kyriakos C.; Symeonidis, Andreas L.	Companion Proceedings of the The Web Conference 2018	"Speeding up the development process of Web Services, while adhering to high quality software standards is a typical requirement in the software industry. This is why industry specialists usually suggest ""driven by"" development approaches to tackle this problem. In this paper, we propose such a methodology that employs Specification Driven Development and Behavior Driven Development in order to facilitate the phases of Web Service requirements elicitation and specification. Furthermore, we introduce gherkin2OAS, a software tool that aspires to bridge the aforementioned development approaches. Through the suggested methodology and tool, one may design and build RESTful services fast, while ensuring proper functionality."				Included	Included	new_screen			2						
203	Behave	Sismic—A Python library for statechart execution and testing	Statecharts are a well-known visual modelling language for representing the executable behaviour of complex reactive event-based systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques, such as test-driven development, behaviour-driven development, design by contract, and property statecharts for monitoring of violations of behavioural properties during statechart execution. Sismic is an open-source Python library providing a tool suite to define, simulate, execute and test statecharts with all of the aforementioned techniques.	Statechart, Executable modelling, Behaviour-driven development, Design by contract, Runtime verification	Decan, Alexandre; Mens, Tom	SoftwareX	Statecharts are a well-known visual modelling language for representing the executable behaviour of complex reactive event-based systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques, such as test-driven development, behaviour-driven development, design by contract, and property statecharts for monitoring of violations of behavioural properties during statechart execution. Sismic is an open-source Python library providing a tool suite to define, simulate, execute and test statecharts with all of the aforementioned techniques.				Excluded	Excluded	new_screen			2						
204	Behave	A Method for Testing and Validating Executable Statechart Models	Statecharts constitute an executable language for modelling event-based reactive systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques. In this article, we propose a method aimed at enhancing statechart design with a range of techniques that have proven their usefulness to increase the quality and reliability of source code. The method is accompanied by a process that flexibly accommodates testing and validation techniques such as test-driven development, behaviour-driven development, design by contract, and property statecharts that check for violations of behavioural properties during statechart execution. The method is supported by the Sismic tool, an open-source statechart interpreter library in Python, which supports all the aforementioned techniques. Based on this tooling, we carry out a controlled user study to evaluate the feasibility, usefulness and adequacy of the proposed techniques for statechart testing and validation.	Behaviour-driven development; Design by contract; Runtime verification; Statechart; Executable modeling	Mens, Tom; Decan, Alexandre; Spanoudakis, Nikolaos I.	Softw. Syst. Model.	Statecharts constitute an executable language for modelling event-based reactive systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques. In this article, we propose a method aimed at enhancing statechart design with a range of techniques that have proven their usefulness to increase the quality and reliability of source code. The method is accompanied by a process that flexibly accommodates testing and validation techniques such as test-driven development, behaviour-driven development, design by contract, and property statecharts that check for violations of behavioural properties during statechart execution. The method is supported by the Sismic tool, an open-source statechart interpreter library in Python, which supports all the aforementioned techniques. Based on this tooling, we carry out a controlled user study to evaluate the feasibility, usefulness and adequacy of the proposed techniques for statechart testing and validation.				Excluded	Excluded	new_screen			2						
205	Behave	A method for testing and validating executable statechart models	Statecharts constitute an executable language for modelling event-based reactive systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques. In this article, we propose a method aimed at enhancing statechart design with a range of techniques that have proven their usefulness to increase the quality and reliability of source code. The method is accompanied by a process that flexibly accommodates testing and validation techniques such as test-driven development, behaviour-driven development, design by contract, and property statecharts that check for violations of behavioural properties during statechart execution. The method is supported by the Sismic tool, an open-source statechart interpreter library in Python, which supports all the aforementioned techniques. Based on this tooling, we carry out a controlled user study to evaluate the feasibility, usefulness and adequacy of the proposed techniques for statechart testing and validation. © 2018, Springer-Verlag GmbH Germany, part of Springer Nature.		Mens T., Decan A., Spanoudakis N.I.	Software and Systems Modeling	Statecharts constitute an executable language for modelling event-based reactive systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques. In this article, we propose a method aimed at enhancing statechart design with a range of techniques that have proven their usefulness to increase the quality and reliability of source code. The method is accompanied by a process that flexibly accommodates testing and validation techniques such as test-driven development, behaviour-driven development, design by contract, and property statecharts that check for violations of behavioural properties during statechart execution. The method is supported by the Sismic tool, an open-source statechart interpreter library in Python, which supports all the aforementioned techniques. Based on this tooling, we carry out a controlled user study to evaluate the feasibility, usefulness and adequacy of the proposed techniques for statechart testing and validation. © 2018, Springer-Verlag GmbH Germany, part of Springer Nature.				Included	Included	new_screen			2						
206	Behave	Rails 3 in Action	Summary Rails 3 in Action is a collaboration between Rails community leaders, Ryan Bigg and Yehuda Katz, that covers Rails 3.1 making it the most up-to-date resource available. But it's much more than just a Rails 3 reference book. You'll learn to do Rails the right way, so you can build stable, scalable, and maintainable apps that will satisfy even the most demanding clients. About the BookRails 3 is a full stack, open source web framework powered by Ruby and this book is an introduction to it. Whether you're just starting or you have a few cycles under your belt, you'll appreciate the book's guru's-eye-view of idiomatic Rails programming.You'll master Rails 3.1 by developing a ticket tracking application that includes RESTful routing, authentication and authorization, state maintenance, file uploads, email, and more. You'll also explore powerful features like designing your own APIs and building a Rails engine. You will see Test Driven Development and Behavior Driven Development in action throughout the book, just like you would in a top Rails shop.It is helpful for readers to have a background in Ruby, but no prior Rails experience is needed. What's InsideCovers Rails 3.1 from the ground up Testing and BDD using RSpec and Cucumber Working with Rack=============================================== Table of ContentsRuby on Rails, the framework Testing saves your bacon Developing a real Rails application Oh CRUD! Nested resources Authentication and basic authorization Basic access control More authorization File uploading Tracking state Tagging Sending email Designing an API Deployment Alternative authentication Basic performance enhancements Engines Rack-based applications		Bigg, Ryan; Katz, Yehuda		Summary Rails 3 in Action is a collaboration between Rails community leaders, Ryan Bigg and Yehuda Katz, that covers Rails 3.1 making it the most up-to-date resource available. But it's much more than just a Rails 3 reference book. You'll learn to do Rails the right way, so you can build stable, scalable, and maintainable apps that will satisfy even the most demanding clients. About the BookRails 3 is a full stack, open source web framework powered by Ruby and this book is an introduction to it. Whether you're just starting or you have a few cycles under your belt, you'll appreciate the book's guru's-eye-view of idiomatic Rails programming.You'll master Rails 3.1 by developing a ticket tracking application that includes RESTful routing, authentication and authorization, state maintenance, file uploads, email, and more. You'll also explore powerful features like designing your own APIs and building a Rails engine. You will see Test Driven Development and Behavior Driven Development in action throughout the book, just like you would in a top Rails shop.It is helpful for readers to have a background in Ruby, but no prior Rails experience is needed. What's InsideCovers Rails 3.1 from the ground up Testing and BDD using RSpec and Cucumber Working with Rack=============================================== Table of ContentsRuby on Rails, the framework Testing saves your bacon Developing a real Rails application Oh CRUD! Nested resources Authentication and basic authorization Basic access control More authorization File uploading Tracking state Tagging Sending email Designing an API Deployment Alternative authentication Basic performance enhancements Engines Rack-based applications				Excluded	Excluded	new_screen			2						
207	Behave	BeSoS: A Tool for Behavior-driven and Scenario-based Requirements Modeling for Systems of Systems	Systems of Systems (SoS), like connected vehicle systems, provide their functionality by the interaction of several constituent systems (CSs). [Problem] Due to the managerial, operational and evolutionary independence of the CSs in an SoS, requirements constantly change over time and linear, top-down requirements engineering methods cannot be applied without significant adaptations. New tools are needed that support the continuous and iterative specification and alignment of requirements across different levels of abstraction. [Principal Ideas] We propose to integrate the behavior-driven development (BDD) approach with an intuitive and executable scenario-based modeling of functional requirements. In this way, stakeholder expectations can be structured via features and documented in natural language as usage scenarios. Based on usage scenarios, the modeling of functional requirements can be driven by tests, allowing for the automated testing and analysis of requirements. This in turn supports the iterative specification of requirements and the alignment of stakeholder needs. [Contribution] In this paper we showcase the tool BeSoS that supports the iterative and behavior-driven specification of requirements in an SoS context. We propose a method and describe its tool components using an example. The tool is available here: https://vimeo.com/512739942. © 2021 CEUR-WS. All rights reserved.		Wiecher C., Greenyer J.	CEUR Workshop Proceedings	Systems of Systems (SoS), like connected vehicle systems, provide their functionality by the interaction of several constituent systems (CSs). [Problem] Due to the managerial, operational and evolutionary independence of the CSs in an SoS, requirements constantly change over time and linear, top-down requirements engineering methods cannot be applied without significant adaptations. New tools are needed that support the continuous and iterative specification and alignment of requirements across different levels of abstraction. [Principal Ideas] We propose to integrate the behavior-driven development (BDD) approach with an intuitive and executable scenario-based modeling of functional requirements. In this way, stakeholder expectations can be structured via features and documented in natural language as usage scenarios. Based on usage scenarios, the modeling of functional requirements can be driven by tests, allowing for the automated testing and analysis of requirements. This in turn supports the iterative specification of requirements and the alignment of stakeholder needs. [Contribution] In this paper we showcase the tool BeSoS that supports the iterative and behavior-driven specification of requirements in an SoS context. We propose a method and describe its tool components using an example. The tool is available here: https://vimeo.com/512739942. © 2021 CEUR-WS. All rights reserved.				Included	Included	new_screen			2						
208	Behave	Behavior-Driven Development: An Expert Panel to Evaluate Benefits and Challenges	"Teaching modern software techniques is a challenging task as these practices tend to be collaborative and require a lot of preparation and environment setup. Among these techniques is Behavior-Driven Development (BDD), a development method which proposes software to be develop focusing primarily on its expected behavior. In this context, this paper investigates the perception of active-learning experts regarding the potential benefits and challenges of teaching BDD in active learning environments to software engineering students. To achieve this goal, we have conducted an expert panel with 28 active-learning experts from four countries. Our preliminary results indicate that experts perceive both benefits, like improvement in specification, and challenges to embrace the BDD ""culture"" when teaching BDD to software engineering students. Based in these findings, we found indicatives that BDD should benefit software engineering students in active learning environments, however it may require more setup, teacher preparation and engagement during the learning process."	Behavior-Driven Development; Agile Development; Challenge Based Learning; Software Engineering	Nascimento, Nicolas; Santos, Alan R.; Sales, Afonso; Chanin, Rafael	Proceedings of the 34th Brazilian Symposium on Software Engineering	"Teaching modern software techniques is a challenging task as these practices tend to be collaborative and require a lot of preparation and environment setup. Among these techniques is Behavior-Driven Development (BDD), a development method which proposes software to be develop focusing primarily on its expected behavior. In this context, this paper investigates the perception of active-learning experts regarding the potential benefits and challenges of teaching BDD in active learning environments to software engineering students. To achieve this goal, we have conducted an expert panel with 28 active-learning experts from four countries. Our preliminary results indicate that experts perceive both benefits, like improvement in specification, and challenges to embrace the BDD ""culture"" when teaching BDD to software engineering students. Based in these findings, we found indicatives that BDD should benefit software engineering students in active learning environments, however it may require more setup, teacher preparation and engagement during the learning process."				Included	Included	new_screen			2						
209	Behave	Testing Meets Static and Runtime Verification	Test driven development (TDD) is a technique where test cases are used to guide the development of a system. This technique introduces several advantages at the time of developing a system, e.g. writing clean code, good coverage for the features of the system, and evolutionary development. In this paper we show how the capabilities of a testing focused development methodology based on TDD and model-based testing, can be enhanced by integrating static and runtime verification into its workflow. Considering that the desired system properties capture data- as well as control-oriented aspects, we integrate TDD with (static) deductive verification as an aid in the development of the data-oriented aspects, and we integrate model-based testing with runtime verification as an aid in the development of the control-oriented aspects. As a result of this integration, the proposed development methodology features the benefits of TDD and model-based testing, enhanced with, for instance, early detection of bugs which may be missed by TDD, regarding data aspects, and the validation of the overall system with respect to the model, regarding the control aspects.	runtime verification; Java; static verification; test driven development	Chimento, Jesús Mauricio; Ahrendt, Wolfgang; Schneider, Gerardo	Proceedings of the 6th Conference on Formal Methods in Software Engineering	Test driven development (TDD) is a technique where test cases are used to guide the development of a system. This technique introduces several advantages at the time of developing a system, e.g. writing clean code, good coverage for the features of the system, and evolutionary development. In this paper we show how the capabilities of a testing focused development methodology based on TDD and model-based testing, can be enhanced by integrating static and runtime verification into its workflow. Considering that the desired system properties capture data- as well as control-oriented aspects, we integrate TDD with (static) deductive verification as an aid in the development of the data-oriented aspects, and we integrate model-based testing with runtime verification as an aid in the development of the control-oriented aspects. As a result of this integration, the proposed development methodology features the benefits of TDD and model-based testing, enhanced with, for instance, early detection of bugs which may be missed by TDD, regarding data aspects, and the validation of the overall system with respect to the model, regarding the control aspects.				Excluded	Excluded	new_screen			2						
210	Behave	Jasmine JavaScript Testing Update	Test your JavaScript applications efficiently using Jasmine and React.js About This BookLeverage the power of unit testing React.js to develop full-fledged JavaScript applicationsLearn the best practices of modularization and code organization while scaling your applicationEnhance your practical skills required to develop applications using the Jasmine framework in a step-by-step mannerWho This Book Is ForThis book is for web developers and designers who work with React.js and JavaScript and who are new to unit testing and automation. It's assumed that you have a basic knowledge of JavaScript and HTML. In Detail Take your testing of JavaScript applications to a new level of efficiency and reliability with the help of this book. Starting with the fundamentals of Jasmine and behavior-driven development (BDD), you will learn about tooling and automation. You will learn how to create a sustainable code base with the help of Jasmine. You will also take a look at integrated testing with React.js and Karma, and how you can speed this process up by faking AJAX requests. As you progress through the book, you will learn about the challenges of testing an application built on top of a framework and how you can prevent your application from suffering from dependency management. You will understand the concept of client-side and server-side rendering and test applications using React.js. You will also learn to automate using webpack and work with JavaScript module systems using ECMA Script 6 (ES6) modules.By the end of this book, you will be a competent web developer with good knowledge and a strong understanding of how to efficiently use the Jasmine framework for testing purposes.		Ragonha, Paulo		Test your JavaScript applications efficiently using Jasmine and React.js About This BookLeverage the power of unit testing React.js to develop full-fledged JavaScript applicationsLearn the best practices of modularization and code organization while scaling your applicationEnhance your practical skills required to develop applications using the Jasmine framework in a step-by-step mannerWho This Book Is ForThis book is for web developers and designers who work with React.js and JavaScript and who are new to unit testing and automation. It's assumed that you have a basic knowledge of JavaScript and HTML. In Detail Take your testing of JavaScript applications to a new level of efficiency and reliability with the help of this book. Starting with the fundamentals of Jasmine and behavior-driven development (BDD), you will learn about tooling and automation. You will learn how to create a sustainable code base with the help of Jasmine. You will also take a look at integrated testing with React.js and Karma, and how you can speed this process up by faking AJAX requests. As you progress through the book, you will learn about the challenges of testing an application built on top of a framework and how you can prevent your application from suffering from dependency management. You will understand the concept of client-side and server-side rendering and test applications using React.js. You will also learn to automate using webpack and work with JavaScript module systems using ECMA Script 6 (ES6) modules.By the end of this book, you will be a competent web developer with good knowledge and a strong understanding of how to efficiently use the Jasmine framework for testing purposes.				Excluded	Excluded	new_screen			2						
211	Behave	TestBox: Behavior Driven Development	TestBox is a testing framework for ColdFusion (CFML) that is based on BDD (Behavior Driven Development) for providing a clean obvious syntax for writing tests. It also includes MockBox for mocking and stubbing.		Majano, Luis Fernando; Reyes, Jorge Emilio		TestBox is a testing framework for ColdFusion (CFML) that is based on BDD (Behavior Driven Development) for providing a clean obvious syntax for writing tests. It also includes MockBox for mocking and stubbing.				Excluded	Excluded	new_screen			2						
212	Behave	Assessing Agile Testing Practices for Enterprise Systems: A Survey Approach	"Testing enterprise systems is a challenging task. In this context, besides considering user requirements and business rules, there are several concerns that must also be considered when designing a test suite, including user interaction, integration with legacy systems, and access to relational or non-relational databases. In addition, test engineers often have to decide whether to test in the different levels (e.g., unit, integration, and system testing) or not, whether to use mock objects or not, and so on. Sadly, these decisions often conflict to each other. In this paper, we report an 18-month experience on using different approaches and tools to test two enterprise systems (SISBOL and SISDOT) from the Brazilian Army. SISBOL is an enterprise system based on the REST architectural style, using JEE (Java Enterprise Edition) in the business and integration tiers and AngularJS in the presentation tier. On the other hand, SISDOT is a ""pure"" Java enterprise system, using Java Server Faces on the presentation tier. We found that using executable specifications (as recommended in approaches based on Behavior Driven Development) is not only valid in test first scenarios as well as giving confidence on the system requirements validation, but they also help to identify new execution paths when the source code had been already implemented—suggesting that it is also promising to introduce a BDD approach in later stages of the development than testing pure JEE systems at the integration level."	Software Testing; Test Driven Development; Behavior Driven Development; Specification by Example	Fazzolino, Rafael; de Faria, Henrique Medrado; Amaral, Luis Henrique Vieira; Canedo, Edna Dias; Rodrigues, Genaína Nunes; Bonifácio, Rodrigo	Proceedings of the III Brazilian Symposium on Systematic and Automated Software Testing	"Testing enterprise systems is a challenging task. In this context, besides considering user requirements and business rules, there are several concerns that must also be considered when designing a test suite, including user interaction, integration with legacy systems, and access to relational or non-relational databases. In addition, test engineers often have to decide whether to test in the different levels (e.g., unit, integration, and system testing) or not, whether to use mock objects or not, and so on. Sadly, these decisions often conflict to each other. In this paper, we report an 18-month experience on using different approaches and tools to test two enterprise systems (SISBOL and SISDOT) from the Brazilian Army. SISBOL is an enterprise system based on the REST architectural style, using JEE (Java Enterprise Edition) in the business and integration tiers and AngularJS in the presentation tier. On the other hand, SISDOT is a ""pure"" Java enterprise system, using Java Server Faces on the presentation tier. We found that using executable specifications (as recommended in approaches based on Behavior Driven Development) is not only valid in test first scenarios as well as giving confidence on the system requirements validation, but they also help to identify new execution paths when the source code had been already implemented—suggesting that it is also promising to introduce a BDD approach in later stages of the development than testing pure JEE systems at the integration level."				Included	Included	new_screen			2						
213	Behave	Distributed agile: Component-based user acceptance testing	Testing is conducted at multiple levels during the development of software. User Acceptance Testing conforms that the software meets user's criteria. In this paper, User Acceptance Testing is automatically conducted based on acceptance criteria. The acceptance criteria are written in the form of Given-When-Then Template. These acceptance criteria are broken down into steps and numbered. The dependencies among the steps are determined as Given->When->Then. Henceforth, the steps are arranged in a dependency graph. This graph further leads to the creation of a decision table in which the outcome of one step leads to the outcomes of its dependent steps. The decision table forms the basis of generation of a binary weighted dependency tree. This tree becomes the means to form test coverage (number of combinations to test) which forms the basis of generation of acceptance test cases.		P. Pandit; S. Tahiliani; M. Sharma	2016 Symposium on Colossal Data Analysis and Networking (CDAN)	Testing is conducted at multiple levels during the development of software. User Acceptance Testing conforms that the software meets user's criteria. In this paper, User Acceptance Testing is automatically conducted based on acceptance criteria. The acceptance criteria are written in the form of Given-When-Then Template. These acceptance criteria are broken down into steps and numbered. The dependencies among the steps are determined as Given->When->Then. Henceforth, the steps are arranged in a dependency graph. This graph further leads to the creation of a decision table in which the outcome of one step leads to the outcomes of its dependent steps. The decision table forms the basis of generation of a binary weighted dependency tree. This tree becomes the means to form test coverage (number of combinations to test) which forms the basis of generation of acceptance test cases.				Included	Included	new_screen			2						
214	Behave	Modeling Test Cases in BPMN for Behavior-Driven Development	Testing large-scale process integration solutions is complex and cumbersome. To tackle this problem, researchers employed behavior-driven development. They used the Business Process Model and Notation language to model domain-specific test cases. These test cases can be understood by both developers and business stakeholders and can be executed automatically.		Lübke, Daniel; van Lessen, Tammo	IEEE Softw.	Testing large-scale process integration solutions is complex and cumbersome. To tackle this problem, researchers employed behavior-driven development. They used the Business Process Model and Notation language to model domain-specific test cases. These test cases can be understood by both developers and business stakeholders and can be executed automatically.				Included	Included	new_screen			2						
215	Behave	A study of value in agile software development organizations	The Agile manifesto focuses on the delivery of valuable software. In Lean, the principles emphasise value, where every activity that does not add value is seen as waste. Despite the strong focus on value, and that the primary critical success factor for software intensive product development lies in the value domain, no empirical study has investigated specifically what value is. This paper presents an empirical study that investigates how value is interpreted and prioritised, and how value is assured and measured. Data was collected through semi-structured interviews with 23 participants from 14 agile software development organisations. The contribution of this study is fourfold. First, it examines how value is perceived amongst agile software development organisations. Second, it compares the perceptions and priorities of the perceived values by domains and roles. Third, it includes an examination of what practices are used to achieve value in industry, and what hinders the achievement of value. Fourth, it characterises what measurements are used to assure, and evaluate value-creation activities.	Value, Agile software development, Empirical	Alahyari, Hiva; Berntsson Svensson, Richard; Gorschek, Tony	Journal of Systems and Software	The Agile manifesto focuses on the delivery of valuable software. In Lean, the principles emphasise value, where every activity that does not add value is seen as waste. Despite the strong focus on value, and that the primary critical success factor for software intensive product development lies in the value domain, no empirical study has investigated specifically what value is. This paper presents an empirical study that investigates how value is interpreted and prioritised, and how value is assured and measured. Data was collected through semi-structured interviews with 23 participants from 14 agile software development organisations. The contribution of this study is fourfold. First, it examines how value is perceived amongst agile software development organisations. Second, it compares the perceptions and priorities of the perceived values by domains and roles. Third, it includes an examination of what practices are used to achieve value in industry, and what hinders the achievement of value. Fourth, it characterises what measurements are used to assure, and evaluate value-creation activities.				Excluded	Excluded	new_screen			2						
216	Behave	User and System Stories: An Agile Approach for Managing Requirements in AOSE	The agile software development life cycle is widely used in industry today due to its highly flexible and iterative processes that facilitate rapid prototyping. There has been recent work in bringing concepts and processes from agile methodologies to agent-oriented software engineering (AOSE). We contribute to this effort by presenting in this paper a novel approach to capturing requirements of agent systems in AOSE using and extending agile concepts. In this paper, we propose to adopt and extend the well-known concept of User Stories to facilitate the development of agent systems. We introduce a novel concept, System Story, that defines requirements from the perspective of the system. These System Stories are refinements of User Stories and provide more intuitive mappings to agent concepts in the design and implementation. We show how our approach allows better traceability of requirements between stories and the different software development artifacts. We validate our proposal with a feature-based comparison to recent related work, and a preliminary user evaluation based on a drone simulation of a simple search and rescue case study.		Rodriguez, Sebastian; Thangarajah, John; Winikoff, Michael	Proceedings of the 20th International Conference on Autonomous Agents and MultiAgent Systems	The agile software development life cycle is widely used in industry today due to its highly flexible and iterative processes that facilitate rapid prototyping. There has been recent work in bringing concepts and processes from agile methodologies to agent-oriented software engineering (AOSE). We contribute to this effort by presenting in this paper a novel approach to capturing requirements of agent systems in AOSE using and extending agile concepts. In this paper, we propose to adopt and extend the well-known concept of User Stories to facilitate the development of agent systems. We introduce a novel concept, System Story, that defines requirements from the perspective of the system. These System Stories are refinements of User Stories and provide more intuitive mappings to agent concepts in the design and implementation. We show how our approach allows better traceability of requirements between stories and the different software development artifacts. We validate our proposal with a feature-based comparison to recent related work, and a preliminary user evaluation based on a drone simulation of a simple search and rescue case study.				Excluded	Excluded	new_screen			2						
217	Behave	The Art of Rails (Programmer to Programmer)	The Art of Rails(r) Any programmer knows that an API is only half the story, and with Ruby on Rails(r) this is especially true. Good Rails development, like good web development, is much more about the design choices you make than the framework you have at your disposal. Written by an experienced web application developer, this book picks up where the API leaves off and explains how to take good Rails code and turn it into beautiful Rails code: simple, effective, reusable, evolvable code. In a blend of design and programming, this book identifies and describes the very latest in design patterns, programming abstractions, and development methodologies that have emerged for the modern web. Ruby on Rails offers a completely new way of thinking about and using these emerging techniques, and learning to think like a Rails developer will enable you to rapidly design and write high-quality code with elegance and maintainability. With each design technique, you will discover how Rails incorporates it into its domain-specific language, and you will learn how to weave it seamlessly into your own Rails applications. Then you will learn how to take the next step and transform yourself from user into creator, making your own additions to Rails and crafting a development environment tailored to your specific needs. What you will learn from this book * Techniques for organizing your code between and within Model, View, and Controller to eliminate code repetition and maximize your effectiveness * How to think like a REST-based developer and use Rails 2.0 to translate these thoughts into your code * Advanced Ruby and meta-programming: how to use features such as block-based development, monkey patching, and dynamic APIs to build your own additions to the Rails framework * Design patterns for AJAX, web APIs, HTML decomposition, schema development, meta-programming, and more * Behavior-driven development: A new style of testing and development centered arou nd stories and behaviors instead of method calls and assertions * Ways to make your development both productive and fun in the software you write Who this book is for This book is for developers familiar with Ruby on Rails who are looking to advance their skills by learning the design and coding techniques that enable a mastery of web application development with Rails. Wrox guides are crafted to make learning programming languages and technologies easier than you think. Written by programmers for programmers, they provide a structured, tutorial format that will guide you through all the techniques involved.		Benson, Edward		The Art of Rails(r) Any programmer knows that an API is only half the story, and with Ruby on Rails(r) this is especially true. Good Rails development, like good web development, is much more about the design choices you make than the framework you have at your disposal. Written by an experienced web application developer, this book picks up where the API leaves off and explains how to take good Rails code and turn it into beautiful Rails code: simple, effective, reusable, evolvable code. In a blend of design and programming, this book identifies and describes the very latest in design patterns, programming abstractions, and development methodologies that have emerged for the modern web. Ruby on Rails offers a completely new way of thinking about and using these emerging techniques, and learning to think like a Rails developer will enable you to rapidly design and write high-quality code with elegance and maintainability. With each design technique, you will discover how Rails incorporates it into its domain-specific language, and you will learn how to weave it seamlessly into your own Rails applications. Then you will learn how to take the next step and transform yourself from user into creator, making your own additions to Rails and crafting a development environment tailored to your specific needs. What you will learn from this book * Techniques for organizing your code between and within Model, View, and Controller to eliminate code repetition and maximize your effectiveness * How to think like a REST-based developer and use Rails 2.0 to translate these thoughts into your code * Advanced Ruby and meta-programming: how to use features such as block-based development, monkey patching, and dynamic APIs to build your own additions to the Rails framework * Design patterns for AJAX, web APIs, HTML decomposition, schema development, meta-programming, and more * Behavior-driven development: A new style of testing and development centered arou nd stories and behaviors instead of method calls and assertions * Ways to make your development both productive and fun in the software you write Who this book is for This book is for developers familiar with Ruby on Rails who are looking to advance their skills by learning the design and coding techniques that enable a mastery of web application development with Rails. Wrox guides are crafted to make learning programming languages and technologies easier than you think. Written by programmers for programmers, they provide a structured, tutorial format that will guide you through all the techniques involved.				Excluded	Excluded	new_screen			2						
218	Behave	The blockchain: State-of-the-art and research challenges	The blockchain revolutionizes the creation of both scalable information technology systems and diversified applications by integrating the increasingly popular artificial intelligence, cloud computing, and big data. Various industries have recently begun to implement the exploration of blockchain. It will not take long for the blockchain to spread all over the world. In order to identify and further the development of the blockchain technology, this paper reviews the extant studies on the blockchain and its key components, blockchain-based IoT, blockchain-based security, blockchain-based data management, and the main applications based on the blockchain, and it delineates potential trends and challenges. This study provides a comprehensive overview of state-of-the-art blockchain and describes a forward-looking direction.	Blockchain, Decentralization, Smart contract, Security, Privacy	Lu, Yang	Journal of Industrial Information Integration	The blockchain revolutionizes the creation of both scalable information technology systems and diversified applications by integrating the increasingly popular artificial intelligence, cloud computing, and big data. Various industries have recently begun to implement the exploration of blockchain. It will not take long for the blockchain to spread all over the world. In order to identify and further the development of the blockchain technology, this paper reviews the extant studies on the blockchain and its key components, blockchain-based IoT, blockchain-based security, blockchain-based data management, and the main applications based on the blockchain, and it delineates potential trends and challenges. This study provides a comprehensive overview of state-of-the-art blockchain and describes a forward-looking direction.				Excluded	Excluded	new_screen			2						
219	Behave	A User‐Centered Behavioral Software Development Model	The concept of usability, which affects the quality and cost of the software projects, has become essential in recent years. There is a need to integrate usability testing activities and techniques into the development processes; however, integration is difficult. Therefore, this study proposes user‐centered behavioral (UCB) software development model, which aims to bridge the gap between human–computer interaction (HCI) and software engineering (SE) disciplines. A triangulation methodology of mixed methods is used to understand the current situation in software development companies in terms of usability and user‐centered software development by survey and interviews. Their results are then used to inform the development of the proposed model. The UCB software development model proposes a process in which several tools and techniques from SE and HCI are integrated to facilitate the production of highly usable software. In essence, the model proposes an iterative process that combines behavior‐driven development (BDD)—an agile approach that enables a better understanding and analysis of the requirements—with the style guides, usability tests, heuristic evaluation, and Wizard of Oz techniques of HCI. The model was evaluated in a pilot project and then is improved based on feedback gathered. Participants' feedback supported the effectiveness of the proposed model.The UCB software development model proposes a process in which several tools and techniques from SE and HCI are integrated to create a model that will facilitate the production of highly usable software. In essence, the model proposes an iterative process that combines behavior‐driven development (BDD)—an agile approach that enables a better understanding and analysis of the requirements—with the style guides, usability tests, heuristic evaluation, and Wizard of Oz techniques of HCI. image	software engineering; agile methodology; behavior‐driven development (BDD); human–computer interaction (HCI); user‐centered design; user‐centered software development model	Güncan, Damla; Onay Durdu, Pınar	J. Softw. Evol. Process	The concept of usability, which affects the quality and cost of the software projects, has become essential in recent years. There is a need to integrate usability testing activities and techniques into the development processes; however, integration is difficult. Therefore, this study proposes user‐centered behavioral (UCB) software development model, which aims to bridge the gap between human–computer interaction (HCI) and software engineering (SE) disciplines. A triangulation methodology of mixed methods is used to understand the current situation in software development companies in terms of usability and user‐centered software development by survey and interviews. Their results are then used to inform the development of the proposed model. The UCB software development model proposes a process in which several tools and techniques from SE and HCI are integrated to facilitate the production of highly usable software. In essence, the model proposes an iterative process that combines behavior‐driven development (BDD)—an agile approach that enables a better understanding and analysis of the requirements—with the style guides, usability tests, heuristic evaluation, and Wizard of Oz techniques of HCI. The model was evaluated in a pilot project and then is improved based on feedback gathered. Participants' feedback supported the effectiveness of the proposed model.The UCB software development model proposes a process in which several tools and techniques from SE and HCI are integrated to create a model that will facilitate the production of highly usable software. In essence, the model proposes an iterative process that combines behavior‐driven development (BDD)—an agile approach that enables a better understanding and analysis of the requirements—with the style guides, usability tests, heuristic evaluation, and Wizard of Oz techniques of HCI. image				Excluded	Excluded	new_screen			2						
220	Behave	Behavior Driven Development for circuit design and verification	The design of hardware systems is a challenging and erroneous task where about 70% of the effort in designing these systems is spent on verification. In general, testing and verification are usually tasks that are being applied as a post-process to the implementation. In this paper, we propose a new design flow based on Behavior Driven Development (BDD), an agile technique for the development of software in which acceptance tests written in natural language play a central role and are the starting point in the design flow. We advance the flow such that the specifics that arise when modeling hardware are taken into account. Furthermore, we present a technique that allows for the automatic generalization of test cases to properties that are suitable for formal verification. This allows the designer to apply formal verification techniques based on test cases without specifying properties. We implemented our approach and evaluated the flow for an illustrative example that successfully demonstrates the advantages of the proposed flow.		M. Diepenbeck; M. Soeken; D. Große; R. Drechsler	2012 IEEE International High Level Design Validation and Test Workshop (HLDVT)	The design of hardware systems is a challenging and erroneous task where about 70% of the effort in designing these systems is spent on verification. In general, testing and verification are usually tasks that are being applied as a post-process to the implementation. In this paper, we propose a new design flow based on Behavior Driven Development (BDD), an agile technique for the development of software in which acceptance tests written in natural language play a central role and are the starting point in the design flow. We advance the flow such that the specifics that arise when modeling hardware are taken into account. Furthermore, we present a technique that allows for the automatic generalization of test cases to properties that are suitable for formal verification. This allows the designer to apply formal verification techniques based on test cases without specifying properties. We implemented our approach and evaluated the flow for an illustrative example that successfully demonstrates the advantages of the proposed flow.				Included	Included	new_screen			2						
221	Behave	Behavior driven development for circuit design and verification	The design of hardware systems is a challenging and erroneous task where about 70% of the effort in designing these systems is spent on verification. In general, testing and verification are usually tasks that are being applied as a post-process to the implementation. In this paper, we propose a new design flow based on Behavior Driven Development (BDD), an agile technique for the development of software in which acceptance tests written in natural language play a central role and are the starting point in the design flow. We advance the flow such that the specifics that arise when modeling hardware are taken into account. Furthermore, we present a technique that allows for the automatic generalization of test cases to properties that are suitable for formal verification. This allows the designer to apply formal verification techniques based on test cases without specifying properties. We implemented our approach and evaluated the flow for an illustrative example that successfully demonstrates the advantages of the proposed flow. © 2012 IEEE.		Diepenbeck M., Soeken M., Große D., Drechsler R.	Proceedings - IEEE International High-Level Design Validation and Test Workshop, HLDVT	The design of hardware systems is a challenging and erroneous task where about 70% of the effort in designing these systems is spent on verification. In general, testing and verification are usually tasks that are being applied as a post-process to the implementation. In this paper, we propose a new design flow based on Behavior Driven Development (BDD), an agile technique for the development of software in which acceptance tests written in natural language play a central role and are the starting point in the design flow. We advance the flow such that the specifics that arise when modeling hardware are taken into account. Furthermore, we present a technique that allows for the automatic generalization of test cases to properties that are suitable for formal verification. This allows the designer to apply formal verification techniques based on test cases without specifying properties. We implemented our approach and evaluated the flow for an illustrative example that successfully demonstrates the advantages of the proposed flow. © 2012 IEEE.				Excluded	Excluded	new_screen			2						
222	Behave	Behaviour driven development for tests and verification	The design of hardware systems is a challenging and error-prone task, where a signifcant portion of the effort is spent for testing and verification. Usually testing and verification are applied as a post-process to the implementation. Meanwhile, for the development of software, test-first approaches such as test driven development (TDD) have become increasingly important. In this paper, we propose a new design flow based on behaviour driven development (BDD), an extension of TDD, where acceptance tests written in natural language drive the implementation. We extend this idea by allowing the specification of properties in natural language and use them as a starting point in the design flow. The flow also includes an automatic generalisation of test cases to properties that are used for formal verification. In this way, testing and formal verification are combined in a seamless manner, while keeping the requirements - from which both tests and formal properties are derived - in a single consistent document. The approach has been implemented and evaluated on several examples to demonstrate the advantages of the proposed flow. © 2014 Springer International Publishing Switzerland.		Diepenbeck M., Kühne U., Soeken M., Drechsler R.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	The design of hardware systems is a challenging and error-prone task, where a signifcant portion of the effort is spent for testing and verification. Usually testing and verification are applied as a post-process to the implementation. Meanwhile, for the development of software, test-first approaches such as test driven development (TDD) have become increasingly important. In this paper, we propose a new design flow based on behaviour driven development (BDD), an extension of TDD, where acceptance tests written in natural language drive the implementation. We extend this idea by allowing the specification of properties in natural language and use them as a starting point in the design flow. The flow also includes an automatic generalisation of test cases to properties that are used for formal verification. In this way, testing and formal verification are combined in a seamless manner, while keeping the requirements - from which both tests and formal properties are derived - in a single consistent document. The approach has been implemented and evaluated on several examples to demonstrate the advantages of the proposed flow. © 2014 Springer International Publishing Switzerland.				Included	Included	new_screen			2						
223	Behave	The ASSERT Virtual Machine: A Predictable Platform for Real-Time Systems	The development of real-time control systems is a complex process which has to face often conflicting requirements, especially those related to the performance of the control methods and the real-time behaviour of the system. The ASSERT Virtual Machine provides a reliable execution platform for such systems, which allows developers to cope with functional and real-time aspects separately. In order to guarantee the required real-time properties, the virtual machine only accepts software components which have a predictable temporal behaviour which can be analysed at system design time. Such components can be automatically generated from a high-level description of a system which embodies the functional components (e.g. control algorithms) into a set of containers providing the appropriate concurrent and realtime behaviour. The ASSERT Virtual Machine has been implemented in Ada 2005, using a predictable tasking subset of the language known as the Ravenscar profile. A prototype has been validated on several pilot-scale spacecraft control systems, with good results.	Computers for control, real-time systems, programming environments, software engineering, model-driven development	de la Puente, Juan A.; Zamorano, Juan; Pulido, José A.; Urueña, Santiago	IFAC Proceedings Volumes	The development of real-time control systems is a complex process which has to face often conflicting requirements, especially those related to the performance of the control methods and the real-time behaviour of the system. The ASSERT Virtual Machine provides a reliable execution platform for such systems, which allows developers to cope with functional and real-time aspects separately. In order to guarantee the required real-time properties, the virtual machine only accepts software components which have a predictable temporal behaviour which can be analysed at system design time. Such components can be automatically generated from a high-level description of a system which embodies the functional components (e.g. control algorithms) into a set of containers providing the appropriate concurrent and realtime behaviour. The ASSERT Virtual Machine has been implemented in Ada 2005, using a predictable tasking subset of the language known as the Ravenscar profile. A prototype has been validated on several pilot-scale spacecraft control systems, with good results.				Excluded	Excluded	new_screen			2						
224	Behave	Scenarios in the Loop: Integrated Requirements Analysis and Automotive System Validation	The development of safety-relevant systems in the automotive industry requires the definition of high-quality requirements and tests for the coordination and monitoring of development activities in an agile development environment. In this paper we describe a Scenarios in the Loop (SCIL) approach. SCIL combines (1) natural language requirements specification based on Behavior-Driven Development (BDD) with (2) formal and test-driven requirements modeling and analysis, and (3) integrates discipline-specific tools for software and system validation during development. A central element of SCIL is a flexible and executable scenario-based modeling language, the Scenario Modeling Language for Kotlin (SMLK). SMLK allows for an intuitive requirements formalization, and supports engineers to move iteratively, and continuously aided by automated checks, from stakeholder requirements to the validation of the implemented system. We evaluated the approach using a real example from the field of e-mobility.	automotive systems engineering; BizDevOps; requirements analysis; system validation	Wiecher, Carsten; Japs, Sergej; Kaiser, Lydia; Greenyer, Joel; Dumitrescu, Roman; Wolff, Carsten	Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems: Companion Proceedings	The development of safety-relevant systems in the automotive industry requires the definition of high-quality requirements and tests for the coordination and monitoring of development activities in an agile development environment. In this paper we describe a Scenarios in the Loop (SCIL) approach. SCIL combines (1) natural language requirements specification based on Behavior-Driven Development (BDD) with (2) formal and test-driven requirements modeling and analysis, and (3) integrates discipline-specific tools for software and system validation during development. A central element of SCIL is a flexible and executable scenario-based modeling language, the Scenario Modeling Language for Kotlin (SMLK). SMLK allows for an intuitive requirements formalization, and supports engineers to move iteratively, and continuously aided by automated checks, from stakeholder requirements to the validation of the implemented system. We evaluated the approach using a real example from the field of e-mobility.				Included	Included	new_screen			2						
225	Behave	Continuous Security through Integration Testing in an Electronic Health Records System	The estimated average cost of a healthcare data breach in 2019 was $6.45 million, which is the highest among all industries. Yet, security remains an afterthought in many digital health applications. Formal methods for testing for bugs are commonplace in software development through the use of unit testing, integration testing, system testing, and acceptance testing. More so, in modern software engineering, continuous integration is a well-known concept to run automated tests soon after any code change, when the system builds and notifies the development team of the test results. In this paper, we describe the use of a popular Python unit testing framework to implement a formal method of security testing. Common Vulnerability Scoring System (CVSS) is used to calculate metrics that represent the state of security of a deployed system. We developed a series of Pytest Behavioral Driven Development (BDD) scripts to test the Authentication and Availability of a widely used Electronic Health Records System called OpenMRS. The advantage of using the BDD approach is that testing scripts, called Gherkin files, can be read, and understood by the developers as well as the non-developer stakeholders. The use of Gherkin serves two purposes: firstly, it serves as the project’s documentation, and secondly, it automates the tests. The use of the CVSS score between 0 to 10 becomes an objective metric to compare every code change, thus achieving continuous security. We plan to expand BDD scripts to attacks like Denial of Service, Session Hijacking, SQL Injection, and other privilege escalation attacks.	Behavior Driven Development;Common Vulnerability Scoring System;Continuous Security;Electronic Health Records;Integration testing;OpenMRS	S. Purkayastha; S. Goyal; T. Phillips; H. Wu; B. Haakenson; X. Zou	2020 International Conference on Software Security and Assurance (ICSSA)	The estimated average cost of a healthcare data breach in 2019 was $6.45 million, which is the highest among all industries. Yet, security remains an afterthought in many digital health applications. Formal methods for testing for bugs are commonplace in software development through the use of unit testing, integration testing, system testing, and acceptance testing. More so, in modern software engineering, continuous integration is a well-known concept to run automated tests soon after any code change, when the system builds and notifies the development team of the test results. In this paper, we describe the use of a popular Python unit testing framework to implement a formal method of security testing. Common Vulnerability Scoring System (CVSS) is used to calculate metrics that represent the state of security of a deployed system. We developed a series of Pytest Behavioral Driven Development (BDD) scripts to test the Authentication and Availability of a widely used Electronic Health Records System called OpenMRS. The advantage of using the BDD approach is that testing scripts, called Gherkin files, can be read, and understood by the developers as well as the non-developer stakeholders. The use of Gherkin serves two purposes: firstly, it serves as the project’s documentation, and secondly, it automates the tests. The use of the CVSS score between 0 to 10 becomes an objective metric to compare every code change, thus achieving continuous security. We plan to expand BDD scripts to attacks like Denial of Service, Session Hijacking, SQL Injection, and other privilege escalation attacks.				Included	Included	new_screen			2						
226	Behave	Design Driven Testing: Test Smarter, Not Harder	The groundbreaking book Design Driven Testing brings sanity back to the software development process by flipping around the concept of Test Driven Development (TDD)restoring the concept of using testing to verify a design instead of pretending that unit tests are a replacement for design. Anyone who feels that TDD is Too Damn Difficult will appreciate this book. Design Driven Testing shows that, by combining a forward-thinking development process with cutting-edge automation, testing can be a finely targeted, business-driven, rewarding effort. In other words, youll learn how to test smarter, not harder. Applies a feedback-driven approach to each stage of the project lifecycle. Illustrates a lightweight and effective approach using a core subset of UML. Follows a real-life example project using Java and Flex/ActionScript. Presents bonus chapters for advanced DDTers covering unit-test antipatterns (and their opposite, test-conscious design patterns), and showing how to create your own test transformation templates in Enterprise Architect. What youll learn Create unit and behavioral tests using JUnit, NUnit, FlexUnit. Generate acceptance tests for all usage paths through use case thread expansion. Generate requirement tests for functional requirements. Run complex acceptance tests across the enterprise. Isolate individual control points for self-contained unit/behavioral tests. Apply Behavior Driven Development frameworks like JBehave and NBehave Design Driven Testing should appeal to developers, project managers, testers, business analysts, architectsin fact anyone who builds software that needs to be tested. While equally applicable on both large and small projects, Design Driven Testing is especially helpful to those developers who need to verify their software against formal requirements. Such developers will benefit greatly from the rational and disciplined approach espoused by the authors.		Stephens, Matt; Rosenberg, Doug		The groundbreaking book Design Driven Testing brings sanity back to the software development process by flipping around the concept of Test Driven Development (TDD)restoring the concept of using testing to verify a design instead of pretending that unit tests are a replacement for design. Anyone who feels that TDD is Too Damn Difficult will appreciate this book. Design Driven Testing shows that, by combining a forward-thinking development process with cutting-edge automation, testing can be a finely targeted, business-driven, rewarding effort. In other words, youll learn how to test smarter, not harder. Applies a feedback-driven approach to each stage of the project lifecycle. Illustrates a lightweight and effective approach using a core subset of UML. Follows a real-life example project using Java and Flex/ActionScript. Presents bonus chapters for advanced DDTers covering unit-test antipatterns (and their opposite, test-conscious design patterns), and showing how to create your own test transformation templates in Enterprise Architect. What youll learn Create unit and behavioral tests using JUnit, NUnit, FlexUnit. Generate acceptance tests for all usage paths through use case thread expansion. Generate requirement tests for functional requirements. Run complex acceptance tests across the enterprise. Isolate individual control points for self-contained unit/behavioral tests. Apply Behavior Driven Development frameworks like JBehave and NBehave Design Driven Testing should appeal to developers, project managers, testers, business analysts, architectsin fact anyone who builds software that needs to be tested. While equally applicable on both large and small projects, Design Driven Testing is especially helpful to those developers who need to verify their software against formal requirements. Such developers will benefit greatly from the rational and disciplined approach espoused by the authors.				Excluded	Excluded	new_screen			2						
227	Behave	Development of health software using behaviour driven development - BDD	The health software industry is facing an immense challenge of managing quality and preventing software failures. Poorly defined requirements are one of the significant cause of health software failures. Agile practices are being increasingly used by the software industry to develop systems on time and within budget with improved software quality and user acceptance. Behaviour-driven development (BDD) is an agile software engineering practice that can help to improve health software quality vastly. BDD achieves this by prioritising the illustration of software's behaviour using ubiquitous language, followed by automated acceptance testing to assess if the illustrated behaviour was achieved. This paper presents a review of BDD literature, including the characteristics of BDD and examines how BDD can benefit health software quality. The paper reviews health software standards and guidelines, to examine their compatibility with a BDD approach. Finally, the paper details future plans for the development of a framework that provides health software companies with a detailed step by step guideline on how to use BDD to develop safer health software. Copyright © 2020 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.		Anjum M.Z., Mahon S.T.M., MahonMcCaffery F.	MODELSWARD 2020 - Proceedings of the 8th International Conference on Model-Driven Engineering and Software Development	The health software industry is facing an immense challenge of managing quality and preventing software failures. Poorly defined requirements are one of the significant cause of health software failures. Agile practices are being increasingly used by the software industry to develop systems on time and within budget with improved software quality and user acceptance. Behaviour-driven development (BDD) is an agile software engineering practice that can help to improve health software quality vastly. BDD achieves this by prioritising the illustration of software's behaviour using ubiquitous language, followed by automated acceptance testing to assess if the illustrated behaviour was achieved. This paper presents a review of BDD literature, including the characteristics of BDD and examines how BDD can benefit health software quality. The paper reviews health software standards and guidelines, to examine their compatibility with a BDD approach. Finally, the paper details future plans for the development of a framework that provides health software companies with a detailed step by step guideline on how to use BDD to develop safer health software. Copyright © 2020 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.				Excluded	Excluded	new_screen			2						
228	Behave	Behaviour-driven development applied to the conformance testing of INSPIRE web services	The implementation of the INSPIRE directive requires to check the conformity of a large number of network services with the implementing rules of INSPIRE. The evaluation whether a service is fully conformant with INSPIRE is complex and requires the use of specialized testing tools that should report how verification has been made and should identify non-conformances. The use of these tools requires a high degree of technical knowledge. This fact makes very difficult for non-technical stakeholders (end users, managers, domain experts, etc.) to participate effectively in conformance testing, hinders stakeholders understanding of the causes and consequences of non-conformant results and may cause in some stakeholders disinterest in conformance testing. This work explores the suitability of a behaviour-driven development (BDD) approach to the conformance testing of OGC Web services in the context of the INSPIRE directive. BDD emphasizes the participation of non-technical parties in the design of acceptance tests by means of automatable abstract tests expressed in a human readable format. Using this idea as base, this work describes a BDD based workflow to derive abstract test suites and executable test suites from INSPIRE implementation requirements that can be written in the language used by non-technical stakeholders. This work also analyses if BDD and popular BDD tools, such as Gherkin and Cucumber, are compatible with ISO 19105:2000 testing methodology. As demonstration, we present an online conformance tool for INSPIRE View and Discovery services that executes BDD test suites. © Springer International Publishing Switzerland 2014.		Lopez-Pellicer F.J., Latre M.Á., Nogueras-Iso J., Javier Zarazaga-Soria F., Barrera J.	Lecture Notes in Geoinformation and Cartography	The implementation of the INSPIRE directive requires to check the conformity of a large number of network services with the implementing rules of INSPIRE. The evaluation whether a service is fully conformant with INSPIRE is complex and requires the use of specialized testing tools that should report how verification has been made and should identify non-conformances. The use of these tools requires a high degree of technical knowledge. This fact makes very difficult for non-technical stakeholders (end users, managers, domain experts, etc.) to participate effectively in conformance testing, hinders stakeholders understanding of the causes and consequences of non-conformant results and may cause in some stakeholders disinterest in conformance testing. This work explores the suitability of a behaviour-driven development (BDD) approach to the conformance testing of OGC Web services in the context of the INSPIRE directive. BDD emphasizes the participation of non-technical parties in the design of acceptance tests by means of automatable abstract tests expressed in a human readable format. Using this idea as base, this work describes a BDD based workflow to derive abstract test suites and executable test suites from INSPIRE implementation requirements that can be written in the language used by non-technical stakeholders. This work also analyses if BDD and popular BDD tools, such as Gherkin and Cucumber, are compatible with ISO 19105:2000 testing methodology. As demonstration, we present an online conformance tool for INSPIRE View and Discovery services that executes BDD test suites. © Springer International Publishing Switzerland 2014.				Included	Included	new_screen			2						
229	Behave	Towards a Thing-In-the-Loop Approach for the Verification and Validation of IoT Systems	The Internet of Things (IoT) is rapidly increasing its diffusion, posing great challenges to the research community. IoT systems are composed by smart objects (Things) that are interconnected in order to provide new products and services. The interaction of heterogeneous and distributed smart things guided by software with the physical world brings new sources of safety issues. To this reason, providing valuable and effective solutions to support the verification and validation of such systems is needed. In this paper we introduce a model-driven Thing-In-the-Loop verification and validation approach that transfers the best practices adopted in different embedded system domains towards the IoT world. Starting from models and scenarios representing the structure and behaviors of the IoT system as well as models of its context our approach generates appropriate test cases that are executed in accordance with Model-in-the-Loop, Software-in-the-Loop and Hardware-in-the-Loop techniques. We preliminarily evaluated the feasibility of our approach by applying it in the context of a Smart Mobility case study.	Internet of Things; Model-driven engineering; Thing-In-the-loop; verification and validation	Amalfitano, Domenico; Amatucci, Nicola; De Simone, Vincenzo; Riccio, Vincenzo; Rita, Fasolino Anna	Proceedings of the 1st ACM Workshop on the Internet of Safe Things	The Internet of Things (IoT) is rapidly increasing its diffusion, posing great challenges to the research community. IoT systems are composed by smart objects (Things) that are interconnected in order to provide new products and services. The interaction of heterogeneous and distributed smart things guided by software with the physical world brings new sources of safety issues. To this reason, providing valuable and effective solutions to support the verification and validation of such systems is needed. In this paper we introduce a model-driven Thing-In-the-Loop verification and validation approach that transfers the best practices adopted in different embedded system domains towards the IoT world. Starting from models and scenarios representing the structure and behaviors of the IoT system as well as models of its context our approach generates appropriate test cases that are executed in accordance with Model-in-the-Loop, Software-in-the-Loop and Hardware-in-the-Loop techniques. We preliminarily evaluated the feasibility of our approach by applying it in the context of a Smart Mobility case study.				Excluded	Excluded	new_screen			2						
230	Behave	Supporting smart construction with dependable edge computing infrastructures and applications	The Internet of Things (IoT) such as the use of robots, sensors, actuators, electronic signalization and a variety of other Internet enabled physical devices may provide for new advanced smart applications to be used in construction in the very near future. Such applications require real-time responses and are therefore time-critical. Therefore, in order to support collaboration, control, monitoring, supply management, safety and other construction processes, they have to meet dependability requirements, including requirements for high Quality of Service (QoS). Dependability and high QoS can be achieved by using adequate number and quality of computing resources, such as processing, memory and networking elements, geographically close to the smart environments. The goal of this study is to develop a practical edge computing architecture and design, which can be used to support smart construction environments with high QoS. This study gives particular attention to the solution design, which relies on latest cloud and software engineering approaches and technologies, and provides elasticity, interoperability and adaptation to companies' specific needs. Two edge computing applications supporting video communications and construction process documentation are developed and demonstrate a viable edge computing design for smart construction.	Smart construction, Dependability, Internet of Things, Container-based systems, Edge computing	Kochovski, Petar; Stankovski, Vlado	Automation in Construction	The Internet of Things (IoT) such as the use of robots, sensors, actuators, electronic signalization and a variety of other Internet enabled physical devices may provide for new advanced smart applications to be used in construction in the very near future. Such applications require real-time responses and are therefore time-critical. Therefore, in order to support collaboration, control, monitoring, supply management, safety and other construction processes, they have to meet dependability requirements, including requirements for high Quality of Service (QoS). Dependability and high QoS can be achieved by using adequate number and quality of computing resources, such as processing, memory and networking elements, geographically close to the smart environments. The goal of this study is to develop a practical edge computing architecture and design, which can be used to support smart construction environments with high QoS. This study gives particular attention to the solution design, which relies on latest cloud and software engineering approaches and technologies, and provides elasticity, interoperability and adaptation to companies' specific needs. Two edge computing applications supporting video communications and construction process documentation are developed and demonstrate a viable edge computing design for smart construction.				Excluded	Excluded	new_screen			2						
231	Behave	Towards Behavior-Driven Graphical User Interface Testing	The majority of users interacts with an application through its graphical user interface (GUI). To ensure high quality and expected behavior, those graphical user interfaces have to be tested thoroughly. Yet, creating graphical user interface test cases is considered expensive in comparison to unit or integration tests. In addition, test cases are perceived to be expensive to run and brittle, therefore causing a lot of false negative test results. Behavior-driven test case design addresses this challenges by bringing requirement specifications and test cases closer together. Although industry-proven tools map test specifications automatically, test methods making test scripts executable need to be implemented manually. The specification language Slang introduced by this paper generates automatically executable test cases from BDD-like feature descriptions that integrate low-fidelity prototypes in form of wireframesketcher models. To quantify the economic advantage of our approach an AB/BA crossover designed experiment was conducted. The experiment showed that creating automatically executable test cases utilizing Slang takes 63% less time compared to the industry-proven tool JBehave. In addition to presenting the experiment's results, the paper elaborates on first experience from applying the approach in a large Swiss bank. The findings of our experiments are supported by results from applying our approach in real-world scenarios. In addition, experiment as well as case study participants appreciated the sophisticated editor support of Slang.	behavior-driven development; domain-specific language; GUI test case generation; model-driven engineering; case study	Bünder, Hendrik; Kuchen, Herbert	SIGAPP Appl. Comput. Rev.	The majority of users interacts with an application through its graphical user interface (GUI). To ensure high quality and expected behavior, those graphical user interfaces have to be tested thoroughly. Yet, creating graphical user interface test cases is considered expensive in comparison to unit or integration tests. In addition, test cases are perceived to be expensive to run and brittle, therefore causing a lot of false negative test results. Behavior-driven test case design addresses this challenges by bringing requirement specifications and test cases closer together. Although industry-proven tools map test specifications automatically, test methods making test scripts executable need to be implemented manually. The specification language Slang introduced by this paper generates automatically executable test cases from BDD-like feature descriptions that integrate low-fidelity prototypes in form of wireframesketcher models. To quantify the economic advantage of our approach an AB/BA crossover designed experiment was conducted. The experiment showed that creating automatically executable test cases utilizing Slang takes 63% less time compared to the industry-proven tool JBehave. In addition to presenting the experiment's results, the paper elaborates on first experience from applying the approach in a large Swiss bank. The findings of our experiments are supported by results from applying our approach in real-world scenarios. In addition, experiment as well as case study participants appreciated the sophisticated editor support of Slang.				Included	Included	new_screen			2						
232	Behave	The behavior driven development applied to the software quality test: A case study applied to the promotion of sports financing in Brazil	The mechanisms of private investment in Brazilian sport are one of the main sources of resources that athletes hold to promote participation in high-performance competitions. In order to improve this flow, softwares are designed to shorten the path between donors and recipients. These tools, such as 'Meu Campeãu' used in this paper, require efficient analysis of the quality of the product offered. Concepts known as agile methodologies have brought a new style to the analysis of the software developed, and one of them has gained considerable prominence, known such as BDD (Behavior Driven Development), so this paper aims to analyze the implementation of Behavior Driven Development in the software quality verification process 'Meu Campeãu'. © 2019 AISTI.		Cavalcante M.G., Sales J.I.	Iberian Conference on Information Systems and Technologies, CISTI	The mechanisms of private investment in Brazilian sport are one of the main sources of resources that athletes hold to promote participation in high-performance competitions. In order to improve this flow, softwares are designed to shorten the path between donors and recipients. These tools, such as 'Meu Campeãu' used in this paper, require efficient analysis of the quality of the product offered. Concepts known as agile methodologies have brought a new style to the analysis of the software developed, and one of them has gained considerable prominence, known such as BDD (Behavior Driven Development), so this paper aims to analyze the implementation of Behavior Driven Development in the software quality verification process 'Meu Campeãu'. © 2019 AISTI.				Included	Included	new_screen			2						
233	Behave	Graph-based and scenario-driven microservice analysis, retrieval, and testing	The microservice architecture (MSA) differs fundamentally from the monolithic, layered architecture. The use of microservices provides a high degree of autonomy, composability, scalability, and fault-tolerance. MSA is regarded by many as a promising architecture for smart-city applications; however, a number of issues remain, including (1) the management of complex call relationships among microservices; (2) ensuring the quality of the overall software system even as new microservices are added and existing ones are modified, and (3) locating existing microservices that satisfy new requirements. In this paper, we propose a novel approach to the development of microservice-based systems, referred to as GSMART (Graph-based and Scenario-driven Microservice Analysis, Retrieval and Testing). GSMART enables the automatic generation of a “Service Dependency Graph (SDG)” by which to visualize and analyze dependency relationships between microservices as well as between services and scenarios. It also enables the automatic retrieval of test cases required for system changes to reduce the time and costs associated with regression testing. A microservice retrieval method using VSM and word2vec accelerates the development of new microservices tailored specifically to the needs of users based on user-provided scenarios. Experiment results demonstrate the feasibility, effectiveness, and efficiency of all of the main features of GSMART.	Microservice retrieval, Microservice testing, Microservice analysis, Service dependency graph, Behavior-driven development	Ma, Shang-Pin; Fan, Chen-Yuan; Chuang, Yen; Liu, I.-Hsiu; Lan, Ci-Wei	Future Generation Computer Systems	The microservice architecture (MSA) differs fundamentally from the monolithic, layered architecture. The use of microservices provides a high degree of autonomy, composability, scalability, and fault-tolerance. MSA is regarded by many as a promising architecture for smart-city applications; however, a number of issues remain, including (1) the management of complex call relationships among microservices; (2) ensuring the quality of the overall software system even as new microservices are added and existing ones are modified, and (3) locating existing microservices that satisfy new requirements. In this paper, we propose a novel approach to the development of microservice-based systems, referred to as GSMART (Graph-based and Scenario-driven Microservice Analysis, Retrieval and Testing). GSMART enables the automatic generation of a “Service Dependency Graph (SDG)” by which to visualize and analyze dependency relationships between microservices as well as between services and scenarios. It also enables the automatic retrieval of test cases required for system changes to reduce the time and costs associated with regression testing. A microservice retrieval method using VSM and word2vec accelerates the development of new microservices tailored specifically to the needs of users based on user-provided scenarios. Experiment results demonstrate the feasibility, effectiveness, and efficiency of all of the main features of GSMART.				Included	Included	new_screen			2						
234	Behave	CEUR Workshop Proceedings	The proceedings contain 10 papers. The topics discussed include: pattern-driven knowledge systems engineering; an ontology debugger for the semantic Wiki KnowWE; behaviour-driven development for computer-interpretable clinical guidelines; ensuring the semantic correctness of workflow processes: an ontological approach; integration of activity modeller with Bayesian network based recommender for business processes; towards an ontological analysis of BPMN; CAPJA - a connector architecture for prolog and Java; migration of rule inference engine to mobile platform. challenges and case study; knowledge modeling with the open source tool myCBR; and SBVRwiki.		[No author name available]	CEUR Workshop Proceedings	The proceedings contain 10 papers. The topics discussed include: pattern-driven knowledge systems engineering; an ontology debugger for the semantic Wiki KnowWE; behaviour-driven development for computer-interpretable clinical guidelines; ensuring the semantic correctness of workflow processes: an ontological approach; integration of activity modeller with Bayesian network based recommender for business processes; towards an ontological analysis of BPMN; CAPJA - a connector architecture for prolog and Java; migration of rule inference engine to mobile platform. challenges and case study; knowledge modeling with the open source tool myCBR; and SBVRwiki.				Excluded	Excluded	new_screen			2						
235	Behave	Proceedings - 34th Brazilian Symposium on Software Engineering, SBES 2020	The proceedings contain 101 papers. The topics discussed include: on the influence of different perspectives on evaluating the quality of teamwork in the context of agile software development; challenges in agile transformation journey - a qualitative study; agile global software development: a systematic literature review; behavior-driven development: an expert panel to evaluate benefits and challenges [insightful ideas and emerging results; adaptations of scrum roles in software projects: survey and representation tentative with feature models; are code smell co-occurrences harmful to internal quality attributes? a mixed-method study; recommending composite refactorings for smell removal: heuristics and evaluation; a catalog of object-relational mapping code smells for java; and probabilistic model-based analysis to improve software energy efficiency.		[No author name available]	ACM International Conference Proceeding Series	The proceedings contain 101 papers. The topics discussed include: on the influence of different perspectives on evaluating the quality of teamwork in the context of agile software development; challenges in agile transformation journey - a qualitative study; agile global software development: a systematic literature review; behavior-driven development: an expert panel to evaluate benefits and challenges [insightful ideas and emerging results; adaptations of scrum roles in software projects: survey and representation tentative with feature models; are code smell co-occurrences harmful to internal quality attributes? a mixed-method study; recommending composite refactorings for smell removal: heuristics and evaluation; a catalog of object-relational mapping code smells for java; and probabilistic model-based analysis to improve software energy efficiency.				Excluded	Excluded	new_screen			2						
236	Behave	Proceedings - 2021 IEEE/ACM 6th International Workshop on Metamorphic Testing, MET 2021	The proceedings contain 11 papers. The topics discussed include: robustness evaluation of stacked generative adversarial networks using metamorphic testing; metamorphic detection of repackaged malware; applying metamorphic testing to homomorphic cryptography; BMT: behavior driven development-based metamorphic testing for autonomous driving models; enhancing Euro NCAP standards with metamorphic testing for verification of advanced driver-assistance systems; towards automated metamorphic test identification for ocean system models; metamorphic testing on the continuum of verification and validation of simulation models; and metamorphic testing for image-based calcium imaging analysis pipelines.		[No author name available]	Proceedings - 2021 IEEE/ACM 6th International Workshop on Metamorphic Testing, MET 2021	The proceedings contain 11 papers. The topics discussed include: robustness evaluation of stacked generative adversarial networks using metamorphic testing; metamorphic detection of repackaged malware; applying metamorphic testing to homomorphic cryptography; BMT: behavior driven development-based metamorphic testing for autonomous driving models; enhancing Euro NCAP standards with metamorphic testing for verification of advanced driver-assistance systems; towards automated metamorphic test identification for ocean system models; metamorphic testing on the continuum of verification and validation of simulation models; and metamorphic testing for image-based calcium imaging analysis pipelines.				Excluded	Excluded	new_screen			2						
237	Behave	21st International Conference on Agile Software Development, XP 2020	The proceedings contain 16 papers. The special focus in this conference is on Agile Software Development. The topics include: “When in Rome, Do as the Romans Do”: Cultural Barriers to Being Agile in Distributed Teams; a Quantitative Exploration of the 9-Factor Theory: Distribution of Leadership Roles Between Scrum Master and Agile Team; what an Agile Leader Does: The Group Dynamics Perspective; “This is Just a Prototype”: How Ethics Are Ignored in Software Startup-Like Environments; hypotheses Elicitation in Early-Stage Software Startups Based on Cognitive Mapping; results from a Replicated Experiment on the Affective Reactions of Novice Developers When Applying Test-Driven Development; examining the Current State of System Testing Methodologies in Quality Assurance; onboarding: How Newcomers Integrate into an Agile Project Team; combining User-Centered Design and Lean Startup with Agile Software Development: A Case Study of Two Agile Teams; agile Software Development Practices and Success in Outsourced Projects: The Moderating Role of Requirements Risk; on the Use of Design Thinking: A Survey of the Brazilian Agile Software Development Community; characterising the Quality of Behaviour Driven Development Specifications; “I Don’t Understand!”: Toward a Model to Evaluate the Role of User Story Quality; large-Scale Agile Transformation: A Case Study of Transforming Business, Development and Operations.		[No author name available]	Lecture Notes in Business Information Processing	The proceedings contain 16 papers. The special focus in this conference is on Agile Software Development. The topics include: “When in Rome, Do as the Romans Do”: Cultural Barriers to Being Agile in Distributed Teams; a Quantitative Exploration of the 9-Factor Theory: Distribution of Leadership Roles Between Scrum Master and Agile Team; what an Agile Leader Does: The Group Dynamics Perspective; “This is Just a Prototype”: How Ethics Are Ignored in Software Startup-Like Environments; hypotheses Elicitation in Early-Stage Software Startups Based on Cognitive Mapping; results from a Replicated Experiment on the Affective Reactions of Novice Developers When Applying Test-Driven Development; examining the Current State of System Testing Methodologies in Quality Assurance; onboarding: How Newcomers Integrate into an Agile Project Team; combining User-Centered Design and Lean Startup with Agile Software Development: A Case Study of Two Agile Teams; agile Software Development Practices and Success in Outsourced Projects: The Moderating Role of Requirements Risk; on the Use of Design Thinking: A Survey of the Brazilian Agile Software Development Community; characterising the Quality of Behaviour Driven Development Specifications; “I Don’t Understand!”: Toward a Model to Evaluate the Role of User Story Quality; large-Scale Agile Transformation: A Case Study of Transforming Business, Development and Operations.				Excluded	Excluded	new_screen			2						
238	Behave	2020 IEEE International Conference on Problems of Infocommunications Science and Technology, PIC S and T 2020 - Proceedings	The proceedings contain 171 papers. The topics discussed include: last mile technique for wireless delivery system using an accelerating lens; compact polarizers for satellite information systems; highly-distributed systems: what is inside?; behavior driven development approach in the modern quality control process; analysis of influence of UDP parameters on QoS in IP network; categorical analysis of logical networks in application to intelligent radar systems; models and information technology for reliable design of the functioning processes of flexible production systems as complex human-machine systems; advanced code-based electronic digital signature scheme; required safety component of automotive cyber-physical systems; and structure optimization of the multi-channel on-board radar with antenna aperture synthesis and algorithm for power line selection on the background of the earth surface.		[No author name available]	2020 IEEE International Conference on Problems of Infocommunications Science and Technology, PIC S and T 2020 - Proceedings	The proceedings contain 171 papers. The topics discussed include: last mile technique for wireless delivery system using an accelerating lens; compact polarizers for satellite information systems; highly-distributed systems: what is inside?; behavior driven development approach in the modern quality control process; analysis of influence of UDP parameters on QoS in IP network; categorical analysis of logical networks in application to intelligent radar systems; models and information technology for reliable design of the functioning processes of flexible production systems as complex human-machine systems; advanced code-based electronic digital signature scheme; required safety component of automotive cyber-physical systems; and structure optimization of the multi-channel on-board radar with antenna aperture synthesis and algorithm for power line selection on the background of the earth surface.				Excluded	Excluded	new_screen			2						
239	Behave	CEUR Workshop Proceedings	The proceedings contain 19 papers. The topics discussed include: product configuration in the wild: strategies for conflicting decisions in web configurators; configuring release plans; insights for configuration in natural language; group decision support for requirements management processes; Chatbot-based tourist recommendations using model-based reasoning; the effect of default options on consumer decisions in the product configuration process; cost benefit analysis in product configuration systems; do you read me? on the limits of manufacturing part numbers for communicating product variety; behavior-driven development in product configuration systems; integrating semantic web technologies and ASP for product configuration; measuring the complexity of product configuration systems; generating configuration models from requirements to assist in product management - dependency engine and its performance assessment; quasi-finite domains: dealing with the infinite in mass customization; software configuration diagnosis - a survey of existing methods and open challenges; knowledge retrieval for configuring risks when answering calls to tenders or direct customer demands; how to deal with engineering-to-order product/system configuration?; towards knowledge infrastructure for highly variant voltage transmission systems; and configuration lifecycle management - an assessment of the benefits based on maturity.		[No author name available]	CEUR Workshop Proceedings	The proceedings contain 19 papers. The topics discussed include: product configuration in the wild: strategies for conflicting decisions in web configurators; configuring release plans; insights for configuration in natural language; group decision support for requirements management processes; Chatbot-based tourist recommendations using model-based reasoning; the effect of default options on consumer decisions in the product configuration process; cost benefit analysis in product configuration systems; do you read me? on the limits of manufacturing part numbers for communicating product variety; behavior-driven development in product configuration systems; integrating semantic web technologies and ASP for product configuration; measuring the complexity of product configuration systems; generating configuration models from requirements to assist in product management - dependency engine and its performance assessment; quasi-finite domains: dealing with the infinite in mass customization; software configuration diagnosis - a survey of existing methods and open challenges; knowledge retrieval for configuring risks when answering calls to tenders or direct customer demands; how to deal with engineering-to-order product/system configuration?; towards knowledge infrastructure for highly variant voltage transmission systems; and configuration lifecycle management - an assessment of the benefits based on maturity.				Excluded	Excluded	new_screen			2						
240	Behave	8th International Conference on Model and Data Engineering, MEDI 2018, International Workshop on Modeling, Verification and Testing of Dependable Critical Systems, DETECT 2018, Model and Data Engineering for Social Good Workshop, MEDI4SG 2018, 2nd International Workshop on Cybersecurity and Functional Safety in Cyber-Physical Systems, IWCFS 2018, International Workshop on Formal Model for Mastering Multifaceted Systems, REMEDY 2018	The proceedings contain 21 papers. The special focus in this conference is on Model and Data Engineering. The topics include: Towards a requirements engineering approach for capturing uncertainty in cyber-physical systems environment; assessment of emerging standards for safety and security co-design on a railway case study; generation of behavior-driven development C++ tests from abstract state machine scenarios; hybrid systems and event-B: A formal approach to signalised left-turn assist; handling reparation in incremental construction of realizable conversation protocols; Analyzing a ROS based architecture for its cross reuse in ISO26262 settings; reliability in fully probabilistic event-B: How to bound the enabling of events; systematic construction of critical embedded systems using event-B; component design and adaptation based on behavioral contracts; An MDA approach for the specification of relay-based diagrams; Towards real-time semantics for a distributed event-based MOP language; Automatic planning: From event-B to PDDL; a problem-oriented approach to critical system design and diagnosis support; formal specification and verification of cloud resource allocation using timed petri-nets; Petri nets to event-B: Handling mathematical sequences through an ERTMS L3 Case; model-based verification and testing methodology for safety-critical airborne systems; gamification and serious games based learning for early childhood in rural areas; context-based sentiment analysis: A survey; a multi-agent system-based distributed intrusion detection system for a cloud computing.		[No author name available]	Communications in Computer and Information Science	The proceedings contain 21 papers. The special focus in this conference is on Model and Data Engineering. The topics include: Towards a requirements engineering approach for capturing uncertainty in cyber-physical systems environment; assessment of emerging standards for safety and security co-design on a railway case study; generation of behavior-driven development C++ tests from abstract state machine scenarios; hybrid systems and event-B: A formal approach to signalised left-turn assist; handling reparation in incremental construction of realizable conversation protocols; Analyzing a ROS based architecture for its cross reuse in ISO26262 settings; reliability in fully probabilistic event-B: How to bound the enabling of events; systematic construction of critical embedded systems using event-B; component design and adaptation based on behavioral contracts; An MDA approach for the specification of relay-based diagrams; Towards real-time semantics for a distributed event-based MOP language; Automatic planning: From event-B to PDDL; a problem-oriented approach to critical system design and diagnosis support; formal specification and verification of cloud resource allocation using timed petri-nets; Petri nets to event-B: Handling mathematical sequences through an ERTMS L3 Case; model-based verification and testing methodology for safety-critical airborne systems; gamification and serious games based learning for early childhood in rural areas; context-based sentiment analysis: A survey; a multi-agent system-based distributed intrusion detection system for a cloud computing.				Excluded	Excluded	new_screen			2						
241	Behave	17th AGILE Conference on Geographic Information Science, AGILE 2014	The proceedings contain 22 papers. The special focus in this conference is on Geographic Information Science. The topics include: Estimating completeness of vgi datasets by analyzing community activity over time periods; estimation of building types on openstreetmap based on urban morphology analysis; qualitative representations of extended spatial objects in sketch maps; exploring the geographical relations between social media and flood phenomena to improve situational awareness; event identification from georeferenced images; a recursive bayesian filter for anomalous behavior detection in trajectory data; using GPS logs to identify agronomical activities; assessing the influence of preprocessing methods on raw GPS-Data for automated change point detection; mining frequent spatio-temporal patterns in wind speed and direction; the text encoding algorithm for latitude/longitude/time; fast SNN-Based clustering approach for large geospatial data sets; RSS and sensor fusion algorithms for indoor location systems on Smartphones; an image segmentation process enhancement for land cover mapping from very high resolution remote sensing data application in a rural area; line matching for integration of photographic and geographic databases; encoding and querying historic map content; an area merge operation for smooth zooming; point labeling with sliding labels in interactive maps; comparing verbal instructions and sketch maps.; behaviour-driven development applied to the conformance testing of INSPIRE web services; making the web of data available via web feature services; a geospatial exploration of comparable cities and a gis-based process for calculating visibility impact from buildings during transmission line routing.		[No author name available]	Lecture Notes in Geoinformation and Cartography	The proceedings contain 22 papers. The special focus in this conference is on Geographic Information Science. The topics include: Estimating completeness of vgi datasets by analyzing community activity over time periods; estimation of building types on openstreetmap based on urban morphology analysis; qualitative representations of extended spatial objects in sketch maps; exploring the geographical relations between social media and flood phenomena to improve situational awareness; event identification from georeferenced images; a recursive bayesian filter for anomalous behavior detection in trajectory data; using GPS logs to identify agronomical activities; assessing the influence of preprocessing methods on raw GPS-Data for automated change point detection; mining frequent spatio-temporal patterns in wind speed and direction; the text encoding algorithm for latitude/longitude/time; fast SNN-Based clustering approach for large geospatial data sets; RSS and sensor fusion algorithms for indoor location systems on Smartphones; an image segmentation process enhancement for land cover mapping from very high resolution remote sensing data application in a rural area; line matching for integration of photographic and geographic databases; encoding and querying historic map content; an area merge operation for smooth zooming; point labeling with sliding labels in interactive maps; comparing verbal instructions and sketch maps.; behaviour-driven development applied to the conformance testing of INSPIRE web services; making the web of data available via web feature services; a geospatial exploration of comparable cities and a gis-based process for calculating visibility impact from buildings during transmission line routing.				Excluded	Excluded	new_screen			2						
242	Behave	CEUR Workshop Proceedings	The proceedings contain 24 papers. The topics discussed include: modeling test cases in BPMN for behavior-driven development; automating data exchange in process choreographies; gameful business process modeling; a game theoretic perspective on business processes; elastic process optimization and scheduling in the cloud; learning from quality issues of BPMN models from industry; the process of creating a domain specific modeling method; requirements catalog for business process modeling recommender systems; evaluating wiki collaborative features in ontology authoring; a visual language for modeling multiple perspectives of business process compliance rules; detecting flight trajectory anomalies and predicting diversions in freight transportation; and plausibility checking of formal business process specifications in linear temporal logic.		[No author name available]	CEUR Workshop Proceedings	The proceedings contain 24 papers. The topics discussed include: modeling test cases in BPMN for behavior-driven development; automating data exchange in process choreographies; gameful business process modeling; a game theoretic perspective on business processes; elastic process optimization and scheduling in the cloud; learning from quality issues of BPMN models from industry; the process of creating a domain specific modeling method; requirements catalog for business process modeling recommender systems; evaluating wiki collaborative features in ontology authoring; a visual language for modeling multiple perspectives of business process compliance rules; detecting flight trajectory anomalies and predicting diversions in freight transportation; and plausibility checking of formal business process specifications in linear temporal logic.				Excluded	Excluded	new_screen			2						
243	Behave	2012 IEEE International High Level Design Validation and Test Workshop, HLDVT 2012	The proceedings contain 24 papers. The topics discussed include: sequential equivalence checking of hard instances with targeted inductive invariants and efficient filtering strategies; behavior driven development for circuit design and verification; using decision diagrams to compactly represent the state space for explicit model checking; automatic generation of deadlock detection algorithms for a family of micro-architecture description languages of communication fabrics; automatic generation of Verilog bus transactors from natural language protocol specifications; single-source hardware modeling of different abstraction levels with state charts; using haloes in mixed-signal assertion based verification; a formal method to improve SystemVerilog functional coverage; a functional test generation technique for RTL datapaths; constrained signal selection for post-silicon validation; and monitoring distributed reactive systems.		[No author name available]	Proceedings - IEEE International High-Level Design Validation and Test Workshop, HLDVT	The proceedings contain 24 papers. The topics discussed include: sequential equivalence checking of hard instances with targeted inductive invariants and efficient filtering strategies; behavior driven development for circuit design and verification; using decision diagrams to compactly represent the state space for explicit model checking; automatic generation of deadlock detection algorithms for a family of micro-architecture description languages of communication fabrics; automatic generation of Verilog bus transactors from natural language protocol specifications; single-source hardware modeling of different abstraction levels with state charts; using haloes in mixed-signal assertion based verification; a formal method to improve SystemVerilog functional coverage; a functional test generation technique for RTL datapaths; constrained signal selection for post-silicon validation; and monitoring distributed reactive systems.				Excluded	Excluded	new_screen			2						
244	Behave	Objects, Models, Components, Patterns - 50th International Conference, TOOLS 2012, Proceedings	The proceedings contain 24 papers. The topics discussed include: supporting compile-time debugging and precise error reporting in meta-programs; identifying a unifying mechanism for the implementation of concurrency abstractions on multi-language virtual machines; verification of snapshotable trees using access permissions and typestate; multiparty session C: safe parallel programming with message optimisation; non-interference on UMI state-charts; representing uniqueness constraints in object-relational mapping; detection of seed methods for quantification of feature confinement; assisted behavior driven development using natural language processing; learning to classify bug reports into components; incremental dynamic updates with first-class contexts; and elucidative development for model-based documentation.		[No author name available]	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	The proceedings contain 24 papers. The topics discussed include: supporting compile-time debugging and precise error reporting in meta-programs; identifying a unifying mechanism for the implementation of concurrency abstractions on multi-language virtual machines; verification of snapshotable trees using access permissions and typestate; multiparty session C: safe parallel programming with message optimisation; non-interference on UMI state-charts; representing uniqueness constraints in object-relational mapping; detection of seed methods for quantification of feature confinement; assisted behavior driven development using natural language processing; learning to classify bug reports into components; incremental dynamic updates with first-class contexts; and elucidative development for model-based documentation.				Excluded	Excluded	new_screen			2						
245	Behave	IFIP WG 13.2/13.5 Joint 6th International Conference on Human-Centered Software Engineering, HCSE 2016 and 8th International Conference on Human Error, Safety, and System Development, HESSD 2016	The proceedings contain 25 papers. The special focus in this conference is on Agile, Human-Centered Software Engineering, Usability Evaluation, Testing, Socio-Technical, Ethical Considerations, Human Error, Safety-Critical Systems, User, Developer Experience, Models, Methods, Adopting Tools, Demos and Posters. The topics include: Supporting the HCI aspect of agile software development by tool support for UI-pattern transformations; usability problems experienced by different groups of skilled internet users; user-test results injection into task-based design process for the assessment and improvement of both usability and user experience; framework for relative web usability evaluation on usability features in MDD; testing prototypes and final user interfaces through an ontological perspective for behavior-driven development; complementary tools and techniques for supporting fitness-for-purpose of interactive critical systems; a conceptual ux-aware model of requirements; audio guidance for runner training; enterprise model-driven agile human-centered software engineering; collaborative task modelling on the web and declarative prototyping with data; a first prototype integrated in HAMSTERS.		[No author name available]	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	The proceedings contain 25 papers. The special focus in this conference is on Agile, Human-Centered Software Engineering, Usability Evaluation, Testing, Socio-Technical, Ethical Considerations, Human Error, Safety-Critical Systems, User, Developer Experience, Models, Methods, Adopting Tools, Demos and Posters. The topics include: Supporting the HCI aspect of agile software development by tool support for UI-pattern transformations; usability problems experienced by different groups of skilled internet users; user-test results injection into task-based design process for the assessment and improvement of both usability and user experience; framework for relative web usability evaluation on usability features in MDD; testing prototypes and final user interfaces through an ontological perspective for behavior-driven development; complementary tools and techniques for supporting fitness-for-purpose of interactive critical systems; a conceptual ux-aware model of requirements; audio guidance for runner training; enterprise model-driven agile human-centered software engineering; collaborative task modelling on the web and declarative prototyping with data; a first prototype integrated in HAMSTERS.				Excluded	Excluded	new_screen			2						
246	Behave	Enterprise Information Systems of the Future - 6th IFIP WG 8.9 Working Conference, CONFENIS 2012, Revised Selected Papers	The proceedings contain 25 papers. The topics discussed include: process innovation: redesigning an enterprise backbone system; sub-process discovery: opportunities for process diagnostics; measuring the impact of suspension on the process enactment environment during process evolution; user perceptions, motivations and implications on ERP usage: an Indian higher education context; a decision support system based on RCM approach to define maintenance strategies; towards more flexible enterprise information systems; a proposal of a process model for requirements elicitation in information mining projects; a financial perspective on improving ICT service delivery: a case at the Belgian railways; looking for a fit for purpose: business process maturity models from a user's perspective; enterprise information systems security: a case study in the banking sector; and implementing behavior driven development in an open source ERP.		[No author name available]	Lecture Notes in Business Information Processing	The proceedings contain 25 papers. The topics discussed include: process innovation: redesigning an enterprise backbone system; sub-process discovery: opportunities for process diagnostics; measuring the impact of suspension on the process enactment environment during process evolution; user perceptions, motivations and implications on ERP usage: an Indian higher education context; a decision support system based on RCM approach to define maintenance strategies; towards more flexible enterprise information systems; a proposal of a process model for requirements elicitation in information mining projects; a financial perspective on improving ICT service delivery: a case at the Belgian railways; looking for a fit for purpose: business process maturity models from a user's perspective; enterprise information systems security: a case study in the banking sector; and implementing behavior driven development in an open source ERP.				Excluded	Excluded	new_screen			2						
247	Behave	2017 8th International Conference on Information and Communication Systems, ICICS 2017	The proceedings contain 65 papers. The topics discussed include: using behavior-driven development with hardware-software co-design for autonomous load management; dealing with decisional natural language why-question in business intelligence; sentence-aligned parallel corpus Amazigh-English; corpora for sentiment analysis of Arabic text in social media; ALIF editor for generating Arabic normalized lexicons; a brain friendly tool to facilitate research-teaching nexus: mind maps; adaptive e-learning web-based English tutor using data mining techniques and Jackson's learning styles; and towards a model-based approach for developing and QA of online business processes.		[No author name available]	2017 8th International Conference on Information and Communication Systems, ICICS 2017	The proceedings contain 65 papers. The topics discussed include: using behavior-driven development with hardware-software co-design for autonomous load management; dealing with decisional natural language why-question in business intelligence; sentence-aligned parallel corpus Amazigh-English; corpora for sentiment analysis of Arabic text in social media; ALIF editor for generating Arabic normalized lexicons; a brain friendly tool to facilitate research-teaching nexus: mind maps; adaptive e-learning web-based English tutor using data mining techniques and Jackson's learning styles; and towards a model-based approach for developing and QA of online business processes.				Excluded	Excluded	new_screen			2						
248	Behave	4th International Conference on Computer Science and Computational Intelligence: Enabling Collaboration to Escalate Impact of Research Results for Society, ICCSCI 2019	The proceedings contain 87 papers. The topics discussed include: comparative performance of filtering methods for reducing noise in ischemic posterior Fossa CT images; gender demography classification on instagram based on user's comments section; automotive security with authorization and tracking via gps; combination of test-driven development and behavior-driven development for improving backend testing performance; modeling of the acute lymphoblastic leukemia detection based on the principal object characteristics of the color image; music recommender system based on genre using convolutional recurrent neural networks; MobileNet convolutional neural networks and support vector machines for palmprint recognition; MVC architecture: a comparative study between laravel framework and slim framework in freelancer project monitoring system web based; and recommendation of scheduling tourism routes using tabu search method (case study Bandung).		[No author name available]	Procedia Computer Science	The proceedings contain 87 papers. The topics discussed include: comparative performance of filtering methods for reducing noise in ischemic posterior Fossa CT images; gender demography classification on instagram based on user's comments section; automotive security with authorization and tracking via gps; combination of test-driven development and behavior-driven development for improving backend testing performance; modeling of the acute lymphoblastic leukemia detection based on the principal object characteristics of the color image; music recommender system based on genre using convolutional recurrent neural networks; MobileNet convolutional neural networks and support vector machines for palmprint recognition; MVC architecture: a comparative study between laravel framework and slim framework in freelancer project monitoring system web based; and recommendation of scheduling tourism routes using tabu search method (case study Bandung).				Excluded	Excluded	new_screen			2						
249	Behave	CLOSER 2016 - Proceedings of the 6th International Conference on Cloud Computing and Services Science	The proceedings contain 88 papers. The topics discussed include: native cloud applications; SemNaaS: semantic web for network as a service; design time validation for the correct execution of BPMN collaborations; evidence collection in cloud provider chains; decision support system for adoption of cloud-based services; towards auditing of cloud provider chains using CloudTrust protocol; testing of web services using behavior-driven development; from architecture modeling to application provisioning for the cloud by combining UML and TOSCA; a scalable architecture for distributed OSGi in the cloud; LADY: dynamic resolution of assemblies for extensible and distributed .NET applications; and toward cloud-based classification and annotation support.		[No author name available]	CLOSER 2016 - Proceedings of the 6th International Conference on Cloud Computing and Services Science	The proceedings contain 88 papers. The topics discussed include: native cloud applications; SemNaaS: semantic web for network as a service; design time validation for the correct execution of BPMN collaborations; evidence collection in cloud provider chains; decision support system for adoption of cloud-based services; towards auditing of cloud provider chains using CloudTrust protocol; testing of web services using behavior-driven development; from architecture modeling to application provisioning for the cloud by combining UML and TOSCA; a scalable architecture for distributed OSGi in the cloud; LADY: dynamic resolution of assemblies for extensible and distributed .NET applications; and toward cloud-based classification and annotation support.				Excluded	Excluded	new_screen			2						
250	Behave	A Service Framework for Parallel Test Execution on a Developer's Local Development Workstation	The proliferation of distributed microservices driven by service oriented architecture and the effectiveness of agile software development processes such as Test Driven Development (TDD), Behavior Driven Development (BDD), inspired by extreme programming (XP), have driven the challenging necessity to receive prompt test feedback during software development iteratively. Although few test frameworks can execute unit tests in memory in parallel, no existing test frameworks can reliably perform parallel execution for the tests that rely on file system access, database fixtures and network communication. Isolated test execution environment with dedicated resources is a prerequisite to address these challenges. No previous research addresses this need to run groups of tests in parallel on the same development host. In this paper, to cut down test execution time, we present a service framework for parallel tests execution in a developer's containerized sandbox using operating system level virtualization provided by Docker, the new hot driver for Platform as a Service (PaaS).	agile development; cloud testing; Docker; parallel testing; test execution environment	Rahman, Mazedur; Chen, Zehua; Gao, Jerry	Proceedings of the 2015 IEEE Symposium on Service-Oriented System Engineering	The proliferation of distributed microservices driven by service oriented architecture and the effectiveness of agile software development processes such as Test Driven Development (TDD), Behavior Driven Development (BDD), inspired by extreme programming (XP), have driven the challenging necessity to receive prompt test feedback during software development iteratively. Although few test frameworks can execute unit tests in memory in parallel, no existing test frameworks can reliably perform parallel execution for the tests that rely on file system access, database fixtures and network communication. Isolated test execution environment with dedicated resources is a prerequisite to address these challenges. No previous research addresses this need to run groups of tests in parallel on the same development host. In this paper, to cut down test execution time, we present a service framework for parallel tests execution in a developer's containerized sandbox using operating system level virtualization provided by Docker, the new hot driver for Platform as a Service (PaaS).				Excluded	Excluded	new_screen			2						
251	Behave	A Systematic Literature Review on Quality Criteria for Agile Requirements Specifications	The quality of requirements is typically considered as an important factor for the quality of the end product. For traditional up-front requirements specifications, a number of standards have been defined on what constitutes good quality : Requirements should be complete, unambiguous, specific, time-bounded, consistent, etc. For agile requirements specifications, no new standards have been defined yet, and it is not clear yet whether traditional quality criteria still apply. To investigate what quality criteria for assessing the correctness of written agile requirements exist, we have conducted a systematic literature review. The review resulted in a list of 16 selected papers on this topic. These selected papers describe 28 different quality criteria for agile requirements specifications. We categorize and analyze these criteria and compare them with those from traditional requirements engineering. We discuss findings from the 16 papers in the form of recommendations for practitioners on quality assessment of agile requirements. At the same time, we indicate the open points in the form of a research agenda for researchers working on this topic .	Systematic literature review; Agile requirement; Correctness; Just-in-time; Quality assessment; Quality criteria	Heck, Petra; Zaidman, Andy	Software Quality Journal	The quality of requirements is typically considered as an important factor for the quality of the end product. For traditional up-front requirements specifications, a number of standards have been defined on what constitutes good quality : Requirements should be complete, unambiguous, specific, time-bounded, consistent, etc. For agile requirements specifications, no new standards have been defined yet, and it is not clear yet whether traditional quality criteria still apply. To investigate what quality criteria for assessing the correctness of written agile requirements exist, we have conducted a systematic literature review. The review resulted in a list of 16 selected papers on this topic. These selected papers describe 28 different quality criteria for agile requirements specifications. We categorize and analyze these criteria and compare them with those from traditional requirements engineering. We discuss findings from the 16 papers in the form of recommendations for practitioners on quality assessment of agile requirements. At the same time, we indicate the open points in the form of a research agenda for researchers working on this topic .				Excluded	Excluded	new_screen			2						
252	Behave	The Rails 3 Way	The Rails 3 Way is a comprehensive resource that digs into the new features in Rails 3 and perhaps more importantly, the rationale behind them.Yehuda Katz, Rails Core The Bible for Ruby on Rails Application Development Ruby on Rails strips complexity from the development process, enabling professional developers to focus on what matters most: delivering business value via clean and maintainable code. The Rails 3 Way is the only comprehensive, authoritative guide to delivering production-quality code with Rails 3. Pioneering Rails expert Obie Fernandez and a team of leading experts illuminate the entire Rails 3 API, along with the idioms, design approaches, and libraries that make developing applications with Rails so powerful. Drawing on their unsurpassed experience and track record, they address the real challenges development teams face, showing how to use Rails 3 to maximize your productivity. Using numerous detailed code examples, the author systematically covers Rails 3 key capabilities and subsystems, making this book a reference that you will turn to again and again. He presents advanced Rails programming techniques that have been proven effective in day-to-day usage on dozens of production Rails systems and offers important insights into behavior-driven development and production considerations such as scalability. Dive deep into the Rails 3 codebase and discover why Rails is designed the way it isand how to make it do what you want it to do. This book will help you Learn whats new in Rails 3 Increase your productivity as a web application developer Realize the overall joy in programming with Rails Leverage Rails powerful capabilities for building REST-compliant APIs Drive implementation and protect long-term maintainability using RSpec Design and manipulate your domain layer using Active Record Understand and program complex program flows using Action Controller Master sophisticated URL routing concepts Use Ajax techniques via Rails 3 support for unobtrusive JavaScript Learn to extend Rails with popular gems and plugins, and how to write your own Extend Rails with the best third-party plug-ins and write your own Integrate email services into your applications with Action Mailer Improve application responsiveness with background processing Create your own non-Active Record domain classes using Active Model Master Rails utility classes and extensions in Active Support		Fernandez, Obie		The Rails 3 Way is a comprehensive resource that digs into the new features in Rails 3 and perhaps more importantly, the rationale behind them.Yehuda Katz, Rails Core The Bible for Ruby on Rails Application Development Ruby on Rails strips complexity from the development process, enabling professional developers to focus on what matters most: delivering business value via clean and maintainable code. The Rails 3 Way is the only comprehensive, authoritative guide to delivering production-quality code with Rails 3. Pioneering Rails expert Obie Fernandez and a team of leading experts illuminate the entire Rails 3 API, along with the idioms, design approaches, and libraries that make developing applications with Rails so powerful. Drawing on their unsurpassed experience and track record, they address the real challenges development teams face, showing how to use Rails 3 to maximize your productivity. Using numerous detailed code examples, the author systematically covers Rails 3 key capabilities and subsystems, making this book a reference that you will turn to again and again. He presents advanced Rails programming techniques that have been proven effective in day-to-day usage on dozens of production Rails systems and offers important insights into behavior-driven development and production considerations such as scalability. Dive deep into the Rails 3 codebase and discover why Rails is designed the way it isand how to make it do what you want it to do. This book will help you Learn whats new in Rails 3 Increase your productivity as a web application developer Realize the overall joy in programming with Rails Leverage Rails powerful capabilities for building REST-compliant APIs Drive implementation and protect long-term maintainability using RSpec Design and manipulate your domain layer using Active Record Understand and program complex program flows using Action Controller Master sophisticated URL routing concepts Use Ajax techniques via Rails 3 support for unobtrusive JavaScript Learn to extend Rails with popular gems and plugins, and how to write your own Extend Rails with the best third-party plug-ins and write your own Integrate email services into your applications with Action Mailer Improve application responsiveness with background processing Create your own non-Active Record domain classes using Active Model Master Rails utility classes and extensions in Active Support				Excluded	Excluded	new_screen			2						
253	Behave	Using executable specification and regression testing for broadcast mechanism of visual programming language on smartphones	The rapid advancement of mobile computing technology and the rising usage of mobile apps made our daily life more productive. The mobile app should operate all the time bug-free in order to improve user satisfaction and offers great business value to the end user. At the same time, smartphones are full of special features that make testing of apps more challenging. Actually, the quality is a must for successful applications and it cannot be achieved without testing and verification. In this paper, we present the behavior driven development methodology and Cucumber framework to automate regression testing for Android apps. Particularly, the proposed methods use the visual programming language for smartphones (Catrobat) as a reference. The Catrobat program scripts communicate via a broadcast mechanism. The objective is to test the broadcast mechanism from different angles and track regression errors as well as specify and diagnose bugs with the help of executable specifications. The results show that the methods are able to effectively reveal deficiencies in the broadcast mechanism, and ensure that the app meets end users' expectations and needs. © 2018, International Association of Online Engineering.		Ali Z., Ayyal Awwad A.M., Slany W.	International Journal of Interactive Mobile Technologies	The rapid advancement of mobile computing technology and the rising usage of mobile apps made our daily life more productive. The mobile app should operate all the time bug-free in order to improve user satisfaction and offers great business value to the end user. At the same time, smartphones are full of special features that make testing of apps more challenging. Actually, the quality is a must for successful applications and it cannot be achieved without testing and verification. In this paper, we present the behavior driven development methodology and Cucumber framework to automate regression testing for Android apps. Particularly, the proposed methods use the visual programming language for smartphones (Catrobat) as a reference. The Catrobat program scripts communicate via a broadcast mechanism. The objective is to test the broadcast mechanism from different angles and track regression errors as well as specify and diagnose bugs with the help of executable specifications. The results show that the methods are able to effectively reveal deficiencies in the broadcast mechanism, and ensure that the app meets end users' expectations and needs. © 2018, International Association of Online Engineering.				Included	Included	new_screen			2						
254	Behave	Reconciling requirements and continuous integration in an agile context	The RE'18 theme is: 'Crossing Boundaries and Increasing Impact'. In this context we propose a tutorial on Requirements in an Agile context that aims at exploring the boundaries between requirements, specifications, stories, scenarios and tests. It follows the recent work started in the RE community about agility, from a practical point of view. © 2018 IEEE.		Mosser S., Bruel J.-M.	Proceedings - 2018 IEEE 26th International Requirements Engineering Conference, RE 2018	The RE'18 theme is: 'Crossing Boundaries and Increasing Impact'. In this context we propose a tutorial on Requirements in an Agile context that aims at exploring the boundaries between requirements, specifications, stories, scenarios and tests. It follows the recent work started in the RE community about agility, from a practical point of view. © 2018 IEEE.				Excluded	Excluded	new_screen			2						
255	Behave	The impact of tailoring criteria on agile practices adoption: A survey with novice agile practitioners in Brazil	The software development industry adopts agile methods in different ways by considering contextual requirements. To fulfill organizational needs, adoption strategies consider agile methods tailoring. However, tailoring according to the context of the organization remains a problem to be solved. Literature on criteria for adopting software development methods exists, but not specifically for agile methods. Given this scenario, the following research question arises: what is the impact of software method tailoring criteria on the adoption of agile practices? To answer this question, we conducted a survey among agile practitioners in Brazil to gather data about importance of the tailoring criteria and agile practices adopted. A model for agile practices adoption based on the tailoring criteria is proposed using the results of the survey with a majority of novice agile practitioners. The proposed model was validated using PLS-SEM (partial least squares structural equation modeling) and the survey data. Results show that adoption of agile practices was influenced by criteria such as external environment, previous knowledge and internal environment. Results also indicate that organizations tend to use hybrid/custom software methods and select agile practices according to their needs.	Agile method tailoring, Tailoring criteria, Agile practices selection, Agile practices adoption, PLS-SEM, Software method tailoring	Campanelli, Amadeu Silveira; Camilo, Ronaldo Darwich; Parreiras, Fernando Silva	Journal of Systems and Software	The software development industry adopts agile methods in different ways by considering contextual requirements. To fulfill organizational needs, adoption strategies consider agile methods tailoring. However, tailoring according to the context of the organization remains a problem to be solved. Literature on criteria for adopting software development methods exists, but not specifically for agile methods. Given this scenario, the following research question arises: what is the impact of software method tailoring criteria on the adoption of agile practices? To answer this question, we conducted a survey among agile practitioners in Brazil to gather data about importance of the tailoring criteria and agile practices adopted. A model for agile practices adoption based on the tailoring criteria is proposed using the results of the survey with a majority of novice agile practitioners. The proposed model was validated using PLS-SEM (partial least squares structural equation modeling) and the survey data. Results show that adoption of agile practices was influenced by criteria such as external environment, previous knowledge and internal environment. Results also indicate that organizations tend to use hybrid/custom software methods and select agile practices according to their needs.				Excluded	Excluded	new_screen			2						
256	Behave	Rules of thumb to increase the software quality through testing	The software maintenance typically requires 40-80% of the overall project costs, and this considerable variability mostly depends on the software internal quality: the more the software is designed and implemented to constantly welcome new changes, the lower will be the maintenance costs. The internal quality is typically enforced through testing, which in turn also affects the development and maintenance costs. This is the reason why testing methodologies have become a major concern for any company that builds - or is involved in building - software. Although there is no testing approach that suits all contexts, we infer some general guidelines learned during the Development of the Italian Single-dish COntrol System (DISCOS), which is a project aimed at producing the control software for the three INAF radio telescopes (the Medicina and Noto dishes, and the newly-built SRT). These guidelines concern both the development and the maintenance phases, and their ultimate goal is to maximize the DISCOS software quality through a Behavior-Driven Development (BDD) workflow beside a continuous delivery pipeline. We consider different topics and patterns; they involve the proper apportion of the tests (from end-to-end to low-level tests), the choice between hardware simulators and mockers, why and how to apply TDD and the dependency injection to increase the test coverage, the emerging technologies available for test isolation, bug fixing, how to protect the system from the external resources changes (firmware updating, hardware substitution, etc.) and, eventually, how to accomplish BDD starting from functional tests and going through integration and unit tests. We discuss pros and cons of each solution and point out the motivations of our choices either as a general rule or narrowed in the context of the DISCOS project. © COPYRIGHT SPIE. Downloading of the abstract is permitted for personal use only.		Buttu M., Bartolini M., Migoni C., Orlati A., Poppi S., Righini S.	Proceedings of SPIE - The International Society for Optical Engineering	The software maintenance typically requires 40-80% of the overall project costs, and this considerable variability mostly depends on the software internal quality: the more the software is designed and implemented to constantly welcome new changes, the lower will be the maintenance costs. The internal quality is typically enforced through testing, which in turn also affects the development and maintenance costs. This is the reason why testing methodologies have become a major concern for any company that builds - or is involved in building - software. Although there is no testing approach that suits all contexts, we infer some general guidelines learned during the Development of the Italian Single-dish COntrol System (DISCOS), which is a project aimed at producing the control software for the three INAF radio telescopes (the Medicina and Noto dishes, and the newly-built SRT). These guidelines concern both the development and the maintenance phases, and their ultimate goal is to maximize the DISCOS software quality through a Behavior-Driven Development (BDD) workflow beside a continuous delivery pipeline. We consider different topics and patterns; they involve the proper apportion of the tests (from end-to-end to low-level tests), the choice between hardware simulators and mockers, why and how to apply TDD and the dependency injection to increase the test coverage, the emerging technologies available for test isolation, bug fixing, how to protect the system from the external resources changes (firmware updating, hardware substitution, etc.) and, eventually, how to accomplish BDD starting from functional tests and going through integration and unit tests. We discuss pros and cons of each solution and point out the motivations of our choices either as a general rule or narrowed in the context of the DISCOS project. © COPYRIGHT SPIE. Downloading of the abstract is permitted for personal use only.				Excluded	Excluded	new_screen			2						
257	Behave	Automated testing framework development based on social interaction and communication principles	The speed of development of the IT industry as well as the computational power which are increasing exponentially, create great competitiveness in the process of development but also in the launching of software products on the market. Automated testing comes to help with these challenges by trying to increase the speed of development by offering fast feedback and trustworthy quality by means of repeated runs of the implemented tests. This isn't a problem just on a technical level, but also on a social level, especially in the area of communication and understanding the requirements of the client. This work presents the implementation of an automated testing framework which also addresses the social problems. BDD or “Behavior Driven Development” includes an approach which would like to line up the area of client requests to the technical area, offering a uniform platform of collaboration and development. The implementation of this principle is applied in an MVP (Minimum Viable Product) type project which is meant to demonstrate the technical solution which may draw together, both socially and communication wise, the business teams and the technical implementation teams.	testing process;BDD;automated testing;Gherkin language	A. Contan; L. Miclea; C. Dehelean	2017 14th International Conference on Engineering of Modern Electric Systems (EMES)	The speed of development of the IT industry as well as the computational power which are increasing exponentially, create great competitiveness in the process of development but also in the launching of software products on the market. Automated testing comes to help with these challenges by trying to increase the speed of development by offering fast feedback and trustworthy quality by means of repeated runs of the implemented tests. This isn't a problem just on a technical level, but also on a social level, especially in the area of communication and understanding the requirements of the client. This work presents the implementation of an automated testing framework which also addresses the social problems. BDD or “Behavior Driven Development” includes an approach which would like to line up the area of client requests to the technical area, offering a uniform platform of collaboration and development. The implementation of this principle is applied in an MVP (Minimum Viable Product) type project which is meant to demonstrate the technical solution which may draw together, both socially and communication wise, the business teams and the technical implementation teams.				Included	Included	new_screen			2						
258	Behave	Enabling faith-inspired education on the sustainable development goals through e-learning	The Sustainable Development Goals (SDGs) are composed from a variety of universal goals. They come with a heavy load on ethical demands while they do not provide any ethical guidance. One possibility to fill this void is to teach the SDGs with a faith-based narrative. Grown out of a workshop by Bread for World we will present our approach of Ownership-inspired Behavior-driven development, which is a strategy for an e-learning governance to introduce an Android app to support e-learning on the SDGs in theological education in remote areas in the Global South. Our goal is to develop a governance strategy for higher theological education to fill the SDGs with a faith-based narrative by using e-learning technology. Based on the staircase curriculum for the education of future church leaders developed by the British FBO Relay Trust we introduce the theoretical framework for this goal, which makes the transfer from a hierarchical governance structure found in many African societies into a dynamic e-learning framework. © Springer International Publishing AG 2018.		Gottschalk J., Winther-Nielsen N.	World Sustainability Series	The Sustainable Development Goals (SDGs) are composed from a variety of universal goals. They come with a heavy load on ethical demands while they do not provide any ethical guidance. One possibility to fill this void is to teach the SDGs with a faith-based narrative. Grown out of a workshop by Bread for World we will present our approach of Ownership-inspired Behavior-driven development, which is a strategy for an e-learning governance to introduce an Android app to support e-learning on the SDGs in theological education in remote areas in the Global South. Our goal is to develop a governance strategy for higher theological education to fill the SDGs with a faith-based narrative by using e-learning technology. Based on the staircase curriculum for the education of future church leaders developed by the British FBO Relay Trust we introduce the theoretical framework for this goal, which makes the transfer from a hierarchical governance structure found in many African societies into a dynamic e-learning framework. © Springer International Publishing AG 2018.				Excluded	Excluded	new_screen			2						
259	Behave	Using BDD and SBVR to Refine Business Goals into an Event-B Model: A Research Idea	The transition from a requirements document to a formal specification in Event-B is usually manual and ad-hoc. In order to bridge this gap, we propose a method based on Behavior-Driven Development, an agile approach, and that uses a structured natural language conformant to the formalism of the Semantics of Business Vocabulary and Business Rules (SBVR) standard. This method will successively refine a list of high-level business goals into an Event-B model using transformations. In this paper we present our research idea, describing the steps of this method and showing an example based on the Train System scenario described by Abrial.	BDD; event-B; formal methods; method; requirements; SBVR	Siqueira, Fabio Levy; de Sousa, Thiago C.; Silva, Paulo S. Muniz	Proceedings of the 5th International FME Workshop on Formal Methods in Software Engineering	The transition from a requirements document to a formal specification in Event-B is usually manual and ad-hoc. In order to bridge this gap, we propose a method based on Behavior-Driven Development, an agile approach, and that uses a structured natural language conformant to the formalism of the Semantics of Business Vocabulary and Business Rules (SBVR) standard. This method will successively refine a list of high-level business goals into an Event-B model using transformations. In this paper we present our research idea, describing the steps of this method and showing an example based on the Train System scenario described by Abrial.				Included	Included	new_screen			2						
260	Behave	Using behaviour-driven development with hardware-software co-design for autonomous load management	The typical approach to designing embedded systems manages the specification and design of the hardware and software separately. HW/SW Co-design is used, in embedded computing, to allow the hardware and the software to be designed and implemented together and make sure that the non-functional properties are met. Behavior-driven development (BDD) is an agile software development approach that spurs collaboration of project stakeholders to ensure the right software is developed to meet their needs. BDD describes the behavior of the system as executable user stories and focuses on how the system behaves for users interact with the system. In this paper, we introduce an approach that integrates BDD with HW/SW Co-design. The approach provides the ability to describe the behavior of the software as executable user stories in a HW/SW Co-design environment. The approach is evaluated using a renewable energy project in collaboration with a private company in Canada to build a system for autonomous load management of self-forming renewable energy nanogrids.	Embedded Systems;Behaviour-Driven Development;Hardware-Software Co-Design;Test-driven development;Nanogrid systems;Agile software	M. Alhaj; G. Arbez; L. Peyton	2017 8th International Conference on Information and Communication Systems (ICICS)	The typical approach to designing embedded systems manages the specification and design of the hardware and software separately. HW/SW Co-design is used, in embedded computing, to allow the hardware and the software to be designed and implemented together and make sure that the non-functional properties are met. Behavior-driven development (BDD) is an agile software development approach that spurs collaboration of project stakeholders to ensure the right software is developed to meet their needs. BDD describes the behavior of the system as executable user stories and focuses on how the system behaves for users interact with the system. In this paper, we introduce an approach that integrates BDD with HW/SW Co-design. The approach provides the ability to describe the behavior of the software as executable user stories in a HW/SW Co-design environment. The approach is evaluated using a renewable energy project in collaboration with a private company in Canada to build a system for autonomous load management of self-forming renewable energy nanogrids.				Included	Included	new_screen			2						
261	Behave	Towards automated requirements checking throughout development processes of interactive systems	The user-centered development process of interactive systems is iterative and, during multiple iterations, users have the opportunity to bring new requirements that are very likely to have an impact, not only in future development, but also affect previously developed artifacts. Manual testing of all artifacts when new requirements are introduced can be cumbersome and time consuming. For that, we need flexible methods to ensure continuous consistency and accuracy among the various artifacts employed to build interactive systems. The ultimate goal of this position paper is to briefly present our vision on an approach for automating the requirements assessment using a Behavior-Driven Development perspective. Thereby, automated tests can run early in the design process, providing a continuous quality assurance of requirements, and helping clients and teams to identify potential problems and inconsistencies before commitments with software implementation.		Silva T.R., Winckler M.A.A.	CEUR Workshop Proceedings	The user-centered development process of interactive systems is iterative and, during multiple iterations, users have the opportunity to bring new requirements that are very likely to have an impact, not only in future development, but also affect previously developed artifacts. Manual testing of all artifacts when new requirements are introduced can be cumbersome and time consuming. For that, we need flexible methods to ensure continuous consistency and accuracy among the various artifacts employed to build interactive systems. The ultimate goal of this position paper is to briefly present our vision on an approach for automating the requirements assessment using a Behavior-Driven Development perspective. Thereby, automated tests can run early in the design process, providing a continuous quality assurance of requirements, and helping clients and teams to identify potential problems and inconsistencies before commitments with software implementation.				Excluded	Excluded	new_screen			2						
262	Behave	Automated Test Input Generation via Model Inference Based on User Story and Acceptance Criteria for Mobile Application Development	"There has been observed explosive growth in the development of mobile applications (apps) for Android and iOS operating systems, which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of developers to devote time and sufficient efforts towards testing to make the apps bug-free and operational in the hands of end-users without any hiccup. Manual testing procedures take a prolonged amount of time in writing test cases, and in some cases, the full testing requirements are not met. Besides, the insufficient knowledge of tester also impacts the overall quality and bug-free apps. To overcome the obstacles of testing, we propose a new testing methodology cum tool called ""AgileUATM"" which works primarily towards white-box and black-box testing. To evaluate the validity of the proposed tool, we put the tool in a real-time operational environment concerning mobile test apps. By using this tool, all the acceptance criteria are determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. The results show that the proposed tool generated effective and accurate test cases, test input. Meanwhile, expected output was also generated in a unified fashion from the user stories to meet acceptance criteria. The proposed solution also reduced the development time to identify test data as compared to manual Behavior-Driven Development (BDD) methodologies. This tool can support the developers to get a better idea about the required tests and able to translate the customer's natural languages to computer languages as well. This paper fulfills an approach to suitably test mobile application development. © 2020 World Scientific Publishing Company."		Nguyen D.-M., Huynh Q.-T., Ha N.-H., Nguyen T.-H.	International Journal of Software Engineering and Knowledge Engineering	"There has been observed explosive growth in the development of mobile applications (apps) for Android and iOS operating systems, which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of developers to devote time and sufficient efforts towards testing to make the apps bug-free and operational in the hands of end-users without any hiccup. Manual testing procedures take a prolonged amount of time in writing test cases, and in some cases, the full testing requirements are not met. Besides, the insufficient knowledge of tester also impacts the overall quality and bug-free apps. To overcome the obstacles of testing, we propose a new testing methodology cum tool called ""AgileUATM"" which works primarily towards white-box and black-box testing. To evaluate the validity of the proposed tool, we put the tool in a real-time operational environment concerning mobile test apps. By using this tool, all the acceptance criteria are determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. The results show that the proposed tool generated effective and accurate test cases, test input. Meanwhile, expected output was also generated in a unified fashion from the user stories to meet acceptance criteria. The proposed solution also reduced the development time to identify test data as compared to manual Behavior-Driven Development (BDD) methodologies. This tool can support the developers to get a better idea about the required tests and able to translate the customer's natural languages to computer languages as well. This paper fulfills an approach to suitably test mobile application development. © 2020 World Scientific Publishing Company."				Included	Included	new_screen			2						
263	Behave	Security and privacy behavior definition for behavior driven development	There is an issue when security measures are implemented and tested while using agile software development techniques such as Behavior Driven Development (BDD). We need to define the necessary levels of security and the privacy behaviors and acceptance criteria for the BDD. A method for defining the acceptance criteria (BehaveSafe) by creating a threat and countermeasure graph called theT&C graph is proposed in this paper. We have estimated the efficiency of our method with a web based system. © Springer International Publishing Switzerland 2014.		Okubo T., Kakizaki Y., Kobashi T., Washizaki H., Ogata S., Kaiya H., Yoshioka N.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	There is an issue when security measures are implemented and tested while using agile software development techniques such as Behavior Driven Development (BDD). We need to define the necessary levels of security and the privacy behaviors and acceptance criteria for the BDD. A method for defining the acceptance criteria (BehaveSafe) by creating a threat and countermeasure graph called theT&C graph is proposed in this paper. We have estimated the efficiency of our method with a web based system. © Springer International Publishing Switzerland 2014.				Included	Included	new_screen			2						
264	Behave	Effort Estimation using Bayesian Networks for Agile Development	This article proposes an automatic method to estimate the effort of development based on narrative texts. Narrative used the agile method. We propose techniques of symbolic analysis of natural language were used for extraction of verbs and nouns, and verbal reduction (verbs in infinitive), and the standardization of keywords through synonyms. For the machine learning was used if the naive Bayesian classifier model. Apply and test the model in real environment that used the narratives in the Portuguese language in the form of BDD (Behavior Driven Development). In these tests, obtaining an accuracy of 83% in the estimates of the story points.	Bayesian network model;Agile;Estimation	C. Ratke; H. H. Hoffmann; T. Gaspar; P. E. Floriani	2019 2nd International Conference on Computer Applications & Information Security (ICCAIS)	This article proposes an automatic method to estimate the effort of development based on narrative texts. Narrative used the agile method. We propose techniques of symbolic analysis of natural language were used for extraction of verbs and nouns, and verbal reduction (verbs in infinitive), and the standardization of keywords through synonyms. For the machine learning was used if the naive Bayesian classifier model. Apply and test the model in real environment that used the narratives in the Portuguese language in the form of BDD (Behavior Driven Development). In these tests, obtaining an accuracy of 83% in the estimates of the story points.				Excluded	Excluded	new_screen			2						
265	Behave	Test-Driven Java Development - Second Edition: Invoke TDD Principles for End-to-End Application Development	This book will teach the concepts of test driven development in Java so you can build clean, maintainable and robust code Key Features Explore the most popular TDD tools and frameworks and become more proficient in building applicationsCreate applications with better code design, fewer bugs, and higher test coverage, enabling you to get them to market quickly Implement test-driven programming methods into your development workflows Book Description Test-driven development (TDD) is a development approach that relies on a test-first procedure that emphasizes writing a test before writing the necessary code, and then refactoring the code to optimize it. The value of performing TDD with Java, one of the longest established programming languages, is to improve the productivity of programmers and the maintainability and performance of code, and develop a deeper understanding of the language and how to employ it effectively. Starting with the basics of TDD and understanding why its adoption is beneficial, this book will take you from the first steps of TDD with Java until you are confident enough to embrace the practice in your day-to-day routine. You'll be guided through setting up tools, frameworks, and the environment you need, and we will dive right into hands-on exercises with the goal of mastering one practice, tool, or framework at a time. You'll learn about the Red-Green-Refactor procedure, how to write unit tests, and how to use them as executable documentation. With this book, you'll also discover how to design simple and easily maintainable code, work with mocks, utilize behavior-driven development, refactor old legacy code, and release a half-finished feature to production with feature toggles. You will finish this book with a deep understanding of the test-driven development methodology and the confidence to apply it to application programming with Java. What you will learn Explore the tools and frameworks required for effective TDD development Perform the Red-Green-Refactor process efficiently, the pillar around which all other TDD procedures are based Master effective unit testing in isolation from the rest of your code Design simple and easily maintainable code by implementing different techniques Use mocking frameworks and techniques to easily write and quickly execute tests Develop an application to implement behavior-driven development in conjunction with unit testing Enable and disable features using feature toggles Who This Book Is ForIf you're an experienced Java developer and want to implement more effective methods of programming systems and applications, then this book is for you.		Garcia, Alex; Farcic, Viktor		This book will teach the concepts of test driven development in Java so you can build clean, maintainable and robust code Key Features Explore the most popular TDD tools and frameworks and become more proficient in building applicationsCreate applications with better code design, fewer bugs, and higher test coverage, enabling you to get them to market quickly Implement test-driven programming methods into your development workflows Book Description Test-driven development (TDD) is a development approach that relies on a test-first procedure that emphasizes writing a test before writing the necessary code, and then refactoring the code to optimize it. The value of performing TDD with Java, one of the longest established programming languages, is to improve the productivity of programmers and the maintainability and performance of code, and develop a deeper understanding of the language and how to employ it effectively. Starting with the basics of TDD and understanding why its adoption is beneficial, this book will take you from the first steps of TDD with Java until you are confident enough to embrace the practice in your day-to-day routine. You'll be guided through setting up tools, frameworks, and the environment you need, and we will dive right into hands-on exercises with the goal of mastering one practice, tool, or framework at a time. You'll learn about the Red-Green-Refactor procedure, how to write unit tests, and how to use them as executable documentation. With this book, you'll also discover how to design simple and easily maintainable code, work with mocks, utilize behavior-driven development, refactor old legacy code, and release a half-finished feature to production with feature toggles. You will finish this book with a deep understanding of the test-driven development methodology and the confidence to apply it to application programming with Java. What you will learn Explore the tools and frameworks required for effective TDD development Perform the Red-Green-Refactor process efficiently, the pillar around which all other TDD procedures are based Master effective unit testing in isolation from the rest of your code Design simple and easily maintainable code by implementing different techniques Use mocking frameworks and techniques to easily write and quickly execute tests Develop an application to implement behavior-driven development in conjunction with unit testing Enable and disable features using feature toggles Who This Book Is ForIf you're an experienced Java developer and want to implement more effective methods of programming systems and applications, then this book is for you.				Excluded	Excluded	new_screen			2						
266	Behave	Behavior-driven development using specification by example: An approach for delivering the right software built in right way	"This chapter highlights a crucial problem seen often in software development that is bridging the communication gap between business and Development"" (BDD) methodology supplemented with ""Specification By Example"" approach of delivering the right software that matters. Effective communication has always been a challenge between clients, business stakeholders, project managers, developers, testers and business analysts because a ""ubiquitous"" language that every one can easily understand and use does not exist. Specification By Example serves as that ubiquitous language for all, helps build right software that matters through effective communication. Specifications are written in plain English language using the Gherkin syntax to describe various behaviors of software. BDD tools help write software specification using gherkin language and also create a living documentation that is automatically generated by programming language reflecting the current state of software at any given point of time. © 2016 by IGI Global. All rights reserved."		Menon P.R.	Emerging Innovations in Agile Software Development	"This chapter highlights a crucial problem seen often in software development that is bridging the communication gap between business and Development"" (BDD) methodology supplemented with ""Specification By Example"" approach of delivering the right software that matters. Effective communication has always been a challenge between clients, business stakeholders, project managers, developers, testers and business analysts because a ""ubiquitous"" language that every one can easily understand and use does not exist. Specification By Example serves as that ubiquitous language for all, helps build right software that matters through effective communication. Specifications are written in plain English language using the Gherkin syntax to describe various behaviors of software. BDD tools help write software specification using gherkin language and also create a living documentation that is automatically generated by programming language reflecting the current state of software at any given point of time. © 2016 by IGI Global. All rights reserved."				Excluded	Excluded	new_screen			2						
267	Behave	The Business Transformation Framework and Enterprise Architecture Framework for Managers in Business Innovation: An Applied Holistic Mathematical Model	This journal article proposes a cross-business domain applied holistic mathematical model (AHMM) that is the result of a lifetime long research on business transformations, applied mathematics, software modelling, business engineering, financial analysis, and global enterprise architecture. This ultimate research is based on an authentic and proprietary mixed research method that is supported by an underlining mainly qualitative holistic reasoning model module. The proposed AHMM formalism attempts to mimic some functions of the human brain, which uses empirical processes that are mainly based on the beam-search, like heuristic decision-making process. The AHMM can be used to implement a decision-making system or an expert system that can integrate in the enterprise’s business, information and communication technology environments. The AHMM uses a behaviour driven development environment or a natural language environment that can be easily adopted by the project’s development teams. The AHMM offers a high level implementation environment that can be used by any team member without any prior computer sciences qualification. The AHMM can be used also to model enterprise architecture (EA) blueprints, business transformation projects, or knowledge management systems; it is supported by many real-life cases of various business domains. The uniqueness of this research is that the AHMM promotes a holistic unbundling process, the alignment of various EA standards and transformation strategies to support business transformation projects. © 2021 IGI Global. All rights reserved.		Trad A.	International Journal of Service Science, Management, Engineering, and Technology	This journal article proposes a cross-business domain applied holistic mathematical model (AHMM) that is the result of a lifetime long research on business transformations, applied mathematics, software modelling, business engineering, financial analysis, and global enterprise architecture. This ultimate research is based on an authentic and proprietary mixed research method that is supported by an underlining mainly qualitative holistic reasoning model module. The proposed AHMM formalism attempts to mimic some functions of the human brain, which uses empirical processes that are mainly based on the beam-search, like heuristic decision-making process. The AHMM can be used to implement a decision-making system or an expert system that can integrate in the enterprise’s business, information and communication technology environments. The AHMM uses a behaviour driven development environment or a natural language environment that can be easily adopted by the project’s development teams. The AHMM offers a high level implementation environment that can be used by any team member without any prior computer sciences qualification. The AHMM can be used also to model enterprise architecture (EA) blueprints, business transformation projects, or knowledge management systems; it is supported by many real-life cases of various business domains. The uniqueness of this research is that the AHMM promotes a holistic unbundling process, the alignment of various EA standards and transformation strategies to support business transformation projects. © 2021 IGI Global. All rights reserved.				Excluded	Excluded	new_screen			2						
268	Behave	Ontological syntax highlighting	This paper deals with the special type of syntax highlighting which is powered by combination of DEMO methodology (Design & Engineering Methodology for Organizations), BDD technique (Behaviour-Driven Development). Main contribution of this paper is the idea how to highlight business relevant code in IDEs (Integrated Development Environments) and notice a developer about the fact that important part of code base is edited. The proposal of the implementation encounters usage of code coverage technique and user stories derived upon DEMO methodology. © 2018 Author(s).		Matula J., Zacek J.	AIP Conference Proceedings	This paper deals with the special type of syntax highlighting which is powered by combination of DEMO methodology (Design & Engineering Methodology for Organizations), BDD technique (Behaviour-Driven Development). Main contribution of this paper is the idea how to highlight business relevant code in IDEs (Integrated Development Environments) and notice a developer about the fact that important part of code base is edited. The proposal of the implementation encounters usage of code coverage technique and user stories derived upon DEMO methodology. © 2018 Author(s).				Included	Included	new_screen			2						
269	Behave	A History of the Groovy Programming Language	This paper describes the history of the Groovy programming language. At the time of Groovy’s inception, Java was a dominant programming language with a wealth of useful libraries. Despite this, it was perceived by some to be evolving slowing and to have shortcomings for scripting, rapid prototyping and when trying to write minimalistic code. Other languages seemed to be innovating faster than Java and, while overcoming some of Java’s shortcomings, used syntax that was less familiar to Java developers. Integration with Java libraries was also non-optimal. Groovy was created as a complementary language to Java—its dynamic counterpart. It would look and feel like Java but focus on extensibility and rapid innovation. Groovy would borrow ideas from dynamic languages like Ruby, Python and Smalltalk where needed to provide compelling JVM solutions for some of Java’s shortcomings. Groovy supported innovation through its runtime and compile-time metaprogramming capabilities. It supported simple operator overloading, had a flexible grammar and was extensible. These characteristics made it suitable for growing the language to have new commands (verbs) and properties (nouns) specific to a particular domain, a so called Domain Specific Language (DSL). While still intrinsically linked with Java, over time Groovy has evolved from a niche dynamic scripting language into a compelling mainstream language. After many years as a principally dynamically-typed language, a static nature was added to Groovy. Code could be statically type checked or when dynamic features weren’t needed, they could be turned off entirely for Java-like performance. A number of nuances to the static nature came about to support the style of coding used by Groovy developers. Many choices made by Groovy in its design, later appeared in other languages (Swift, C#, Kotlin, Ceylon, PHP, Ruby, Coffeescript, Scala, Frege, TypeScript and Java itself). This includes Groovy’s dangling closure, Groovy builders, null-safe navigation, the Elvis operator, ranges, the spaceship operator, and flow typing. For most languages, we don’t know to what extent Groovy played a part in their choices. We do know that Kotlin took inspiration from Groovy’s dangling closures, builder concept, default it parameter for closures, templates and interpolated strings, null-safe navigation and the Elvis operator. The leadership, governance and sponsorship arrangements of Groovy have evolved over time, but Groovy has always been a successful highly collaborative open source project driven more by the needs of the community than by a vision of a particular company or person.	Closure; Domain Specific Languages; Dynamic typing; Extensibility; Functional programming; Metaprogramming; Object-oriented; Scripting; Static typing	King, Paul	Proc. ACM Program. Lang.	This paper describes the history of the Groovy programming language. At the time of Groovy’s inception, Java was a dominant programming language with a wealth of useful libraries. Despite this, it was perceived by some to be evolving slowing and to have shortcomings for scripting, rapid prototyping and when trying to write minimalistic code. Other languages seemed to be innovating faster than Java and, while overcoming some of Java’s shortcomings, used syntax that was less familiar to Java developers. Integration with Java libraries was also non-optimal. Groovy was created as a complementary language to Java—its dynamic counterpart. It would look and feel like Java but focus on extensibility and rapid innovation. Groovy would borrow ideas from dynamic languages like Ruby, Python and Smalltalk where needed to provide compelling JVM solutions for some of Java’s shortcomings. Groovy supported innovation through its runtime and compile-time metaprogramming capabilities. It supported simple operator overloading, had a flexible grammar and was extensible. These characteristics made it suitable for growing the language to have new commands (verbs) and properties (nouns) specific to a particular domain, a so called Domain Specific Language (DSL). While still intrinsically linked with Java, over time Groovy has evolved from a niche dynamic scripting language into a compelling mainstream language. After many years as a principally dynamically-typed language, a static nature was added to Groovy. Code could be statically type checked or when dynamic features weren’t needed, they could be turned off entirely for Java-like performance. A number of nuances to the static nature came about to support the style of coding used by Groovy developers. Many choices made by Groovy in its design, later appeared in other languages (Swift, C#, Kotlin, Ceylon, PHP, Ruby, Coffeescript, Scala, Frege, TypeScript and Java itself). This includes Groovy’s dangling closure, Groovy builders, null-safe navigation, the Elvis operator, ranges, the spaceship operator, and flow typing. For most languages, we don’t know to what extent Groovy played a part in their choices. We do know that Kotlin took inspiration from Groovy’s dangling closures, builder concept, default it parameter for closures, templates and interpolated strings, null-safe navigation and the Elvis operator. The leadership, governance and sponsorship arrangements of Groovy have evolved over time, but Groovy has always been a successful highly collaborative open source project driven more by the needs of the community than by a vision of a particular company or person.				Excluded	Excluded	new_screen			2						
270	Behave	Integrating behavior driven development and programming by contract	This paper developed a Contracted Behavior Driven Development (CBDD) method that extends and combines the ideas behind Test/Behavior Driven Development (TDD/BDD) and Programming by Contract (PBC) to improve the overall stability and quality of a system. A tool is developed to derive unit tests automatically by analyzing human written specifications for preconditions and post-conditions when coupled with data definitions. These results will be used to generate code to be run by a unit testing framework before deployment, either as part of a continuous integration environment or by individual developers. The tool will also generate wireframe classes implementing pre and post-conditions within the code and using runtime contract analysis to generate information when an exception occurs, thereby helping to automate verification of bug fixes. © 2013 Springer-Verlag Berlin Heidelberg.		Schoeneman L., Liu J.B.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	This paper developed a Contracted Behavior Driven Development (CBDD) method that extends and combines the ideas behind Test/Behavior Driven Development (TDD/BDD) and Programming by Contract (PBC) to improve the overall stability and quality of a system. A tool is developed to derive unit tests automatically by analyzing human written specifications for preconditions and post-conditions when coupled with data definitions. These results will be used to generate code to be run by a unit testing framework before deployment, either as part of a continuous integration environment or by individual developers. The tool will also generate wireframe classes implementing pre and post-conditions within the code and using runtime contract analysis to generate information when an exception occurs, thereby helping to automate verification of bug fixes. © 2013 Springer-Verlag Berlin Heidelberg.				Included	Included	new_screen			2						
271	Behave	Transit use and the work commute: Analyzing the role of last mile issues	This paper examines the role that public transport last mile problems play in mode choice decisions of commuters, while controlling for trip, built environment, and decision maker related variables. Last-mile problems arise due to lack of adequate connectivity between transit stops and trip origin or termination points. The paper is motivated by previous literature which has pointed out that high-quality public transit needs to consider end-to-end connectivity from trip origins to destinations. In contrast to previous work on transit last mile problems, which has focused on physical distance and sidewalks to transit stops, we consider a wider range of area factors including transit availability, job accessibility, parking costs, the quality of the pedestrian environment and risks to pedestrians from vehicular traffic, and social characteristics such as street-level crime. Using a discrete choice model, our goal is to unpack ways in which such factors contribute to the last-mile problem in home-based work trips, while controlling for these wider range of factors as well as the usual variables such as cost and trip time that inform mode choice. We find that the prevalence of non-domestic violent crimes reduces the odds of using all types of non-motorized alternatives as well as transit that is accessed either by walking or driving. Using compensating variation to measure welfare changes, we show that there are significant benefits that could be brought to transit service users through increasing safety in the transit access trip. By separately controlling for origin and destination transit accessibility, we show that improved destination accessibility significantly boosts transit use to a greater degree than increases in origin level accessibility. These findings argue for improving accessibility and related job densities at employment centers.	Transit use, Last mile problems, Crime, Accessibility, Destination accessibility, Mode choice	Tilahun, Nebiyou; Thakuriah, Piyushimita (Vonu); Li, Moyin; Keita, Yaye	Journal of Transport Geography	This paper examines the role that public transport last mile problems play in mode choice decisions of commuters, while controlling for trip, built environment, and decision maker related variables. Last-mile problems arise due to lack of adequate connectivity between transit stops and trip origin or termination points. The paper is motivated by previous literature which has pointed out that high-quality public transit needs to consider end-to-end connectivity from trip origins to destinations. In contrast to previous work on transit last mile problems, which has focused on physical distance and sidewalks to transit stops, we consider a wider range of area factors including transit availability, job accessibility, parking costs, the quality of the pedestrian environment and risks to pedestrians from vehicular traffic, and social characteristics such as street-level crime. Using a discrete choice model, our goal is to unpack ways in which such factors contribute to the last-mile problem in home-based work trips, while controlling for these wider range of factors as well as the usual variables such as cost and trip time that inform mode choice. We find that the prevalence of non-domestic violent crimes reduces the odds of using all types of non-motorized alternatives as well as transit that is accessed either by walking or driving. Using compensating variation to measure welfare changes, we show that there are significant benefits that could be brought to transit service users through increasing safety in the transit access trip. By separately controlling for origin and destination transit accessibility, we show that improved destination accessibility significantly boosts transit use to a greater degree than increases in origin level accessibility. These findings argue for improving accessibility and related job densities at employment centers.				Excluded	Excluded	new_screen			2						
272	Behave	Extending behavior-driven development for assessing user interface design artifacts	This paper presents a scenario-based approach to specify requirements and tests by extending Behavior-Driven Development (BDD) with the aim of ensuring the consistency between user requirements and user interface design artifacts. The approach has been evaluated by exploiting user requirements specified by a group of potential Product Owners (POs) for a web system to book business trips. Such requirements gave rise to a set of User Stories that have been refined and used to automatically check the consistency of task models, user interface (UI) prototypes, and final UIs of the system. The results have shown our approach was able to identify different types of inconsistencies in the set of analyzed artifacts and consistently keep the semantic traces between them. © 2019 Knowledge Systems Institute Graduate School. All rights reserved.		Silva T.R., Winckler M., Trætteberg H.	Proceedings of the International Conference on Software Engineering and Knowledge Engineering, SEKE	This paper presents a scenario-based approach to specify requirements and tests by extending Behavior-Driven Development (BDD) with the aim of ensuring the consistency between user requirements and user interface design artifacts. The approach has been evaluated by exploiting user requirements specified by a group of potential Product Owners (POs) for a web system to book business trips. Such requirements gave rise to a set of User Stories that have been refined and used to automatically check the consistency of task models, user interface (UI) prototypes, and final UIs of the system. The results have shown our approach was able to identify different types of inconsistencies in the set of analyzed artifacts and consistently keep the semantic traces between them. © 2019 Knowledge Systems Institute Graduate School. All rights reserved.				Included	Included	new_screen			2						
273	Behave	Beast Methodology: An Agile Testing Methodology for Multi-Agent Systems Based on Behaviour Driven Development	This paper presents a testing methodology to apply Behaviour Driven Development (BDD) techniques while developing Multi-Agent Systems (MASs), termed BEhavioural Agent Simple Testing (BEAST) Methodology. This methodology is supported by the open source framework (BEAST Tool) which automatically generates test cases skeletons from BDD scenarios specifications. The developed framework allows the testing of MASs based on JADE or JADEX platforms. In addition, this framework offers a set of configurable Mock Agents with the aim of being able to execute tests while the MAS is under development. The BEAST Methodology presents transparent traceability from user requirements to test cases. Thus, the stakeholders can be aware of the project status. The methodology and the associated tool have been validated in the development of a MAS for fault diagnosis in FTTH (Fiber To The Home) networks. The results have been measured in quantifiable way obtaining a reduction of the tests implementation time.	Behaviour-driven development; Multi-agent systems; Agile; Methodology; Mock-agents; Test	Carrera, Álvaro; Iglesias, Carlos A.; Garijo, Mercedes	Information Systems Frontiers	This paper presents a testing methodology to apply Behaviour Driven Development (BDD) techniques while developing Multi-Agent Systems (MASs), termed BEhavioural Agent Simple Testing (BEAST) Methodology. This methodology is supported by the open source framework (BEAST Tool) which automatically generates test cases skeletons from BDD scenarios specifications. The developed framework allows the testing of MASs based on JADE or JADEX platforms. In addition, this framework offers a set of configurable Mock Agents with the aim of being able to execute tests while the MAS is under development. The BEAST Methodology presents transparent traceability from user requirements to test cases. Thus, the stakeholders can be aware of the project status. The methodology and the associated tool have been validated in the development of a MAS for fault diagnosis in FTTH (Fiber To The Home) networks. The results have been measured in quantifiable way obtaining a reduction of the tests implementation time.				Excluded	Excluded	new_screen			2						
274	Behave	Beast methodology: An agile testing methodology for multi-agent systems based on behaviour driven development	This paper presents a testing methodology to apply Behaviour Driven Development (BDD) techniques while developing Multi-Agent Systems (MASs), termed BEhavioural Agent Simple Testing (BEAST) Methodology. This methodology is supported by the open source framework (BEAST Tool) which automatically generates test cases skeletons from BDD scenarios specifications. The developed framework allows the testing of MASs based on JADE or JADEX platforms. In addition, this framework offers a set of configurable Mock Agents with the aim of being able to execute tests while the MAS is under development. The BEAST Methodology presents transparent traceability from user requirements to test cases. Thus, the stakeholders can be aware of the project status. The methodology and the associated tool have been validated in the development of a MAS for fault diagnosis in FTTH (Fiber To The Home) networks. The results have been measured in quantifiable way obtaining a reduction of the tests implementation time. © 2013 Springer Science+Business Media New York.		Carrera A., Iglesias C.A., Garijo M.	Information Systems Frontiers	This paper presents a testing methodology to apply Behaviour Driven Development (BDD) techniques while developing Multi-Agent Systems (MASs), termed BEhavioural Agent Simple Testing (BEAST) Methodology. This methodology is supported by the open source framework (BEAST Tool) which automatically generates test cases skeletons from BDD scenarios specifications. The developed framework allows the testing of MASs based on JADE or JADEX platforms. In addition, this framework offers a set of configurable Mock Agents with the aim of being able to execute tests while the MAS is under development. The BEAST Methodology presents transparent traceability from user requirements to test cases. Thus, the stakeholders can be aware of the project status. The methodology and the associated tool have been validated in the development of a MAS for fault diagnosis in FTTH (Fiber To The Home) networks. The results have been measured in quantifiable way obtaining a reduction of the tests implementation time. © 2013 Springer Science+Business Media New York.				Included	Included	new_screen			2						
275	Behave	A Study of Test Techniques for Integration with Domain Driven Design	This paper presents an exploratory study on agile techniques for software testing Test-Driven Development and Behaviour-Driven Development for integration with the agile software development technique known as Domain-Driven Design. It also comprises a comparison between both test approaches, enhancing the strengths and weaknesses of each one. To make it feasible the integration proposal, an example of domain using Apache Isis framework was developed. According to the study performed, the possibility of creating an automatic test generator to make it agile the validation of entities attributes of the domain model was noted.	Behaviour-Driven Development; Apache Isis; Domain-Driven Development; Software Test; Test-Driven Development	Santos, Eloisa Cristina Silva; Beder, Delano Medeiros; Penteado, Rosângela A. Dellosso	Proceedings of the 2015 12th International Conference on Information Technology - New Generations	This paper presents an exploratory study on agile techniques for software testing Test-Driven Development and Behaviour-Driven Development for integration with the agile software development technique known as Domain-Driven Design. It also comprises a comparison between both test approaches, enhancing the strengths and weaknesses of each one. To make it feasible the integration proposal, an example of domain using Apache Isis framework was developed. According to the study performed, the possibility of creating an automatic test generator to make it agile the validation of entities attributes of the domain model was noted.				Included	Included	new_screen			2						
276	Behave	A Behaviour-Driven Development Approach for Cyber-Physical Production Systems	This paper proposes a method for iterative engineering of cyber-physical production systems (CPPS) that allows early testing of virtual prototypes and early involvement of domain experts. It is based on behaviour-driven development (BDD) from agile software engineering, which is adapted to address a set of issues relevant for CPPS engineering including the use of standardised CPPS models, integration testing, test environments, and brownfield development. The paper describes these adaptations and synthesises them into a procedural model of BDD for CPPS. Finally, a prototypical test system for CPPS is presented that partially implements the approach. © 2020 IEEE.		Kannengiesser U., Krenn F., Stary C.	Proceedings - 2020 IEEE Conference on Industrial Cyberphysical Systems, ICPS 2020	This paper proposes a method for iterative engineering of cyber-physical production systems (CPPS) that allows early testing of virtual prototypes and early involvement of domain experts. It is based on behaviour-driven development (BDD) from agile software engineering, which is adapted to address a set of issues relevant for CPPS engineering including the use of standardised CPPS models, integration testing, test environments, and brownfield development. The paper describes these adaptations and synthesises them into a procedural model of BDD for CPPS. Finally, a prototypical test system for CPPS is presented that partially implements the approach. © 2020 IEEE.				Included	Included	new_screen			2						
277	Behave	Lu-Lu	This paper proposes Lu-Lu as an add-on architecture to open MMOGs and social network games, which has been developed to utilise a key set of ingredients that underline collaborative decision making games as reported within the research literature: personalisation, team matching, non-optimal decision making, leading, decisiveness index, scoring, levelling, and multiple stages. The implementation of Lu-Lu is demonstrated as an add-on to the classic supply chain beer game, including customisation of Lu-Lu to facilitate information exchange through the Facebook games platform, e.g., Graph API and Scores API. Performance assessment of Lu-Lu using Behaviour-Driven Development suggests a successful integration of all key ingredients within Lu-Lu's architecture, yielding autonomous behaviour that improves both player enjoyment and decision making.	Collaborative; Decision making; Game; MPEG-7; Personalisation; Profiling	Daylamani-Zad, Damon; Angelides, Marios C.; Agius, Harry	Decis. Support Syst.	This paper proposes Lu-Lu as an add-on architecture to open MMOGs and social network games, which has been developed to utilise a key set of ingredients that underline collaborative decision making games as reported within the research literature: personalisation, team matching, non-optimal decision making, leading, decisiveness index, scoring, levelling, and multiple stages. The implementation of Lu-Lu is demonstrated as an add-on to the classic supply chain beer game, including customisation of Lu-Lu to facilitate information exchange through the Facebook games platform, e.g., Graph API and Scores API. Performance assessment of Lu-Lu using Behaviour-Driven Development suggests a successful integration of all key ingredients within Lu-Lu's architecture, yielding autonomous behaviour that improves both player enjoyment and decision making.				Excluded	Excluded	new_screen			2						
278	Behave	Lu-Lu: A framework for collaborative decision making games	This paper proposes Lu-Lu as an add-on architecture to open MMOGs and social network games, which has been developed to utilise a key set of ingredients that underline collaborative decision making games as reported within the research literature: personalisation, team matching, non-optimal decision making, leading, decisiveness index, scoring, levelling, and multiple stages. The implementation of Lu-Lu is demonstrated as an add-on to the classic supply chain beer game, including customisation of Lu-Lu to facilitate information exchange through the Facebook games platform, e.g., Graph API and Scores API. Performance assessment of Lu-Lu using Behaviour-Driven Development suggests a successful integration of all key ingredients within Lu-Lu's architecture, yielding autonomous behaviour that improves both player enjoyment and decision making.	Collaborative, Decision making, Game, Profiling, Personalisation, MPEG-7	Daylamani-Zad, Damon; Angelides, Marios C.; Agius, Harry	Decision Support Systems	This paper proposes Lu-Lu as an add-on architecture to open MMOGs and social network games, which has been developed to utilise a key set of ingredients that underline collaborative decision making games as reported within the research literature: personalisation, team matching, non-optimal decision making, leading, decisiveness index, scoring, levelling, and multiple stages. The implementation of Lu-Lu is demonstrated as an add-on to the classic supply chain beer game, including customisation of Lu-Lu to facilitate information exchange through the Facebook games platform, e.g., Graph API and Scores API. Performance assessment of Lu-Lu using Behaviour-Driven Development suggests a successful integration of all key ingredients within Lu-Lu's architecture, yielding autonomous behaviour that improves both player enjoyment and decision making.				Excluded	Excluded	new_screen			2						
279	Behave	An Approach for Guiding Developers in the Choice of Security Solutions and in the Generation of Concrete Test Cases	This paper tackles the problems of choosing security solutions and writing concrete security test cases for software, which are two tasks of the software life cycle requiring time, expertise and experience. We propose in this paper a method, based upon the notion of knowledge base, for helping developers devise more secure applications from the threat modelling step up to the testing one. The first stage of the approach consists of the acquisition and integration of publicly available security data into a data store. This one is used to assist developers in the design of attack-defense trees expressing the attacker possibilities to compromise an application and the defenses that may be implemented. These defenses are given under the form of security pattern combinations, a security pattern being a generic and reusable solution to design more secure applications. In the second stage, these trees are used to guide developers in the test case generation. Test verdicts show whether an application is vulnerable to the threats modelled by an ADTree and whether the consequences of the chosen security patterns are observed from the application (a consequence leading to some observable events partly showing that a pattern is correctly implemented). We applied this approach to web applications and evaluated it on 24 participants. The results are very encouraging in terms of the two criteria: comprehensibility and effectiveness.	Security; Attack-defense trees; Security patterns; Test case generation	Salva, Sébastien; Regainia, Loukmen	Software Quality Journal	This paper tackles the problems of choosing security solutions and writing concrete security test cases for software, which are two tasks of the software life cycle requiring time, expertise and experience. We propose in this paper a method, based upon the notion of knowledge base, for helping developers devise more secure applications from the threat modelling step up to the testing one. The first stage of the approach consists of the acquisition and integration of publicly available security data into a data store. This one is used to assist developers in the design of attack-defense trees expressing the attacker possibilities to compromise an application and the defenses that may be implemented. These defenses are given under the form of security pattern combinations, a security pattern being a generic and reusable solution to design more secure applications. In the second stage, these trees are used to guide developers in the test case generation. Test verdicts show whether an application is vulnerable to the threats modelled by an ADTree and whether the consequences of the chosen security patterns are observed from the application (a consequence leading to some observable events partly showing that a pattern is correctly implemented). We applied this approach to web applications and evaluated it on 24 participants. The results are very encouraging in terms of the two criteria: comprehensibility and effectiveness.				Excluded	Excluded	new_screen			2						
280	Behave	Parsing BDD Stories for Automated Verification of Software Artefacts	This position paper reports on our ongoing developments towards the automated verification of software artefacts by parsing sentences on Behaviour-Driven Development (BDD) stories. The solution we propose is based on different strategies for analysing the consistency of user requirements specified in BDD stories on task models, graphical user interfaces (GUIs), GUI prototypes, and domain models. We illustrate our solution through concrete examples and discuss its challenges and limitations. © 2020, Electronic Communications of the EASST. All rights reserved.		Silva T.R., Fitzgerald B.	Electronic Communications of the EASST	This position paper reports on our ongoing developments towards the automated verification of software artefacts by parsing sentences on Behaviour-Driven Development (BDD) stories. The solution we propose is based on different strategies for analysing the consistency of user requirements specified in BDD stories on task models, graphical user interfaces (GUIs), GUI prototypes, and domain models. We illustrate our solution through concrete examples and discuss its challenges and limitations. © 2020, Electronic Communications of the EASST. All rights reserved.				Included	Included	new_screen			2						
281	Behave	Tit for tat and big steps: The case of Swedish banks’ internationalization 1961–2010	This study examines four major Swedish banks’ internationalization process patterns during the period 1961–2010. The study complements earlier studies by also considering the banks’ levels of market commitment. One objective is to determine if ‘Tit for tat’-behaviour seen in earlier studies of Swedish banks still prevails after the deregulation. Adding to earlier studies, this study also considers the level of market activities and commitments. A secondary purpose is to examine how the financial crisis has affected the banks with reference to the banks’ internationalization patterns. The empirical study is based on archival data on the studied banks’ foreign operations. The results show that the banks’ behaviour follows ‘Tit for tat’-behaviour but that the internationalization has accelerated after the deregulation, hence being carried out with ‘big steps’ rather than small steps. The analysis also shows that the mimetic behaviour is complemented by other types of internationalization behaviours. The differences in bank internationalization also mean that the effect of a financial crisis varies depending on how the banks have internationalized.	Banks, Commitment, Financial crisis, Internationalization process, Longitudinal study	Ekman, Peter; Hadjikhani, Annoch Isa; Pajuvirta, Andreas; Thilenius, Peter	International Business Review	This study examines four major Swedish banks’ internationalization process patterns during the period 1961–2010. The study complements earlier studies by also considering the banks’ levels of market commitment. One objective is to determine if ‘Tit for tat’-behaviour seen in earlier studies of Swedish banks still prevails after the deregulation. Adding to earlier studies, this study also considers the level of market activities and commitments. A secondary purpose is to examine how the financial crisis has affected the banks with reference to the banks’ internationalization patterns. The empirical study is based on archival data on the studied banks’ foreign operations. The results show that the banks’ behaviour follows ‘Tit for tat’-behaviour but that the internationalization has accelerated after the deregulation, hence being carried out with ‘big steps’ rather than small steps. The analysis also shows that the mimetic behaviour is complemented by other types of internationalization behaviours. The differences in bank internationalization also mean that the effect of a financial crisis varies depending on how the banks have internationalized.				Excluded	Excluded	new_screen			2						
282	Behave	A case study of agile software development for safety-Critical systems projects	This study explores the introduction of agile software development within an avionics company engaged in safety-critical system engineering. There is increasing pressure throughout the software industry for development efforts to adopt agile software development in order to respond more rapidly to changing requirements and make more frequent deliveries of systems to customers for review and integration. This pressure is also being experienced in safety-critical industries, where release cycles on typically large and complex systems may run to several years on projects spanning decades. However, safety-critical system developments are normally highly regulated, which may constrain the adoption of agile software development or require adaptation of selected methods or practices. To investigate this potential conflict, we conducted a series of interviews with practitioners in the company, exploring their experiences of adopting agile software development and the challenges encountered. The study also explores the opportunities for altering the existing software process in the company to better fit agile software development to the constraints of software development for safety-critical systems. We conclude by identifying immediate future research directions to better align the tempo of software development for safety-critical systems and agile software development.		Islam, Gibrail; Storer, Tim	Reliability Engineering & System Safety	This study explores the introduction of agile software development within an avionics company engaged in safety-critical system engineering. There is increasing pressure throughout the software industry for development efforts to adopt agile software development in order to respond more rapidly to changing requirements and make more frequent deliveries of systems to customers for review and integration. This pressure is also being experienced in safety-critical industries, where release cycles on typically large and complex systems may run to several years on projects spanning decades. However, safety-critical system developments are normally highly regulated, which may constrain the adoption of agile software development or require adaptation of selected methods or practices. To investigate this potential conflict, we conducted a series of interviews with practitioners in the company, exploring their experiences of adopting agile software development and the challenges encountered. The study also explores the opportunities for altering the existing software process in the company to better fit agile software development to the constraints of software development for safety-critical systems. We conclude by identifying immediate future research directions to better align the tempo of software development for safety-critical systems and agile software development.				Excluded	Excluded	new_screen			2						
283	Behave	Does IT team climate matter? An empirical study of the impact of co-workers and the Confucian work ethic on deviance behavior	This study seeks to determine the impact of IT co-workers on individual deviance behavior in organizations. Using data collected from 322 IT employees and their supervisors in Chinese software companies, we also examine the impact of the Confucian work ethic on deviant behavior. The results suggest that both co-workers’ production deviance and the Confucian work ethic have impacts on individuals’ production deviance. The influence of IT co-workers’ production deviance was greater in high team climates and low team climates than in neutral team climates. The Confucian work ethic has no significant influence on production deviance in low team climates.	Confucian work ethic, IT co-worker production deviance, IT team climate	Zhang, Hanpeng; Luo, Xin (Robert); Liao, Qinyu; Peng, Lifang	Information & Management	This study seeks to determine the impact of IT co-workers on individual deviance behavior in organizations. Using data collected from 322 IT employees and their supervisors in Chinese software companies, we also examine the impact of the Confucian work ethic on deviant behavior. The results suggest that both co-workers’ production deviance and the Confucian work ethic have impacts on individuals’ production deviance. The influence of IT co-workers’ production deviance was greater in high team climates and low team climates than in neutral team climates. The Confucian work ethic has no significant influence on production deviance in low team climates.				Excluded	Excluded	new_screen			2						
284	Behave	Legislation-driven development of a Gift Aid system using Event-B	This work presents our approach to formally model the Swiftaid system design, a digital platform that enables donors to automatically add Gift Aid to donations made via card payments. Following principles of Behaviour-Driven Development, we use Gherkin to capture requirements specified in legislation, specifically the UK Charity (Gift Aid Declarations) Regulations 2016. The Gherkin scenarios provide a basis for subsequent formal modelling and analysis using Event-B, Rodin and ProB. Interactive model simulations assist communication between domain experts, software architects and other stakeholders during requirements capture and system design, enabling the emergent system behaviour to be validated. Our approach was employed within the development of the real Swiftaid product, launched by Streeva in February 2019. Our analysis helped conclude that there was not a strong enough business case for one of the features, whichwas shown to provide nominal user convenience at the expense of increased complexity. This work provides a case study in allying formal and agile software development to enable rapid development of robust software. © 2020, The Author(s).		Williams D.M., Darwish S., Schneider S., Michael D.R.	Formal Aspects of Computing	This work presents our approach to formally model the Swiftaid system design, a digital platform that enables donors to automatically add Gift Aid to donations made via card payments. Following principles of Behaviour-Driven Development, we use Gherkin to capture requirements specified in legislation, specifically the UK Charity (Gift Aid Declarations) Regulations 2016. The Gherkin scenarios provide a basis for subsequent formal modelling and analysis using Event-B, Rodin and ProB. Interactive model simulations assist communication between domain experts, software architects and other stakeholders during requirements capture and system design, enabling the emergent system behaviour to be validated. Our approach was employed within the development of the real Swiftaid product, launched by Streeva in February 2019. Our analysis helped conclude that there was not a strong enough business case for one of the features, whichwas shown to provide nominal user convenience at the expense of increased complexity. This work provides a case study in allying formal and agile software development to enable rapid development of robust software. © 2020, The Author(s).				Included	Included	new_screen			2						
285	Behave	Test Descriptions with ETSI TDL	To address the need for abstract, high-level test descriptions that can be shared among different stakeholders, the European Telecommunications Standards Institute (ETSI) commissioned the design of the Test Description Language (TDL). TDL is designed as a domain-specific language for testing, consisting of a standardised abstract syntax (meta-model) and concrete syntaxes for textual specification, graphical design, and model exchange between tools. Its main purpose is to support a test methodology that is followed in the standardisation work for software-intense systems at ETSI and is applicable in industrial projects as well. TDL enables the formal specification of both test objectives derived from system requirements and test descriptions refining the test objectives. The latter serve as blueprint for the implementation of executable tests. A standardised mapping of TDL specifications to test scripts in the standardised test execution language TTCN-3 widens the reach of TDL to ensure compatibility and consistency of generated executable tests. An open-source toolset has been developed as a common platform to accelerate the adoption of TDL and lower the barrier to entry for users and tool vendors. Reports from pilot applications within three ETSI standardisation groups demonstrate the practicality of the chosen approach.	Model-based testing; Domain-specific modelling; Test description language; Test methodology; Testing in standardisation	Makedonski, Philip; Adamis, Gusztáv; Käärik, Martti; Kristoffersen, Finn; Carignani, Michele; Ulrich, Andreas; Grabowski, Jens	Software Quality Journal	To address the need for abstract, high-level test descriptions that can be shared among different stakeholders, the European Telecommunications Standards Institute (ETSI) commissioned the design of the Test Description Language (TDL). TDL is designed as a domain-specific language for testing, consisting of a standardised abstract syntax (meta-model) and concrete syntaxes for textual specification, graphical design, and model exchange between tools. Its main purpose is to support a test methodology that is followed in the standardisation work for software-intense systems at ETSI and is applicable in industrial projects as well. TDL enables the formal specification of both test objectives derived from system requirements and test descriptions refining the test objectives. The latter serve as blueprint for the implementation of executable tests. A standardised mapping of TDL specifications to test scripts in the standardised test execution language TTCN-3 widens the reach of TDL to ensure compatibility and consistency of generated executable tests. An open-source toolset has been developed as a common platform to accelerate the adoption of TDL and lower the barrier to entry for users and tool vendors. Reports from pilot applications within three ETSI standardisation groups demonstrate the practicality of the chosen approach.				Excluded	Excluded	new_screen			2						
286	Behave	Enabling IoT Platform Interoperability Using a Systematic Development Approach by Example	Today, the IoT landscape consists of a large number of vertical IoT platforms that are rarely interconnected. To enable creation of applications across platforms and domain boundaries interoperability needs to be established between IoT platforms. In this paper we present how this task can be simplified by utilizing a systematic software development process based on behavior- and domain-driven development. This process is illustrated using an example that uses the open source IoT interoperability framework symbIoTe to connect two indoor navigation platforms. We show that developers can actually profit from this approach but existing IoT interoperability frameworks are still cumbersome to use.	Internet of Things;IoT;interoperability;semantic interoperability;behavior-driven development;domain-driven design	M. Schneider; B. Hippchen; S. Abeck; M. Jacoby; R. Herzog	2018 Global Internet of Things Summit (GIoTS)	Today, the IoT landscape consists of a large number of vertical IoT platforms that are rarely interconnected. To enable creation of applications across platforms and domain boundaries interoperability needs to be established between IoT platforms. In this paper we present how this task can be simplified by utilizing a systematic software development process based on behavior- and domain-driven development. This process is illustrated using an example that uses the open source IoT interoperability framework symbIoTe to connect two indoor navigation platforms. We show that developers can actually profit from this approach but existing IoT interoperability frameworks are still cumbersome to use.				Included	Included	new_screen			2						
287	Behave	Mining reading patterns from eye-tracking data: method and demonstration	Understanding how developers interact with different software artifacts when performing comprehension tasks has a potential to improve developers’ productivity. In this paper, we propose a method to analyze eye-tracking data using process mining to find distinct reading patterns of how developers interacted with the different artifacts. To validate our approach, we conducted an exploratory study using eye-tracking involving 11 participants. We applied our method to investigate how developers interact with different artifacts during domain and code understanding tasks. To contextualize the reading patterns and to better understand the perceived benefits and challenges participants associated with the different artifacts and their choice of reading patterns, we complemented the eye-tracking data with the data obtained from think aloud. The study used behavior-driven development, a development practice that is increasingly used in Agile software development contexts, as a setting. The study shows that our method can be used to explore developers’ behavior at an aggregated level and identify behavioral patterns at varying levels of granularity. © 2019, Springer-Verlag GmbH Germany, part of Springer Nature.		Ioannou C., Nurdiani I., Burattin A., Weber B.	Software and Systems Modeling	Understanding how developers interact with different software artifacts when performing comprehension tasks has a potential to improve developers’ productivity. In this paper, we propose a method to analyze eye-tracking data using process mining to find distinct reading patterns of how developers interacted with the different artifacts. To validate our approach, we conducted an exploratory study using eye-tracking involving 11 participants. We applied our method to investigate how developers interact with different artifacts during domain and code understanding tasks. To contextualize the reading patterns and to better understand the perceived benefits and challenges participants associated with the different artifacts and their choice of reading patterns, we complemented the eye-tracking data with the data obtained from think aloud. The study used behavior-driven development, a development practice that is increasingly used in Agile software development contexts, as a setting. The study shows that our method can be used to explore developers’ behavior at an aggregated level and identify behavioral patterns at varying levels of granularity. © 2019, Springer-Verlag GmbH Germany, part of Springer Nature.				Excluded	Excluded	new_screen			2						
288	Behave	Testing Web Applications with State Objects	Use states to drive your tests.		van Deursen, Arie	Commun. ACM	Use states to drive your tests.				Excluded	Excluded	new_screen			2						
289	Behave	User Interface Prototype Generation from Agile Requirements Specifications Written in Concordia	User interface prototypes (UIP) are widely used to get feedback before building a software feature. They can prevent misunderstandings between the software development team and other stakeholders (e.g., users, investors) that lead to rework or a resulting software that does not meet their needs. UIP can also be a valuable resource in Agile software development, in which feedback is key. In this paper, we present an approach to generate UIP automatically from Agile requirements specifications written in Concordia and its corresponding prototype tool. The tool is able to generate UIP for web-based applications. We evaluated the approach and the tool with questionnaires, and the results revealed that: (i) the generated UIP are very similar to those drawn by respondents; (ii) the generated source code has good enough quality to be reused by developers; and (iii) they save design and development time.	user story; agile; concordia; generation; user interface	Pinto, Thiago Delgado; Gonçalves, Willian Inacio; Costa, Pablo Veiga	Proceedings of the 25th Brazillian Symposium on Multimedia and the Web	User interface prototypes (UIP) are widely used to get feedback before building a software feature. They can prevent misunderstandings between the software development team and other stakeholders (e.g., users, investors) that lead to rework or a resulting software that does not meet their needs. UIP can also be a valuable resource in Agile software development, in which feedback is key. In this paper, we present an approach to generate UIP automatically from Agile requirements specifications written in Concordia and its corresponding prototype tool. The tool is able to generate UIP for web-based applications. We evaluated the approach and the tool with questionnaires, and the results revealed that: (i) the generated UIP are very similar to those drawn by respondents; (ii) the generated source code has good enough quality to be reused by developers; and (iii) they save design and development time.				Included	Included	new_screen			2						
290	Behave	Remote but Connected: Ownership-Inspired Behavior-Driven Development and What an E-Learning Governance System for Africa Could Look like	Using e-learning technology is one key for developing sustainable education in urban and remote areas in Western Africa as it reduced the demands on students who are well integrated in their rural society to leave their homes for an expensive education. In this chapter we present Ownership-inspired Behavior-Driven Development (OIBBD), a development strategy designed for e-learning governance in remote areas in Africa to support sustainable education as part of the agenda 2030 and the Sustainable Development Goals (SDGs) and show how the design of a User Experience (UX), which is based on user-centered design and feedback from the African target group can be used to support the implementation of e-learning in Africa. We reflect on how a governance for sustainable development in theological education on the African continent can look like. We ask how such an e-learning governance can support remote e-learning in hard to reach areas in Africa and how this can be designed specifically of the needs of the African socio-culture. The guiding hypothesis of this chapter is, that especially leadership and its activation in African teachers can trigger them to develop ownership in using e-learning technology and this way supports the reaching of SDG 4, which deals with sustainable education. © 2018, Springer International Publishing AG.		Gottschalk J., Winther-Nielsen N.	World Sustainability Series	Using e-learning technology is one key for developing sustainable education in urban and remote areas in Western Africa as it reduced the demands on students who are well integrated in their rural society to leave their homes for an expensive education. In this chapter we present Ownership-inspired Behavior-Driven Development (OIBBD), a development strategy designed for e-learning governance in remote areas in Africa to support sustainable education as part of the agenda 2030 and the Sustainable Development Goals (SDGs) and show how the design of a User Experience (UX), which is based on user-centered design and feedback from the African target group can be used to support the implementation of e-learning in Africa. We reflect on how a governance for sustainable development in theological education on the African continent can look like. We ask how such an e-learning governance can support remote e-learning in hard to reach areas in Africa and how this can be designed specifically of the needs of the African socio-culture. The guiding hypothesis of this chapter is, that especially leadership and its activation in African teachers can trigger them to develop ownership in using e-learning technology and this way supports the reaching of SDG 4, which deals with sustainable education. © 2018, Springer International Publishing AG.				Excluded	Excluded	new_screen			2						
291	Behave	Approach of integrating behaviour-driven development with hardware/software codesign	Using typical approaches in designing embedded systems to manage the specification and design of the hardware and software is not suitable in today’s projects. In this paper, we propose a model-driven approach to integrate Hardware/Software codesign with Behaviour-Driven Development. Hardware/Software codesign approach allows the hardware and the software to be designed and implemented concurrently and optimizes the project design constraint, such as performance and cost. Behaviour-Driven Development spurs project stakeholders to collaborate to ensure the right software is developed to meet their needs and ensures that all project participants communicate in the same language. The approach exploits the advantages of each approach and provides the ability to describe the behaviour of the software as executable user stories in a Hardware/Software codesign environment. The approach is evaluated using a renewable energy project in collaboration with a private company in Canada to build a system for autonomous load management of self-forming renewable energy nanogrids. © 2019, ICIC International. All righs reserved.		Alhaj M., Arbez G., Peyton L.	International Journal of Innovative Computing, Information and Control	Using typical approaches in designing embedded systems to manage the specification and design of the hardware and software is not suitable in today’s projects. In this paper, we propose a model-driven approach to integrate Hardware/Software codesign with Behaviour-Driven Development. Hardware/Software codesign approach allows the hardware and the software to be designed and implemented concurrently and optimizes the project design constraint, such as performance and cost. Behaviour-Driven Development spurs project stakeholders to collaborate to ensure the right software is developed to meet their needs and ensures that all project participants communicate in the same language. The approach exploits the advantages of each approach and provides the ability to describe the behaviour of the software as executable user stories in a Hardware/Software codesign environment. The approach is evaluated using a renewable energy project in collaboration with a private company in Canada to build a system for autonomous load management of self-forming renewable energy nanogrids. © 2019, ICIC International. All righs reserved.				Included	Included	new_screen			2						
292	Behave	Modeling test cases in BPMN for behavior-driven development (extended abstract)	Validating analytical business processes and testing executable ones are difficult task in process development projects. Within the project Terravis, which builds a process hub for enabling fully digitalized mortgage processes between Swiss land registries, banks, notaries and other parties, these tasks became problematic. For improving stakeholder communication and extending the test scope, behavior-driven development was adapted to BPMN and business processes. This technique was introduced and very well received within the project, leading to better process documentation and better tests.		Lübke D., Van Lessen T.	CEUR Workshop Proceedings	Validating analytical business processes and testing executable ones are difficult task in process development projects. Within the project Terravis, which builds a process hub for enabling fully digitalized mortgage processes between Swiss land registries, banks, notaries and other parties, these tasks became problematic. For improving stakeholder communication and extending the test scope, behavior-driven development was adapted to BPMN and business processes. This technique was introduced and very well received within the project, leading to better process documentation and better tests.				Excluded	Excluded	new_screen			2						
293	Behave	Chapter 11 - Validation of DEVS Models Using AGILE-Based Methods	Validation of discrete event system specification (DEVS) models at the early phases of the discrete-event modeling and simulation design process is a crucial topic when dealing with complex DEVS models. Based on software engineering test methods, we present in this chapter a new approach, which integrates Agile test methods in the process of the simulation in order to design and test DEVS models. We propose an implementation in Python language based on the use of aspect programming concepts (patch, mocking objects, and decorators). This implementation is performed in the framework of the DEVSimPy environment with the definition of a plug-in dedicated to the automatic generation and execution of test scenario.	Modeling, Simulation, Discrete event, Formalism, AGILE, Validation	Capocchi, L.; Santucci, J. F.		Validation of discrete event system specification (DEVS) models at the early phases of the discrete-event modeling and simulation design process is a crucial topic when dealing with complex DEVS models. Based on software engineering test methods, we present in this chapter a new approach, which integrates Agile test methods in the process of the simulation in order to design and test DEVS models. We propose an implementation in Python language based on the use of aspect programming concepts (patch, mocking objects, and decorators). This implementation is performed in the framework of the DEVSimPy environment with the definition of a plug-in dedicated to the automatic generation and execution of test scenario.				Excluded	Excluded	new_screen			2						
294	Behave	Gherkin Syntax Extension for Parameterization of Network Switch Configurations in Test Specification	We applied test automation in the style of Behavior-Driven Development (BDD), an agile software development technique. In applying BDD, the problem is that a large amount of similar configurations of network switches have to be written in the BDD test specification files. To solve this problem, parameterization of configurations is considered effective. However, Gherkin, the BDD test specification language, does not provide syntax for parameterization. In this paper, we propose a syntax extension of Gherkin, which enables parameterization of configurations. From experiments on 11 configurations, parameterization using the proposed syntax extension can reduce the number of the lines used to describe configurations by 39%.	test specification;parameterization;BDD;Gherkin;syntax extension;network switch;configuration	T. Li; S. Tsubota; K. Hirono	2017 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)	We applied test automation in the style of Behavior-Driven Development (BDD), an agile software development technique. In applying BDD, the problem is that a large amount of similar configurations of network switches have to be written in the BDD test specification files. To solve this problem, parameterization of configurations is considered effective. However, Gherkin, the BDD test specification language, does not provide syntax for parameterization. In this paper, we propose a syntax extension of Gherkin, which enables parameterization of configurations. From experiments on 11 configurations, parameterization using the proposed syntax extension can reduce the number of the lines used to describe configurations by 39%.				Included	Included	new_screen			2						
295	Behave	Automation and consistency analysis of test cases written in natural language: An industrial context	We present here a novel test automation strategy that receives as input a freestyle natural language (NL) test case (consisting of a sequence of test steps) and produces executable test scripts. This strategy relies on a database of previously automated seed test steps, available for reuse. New steps are automated via a capturing process by a tester, without requiring any programming knowledge. Automated tests can be executed by a replay facility. We discuss the reuse improvement, implementation effort, and user feedback regarding the industrial applicability and usability of our capture & replay tool. We then show that restricting the input textual description to obey a proposed Controlled NL (CNL) brings significant advantages: (1) reuse improvement; (2) the possibility of integration with a test generation framework; and (3) definition of consistency notions for test actions and test action sequences, that ensure, respectively, well-formedness of each action and a proper configuration to safely execute a sequence of actions. We formalize these consistency notions in Alloy and use the Alloy Analyzer to carry out the consistency check; the scalability of the analysis is assessed via an evaluation considering a repository with real test cases; the practical context of our work is mobile device testing, involving a partnership with Motorola Mobility, a Lenovo company.	Test automation, Controlled natural language, Alloy, Test case consistency	Arruda, Filipe; Barros, Flávia; Sampaio, Augusto	Science of Computer Programming	We present here a novel test automation strategy that receives as input a freestyle natural language (NL) test case (consisting of a sequence of test steps) and produces executable test scripts. This strategy relies on a database of previously automated seed test steps, available for reuse. New steps are automated via a capturing process by a tester, without requiring any programming knowledge. Automated tests can be executed by a replay facility. We discuss the reuse improvement, implementation effort, and user feedback regarding the industrial applicability and usability of our capture & replay tool. We then show that restricting the input textual description to obey a proposed Controlled NL (CNL) brings significant advantages: (1) reuse improvement; (2) the possibility of integration with a test generation framework; and (3) definition of consistency notions for test actions and test action sequences, that ensure, respectively, well-formedness of each action and a proper configuration to safely execute a sequence of actions. We formalize these consistency notions in Alloy and use the Alloy Analyzer to carry out the consistency check; the scalability of the analysis is assessed via an evaluation considering a repository with real test cases; the practical context of our work is mobile device testing, involving a partnership with Motorola Mobility, a Lenovo company.				Excluded	Excluded	new_screen			2						
296	Behave	Automatic acceptance testing of the web application security with ITU-T X.805 framework	Web application development companies should ensure the high quality of their products. This can be achieved through high quality of the software development lifecycle. Web applications are mostly running on the Internet and are being exposed to many security threats and malicious operations. The mission of EUCISE2020 project (EUropean test bed for the maritime Common Information Sharing Environment in the 2020 perspective) is to enhance interoperability between systems and networks. The interconnections must be established in a decentralized way using cutting-edge technologies. Hence, it requires innovative and practical solutions from the web development companies. The research problem is being addressed with the Stanford Research Institute NABC (Needs, Approach, Benefits and Competition) method. Our approach is to conceptualize a testing scenario for the web application development process. The concept utilizes the International Telecommunication Union recommended standard security framework (ITU-T X.805) in the context of test automation for end-to-end communications. This study presents a new holistic solution in feature driven fashion. As a result, we propose that building acceptance test scenarios using ITU-T X.805 guidelines in Software Development Lifecycle is a sustainable approach.	EUCISE 2020;ITU-T Recommendation X.805;NABC analysis;web application development;automated testing scenario;behavior-driven development (BDD)	P. Rathod; V. Julkunen; T. Kaisti; J. Nissilä	2015 Second International Conference on Computer Science, Computer Engineering, and Social Media (CSCESM)	Web application development companies should ensure the high quality of their products. This can be achieved through high quality of the software development lifecycle. Web applications are mostly running on the Internet and are being exposed to many security threats and malicious operations. The mission of EUCISE2020 project (EUropean test bed for the maritime Common Information Sharing Environment in the 2020 perspective) is to enhance interoperability between systems and networks. The interconnections must be established in a decentralized way using cutting-edge technologies. Hence, it requires innovative and practical solutions from the web development companies. The research problem is being addressed with the Stanford Research Institute NABC (Needs, Approach, Benefits and Competition) method. Our approach is to conceptualize a testing scenario for the web application development process. The concept utilizes the International Telecommunication Union recommended standard security framework (ITU-T X.805) in the context of test automation for end-to-end communications. This study presents a new holistic solution in feature driven fashion. As a result, we propose that building acceptance test scenarios using ITU-T X.805 guidelines in Software Development Lifecycle is a sustainable approach.				Excluded	Excluded	new_screen			2						
297	Behave	Testing of Web Services Using Behavior-Driven Development	Web services are commonly used in the communication of software over the web. To fully trust a web service, it should be tested and certified, but testing of web services provoke new challenges. Behavior-Driven Development (BDD) can be applied to the testing of web services. Gherkin language is used to define scenarios in BDD. We used Gherkin language to define test cases for web services and we developed a tool to convert these test cases into JMeter test scripts.	Behavior-Driven Development; Software Testing; Gherkin; JMeter; Testing of Web Services; Web Services.	Oruç, Ahmet Furkan; Ovatman, Tolga	Proceedings of the 6th International Conference on Cloud Computing and Services Science - Volume 1 and 2	Web services are commonly used in the communication of software over the web. To fully trust a web service, it should be tested and certified, but testing of web services provoke new challenges. Behavior-Driven Development (BDD) can be applied to the testing of web services. Gherkin language is used to define scenarios in BDD. We used Gherkin language to define test cases for web services and we developed a tool to convert these test cases into JMeter test scripts.				Included	Included	new_screen			2						
298	Behave	ScrumOntoBDD: Agile software development based on scrum, ontologies and behaviour-driven development	When developing a Learning Management System (LMS) using Scrum, we noticed that it was quite often necessary to redefine some system behaviour scenarios, due to ambiguities in the requirement specifications, or due to misinterpretations of stories reported by the Product Owners (POs). The definition of test suites was also cumbersome, resulting in test suites that were incomplete or did not at all comply with the system requirements. Based on this experience and to deal with these problems, in this paper, we propose the ScrumOntoBDD approach to agile software development, which combines Scrum, ontologies and Behaviour-Driven Development (BDD). This approach is centred on the concepts and techniques of Scrum and BDD and focuses on the planning and analysis phases of the software life cycle, since the BDD tools currently provide little support to these phases, while most of the problems during the LMS development were found exactly there. We claim that our approach improves the software development practices in this respect. Furthermore, ScrumOntoBDD employs ontologies in order to reduce ambiguities intrinsic to the use of a natural language as a BDD ubiquitous language. In this paper, we illustrate and systematically evaluate our approach, showing that it is beneficial since it improves the communication between members of an agile development team. © 2021, The Author(s).		Lopes de Souza P., Lopes de Souza W., Ferreira Pires L.	Journal of the Brazilian Computer Society	When developing a Learning Management System (LMS) using Scrum, we noticed that it was quite often necessary to redefine some system behaviour scenarios, due to ambiguities in the requirement specifications, or due to misinterpretations of stories reported by the Product Owners (POs). The definition of test suites was also cumbersome, resulting in test suites that were incomplete or did not at all comply with the system requirements. Based on this experience and to deal with these problems, in this paper, we propose the ScrumOntoBDD approach to agile software development, which combines Scrum, ontologies and Behaviour-Driven Development (BDD). This approach is centred on the concepts and techniques of Scrum and BDD and focuses on the planning and analysis phases of the software life cycle, since the BDD tools currently provide little support to these phases, while most of the problems during the LMS development were found exactly there. We claim that our approach improves the software development practices in this respect. Furthermore, ScrumOntoBDD employs ontologies in order to reduce ambiguities intrinsic to the use of a natural language as a BDD ubiquitous language. In this paper, we illustrate and systematically evaluate our approach, showing that it is beneficial since it improves the communication between members of an agile development team. © 2021, The Author(s).				Included	Included	new_screen			2						
299	Behave	Formal Model Validation Through Acceptance Tests	When formal systems modelling is used as part of the development process, modellers need to understand the requirements in order to create appropriate models, and domain experts need to validate the final models to ensure they fit the needs of stakeholders. A suitable mechanism for such a validation are acceptance tests. In this paper we discuss how the principles of Behaviour-Driven Development (BDD) can be applied to (i) formal modelling and (ii) validation of behaviour specifications, thus coupling those two tasks. We show how to close the gap between the informal domain specification and the formal model, thus enabling the domain expert to write acceptance tests in a high-level language matching the formal specification. We analyse the applicability of this approach by providing the Gherkin scenarios for an formal model of a ‘fixed virtual block’ approach to train movement control, developed according to the Hybrid ERTMS/ETCS Level 3 principles specified by the EEIG ERTMS Users Group and presented as a case study on the 6. International ABZ Conference 2018. © 2019, Springer Nature Switzerland AG.		Fischer T., Dghyam D.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	When formal systems modelling is used as part of the development process, modellers need to understand the requirements in order to create appropriate models, and domain experts need to validate the final models to ensure they fit the needs of stakeholders. A suitable mechanism for such a validation are acceptance tests. In this paper we discuss how the principles of Behaviour-Driven Development (BDD) can be applied to (i) formal modelling and (ii) validation of behaviour specifications, thus coupling those two tasks. We show how to close the gap between the informal domain specification and the formal model, thus enabling the domain expert to write acceptance tests in a high-level language matching the formal specification. We analyse the applicability of this approach by providing the Gherkin scenarios for an formal model of a ‘fixed virtual block’ approach to train movement control, developed according to the Hybrid ERTMS/ETCS Level 3 principles specified by the EEIG ERTMS Users Group and presented as a case study on the 6. International ABZ Conference 2018. © 2019, Springer Nature Switzerland AG.				Included	Included	new_screen			2						
300	Behave	Executable requirements in a safety-critical context with Ada	When people who need the software and people who build the software do not understand each other, the success of a project may be impacted. In the same way, when it is difficult to know which test case corresponds to a given requirement, or if each and every requirement is fully covered by the test suite, we have a traceability issue that may also impact the success of the project. During the last few years, the agile community has suggested a new development paradigm in order to address this traceability issue. This approach is called Behaviour Driven Development (BDD). It is based on a new way of expressing requirements using a common language understandable by all parties at stake. After having described the Behaviour Driven Development in details, we introduce the XReq tool, an Open Source project developed by SOGILIS and part of the Open-DO project. It is designed to bring the Behaviour Driven Development to the Ada language and other statically typed languages. It also aims at facilitating the traceability of High and Low Level Tests in the context of DO-178B projects.		Bâillon C., Bouchez-Mongardé S.	Ada User Journal	When people who need the software and people who build the software do not understand each other, the success of a project may be impacted. In the same way, when it is difficult to know which test case corresponds to a given requirement, or if each and every requirement is fully covered by the test suite, we have a traceability issue that may also impact the success of the project. During the last few years, the agile community has suggested a new development paradigm in order to address this traceability issue. This approach is called Behaviour Driven Development (BDD). It is based on a new way of expressing requirements using a common language understandable by all parties at stake. After having described the Behaviour Driven Development in details, we introduce the XReq tool, an Open Source project developed by SOGILIS and part of the Open-DO project. It is designed to bring the Behaviour Driven Development to the Ada language and other statically typed languages. It also aims at facilitating the traceability of High and Low Level Tests in the context of DO-178B projects.				Included	Included	new_screen			2						
301	Behave	Creation of multiple conceptual models from user stories – a natural language processing approach	While Agile methodologies are used in software development, researchers have identified many issues related to requirements engineering in Agile approaches. Some of these issues relate to ambiguity in user stories, which is a widely-used requirements specification mechanism in Agile methodologies. This research proposes the use of conceptual models while developing user stories. We posit that the use of conceptual models helps reducing ambiguity in user stories. An important aspect of our research is the creation of an algorithm for automatic generation of such models while developing the user stories. © Springer Nature Switzerland AG 2019.		Gupta A., Poels G., Bera P.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	While Agile methodologies are used in software development, researchers have identified many issues related to requirements engineering in Agile approaches. Some of these issues relate to ambiguity in user stories, which is a widely-used requirements specification mechanism in Agile methodologies. This research proposes the use of conceptual models while developing user stories. We posit that the use of conceptual models helps reducing ambiguity in user stories. An important aspect of our research is the creation of an algorithm for automatic generation of such models while developing the user stories. © Springer Nature Switzerland AG 2019.				Excluded	Excluded	new_screen			2						
302	Behave	Test Automation with the Gauge Framework: Experience and Best Practices	While Behavior-driven development (BDD) tools such as Cucumber are powerful tools for automated testing, they have certain limitations. For example, they often enforce strict syntax for test cases, like the “Given-When-Then” format, which may not always be easy to write for a given test case. A new test automation framework named Gauge (gauge.org) addresses that limitation since it does not prescribe the BDD testing process with a strict syntax. In Gauge, writing a test case is as easy as writing down the flow of test cases in several itemized sentences in a natural language, like English. In the context of Testinium (testinium.com), a large software testing company which provides software testing services, tools and solutions to a large number of clients, we have actively used the Gauge framework since 2018 to develop large automated front-end test suites for several large web applications. In this paper/talk, the speakers will share several examples and best practices of developing automated tests in natural-language requirements using the Gauge framework. By learning from the ideas presented in the talk, readers (attendees) will be able to consider applying the Gauge framework in their own test automation projects. © 2020, Springer Nature Switzerland AG.		Garousi V., Keleş A.B., Balaman Y., Güler Z.Ö.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	While Behavior-driven development (BDD) tools such as Cucumber are powerful tools for automated testing, they have certain limitations. For example, they often enforce strict syntax for test cases, like the “Given-When-Then” format, which may not always be easy to write for a given test case. A new test automation framework named Gauge (gauge.org) addresses that limitation since it does not prescribe the BDD testing process with a strict syntax. In Gauge, writing a test case is as easy as writing down the flow of test cases in several itemized sentences in a natural language, like English. In the context of Testinium (testinium.com), a large software testing company which provides software testing services, tools and solutions to a large number of clients, we have actively used the Gauge framework since 2018 to develop large automated front-end test suites for several large web applications. In this paper/talk, the speakers will share several examples and best practices of developing automated tests in natural-language requirements using the Gauge framework. By learning from the ideas presented in the talk, readers (attendees) will be able to consider applying the Gauge framework in their own test automation projects. © 2020, Springer Nature Switzerland AG.				Excluded	Excluded	new_screen			2						
303	Behave	Leveraging Semi-formal Approaches for DepDevOps	While formal methods have long been praised by the dependable Cyber-Physical System community, continuous software engineering practices are now employing or promoting semi-formal approaches for achieving lean and agile processes. This paper is a discussion about using Behaviour Driven Development, particularly Gherkin and RSpec for DepDevOps, DevOps for dependable Cyber-Physical Systems. © 2020, Springer Nature Switzerland AG.		Zaeske W., Durak U.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	While formal methods have long been praised by the dependable Cyber-Physical System community, continuous software engineering practices are now employing or promoting semi-formal approaches for achieving lean and agile processes. This paper is a discussion about using Behaviour Driven Development, particularly Gherkin and RSpec for DepDevOps, DevOps for dependable Cyber-Physical Systems. © 2020, Springer Nature Switzerland AG.				Included	Included	new_screen			2						
304	Behave	FormTester: Effective Integration of Model-Based and Manually Specified Test Cases	Whilst Model Based Testing (MBT) is an improvement over manual test specification, the leap from it to MBT can be hard. Only recently MBT tools for web applications have emerged that can recover models from existing manually specified test cases. However, there are further requirements for supporting both MBT and manually specified tests. First, we need support for the generation of test initialization procedures. Also, we want to identify areas of the system that are not testable due to defects. We present FormTester, a new MBT tool addressing these limitations. An evaluation with real web applications shows that FormTester helps to reduce the time spent on developing test cases.		Dixit, Rahul; Lutteroth, Christof; Weber, Gerald	Proceedings of the 37th International Conference on Software Engineering - Volume 2	Whilst Model Based Testing (MBT) is an improvement over manual test specification, the leap from it to MBT can be hard. Only recently MBT tools for web applications have emerged that can recover models from existing manually specified test cases. However, there are further requirements for supporting both MBT and manually specified tests. First, we need support for the generation of test initialization procedures. Also, we want to identify areas of the system that are not testable due to defects. We present FormTester, a new MBT tool addressing these limitations. An evaluation with real web applications shows that FormTester helps to reduce the time spent on developing test cases.				Excluded	Excluded	new_screen			2						
305	Behave	Software Automation Testing Secrets Revealed	Widely acknowledged one of the best practical guide to software test automation, Narayanan Palani's Automation Labs has been helping freshers write better automation test scripts for the last three years! Now this classic book has been fully updated and revised with leading-testing tools–and hundreds of new script samples–illustrating the art and science of automation testing. Capturing the body of knowledge available from strong professional experience and industry best practices, Palani synthesizes the most effective techniques and must-know principles into clear, pragmatic guidance. No matter what your experience level,test environment, or project size, this book will inform and stimulate your thinking–and help you build the highest quality automation scripts. Discover the timeless techniques and framework designing methods that help you:Design for TestNG, Visual Studio, Jenkins, Excel VBA, Selenium, HP UFT (formerly QTP), Ranorex, RFT and other wide ranged QA Testing Tools. Reap the benefits of well built selenium webdriver automation framework! Apply powerful programming techniques to build well-estabilished data driven framework, keyword driven framework, hybrid framework, Agile Continuous Integration Automation Framework. Exploit opportunities to design Web services based SOAP Automation Frameworks with the help of SOA, ETL basics and SQL Automation scripts to validate Database Systems! Use construction practices using Object Recognition Technology of test automation tools and capture dynamic web elements. Debug problems in software development life cycle to improve testing process using test estimation techniques, tool selection process. Build quality automation scripts by understanding the machine learning basics of selenium automation framework Resolve automation issues and introduce cucumber, Specflow based Behaviour Driven Development and Test Driven Development in functional testing.		Palani, Narayanan		Widely acknowledged one of the best practical guide to software test automation, Narayanan Palani's Automation Labs has been helping freshers write better automation test scripts for the last three years! Now this classic book has been fully updated and revised with leading-testing tools–and hundreds of new script samples–illustrating the art and science of automation testing. Capturing the body of knowledge available from strong professional experience and industry best practices, Palani synthesizes the most effective techniques and must-know principles into clear, pragmatic guidance. No matter what your experience level,test environment, or project size, this book will inform and stimulate your thinking–and help you build the highest quality automation scripts. Discover the timeless techniques and framework designing methods that help you:Design for TestNG, Visual Studio, Jenkins, Excel VBA, Selenium, HP UFT (formerly QTP), Ranorex, RFT and other wide ranged QA Testing Tools. Reap the benefits of well built selenium webdriver automation framework! Apply powerful programming techniques to build well-estabilished data driven framework, keyword driven framework, hybrid framework, Agile Continuous Integration Automation Framework. Exploit opportunities to design Web services based SOAP Automation Frameworks with the help of SOA, ETL basics and SQL Automation scripts to validate Database Systems! Use construction practices using Object Recognition Technology of test automation tools and capture dynamic web elements. Debug problems in software development life cycle to improve testing process using test estimation techniques, tool selection process. Build quality automation scripts by understanding the machine learning basics of selenium automation framework Resolve automation issues and introduce cucumber, Specflow based Behaviour Driven Development and Test Driven Development in functional testing.				Excluded	Excluded	new_screen			2						
306	Behave	ATDD by Example: A Practical Guide to Acceptance Test-Driven Development	With Acceptance Test-Driven Development (ATDD), business customers, testers, and developers can collaborate to produce testable requirements that help them build higher quality software more rapidly. However, ATDD is still widely misunderstood by many practitioners. ATDD by Example is the first practical, entry-level, hands-on guide to implementing and successfully applying it. ATDD pioneer Markus Grtner walks readers step by step through deriving the right systems from business users, and then implementing fully automated, functional tests that accurately reflect business requirements, are intelligible to stakeholders, and promote more effective development. Through two end-to-end case studies, Grtner demonstrates how ATDD can be applied using diverse frameworks and languages. Each case study is accompanied by an extensive set of artifacts, including test automation classes, step definitions, and full sample implementations. These realistic examples illuminate ATDDs fundamental principles, show how ATDD fits into the broader development process, highlight tips from Grtners extensive experience, and identify crucial pitfalls to avoid. Readers will learn to Master the thought processes associated with successful ATDD implementationUse ATDD with Cucumber to describe software in ways businesspeople can understand Test web pages using ATDD toolsBring ATDD to Java with the FitNesse wiki-based acceptance test framework Use examples more effectively in Behavior-Driven Development (BDD)Specify software collaboratively through innovative workshopsImplement more user-friendly and collaborative test automationTest more cleanly, listen to test results, and refactor tests for greater value If youre a tester, analyst, developer, or project manager, this book offers a concrete foundation for achieving real benefits with ATDD nowand it will help you reap even more value as you gain experience.		Grtner, Markus; Grtner, Markus		With Acceptance Test-Driven Development (ATDD), business customers, testers, and developers can collaborate to produce testable requirements that help them build higher quality software more rapidly. However, ATDD is still widely misunderstood by many practitioners. ATDD by Example is the first practical, entry-level, hands-on guide to implementing and successfully applying it. ATDD pioneer Markus Grtner walks readers step by step through deriving the right systems from business users, and then implementing fully automated, functional tests that accurately reflect business requirements, are intelligible to stakeholders, and promote more effective development. Through two end-to-end case studies, Grtner demonstrates how ATDD can be applied using diverse frameworks and languages. Each case study is accompanied by an extensive set of artifacts, including test automation classes, step definitions, and full sample implementations. These realistic examples illuminate ATDDs fundamental principles, show how ATDD fits into the broader development process, highlight tips from Grtners extensive experience, and identify crucial pitfalls to avoid. Readers will learn to Master the thought processes associated with successful ATDD implementationUse ATDD with Cucumber to describe software in ways businesspeople can understand Test web pages using ATDD toolsBring ATDD to Java with the FitNesse wiki-based acceptance test framework Use examples more effectively in Behavior-Driven Development (BDD)Specify software collaboratively through innovative workshopsImplement more user-friendly and collaborative test automationTest more cleanly, listen to test results, and refactor tests for greater value If youre a tester, analyst, developer, or project manager, this book offers a concrete foundation for achieving real benefits with ATDD nowand it will help you reap even more value as you gain experience.				Excluded	Excluded	new_screen			2						
307	Behave	A serious gaming framework for decision support on hydrological hazards	With increasing population and human intervention on the natural environment, hazards are a growing threat, coming in many forms, including floods, droughts, soil erosion, and water pollution. A key approach to mitigate hydrological disaster risk at the community level is informed planning with decision support systems. The literature shows emerging efforts on multi-hazard decision support systems for hydrological disasters and demonstrates the need for an engaging, accessible, and collaborative serious game environment facilitating the relationship between the environment and communities. In this study, a web-based decision support tool (DST) was developed for hydrological multi-hazard analysis while employing gamification techniques to introduce a competitive element. The serious gaming environment provides functionalities for intuitive management, visualization, and analysis of geospatial, hydrological, and economic data to help stakeholders in the decision-making process regarding hydrological hazard preparedness and response. Major contributions of the presented DST include involving the community in environmental decision making by reducing the technical complexity required for analysis, increasing community awareness for the environmental and socio-economic consequences of hydrological hazards, and allowing stakeholders to discover and discuss potential trade-offs to hazardous scenarios considering the limitations in budget, regulations, and technicality. The paper describes the software design approaches and system architecture applied for a modular, secure, and scalable software as well as the framework's intuitive web-based user interfaces for real-time and collaborative data analysis and damage assessment. Finally, a case study was conducted to demonstrate the usability of DST in a formal setting and to measure user satisfaction with surveys.	Serious games, Multi-hazard tournament, Decision support systems, Hydrological data management and visualization, Web-based systems	Sermet, Yusuf; Demir, Ibrahim; Muste, Marian	Science of The Total Environment	With increasing population and human intervention on the natural environment, hazards are a growing threat, coming in many forms, including floods, droughts, soil erosion, and water pollution. A key approach to mitigate hydrological disaster risk at the community level is informed planning with decision support systems. The literature shows emerging efforts on multi-hazard decision support systems for hydrological disasters and demonstrates the need for an engaging, accessible, and collaborative serious game environment facilitating the relationship between the environment and communities. In this study, a web-based decision support tool (DST) was developed for hydrological multi-hazard analysis while employing gamification techniques to introduce a competitive element. The serious gaming environment provides functionalities for intuitive management, visualization, and analysis of geospatial, hydrological, and economic data to help stakeholders in the decision-making process regarding hydrological hazard preparedness and response. Major contributions of the presented DST include involving the community in environmental decision making by reducing the technical complexity required for analysis, increasing community awareness for the environmental and socio-economic consequences of hydrological hazards, and allowing stakeholders to discover and discuss potential trade-offs to hazardous scenarios considering the limitations in budget, regulations, and technicality. The paper describes the software design approaches and system architecture applied for a modular, secure, and scalable software as well as the framework's intuitive web-based user interfaces for real-time and collaborative data analysis and damage assessment. Finally, a case study was conducted to demonstrate the usability of DST in a formal setting and to measure user satisfaction with surveys.				Excluded	Excluded	new_screen			2						
308	Behave	Towards accountability driven development for machine learning systems	With rapid deployment of Machine Learning (ML) systems into diverse domains such as healthcare and autonomous driving, important questions regarding accountability in case of incidents resulting from ML errors remain largely unsolved. To improve accountability of ML systems, we introduce a framework called Accountability Driven Development (ADD). Our framework reuses Behaviour Driven Development (BDD) approach to describe testing scenarios and system behaviours in ML Systems’ development using natural language, guides and forces developers and intended users to actively record necessary accountability information in the design and implementation stages. In this paper, we illustrate how to transform accountability requirements to specific scenarios and provide syntax to describe them. The use of natural language allows non technical collaborators such as stakeholders and non ML domain experts deeply engaged in ML system development to provide more comprehensive evidence to support system’s accountability. This framework also attributes the responsibility to the whole project team including the intended users rather than putting all the accountability burden on ML engineers only. Moreover, this framework can be considered as a combination of both system test and acceptance test, thus making the development more efficient. We hope this work can attract more engineers to use our idea, which enables them to create more accountable ML systems. Copyright © 2021 for this paper by its authors.		Fung C.P., Pang W., Naja I., Markovic M., Edwards P.	CEUR Workshop Proceedings	With rapid deployment of Machine Learning (ML) systems into diverse domains such as healthcare and autonomous driving, important questions regarding accountability in case of incidents resulting from ML errors remain largely unsolved. To improve accountability of ML systems, we introduce a framework called Accountability Driven Development (ADD). Our framework reuses Behaviour Driven Development (BDD) approach to describe testing scenarios and system behaviours in ML Systems’ development using natural language, guides and forces developers and intended users to actively record necessary accountability information in the design and implementation stages. In this paper, we illustrate how to transform accountability requirements to specific scenarios and provide syntax to describe them. The use of natural language allows non technical collaborators such as stakeholders and non ML domain experts deeply engaged in ML system development to provide more comprehensive evidence to support system’s accountability. This framework also attributes the responsibility to the whole project team including the intended users rather than putting all the accountability burden on ML engineers only. Moreover, this framework can be considered as a combination of both system test and acceptance test, thus making the development more efficient. We hope this work can attract more engineers to use our idea, which enables them to create more accountable ML systems. Copyright © 2021 for this paper by its authors.				Included	Included	new_screen			2						
309	Behave	Automated Acceptance Test Refactoring	With the increasing popularity of agile software development and Test-Driven-Development, also maintenance of acceptance test has become an important issue. In this paper, we describe a concept and a tool for automated acceptance test maintenance using a refactoring approach. Acceptance tests are user tests which are used to determine if a system satisfies acceptance criteria and to enable a customer to determine whether or not to accept the system. In agile development acceptance test are also used as a mean for specification, i.e. acceptance tests are written in advance to the production code (called Behavior-Driven-Development - BDD). In an agile project this poses three major challenges with respect to maintenance of acceptance tests: new requirements may cause changes in the acceptance criteria, which require the system under test to be adapted; when the system under test undergoes a major restructuring, even the acceptance test might have to be adapted; with the increasing acceptance test suite in an agile project the tests themselves may undergo a major reorganization. Having a large acceptance test base, doing these refactorings manually is error prone and causes a lot of effort. In this paper we present a concept and tool for executing automated refactoring for Fit acceptance tests, which significantly reduces the effort for test maintenance and makes them much less error prone.	acceptance test; automation; eclipse; maintenance; plug-in; refactoring	Borg, Rodrick; Kropp, Martin	Proceedings of the 4th Workshop on Refactoring Tools	With the increasing popularity of agile software development and Test-Driven-Development, also maintenance of acceptance test has become an important issue. In this paper, we describe a concept and a tool for automated acceptance test maintenance using a refactoring approach. Acceptance tests are user tests which are used to determine if a system satisfies acceptance criteria and to enable a customer to determine whether or not to accept the system. In agile development acceptance test are also used as a mean for specification, i.e. acceptance tests are written in advance to the production code (called Behavior-Driven-Development - BDD). In an agile project this poses three major challenges with respect to maintenance of acceptance tests: new requirements may cause changes in the acceptance criteria, which require the system under test to be adapted; when the system under test undergoes a major restructuring, even the acceptance test might have to be adapted; with the increasing acceptance test suite in an agile project the tests themselves may undergo a major reorganization. Having a large acceptance test base, doing these refactorings manually is error prone and causes a lot of effort. In this paper we present a concept and tool for executing automated refactoring for Fit acceptance tests, which significantly reduces the effort for test maintenance and makes them much less error prone.				Excluded	Excluded	new_screen			2						
310	Behave	Automated acceptance test refactoring	With the increasing popularity of agile software development and Test-Driven-Development, also maintenance of acceptance test has become an important issue. In this paper, we describe a concept and a tool for automated acceptance test maintenance using a refactoring approach. Acceptance tests are user tests which are used to determine if a system satisfies acceptance criteria and to enable a customer to determine whether or not to accept the system. In agile development acceptance test are also used as a mean for specification, i.e. acceptance tests are written in advance to the production code (called Behavior-Driven-Development - BDD). In an agile project this poses three major challenges with respect to maintenance of acceptance tests: new requirements may cause changes in the acceptance criteria, which require the system under test to be adapted; when the system under test undergoes a major restructuring, even the acceptance test might have to be adapted; with the increasing acceptance test suite in an agile project the tests themselves may undergo a major reorganization. Having a large acceptance test base, doing these refactorings manually is error prone and causes a lot of effort. In this paper we present a concept and tool for executing automated refactoring for Fit acceptance tests, which significantly reduces the effort for test maintenance and makes them much less error prone. Copyright 2011 ACM.		Borg R., Kropp M.	WRT 2011 - Proceedings of the 4th Workshop on Refactoring Tools, co-located with ICSE 2011	With the increasing popularity of agile software development and Test-Driven-Development, also maintenance of acceptance test has become an important issue. In this paper, we describe a concept and a tool for automated acceptance test maintenance using a refactoring approach. Acceptance tests are user tests which are used to determine if a system satisfies acceptance criteria and to enable a customer to determine whether or not to accept the system. In agile development acceptance test are also used as a mean for specification, i.e. acceptance tests are written in advance to the production code (called Behavior-Driven-Development - BDD). In an agile project this poses three major challenges with respect to maintenance of acceptance tests: new requirements may cause changes in the acceptance criteria, which require the system under test to be adapted; when the system under test undergoes a major restructuring, even the acceptance test might have to be adapted; with the increasing acceptance test suite in an agile project the tests themselves may undergo a major reorganization. Having a large acceptance test base, doing these refactorings manually is error prone and causes a lot of effort. In this paper we present a concept and tool for executing automated refactoring for Fit acceptance tests, which significantly reduces the effort for test maintenance and makes them much less error prone. Copyright 2011 ACM.				Excluded	Excluded	new_screen			2						
311	Behave	Building Applications with Scala	Write modern, scalable, and reactive applications with the power of ScalaAbout This BookDelves into the intricacies of functional reactive programming with ScalaExplores frameworks like Akka, Play and Slick used to develop efficient applications A step by step guide with plenty of examples showing practical implementation of essential concepts Who This Book Is ForIf you are a Java or JVM developer who wants to use Scala to build reactive functional applications for the JVM platform, then this book is for you. Prior knowledge of Java or functional programing would help. No Scala knowledge is required. What You Will Learn Use Akka to create a chat service for your appEquip yourself with the techniques and tools to build reports and build database persistence with Scala and Slick Develop a customer-facing Rest API that makes use of Scala and SprayMake use of the Scala web development principles and scale up the architecture of your applicationGet familiar with the core principles and concepts of Functional Programming Use the Play framework to create models, controllers, and views Develop reactive backing frameworks by writing code with RxScala Discover what proper testing entails with Scala using behavior-driven development In DetailScala is known for incorporating both object-oriented and functional programming into a concise and extremely powerful package. However, creating an app in Scala can get a little tricky because of the complexity the language has. This book will help you dive straight into app development by creating a real, reactive, and functional application. We will provide you with practical examples and instructions using a hands-on approach that will give you a firm grounding in reactive functional principles. The book will take you through all the fundamentals of app development within Scala as you build an application piece by piece. We've made sure to incorporate everything you need from setting up to building reports and scaling architecture. This book also covers the most useful tools available in the Scala ecosystem, such as Slick, Play, and Akka, and a whole lot more. It will help you unlock the secrets of building your own up-to-date Scala application while maximizing performance and scalability. Style and approach This book takes a step-by-step approach to app development with Scala. It will place special emphasis on functional language. It will teach you the core benefits of Scala and the fundamentals of functional programming by developing a robust application.		Pacheco, Diego		Write modern, scalable, and reactive applications with the power of ScalaAbout This BookDelves into the intricacies of functional reactive programming with ScalaExplores frameworks like Akka, Play and Slick used to develop efficient applications A step by step guide with plenty of examples showing practical implementation of essential concepts Who This Book Is ForIf you are a Java or JVM developer who wants to use Scala to build reactive functional applications for the JVM platform, then this book is for you. Prior knowledge of Java or functional programing would help. No Scala knowledge is required. What You Will Learn Use Akka to create a chat service for your appEquip yourself with the techniques and tools to build reports and build database persistence with Scala and Slick Develop a customer-facing Rest API that makes use of Scala and SprayMake use of the Scala web development principles and scale up the architecture of your applicationGet familiar with the core principles and concepts of Functional Programming Use the Play framework to create models, controllers, and views Develop reactive backing frameworks by writing code with RxScala Discover what proper testing entails with Scala using behavior-driven development In DetailScala is known for incorporating both object-oriented and functional programming into a concise and extremely powerful package. However, creating an app in Scala can get a little tricky because of the complexity the language has. This book will help you dive straight into app development by creating a real, reactive, and functional application. We will provide you with practical examples and instructions using a hands-on approach that will give you a firm grounding in reactive functional principles. The book will take you through all the fundamentals of app development within Scala as you build an application piece by piece. We've made sure to incorporate everything you need from setting up to building reports and scaling architecture. This book also covers the most useful tools available in the Scala ecosystem, such as Slick, Play, and Akka, and a whole lot more. It will help you unlock the secrets of building your own up-to-date Scala application while maximizing performance and scalability. Style and approach This book takes a step-by-step approach to app development with Scala. It will place special emphasis on functional language. It will teach you the core benefits of Scala and the fundamentals of functional programming by developing a robust application.				Excluded	Excluded	new_screen			2						
312	Behave	Documentation by example	Writing documentation can be fun and rewarding, but keeping up with an ever-changing system can take a toll on that joy. The documentation tends to get either expensive (duplication-intense), outdated or non-existing. This demonstration will present an open source tool that addresses these shortcomings by extending the BDD[1] approach to provide rich and human readable documents automatically from a JUnit[2] test suite. You'll learn how to include snippets, run-time data and more in your documents, all this with minimal effort and intrusion. This approach is suitable both for APIs and GUIs, as will be shown. © 2009 Springer Berlin Heidelberg.		Brolund D.	Lecture Notes in Business Information Processing	Writing documentation can be fun and rewarding, but keeping up with an ever-changing system can take a toll on that joy. The documentation tends to get either expensive (duplication-intense), outdated or non-existing. This demonstration will present an open source tool that addresses these shortcomings by extending the BDD[1] approach to provide rich and human readable documents automatically from a JUnit[2] test suite. You'll learn how to include snippets, run-time data and more in your documents, all this with minimal effort and intrusion. This approach is suitable both for APIs and GUIs, as will be shown. © 2009 Springer Berlin Heidelberg.				Included	Included	new_screen			2						
313	Behave	Discovery: Explore Behaviour Using Examples (Volume 1)	Written by the creator of SpecFlow and the author of The Cucumber for Java Book, this book provides inside information on how to get the most out of the discovery phase of Behaviour Driven Development (BDD). This practical guide demonstrates good collaboration techniques, illustrated by concrete examples. This book is written for everyone involved in the specification and delivery of software (including product owners, business analysts, developers, and testers). The book starts by explaining the reasons BDD exists in the first place and describes techniques for getting the most out of collaboration between business and delivery team members. This is the first in the BDD Books series that will guide you through the entire development process, including specific technical practices needed to successfully drive development using collaboratively-authored specifications and living documentation.		Nagy, Gaspar; Rose, Seb		Written by the creator of SpecFlow and the author of The Cucumber for Java Book, this book provides inside information on how to get the most out of the discovery phase of Behaviour Driven Development (BDD). This practical guide demonstrates good collaboration techniques, illustrated by concrete examples. This book is written for everyone involved in the specification and delivery of software (including product owners, business analysts, developers, and testers). The book starts by explaining the reasons BDD exists in the first place and describes techniques for getting the most out of collaboration between business and delivery team members. This is the first in the BDD Books series that will guide you through the entire development process, including specific technical practices needed to successfully drive development using collaboratively-authored specifications and living documentation.				Excluded	Excluded	new_screen			2						
314	Behave	The RSpec Book: Behaviour Driven Development with Rspec, Cucumber, and Friends	"You'll get started right away with RSpec 2 and Cucumber by developing a simple game, using Cucumber to express high-level requirements in language your customer understands, and RSpec to express more granular requirements that focus on the behavior of individual objects in the system. You'll learn how to use test doubles (mocks and stubs) to control the environment and focus the RSpec examples on one object at a time, and how to customize RSpec to ""speak"" in the language of your domain. You'll develop Rails 3 applications and use companion tools such as Webrat and Selenium to express requirements for web applications both in memory and in the browser. And you'll learn to specify Rails views, controllers, and models, each in complete isolation from the other. Whether you're developing applications, frameworks, or the libraries that power them, The RSpec Book will help you write better code, better tests, and deliver better software to happier users."		Chelimsky, David; Astels, Dave; Helmkamp, Bryan; North, Dan; Dennis, Zach; Hellesoy, Aslak		"You'll get started right away with RSpec 2 and Cucumber by developing a simple game, using Cucumber to express high-level requirements in language your customer understands, and RSpec to express more granular requirements that focus on the behavior of individual objects in the system. You'll learn how to use test doubles (mocks and stubs) to control the environment and focus the RSpec examples on one object at a time, and how to customize RSpec to ""speak"" in the language of your domain. You'll develop Rails 3 applications and use companion tools such as Webrat and Selenium to express requirements for web applications both in memory and in the browser. And you'll learn to specify Rails views, controllers, and models, each in complete isolation from the other. Whether you're developing applications, frameworks, or the libraries that power them, The RSpec Book will help you write better code, better tests, and deliver better software to happier users."				Excluded	Excluded	new_screen			2						
315	Behave	The Cucumber Book: Behaviour-Driven Development for Testers and Developers	Your customers want rock-solid, bug-free software that does exactly what they expect it to do. Yet they can't always articulate their ideas clearly enough for you to turn them into code. The Cucumber Book dives straight into the core of the problem: communication between people. Cucumber saves the day; it's a testing, communication, and requirements tool - all rolled into one. We'll show you how to express your customers' wild ideas as a set of clear, executable specifications that everyone on the team can read. You'll learn how to feed those examples into Cucumber and let it guide your development. You'll build just the right code to keep your customers happy, and not a line more. The first part of the book teaches you how to use the core features of Cucumber. You'll learn how to use Cucumber's Gherkin DSL to describe– in plain language - the behavior your customers want from the system. You'll learn how to write Ruby code that interprets those plain language specifications and checks them against your application. In Part 2, you'll consolidate the knowledge you just gained with a worked example. Although it was born in the Ruby community, you can use Cucumber to test almost any system, from a simple shell script or a Perl script, to enterprise PHP or a Java web application. In Part 3, you'll find a selection of recipes for some of the most common situations you'll encounter using Cucumber in the wild. You'll learn how to test Ajax-heavy web applications with Capybara and Selenium, REST web services, Ruby on Rails applications, command-line applications, legacy applications and lots more! Written by the creator of Cucumber and one of its most experienced users and contributors, The Cucumber Book is an authoritative guide that will give you and your team all the knowledge you need to start using Cucumber with confidence. What You Need: Windows, Mac OS X (with XCode) or Linux Ruby 1.9.2 and upwards		Wynne, Matt; Hellesoy, Aslak		Your customers want rock-solid, bug-free software that does exactly what they expect it to do. Yet they can't always articulate their ideas clearly enough for you to turn them into code. The Cucumber Book dives straight into the core of the problem: communication between people. Cucumber saves the day; it's a testing, communication, and requirements tool - all rolled into one. We'll show you how to express your customers' wild ideas as a set of clear, executable specifications that everyone on the team can read. You'll learn how to feed those examples into Cucumber and let it guide your development. You'll build just the right code to keep your customers happy, and not a line more. The first part of the book teaches you how to use the core features of Cucumber. You'll learn how to use Cucumber's Gherkin DSL to describe– in plain language - the behavior your customers want from the system. You'll learn how to write Ruby code that interprets those plain language specifications and checks them against your application. In Part 2, you'll consolidate the knowledge you just gained with a worked example. Although it was born in the Ruby community, you can use Cucumber to test almost any system, from a simple shell script or a Perl script, to enterprise PHP or a Java web application. In Part 3, you'll find a selection of recipes for some of the most common situations you'll encounter using Cucumber in the wild. You'll learn how to test Ajax-heavy web applications with Capybara and Selenium, REST web services, Ruby on Rails applications, command-line applications, legacy applications and lots more! Written by the creator of Cucumber and one of its most experienced users and contributors, The Cucumber Book is an authoritative guide that will give you and your team all the knowledge you need to start using Cucumber with confidence. What You Need: Windows, Mac OS X (with XCode) or Linux Ruby 1.9.2 and upwards				Excluded	Excluded	new_screen			2						
316	Behave	A Basic Spring Boot Application	We could start writing code directly, but that, even while being pragmatic, would be far from being a real case. Instead, we'll define a product that we want to build, and we'll split it into small chunks. This requirements-oriented approach is used throughout the book to make it more practical. In real life, you'll always have these business requirements.	specific testing technologies/languages	Macero Garc{\'i}a, Mois{\'e}s	Learn Microservices with Spring Boot	https://doi.org/10.1007/978-1-4842-6131-6_3		25--74	"""@Inbook{MaceroGarcia2020,
    author = ""Macero Garc{\'i}a, Mois{\'e}s"",
    title = ""A Basic Spring Boot Application"",
    bookTitle = ""Learn Microservices with Spring Boot: A Practical Approach to RESTful Services Using an Event-Driven Architecture, Cloud-Native Patterns, and Containerization"",
    year = ""2020"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""25--74"",
    abstract = ""We could start writing code directly, but that, even while being pragmatic, would be far from being a real case. Instead, we'll define a product that we want to build, and we'll split it into small chunks. This requirements-oriented approach is used throughout the book to make it more practical. In real life, you'll always have these business requirements."",
    isbn = ""978-1-4842-6131-6"",
    doi = ""10.1007/978-1-4842-6131-6\_3"",
    url = ""https://doi.org/10.1007/978-1-4842-6131-6\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		A Basic Spring Boot Application	http://link.springer.com/chapter/10.1007/978-1-4842-6131-6_3	Apress	nan; Keywords; References
317	Behave	A Beginner's Guide to Scala, Object Orientation and Functional Programming		specific testing technologies/languages	Dr. John Hunt						Excluded	Excluded	new_screen			2						
318	Behave	A Circumstantial Methodological Analysis of Recent Studies on NLP-driven Test Automation Approaches	From manual testing to test automation, test generation is advancing. With the emergence of new challenges---and legacy challenges already persisting---there is a great need of turning test creation activity into a way that is more responsive and effortless. Natural language processing, with its applicability in different domains, is swiftly adopted by researchers in software testing discipline to perform automation of such activities. Attempts like this will bring in prominent paradigm shifts in the conventional and mundane non-automated frameworks of test cases creation (software development activity) from requirement specifications. To explore, as how natural language processing could be employed to assist software testing, this paper presents a detailed article with methodological investigation of some recent research studies. The detailed knowledge will help the practitioners to get insights of how natural language processing (NLP) is being carried out in testing domain and what specific role does each term associated with it will play.	NLP in testing	Gupta, Atulya; Mahapatra, Rajendra Prasad	Intelligent Systems	https://doi.org/10.1007/978-981-33-6081-5_14		155--167	"""@InProceedings{10.1007/978-981-33-6081-5_14,
    author = ""Gupta, Atulya and Mahapatra, Rajendra Prasad"",
    editor = ""Udgata, Siba K. and Sethi, Srinivas and Srirama, Satish N."",
    title = ""A Circumstantial Methodological Analysis of Recent Studies on NLP-driven Test Automation Approaches"",
    booktitle = ""Intelligent Systems"",
    year = ""2021"",
    publisher = ""Springer Singapore"",
    address = ""Singapore"",
    pages = ""155--167"",
    abstract = ""From manual testing to test automation, test generation is advancing. With the emergence of new challenges---and legacy challenges already persisting---there is a great need of turning test creation activity into a way that is more responsive and effortless. Natural language processing, with its applicability in different domains, is swiftly adopted by researchers in software testing discipline to perform automation of such activities. Attempts like this will bring in prominent paradigm shifts in the conventional and mundane non-automated frameworks of test cases creation (software development activity) from requirement specifications. To explore, as how natural language processing could be employed to assist software testing, this paper presents a detailed article with methodological investigation of some recent research studies. The detailed knowledge will help the practitioners to get insights of how natural language processing (NLP) is being carried out in testing domain and what specific role does each term associated with it will play."",
    isbn = ""978-981-33-6081-5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		A Circumstantial Methodological Analysis of Recent Studies on NLP-driven Test Automation Approaches	http://link.springer.com/chapter/10.1007/978-981-33-6081-5_14	Springer Singapore	nan; Keywords; References
319	Behave	A distributable event-oriented architecture for activity recognition in smart homes	In this paper, a new architecture is proposed for continuously generating, propagating, and delivering information by using event-based communication between independent agents. The resulting system can both handle heterogeneous smart environments and compute information in multiple places. With a communication method working as an abstraction layer, the proposed solution enables the use of multiple technologies at once. Additionally, different options for delivering the resulting data to client applications are explored. The implementation of this design as a platform written in Java with the Spring Framework is also presented, along with its handling of ten housing facilities equipped with various sensors (electromagnetic contacts, smart plugs, motion detectors, humidity, temperature, and light sensors). This paper is then concluded by an analysis of the platform workloads incurred by the tracking of a set of low-level activities. Finally, the code is distributed online for the benefit of the community.	Artificial Intelligence; Activity recognition; Complex event processing	Cedric Demongivert; Kevin Bouchard; Sebastien Gaboury; Bruno Bouchard; Maxime Lussier; Maxime Parenteau; Catherine Laliberte; Melanie Couture,; Nathalie Bier; Sylvain Giroux	Journal of Reliable Intelligent Environments	https://doi.org/10.1007/s40860-020-00125-y	"citation_journal_title=J Biomed Inf; citation_title=Automatic assessment of functional health decline in older adults based on smart home data; citation_author=A Alberdi Aramendi, A Weakley, A Aztiria Goenaga, M Schmitter-Edgecombe, DJ Cook; citation_volume=81; citation_publication_date=2018; citation_pages=119-130; citation_doi=10.1016/j.jbi.2018.03.009; citation_id=CR1; citation_journal_title=Pervasive Mobile Comput; citation_title=Enhancing activity recognition using cpd-based activity segmentation; citation_author=S Aminikhanghahi, DJ Cook; citation_volume=53; citation_publication_date=2019; citation_pages=75-89; citation_doi=10.1016/j.pmcj.2019.01.004; citation_id=CR2; Arthur J, Azadegan S (2005) Spring framework for rapid open source j2ee web application development: a case study. Sixth International Conference on Software Engineering. Artificial Intelligence, Networking and Parallel/Distributed Computing and First ACIS International Workshop on self-assembling wireless network, pp 90-95; citation_journal_title=Appl Artif Intell; citation_title=A smart environments architecture (search); citation_author=J Augusto, J Gimenez-Manuel, M Quinde, C Oguego, M Ali, C James-Reynolds; citation_volume=34; citation_issue=2; citation_publication_date=2020; citation_pages=155-186; citation_doi=10.1080/08839514.2020.1712778; citation_id=CR4; citation_journal_title=Human Cent Comput Inf Sci; citation_title=intelligent environments: a manifesto; citation_author=JC Augusto, V Callaghan, D Cook, A Kameas, I Satoh; citation_volume=3; citation_issue=1; citation_publication_date=2013; citation_pages=12; citation_doi=10.1186/2192-1962-3-12; citation_id=CR5; citation_journal_title=ACM Comput Surv; citation_title=A survey on reactive programming; citation_author=E Bainomugisha, AL Carreton, Tv Cutsem, S Mostinckx, Wd Meuter; citation_volume=45; citation_issue=4; citation_publication_date=2013; citation_pages=1-34; citation_doi=10.1145/2501654.2501666; citation_id=CR6; citation_journal_title=Expert Syst Appl; citation_title=Tracking objects within a smart home; citation_author=F Bergeron, K Bouchard, S Gaboury, S Giroux; citation_volume=113; citation_publication_date=2018; citation_pages=428-442; citation_doi=10.1016/j.eswa.2018.07.009; citation_id=CR7; citation_journal_title=Sensors; citation_title=A semi-automatic annotation approach for human activity recognition; citation_author=P Bota, J Silva, D Folgado, H Gamboa; citation_volume=19; citation_publication_date=2019; citation_pages=501; citation_doi=10.3390/s19030501; citation_id=CR8; Bouchard K, Bouchard B, Bouzouanea A (2014) Practical guidelines to build smart homes: lessons learned. Opportunistic networking, smart home, smart city, smart systems (book chapter), pp 1-37; Bozdag E, Mesbah A, van Deursen A (2007) A comparison of push and pull techniques for ajax. In: 2007 9th IEEE International Workshop on web site evolution, pp 15-22; Cigno RL, Russo A, Carra D (2008) On some fundamental properties of p2p push/pull protocols. In: 2008 Second International Conference on communications and electronics, pp 67-73; citation_journal_title=Computer; citation_title=Casas: a smart home in a box; citation_author=D Cook, A Crandall, B Thomas, N Krishnan; citation_volume=46; citation_publication_date=2013; citation_pages=62-69; citation_doi=10.1109/MC.2012.328; citation_id=CR12; citation_journal_title=J Ambient Intell Smart Environ; citation_title=Multi-agent smart environments; citation_author=DJ Cook; citation_volume=1; citation_issue=1; citation_publication_date=2009; citation_pages=51-55; citation_doi=10.3233/AIS-2009-0007; citation_id=CR13; citation_journal_title=IEEE Intell Syst; citation_title=Learning setting-generalized activity models for smart spaces; citation_author=DJ Cook; citation_volume=2010; citation_publication_date=2019; citation_pages=1; citation_id=CR14; Fielding RT, Taylor RN (2000) Architectural styles and the design of network-based software architectures. Ph.D. thesis, University of California, Irvine; citation_journal_title=IEEE Intell Syst; citation_title=Exploiting passive rfid technology for activity recognition in smart homes; citation_author=D Fortin-Simard; citation_volume=30; citation_issue=4; citation_publication_date=2015; citation_pages=7-15; citation_doi=10.1109/MIS.2015.18; citation_id=CR16; citation_title=Web applications with spring boot; citation_publication_date=2019; citation_id=CR17; citation_author=F Gutierrez; citation_publisher=Apress; citation_journal_title=J Reliab Intell Environ; citation_title=Complex behavioral pattern mining in non-intrusive sensor-based smart homes using an intelligent activity inference engine; citation_author=J Hao, A Bouzouane, S Gaboury; citation_volume=3; citation_publication_date=2017; citation_pages=99-116; citation_doi=10.1007/s40860-017-0041-2; citation_id=CR18; citation_journal_title=Computer; citation_title=The gator tech smart house: a programmable pervasive space; citation_author=S Helal, CW Mann, H El-Zabadani, J King, Y Kaddoura, E Jansen; citation_volume=38; citation_publication_date=2005; citation_pages=50-60; citation_doi=10.1109/MC.2005.107; citation_id=CR19; citation_journal_title=J Reliab Intell Environ; citation_title=Smart home in a box: usability study for a large scale self-installation of smart home technologies; citation_author=Y Hu; citation_volume=2; citation_publication_date=2016; citation_pages=93-106; citation_doi=10.1007/s40860-016-0021-y; citation_id=CR20; Kaewkasi C, Gurd JR (2008) Groovy aop: a dynamic aop system for a JVM-based language. In: Proceedings of the 2008 AOSD Workshop on software engineering properties of languages and aspect technologies, SPLAT '08. ACM, New York, pp 3:1-3:6; citation_journal_title=J Interdiscip Res; citation_title=Supporting the development of gerontechnology as part of silver economy building; citation_author=A Klimczuk; citation_volume=2; citation_publication_date=2012; citation_pages=52-56; citation_id=CR22; citation_title=Activity recognition from accelerometer data using symbolic data approach; citation_inbook_title=Data analytics and learning; citation_publication_date=2019; citation_pages=317-329; citation_id=CR23; citation_author=PG Lavanya; citation_author=S Mallappa; citation_publisher=Springer; citation_journal_title=Disabil Rehabil Assistive Technol; citation_title=Identifying participation needs of people with acquired brain injury in the development of a collective community smart home; citation_author=M Levasseur; citation_volume=11; citation_issue=8; citation_publication_date=2016; citation_pages=636-644; citation_doi=10.3109/17483107.2015.1029536; citation_id=CR24; Lucassen G, Dalpiaz F, van der Werf JME, Brinkkemper S, Zowghi D (2017) Behavior-driven requirements traceability via automated acceptance tests. In: 2017 IEEE 25th International Requirements Engineering Conference Workshops (REW). IEEE, pp 431-434; citation_journal_title=J Alzheimers Dis; citation_title=Smart home technology: a new approach for performance measurements of activities of daily living and prediction of mild cognitive impairment in older adults; citation_author=M Lussier; citation_volume=68; citation_publication_date=2019; citation_pages=85-96; citation_doi=10.3233/JAD-180652; citation_id=CR26; Lussier M et al (2020) Using ambient assisted living to monitor older adults with alzheimer's disease: a single-case study to validate monitoring report. JMIR Med Inf; citation_journal_title=Signal Process Image Commun; citation_title=Ts-lstm and temporal-inception: Exploiting spatiotemporal dynamics for activity recognition; citation_author=CY Ma, MH Chen, Z Kira, G AlRegib; citation_volume=71; citation_publication_date=2019; citation_pages=76-87; citation_doi=10.1016/j.image.2018.09.003; citation_id=CR28; citation_journal_title=Pervasive Mobile Comput; citation_title=Adaptive monitoring system for e-health smart homes; citation_author=H Mshali, T Lemlouma, D Magoni; citation_volume=43; citation_publication_date=2018; citation_pages=1-19; citation_doi=10.1016/j.pmcj.2017.11.001; citation_id=CR29; citation_journal_title=J Ambient Intell Smart Environ; citation_title=Sensor-based activity recognition in the context of ambient assisted living systems: a review; citation_author=A Patel, J Shah; citation_volume=11; citation_issue=4; citation_publication_date=2019; citation_pages=301-322; citation_doi=10.3233/AIS-190529; citation_id=CR30; citation_journal_title=Sensors; citation_title=The light node communication framework: A new way to communicate inside smart homes; citation_author=V Plantevin, A Bouzouane, S Gaboury; citation_volume=17; citation_issue=10; citation_publication_date=2017; citation_pages=2397; citation_doi=10.3390/s17102397; citation_id=CR31; Redux website (2020). 
                  https://redux.js.org/introduction/getting-started
                  
                . Accessed 07 May 2020; Solis C, Wang X (2011) A study of the characteristics of behaviour driven development. In: 2011 37th EUROMICRO Conference on software engineering and advanced applications, pp 383-387; citation_journal_title=Inf Softw Technol; citation_title=Test case design for context-aware applications: are we there yet?; citation_author=Santos I Sousa, RM Castro Andrade, LS Rocha, S Matalonga, KM Oliveira, GH Travassos; citation_volume=88; citation_publication_date=2017; citation_pages=1-16; citation_doi=10.1016/j.infsof.2017.03.008; citation_id=CR34; Spock Framework website (2019). 
                  http://spockframework.org
                  
                . Accessed 22 May 2019; citation_journal_title=Computer; citation_title=Using smart homes to detect and analyze health events; citation_author=G Sprint, D Cook, R Fritz, M Schmitter-Edgecombe; citation_volume=49; citation_publication_date=2016; citation_pages=29-37; citation_doi=10.1109/MC.2016.338; citation_id=CR36; Stuart Russell PN (2011) Artificial intelligence: a mordern approach, chap 2, 3rd edn. Pearson, pp 34-63; citation_title=Activity recognition in the home using simple and ubiquitous sensors; citation_inbook_title=Pervasive Computing; citation_publication_date=2004; citation_pages=158-175; citation_id=CR38; citation_author=EM Tapia; citation_author=SS Intille; citation_author=K Larson; citation_publisher=Springer; United Nations DoE, Social Affairs PD (2017) World population ageing 2017. Tech. Rep. ST/ESA/SER.A/408, United Nations; citation_journal_title=Pervasive Mobile Comput; citation_title=A communication efficient distributed learning framework for smart environments; citation_author=L Valerio, A Passarella, M Conti; citation_volume=41; citation_publication_date=2017; citation_pages=46-68; citation_doi=10.1016/j.pmcj.2017.07.014; citation_id=CR40; Wang J, Chen Y, Hao S, Peng X, Hu L (2019) Deep learning for sensor-based activity recognition: A survey. Pattern Recogn Lett 119:3 - 11 (deep Learning for Pattern Recognition); citation_title=Testing and code quality; citation_publication_date=2015; citation_id=CR42; citation_author=G Wielenga; citation_publisher=Apress; Wimo PA, et al (2015) World Alzheimer report 2015. Tech. rep., Alzheimer's Disease International; citation_journal_title=Pattern Recogn; citation_title=Open-set human activity recognition based on micro-doppler signatures; citation_author=Y Yang; citation_volume=85; citation_publication_date=2019; citation_pages=60-69; citation_doi=10.1016/j.patcog.2018.07.030; citation_id=CR44; citation_journal_title=Computing; citation_title=Wits: an iot-endowed computational framework for activity recognition in personalized smart homes; citation_author=L Yao; citation_volume=100; citation_issue=4; citation_publication_date=2018; citation_pages=369-385; citation_doi=10.1007/s00607-018-0603-z; citation_id=CR45; citation_journal_title=IEEE Softw; citation_title=Comprehensive multiplatform dynamic program analysis for java and android; citation_author=Y Zheng, S Kell, L Bulej, H Sun, W Binder; citation_volume=33; citation_issue=4; citation_publication_date=2016; citation_pages=55-63; citation_doi=10.1109/MS.2015.151; citation_id=CR46"			Excluded	Excluded	new_screen			2	Springer Link		A distributable event-oriented architecture for activity recognition in smart homes	http://link.springer.com/article/10.1007/s40860-020-00125-y	Springer Link	nan; Pages; Year; Bibtex
320	Behave	A domain-specific language to design false data injection tests for air traffic control systems	The ADS-B--automatic dependent surveillance-broadcast--technology requires aircraft to broadcast their position and velocity periodically. As compared to legacy radar technologies, coupled with alarming cyber security issues (the ADS-B protocol provides no encryption nor identification), the reliance on aircraft to communicate this surveillance information exposes air transport to new cyber security threats, and especially to FDIAs--false data injection attacks--where an attacker modifies, blocks, or emits fake ADS-B messages to dupe controllers and surveillance systems. This paper is part of an ongoing research initiative toward the generation of FDIA test scenarios and focuses on supporting the test design activity, i.e., supporting ATC experts to meticulously craft test cases in order to assess the resilience of surveillance systems against FDIAs. To achieve this goal, we propose a complete and powerful domain-specific language (DSL), close to natural language, that provides a large expressiveness to support ATC business experts in creating FDIA's test scenarios. We demonstrate the design capabilities of this approach and its productivity gain with respect to manually creating the FDIAs test scenarios.	Artificial Intelligence; Domain-specific language; Air traffic control; ADS-B protocol; Cyber security; False data injection attacks; Automated test generation	Alexandre Vernotte; Aymeric Cretin; Bruno Legeard,; Fabien Peureux	International Journal on Software Tools for Technology Transfer	https://doi.org/10.1007/s10009-021-00604-4	"51, E.W.G.: Safety, performance and interoperability requirements document for ADS-B/NRA application. Tech. rep., The European Organisation for Civil Aviation Equipment (2005). 
                  http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.6059&rep=rep1&type=pdf; Akerman, S., Habler, E., Shabtai, A.: VizADS-B: Analyzing sequences of ADS-B images using explainable convolutional LSTM encoder-decoder to detect cyber attacks (2019). arXiv preprint 
                  arXiv:1906.07921; citation_journal_title=J. ACM; citation_title=A new method of interpolation and smooth curve fitting based on local procedures; citation_author=H Akima; citation_volume=17; citation_publication_date=1970; citation_pages=589-602; citation_doi=10.1145/321607.321609; citation_id=CR3; Asia, I.C.A.O., (ICAO), P.O.: Guidance material on issues to be considered in atc multi-sensor fusion processing including the integration of ADS-B data. Tech. rep., APANPIRG/19 (2008). 
                  https://www.icao.int/APAC/Documents/edocs/cns/grpt_atcmulti_adsbdata.pdf; Baader, F., Horrocks, I., Sattler, U.: Description logics. In: Handbook on Ontologies, pp. 3-28. Springer (2004); Barreto, A.B., Hieb, M., Yano, E.: Developing a complex simulation environment for evaluating cyber attacks. In: Interservice/Industry Training, Simulation, and Education Conference (I/ITSEC), vol. 12248, pp. 1-9 (2012); Belta, C., Yordanov, B., Aydin Gol, E.: Temporal Logics and Automata, pp. 27-38. Springer International Publishing, Cham (2017); citation_journal_title=Sci. Am.; citation_title=The semantic web; citation_author=T Berners-Lee, J Hendler, O Lassila; citation_volume=284; citation_issue=5; citation_publication_date=2001; citation_pages=34-43; citation_doi=10.1038/scientificamerican0501-34; citation_id=CR8; citation_journal_title=J. Navig.; citation_title=Sesar and nextgen: investing in new paradigms; citation_author=P Brooker; citation_volume=61; citation_issue=2; citation_publication_date=2008; citation_pages=195-208; citation_doi=10.1017/S0373463307004596; citation_id=CR9; citation_journal_title=Comput. Sci. Inf. Syst.; citation_title=Ontology driven development of domain-specific languages; citation_author=I Ceh, M Crepinsek, T Kosar, M Mernik; citation_volume=8; citation_issue=2; citation_publication_date=2011; citation_pages=317-342; citation_doi=10.2298/CSIS101231019C; citation_id=CR10; citation_journal_title=IEEE Trans. Signal Process.; citation_title=A simple and efficient estimator for hyperbolic location; citation_author=YT Chan, K Ho; citation_volume=42; citation_issue=8; citation_publication_date=1994; citation_pages=1905-1915; citation_doi=10.1109/78.301830; citation_id=CR11; citation_journal_title=IEEE Softw.; citation_title=Commonality and variability in software engineering; citation_author=J Coplien, D Hoffman, D Weiss; citation_volume=15; citation_issue=6; citation_publication_date=1998; citation_pages=37-45; citation_doi=10.1109/52.730836; citation_id=CR12; Cretin, A., Legeard, B., Peureux, F., Vernotte, A.: Increasing the resilience of ATC systems against false data injection attacks using DSL-based testing. In: Proceedings of the 8th International Conference on Research in Air Transportation (ICRAT'18), Doctoral Symposium, pp. 1-4. Barcelona, Spain (2018); Cretin, A., Vernotte, A., Chevrot, A., Peureux, F., Legeard, B.: Test data generation for false data injection attack testing in air traffic surveillance. In: 4th International Workshop on Testing Extra-Functional Properties and Quality Characteristics of Software Systems (ITEQS 2020). Porto, Portugal (2020); Dan, G., Sandberg, H.: Stealth attacks and protection schemes for state estimators in power systems. In: Smart Grid Communications (SmartGridComm), 2010 First IEEE International Conference on, pp. 214-219. IEEE (2010); citation_journal_title=Am. Math. Mon.; citation_title=On the runge example; citation_author=JF Epperson; citation_volume=94; citation_issue=4; citation_publication_date=1987; citation_pages=329-341; citation_doi=10.1080/00029890.1987.12000642; citation_id=CR16; EUROCONTROL: D23--security assessment for ADS-B ground system--3rd iteration 00.01.02. Tech. rep., Sesar Joint Undertaking (SJU) (2014); citation_journal_title=Ann. Softw. Eng.; citation_title=Dare: Domain analysis and reuse environment; citation_author=W Frakes, R Prieto, C Fox; citation_volume=5; citation_issue=1; citation_publication_date=1998; citation_pages=125-141; citation_doi=10.1023/A:1018972323770; citation_id=CR18; citation_journal_title=J. Autom. Reason.; citation_title=Hermit: an owl 2 reasoner; citation_author=B Glimm, I Horrocks, B Motik, G Stoilos, Z Wang; citation_volume=53; citation_issue=3; citation_publication_date=2014; citation_pages=245-269; citation_doi=10.1007/s10817-014-9305-1; citation_id=CR19; citation_journal_title=Comput. Secur.; citation_title=Using lstm encoder-decoder algorithm for detecting anomalous ADS-B messages; citation_author=E Habler, A Shabtai; citation_volume=78; citation_publication_date=2018; citation_pages=155-173; citation_doi=10.1016/j.cose.2018.07.004; citation_id=CR20; citation_title=A case of visitor versus interpreter pattern; citation_inbook_title=Objects, Models, Components, Patterns; citation_publication_date=2011; citation_pages=228-243; citation_id=CR21; citation_author=M Hills; citation_author=P Klint; citation_author=T Storm; citation_author=J Vinju; citation_publisher=Springer; Jafer, S., Chhaya, B., Durak, U.: Owl ontology to ecore metamodel transformation for designing a domain specific language to develop aviation scenarios. In: Proceedings of the Symposium on Model-Driven Approaches for Simulation Engineering, pp. 1-11 (2017); citation_title=Feature-Oriented Domain Analysis (FODA) Feasibility Study; citation_publication_date=1990; citation_id=CR23; citation_author=KC Kang; citation_author=SG Cohen; citation_author=JA Hess; citation_author=WE Novak; citation_author=AS Peterson; citation_publisher=Carnegie-Mellon Univ Pittsburgh Pa Software Engineering Inst; citation_journal_title=Inf. Softw. Technol.; citation_title=Domain-specific languages: a systematic mapping study; citation_author=T Kosar, S Bohra, M Mernik; citation_volume=71; citation_publication_date=2016; citation_pages=77-91; citation_doi=10.1016/j.infsof.2015.11.001; citation_id=CR24; Lassila, O., Swick, R.R., et al.: Resource description framework (rdf) model and syntax specification (1998); citation_journal_title=Inf. Softw. Technol.; citation_title=A systematic review of domain analysis tools; citation_author=LB Lisboa, VC Garcia, D Lucredio, ES Almeida, SR Lemos Meira, RP Mattos Fortes; citation_volume=52; citation_issue=1; citation_publication_date=2010; citation_pages=1-13; citation_doi=10.1016/j.infsof.2009.05.001; citation_id=CR26; citation_journal_title=ACM Trans. Inf. Syst. Secur. (TISSEC); citation_title=False data injection attacks against state estimation in electric power grids; citation_author=Y Liu, P Ning, MK Reiter; citation_volume=14; citation_issue=1; citation_publication_date=2011; citation_pages=13; citation_doi=10.1145/1952982.1952995; citation_id=CR27; Ma, M.: Resilience against false data injection attack in wireless sensor networks. In: Handbook of Research on Wireless Security, pp. 628-635. IGI Global (2008); Maciel, D., Paiva, A.C., da Silva, A.R.: From requirements to automated acceptance tests of interactive apps: an integrated model-based testing approach. In: Proceedings of the 14th International Conference on Evaluation of Novel Approaches to Software Engineering, pp. 265-272. SCITEPRESS-Science and Technology Publications, Lda (2019); citation_journal_title=Int. J. Crit. Infrastruct. Prot.; citation_title=Analysis of vulnerabilities, attacks, countermeasures and overall risk of the automatic dependent surveillance-broadcast (ADS-B) system; citation_author=MR Manesh, N Kaabouch; citation_volume=19; citation_publication_date=2017; citation_pages=16-31; citation_doi=10.1016/j.ijcip.2017.10.002; citation_id=CR30; Manesh, M.R., Mullins, M., Foerster, K., Kaabouch, N.: A preliminary effort toward investigating the impacts of ADS-B message injection attack. In: 2018 IEEE Aerospace Conference, pp. 1-6. IEEE (2018); Martinovic, I., Strohmeier, M.: Security of ADS-B: State of the art and beyond. DCS (2013); McGuinness, D.L., Van Harmelen, F., et al.: Owl web ontology language overview. W3C Recommend. 10(10): 2004 (2004); Menzel, T., Bagschik, G., Maurer, M.: Scenarios for development, test and validation of automated vehicles. In: 2018 IEEE Intelligent Vehicles Symposium (IV), pp. 1821-1827. IEEE (2018); citation_journal_title=ACM Comput. Surv.; citation_title=When and how to develop domain-specific languages; citation_author=M Mernik, J Heering, AM Sloane; citation_volume=37; citation_issue=4; citation_publication_date=2005; citation_pages=316-344; citation_doi=10.1145/1118890.1118892; citation_id=CR35; citation_journal_title=ACM Comput. Surv. (CSUR); citation_title=When and how to develop domain-specific languages; citation_author=M Mernik, J Heering, AM Sloane; citation_volume=37; citation_issue=4; citation_publication_date=2005; citation_pages=316-344; citation_doi=10.1145/1118890.1118892; citation_id=CR36; Mernik, M., Hrncic, D., Bryant, B.R., Javed, F.: Applications of grammatical inference in software engineering: domain specific language development, pp. 421-457. Imperial College Press (2010). 
                  https://doi.org/10.1142/9781848165458_0008; citation_journal_title=J. Aerosp. Inf. Syst.; citation_title=Automated generation of air traffic encounters for testing conflict-resolution software; citation_author=RA Paielli; citation_volume=10; citation_issue=5; citation_publication_date=2013; citation_pages=209-217; citation_id=CR38; citation_journal_title=IEEE Trans. Parallel Distrib. Syst.; citation_title=The design and implementation of a domain-specific language for network performance testing; citation_author=S Pakin; citation_volume=18; citation_issue=10; citation_publication_date=2007; citation_pages=1436-1449; citation_doi=10.1109/TPDS.2007.1065; citation_id=CR39; citation_journal_title=Comput. Lang. Syst. Struct.; citation_title=Ontological approach for dsl development; citation_author=MJAV Pereira, JA Fonseca, PR Henriques; citation_volume=45; citation_issue=C; citation_publication_date=2016; citation_pages=35-52; citation_doi=10.1016/j.cl.2015.12.004; citation_id=CR40; Queiroz, R., Berger, T., Czarnecki, K.: Geoscenario: an open dsl for autonomous driving scenario representation. In: 2019 IEEE Intelligent Vehicles Symposium (IV), pp. 287-294. IEEE (2019); citation_journal_title=IEEE Trans. Signal Process.; citation_title=Elliptic localization: performance study and optimum receiver placement; citation_author=L Rui, K Ho; citation_volume=62; citation_issue=18; citation_publication_date=2014; citation_pages=4673-4688; citation_doi=10.1109/TSP.2014.2338835; citation_id=CR42; Savvides, A., Park, H., Srivastava, M.B.: The bits and flops of the n-hop multilateration primitive for node localization problems. In: Proceedings of the 1st ACM International Workshop on Wireless Sensor Networks and Applications, pp. 112-121. ACM (2002); Schafer, M., Lenders, V., Martinovic, I.: Experimental analysis of attacks on next generation air traffic communication. In: International Conference on Applied Cryptography and Network Security, pp. 253-271. Springer (2013); Skolnik, M.I.: Radar Handbook. 3rd edn (2008); Smith, A., Cassell, R., Breen, T., Hulstrom, R., Evers, C.: Methods to provide system-wide ADS-B back-up, validation and security. In: 25th Digital Avionics Systems Conference, pp. 1-7. IEEE (2006); Strohmeier, M.: Security in next generation air traffic communication networks. Ph.D. thesis, Oxford University (2016); citation_journal_title=IEEE Trans. Intell. Transp. Syst.; citation_title=On perception and reality in wireless air traffic communications security; citation_author=M Strohmeier, M Schafer, R Pinheiro, V Lenders, I Martinovic; citation_volume=18; citation_issue=6; citation_publication_date=2017; citation_pages=1338-1357; citation_doi=10.1109/TITS.2016.2612584; citation_id=CR48; citation_journal_title=Data Knowl. Eng.; citation_title=Knowledge engineering: principles and methods; citation_author=R Studer, VR Benjamins, D Fensel; citation_volume=25; citation_issue=1-2; citation_publication_date=1998; citation_pages=161-197; citation_doi=10.1016/S0169-023X(97)00056-6; citation_id=CR49; Tairas, R., Mernik, M., Gray, J.: Using ontologies in the domain analysis of domain-specific languages. In: International Conference on Model Driven Engineering Languages and Systems, pp. 332-342. Springer (2008); citation_journal_title=ACM SIGSOFT Softw. Eng. Notes; citation_title=Software development using domain-specific software architectures: Cdrl a011-a curriculum module in the sei style; citation_author=RN Taylor, W Tracz, L Coglianese; citation_volume=20; citation_issue=5; citation_publication_date=1995; citation_pages=27-38; citation_doi=10.1145/217030.217034; citation_id=CR51; citation_journal_title=Electron. Commun. Eng. J.; citation_title=Mode s: an introduction and overview (secondary surveillance radar); citation_author=R Trim; citation_volume=2; citation_issue=2; citation_publication_date=1990; citation_pages=53-59; citation_doi=10.1049/ecej:19900017; citation_id=CR52; Tsarkov, D., Horrocks, I.: Fact++ description logic reasoner: system description. In: International Joint Conference on Automated Reasoning, pp. 292-297. Springer (2006); citation_journal_title=J. Comput. Inf. Technol.; citation_title=Domain-specific language design requires feature descriptions; citation_author=A Deursen, P Klint; citation_volume=10; citation_issue=1; citation_publication_date=2002; citation_pages=1-17; citation_doi=10.2498/cit.2002.01.01; citation_id=CR54; Wesson, K.D., Humphreys, T.E., Evans, B.L.: Can cryptography secure next generation air traffic surveillance? IEEE Secur. Privacy Mag. (2014); Xie, L., Mo, Y., Sinopoli, B.: False data injection attacks in electricity markets. In: Smart Grid Communications (SmartGridComm), First International Conference on, pp. 226-231. IEEE (2010); Zhang, R., Liu, G., Liu, J., Nees, J.P.: Analysis of message attacks in aviation datalink communication. IEEE Access (2017)"			Excluded	Excluded	new_screen			2	Springer Link		A domain-specific language to design false data injection tests for air traffic control systems	http://link.springer.com/article/10.1007/s10009-021-00604-4	Springer Link	nan; Pages; Year; Bibtex
321	Behave	A Dynamic System Model Using Agile Method Techniques Applied to Geomatics	In this paper we propose the use of a model that represents a territory across a dynamic system. As part of the process in the definition of the model we used techniques adaptive software engineering, particularly construction tools associated with agile methods. The dynamic system modeling serves to simulate territorial scenarios and analyze their characteristics using geographical information systems. The approach is to design user stories as artifacts that can be used for example by decision makers, urban planners or researchers to more easily observe and read territorial scenarios that can be to present in the evolution of land-use changes in a geographical area of interest. This represents an important advantage because it reduces reading complexity and facilitates analysis because combining agile methods with a simulation model provide a macroscopic and simplified view of a scenario of nature complex.	Dynamic systems; Geomatics; GIS; Agile methods	Rodr{\'i}guez Zamora, Ren{\'e}; Peraza Garz{\'o}n, {\'A}lvaro; Silva Hern{\'a}ndez, Iliana Amabely	International Congress of Telematics and Computing	https://doi.org/10.1007/978-3-030-33229-7_7		71--82	"""@InProceedings{10.1007/978-3-030-33229-7_7,
    author = ""Rodr{\'i}guez Zamora, Ren{\'e} and Peraza Garz{\'o}n, {\'A}lvaro and Silva Hern{\'a}ndez, Iliana Amabely"",
    editor = ""Mata-Rivera, Miguel Felix and Zagal-Flores, Roberto and Barr{\'i}a-Huidobro, Cristian"",
    title = ""A Dynamic System Model Using Agile Method Techniques Applied to Geomatics"",
    booktitle = ""Telematics and Computing"",
    year = ""2019"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""71--82"",
    abstract = ""In this paper we propose the use of a model that represents a territory across a dynamic system. As part of the process in the definition of the model we used techniques adaptive software engineering, particularly construction tools associated with agile methods. The dynamic system modeling serves to simulate territorial scenarios and analyze their characteristics using geographical information systems. The approach is to design user stories as artifacts that can be used for example by decision makers, urban planners or researchers to more easily observe and read territorial scenarios that can be to present in the evolution of land-use changes in a geographical area of interest. This represents an important advantage because it reduces reading complexity and facilitates analysis because combining agile methods with a simulation model provide a macroscopic and simplified view of a scenario of nature complex."",
    isbn = ""978-3-030-33229-7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		A Dynamic System Model Using Agile Method Techniques Applied to Geomatics	http://link.springer.com/chapter/10.1007/978-3-030-33229-7_7	Springer International Publishing	nan; References
322	Behave	A Four-Leaf Clover Shape Methodology for Prosumer Service Developments	Software development in software development organizations is a complex process and may require knowledge management techniques. If the development is oriented to the creation of a prosumer platform for managing ambient intelligence scenarios, the development could be even more complex. In this paper we present a prosumer model based on our experiences developing prosumer platforms for ambient intelligence scenarios. The model we proposed is composed of a set of six roles (users, service consumers, prosumers, advanced prosumers, platform developers and domain experts), a lifecycle for the prosumer services with eight different states and a methodology where four of the mentioned roles cooperate to develop a service provisioning platform and to propose new add-ons to improve the platform functionality in order to create services in a concrete ambient intelligence scenario.		Mart{\'i}n, Diego; Alcarria, Ramon; S{\'a}nchez-Picot, Alvaro; Robles, Tom{\'a}s; S{\'a}nchez de Rivera, Diego	International Conference on Ubiquitous Computing and Ambient Intelligence	https://doi.org/10.1007/978-3-319-13102-3_78		488--495	"""@InProceedings{10.1007/978-3-319-13102-3_78,
    author = ""Mart{\'i}n, Diego and Alcarria, Ramon and S{\'a}nchez-Picot, Alvaro and Robles, Tom{\'a}s and S{\'a}nchez de Rivera, Diego"",
    editor = ""Herv{\'a}s, Ram{\'o}n and Lee, Sungyoung and Nugent, Chris and Bravo, Jos{\'e}"",
    title = ""A Four-Leaf Clover Shape Methodology for Prosumer Service Developments"",
    booktitle = ""Ubiquitous Computing and Ambient Intelligence. Personalisation and User Adapted Services"",
    year = ""2014"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""488--495"",
    abstract = ""Software development in software development organizations is a complex process and may require knowledge management techniques. If the development is oriented to the creation of a prosumer platform for managing ambient intelligence scenarios, the development could be even more complex. In this paper we present a prosumer model based on our experiences developing prosumer platforms for ambient intelligence scenarios. The model we proposed is composed of a set of six roles (users, service consumers, prosumers, advanced prosumers, platform developers and domain experts), a lifecycle for the prosumer services with eight different states and a methodology where four of the mentioned roles cooperate to develop a service provisioning platform and to propose new add-ons to improve the platform functionality in order to create services in a concrete ambient intelligence scenario."",
    isbn = ""978-3-319-13102-3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		A Four-Leaf Clover Shape Methodology for Prosumer Service Developments	http://link.springer.com/chapter/10.1007/978-3-319-13102-3_78	Springer International Publishing	nan; Keywords; References
323	Behave	A Lightweight Semi-automated Acceptance Test-Driven Development Approach for Web Applications	Applying Acceptance Test Driven Development (ATDD) in the context of web applications is a difficult task due to the intricateness of existing tools/frameworks and, more in general, of the proposed approaches. In this work, we present a simple approach for developing web applications in ATDD mode, based on the usage of Screen Mockups and Selenium IDE.	Test Suite; User Story; Agile Development; Test Script; Real Industrial Case	Clerissi, Diego; Leotta, Maurizio; Reggio, Gianna; Ricca, Filippo	International Conference on Web Engineering	https://doi.org/10.1007/978-3-319-38791-8_55		593--597	"""@InProceedings{10.1007/978-3-319-38791-8_55,
    author = ""Clerissi, Diego and Leotta, Maurizio and Reggio, Gianna and Ricca, Filippo"",
    editor = ""Bozzon, Alessandro and Cudre-Maroux, Philippe and Pautasso, Cesare"",
    title = ""A Lightweight Semi-automated Acceptance Test-Driven Development Approach for Web Applications"",
    booktitle = ""Web Engineering"",
    year = ""2016"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""593--597"",
    abstract = ""Applying Acceptance Test Driven Development (ATDD) in the context of web applications is a difficult task due to the intricateness of existing tools/frameworks and, more in general, of the proposed approaches. In this work, we present a simple approach for developing web applications in ATDD mode, based on the usage of Screen Mockups and Selenium IDE."",
    isbn = ""978-3-319-38791-8""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		A Lightweight Semi-automated Acceptance Test-Driven Development Approach for Web Applications	http://link.springer.com/chapter/10.1007/978-3-319-38791-8_55	Springer International Publishing	nan; References
324	Behave	A Literature Review on Story Test Driven Development	This paper presents a literature review on story-test driven development. Our findings suggest that there are many lessons learned papers that provide anecdotal evidence about the benefits and issues related to the story test driven development. We categorized these findings into seven themes: cost, time, people, code design, testing tools, what to test and test automation. We analyzed research papers on story test driven development to find out how many of these anecdotal findings were critically examined by researchers and analyzed the gaps in between. The analysis can be used by researchers as a ground for further empirical investigation.	Story Test Driven Development; Executable Acceptance Test Driven Development; Requirements; Systematic Review; Testing; Empirical software engineering; Agile software development	Park, Shelly; Maurer, Frank	International Conference on Agile Software Development	https://doi.org/10.1007/978-3-642-13054-0_20		208--213	"""@InProceedings{10.1007/978-3-642-13054-0_20,
    author = ""Park, Shelly and Maurer, Frank"",
    editor = ""Sillitti, Alberto and Martin, Angela and Wang, Xiaofeng and Whitworth, Elizabeth"",
    title = ""A Literature Review on Story Test Driven Development"",
    booktitle = ""Agile Processes in Software Engineering and Extreme Programming"",
    year = ""2010"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""208--213"",
    abstract = ""This paper presents a literature review on story-test driven development. Our findings suggest that there are many lessons learned papers that provide anecdotal evidence about the benefits and issues related to the story test driven development. We categorized these findings into seven themes: cost, time, people, code design, testing tools, what to test and test automation. We analyzed research papers on story test driven development to find out how many of these anecdotal findings were critically examined by researchers and analyzed the gaps in between. The analysis can be used by researchers as a ground for further empirical investigation."",
    isbn = ""978-3-642-13054-0""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		A Literature Review on Story Test Driven Development	http://link.springer.com/chapter/10.1007/978-3-642-13054-0_20	Springer Berlin Heidelberg	nan; References
325	Behave	A New Ontology-Based Approach for Construction of Domain Model	Domain model is one of the most important artefacts in software engineering. It can be built with the use of domain ontologies. The objective of the authors' research is to elaborate an effective approach to domain model construction based on knowledge extraction from existing ontologies. A significant element of the approach is knowledge extraction algorithm. In this paper, a modified, more flexible version of the extraction algorithm is presented. A comparison of the new algorithm with the old one is conducted based on a case study. Both algorithms produce similar results regarding quality measures. In contrast to the old algorithm, the new is parameterized and therefore can be applied in an incremental way what is a valuable feature.	Ontology; Knowledge acquisition; Conceptual modeling	Hnatkowska, Bogumi{\l}a; Huzar, Zbigniew; Tuzinkiewicz, Lech; Dubielewicz, Iwona	Asian Conference on Intelligent Information and Database Systems	https://doi.org/10.1007/978-3-319-54472-4_8		75--85	"""@InProceedings{10.1007/978-3-319-54472-4_8,
    author = ""Hnatkowska, Bogumi{\l}a and Huzar, Zbigniew and Tuzinkiewicz, Lech and Dubielewicz, Iwona"",
    editor = ""Nguyen, Ngoc Thanh and Tojo, Satoshi and Nguyen, Le Minh and Trawi{\'{n}}ski, Bogdan"",
    title = ""A New Ontology-Based Approach for Construction of Domain Model"",
    booktitle = ""Intelligent Information and Database Systems"",
    year = ""2017"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""75--85"",
    abstract = ""Domain model is one of the most important artefacts in software engineering. It can be built with the use of domain ontologies. The objective of the authors' research is to elaborate an effective approach to domain model construction based on knowledge extraction from existing ontologies. A significant element of the approach is knowledge extraction algorithm. In this paper, a modified, more flexible version of the extraction algorithm is presented. A comparison of the new algorithm with the old one is conducted based on a case study. Both algorithms produce similar results regarding quality measures. In contrast to the old algorithm, the new is parameterized and therefore can be applied in an incremental way what is a valuable feature."",
    isbn = ""978-3-319-54472-4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		A New Ontology-Based Approach for Construction of Domain Model	http://link.springer.com/chapter/10.1007/978-3-319-54472-4_8	Springer International Publishing	nan; References
326	Behave	A scalable Cloud-based system for data-intensive spatial analysis	Advances in Cloud computing technology and the availability of affordable and easy to use Cloud services are enabling a multitude of scientific applications to use these resources as primary or secondary computing infrastructure. The urban and built environment research domain is one area that can benefit greatly from Cloud computing. The global population growth and increase in the size and population of cities raise many challenges for governments, planners and researchers alike. The Australian Urban Research Infrastructure Network (AURIN--http://www.aurin.org.au) project has been tasked with developing an advanced platform (e-Infrastructure) across Australia to tackle these challenges. The platform leverages large-scale Cloud resources to provide federated data access to, at present over 1100 data sets from major and often definitive government and industry data-rich organisations, and for scalable data processing and visualisation. The original AURIN tools were developed using the object modelling system (OMS) and supported integrated workflows to define and enact/re-enact scientific processes. More recently the work has evolved to focus more on delivery of a workbench offering a rich range of tools delivered through an extensible workflow environment. In this paper, we provide the background to AURIN including the scientific drivers that are shaping the work and the realisation of the Cloud-based AURIN environment. We focus in particular on the workflow environment and show how it seamlessly utilizes the Cloud for urban research processes focused especially on data-intensive spatial analysis. We illustrate the utilisation of this workflow environment across a range of case studies reflecting urban research activities.	Artificial Intelligence; e-Infrastructure; Urban research; Cloud computing; Geospatial systems; Spatial analysis	R. O. Sinnott; W. Voorsluys	International Journal on Software Tools for Technology Transfer	https://doi.org/10.1007/s10009-015-0398-6	"Hey, A.J., Trefethen, A.E.: The data Deluge: An e-science perspective (2003); citation_journal_title=Comm. ACM; citation_title=A view of cloud computing; citation_author=M Armbrust, A Fox, R Griffith, AD Joseph, R Katz, A Konwinski, G Lee, D Patterson, A Rabkin, I Stoica; citation_volume=53; citation_publication_date=2010; citation_pages=50-58; citation_doi=10.1145/1721654.1721672; citation_id=CR2; citation_journal_title=MIS Quart. Exec.; citation_title=Service-oriented architecture: Myths, realities, and a maturity model; citation_author=R Hirschheim, R Welke, A Schwarz; citation_volume=9; citation_issue=1; citation_publication_date=2010; citation_pages=37-48; citation_id=CR3; citation_journal_title=Science; citation_title=Cyberinfrastructure for e-Science; citation_author=AJ Hey, AE Trefethen; citation_volume=308; citation_publication_date=2005; citation_pages=817-821; citation_doi=10.1126/science.1110410; citation_id=CR4; citation_journal_title=Ecol. Model.; citation_title=An architecture for developing service-oriented and component-based environmental models; citation_author=P Papajorgji, HW Beck, JL Braga; citation_volume=179; citation_publication_date=2004; citation_pages=61-76; citation_doi=10.1016/j.ecolmodel.2004.05.013; citation_id=CR5; citation_journal_title=Comp. Physic. Comm.; citation_title=The worldwide LHC computing grid (worldwide LCG); citation_author=J Shiers; citation_volume=177; citation_issue=1; citation_publication_date=2007; citation_pages=219-223; citation_doi=10.1016/j.cpc.2007.02.021; citation_id=CR6; citation_journal_title=Nature; citation_title=Biology: the big challenges of big data; citation_author=V Marx; citation_volume=498; citation_issue=7453; citation_publication_date=2013; citation_pages=255-260; citation_doi=10.1038/498255a; citation_id=CR7; Hoffa, C., Mehta, G., Freeman, T., Deelman, E., Keahey, K., Berriman, B., Good, J.: On the use of cloud computing for scientific workflows. In: eScience, 2008. eScience'08. IEEE Fourth International Conference on (pp. 640-645) [IEEE (2008, December)]; Sinnott, R.O., Galang, G., Tomko, M., Stimson, R.: Towards an e-Infrastructure for Urban Research Across Australia, IEEE e-Science Conference, Stockholm, Sweden (December 2011); Stimson, R., Tomko, M., Sinnott, R.O.: The Australian Urban Research Infrastructure Network (AURIN) Initiative: A Platform Offering Data and Tools for Urban and Built Environment Researchers across Australia, State of Australian Cities, Melbourne, Australia (November 2011); Pettit, C., Stimson, R., Barton, J., Goldie, X., Sinnott, R.O., Kvan, T.: The Australian Urban Intelligence Network supporting Smart Cities, to appear in CUPUM 2015 Conference book on Smart Cities and Planning Support Systems, eds: Geertman, S., Stillwell, J., Ferreira, J., Goodspeed, R. (February 2015); Sinnott, R.O., Bayliss, C., Galang, G., Greenwood, P., Koetsier, G., Mannix, D., Morandini, L., Nino-Ruiz, M., Pettit, C., Tomko, M., Sarwar, M., Stimson, R., Voorsluys, W., Widjaja, I.: A Data-driven Urban Research Environment for Australia, IEEE e-Science Conference, Chicago USA, (October 2012); citation_journal_title=Genome Biol.; citation_title=Galaxy: a comprehensive approach for supporting accessible, reproducible, and transparent computational research in the life sciences; citation_author=J Goecks, A Nekrutenko, J Taylor; citation_volume=11; citation_issue=8; citation_publication_date=2010; citation_pages=R86; citation_doi=10.1186/gb-2010-11-8-r86; citation_id=CR13; Javadi, B., Tomko, M., Sinnott, R.O.: Decentralised Orchestration of Data-centric Workflows in Cloud Environments. Future Gene. Comp. Syst. (2013). doi:
                    10.1016/j.future.2013.01.008; citation_journal_title=Sci. Program.; citation_title=Pegasus: a framework for mapping complex scientific workflows onto distributed systems; citation_author=E Deelman, G Singh, M Su, J Blythe, Y Gil, C Kesselman, D Katz; citation_volume=13; citation_issue=3; citation_publication_date=2005; citation_pages=219-237; citation_id=CR15; Wolstencroft, K., Haines, R., Fellows, D., Williams, A., Withers, D., Owen, S., Goble, C.: The Taverna workflow suite: designing and executing workflows of Web Services on the desktop, web or in the cloud. Nucleic acids research, gkt328 (2013); Barker, A., Van Hemert, J.: Scientific workflow: a survey and research directions. In Parallel Processing and Applied Mathematics (pp. 746-753). Springer Berlin Heidelberg (2008); Sinnott, R.O., Chhetri, P., Gong, Y., Macaulay, A., Voorsluys, W.: Privacy-preserving Data Linkage through Blind Geo-spatial Data Aggregation, The IEEE International Symposium on Big Data Security on Cloud (BigDataSecurity 2015), New York, USA, (August 2015); Sinnott, R.O., Bayliss, C., Bromage, A., Galang, G., Grazioli, G., Greenwood, P., Macauley, G., Morandini, L., Nino-Ruiz, M., Nogoorani, G., Pettit, C., Tomko, M., Sarwar, M., Stimson, R., Voorsluys, W., Widjaja, I.: The Australian Urban Research Gateway. Journal of Concurrency and Computation: Practice and Experience (April 2014). doi:
                    10.1002/cpe.3282; Widjaja, I., Russo, P., Pettit, C., Sinnott, R.O., Tomko, M.: Modeling Coordinated Multiple Views of Heterogeneous Data Cubes for Urban Visual Analytics, International Journal of Digital Earth (October 2013)"			Excluded	Excluded	new_screen			2	Springer Link		A scalable Cloud-based system for data-intensive spatial analysis	http://link.springer.com/article/10.1007/s10009-015-0398-6	Springer Link	nan; Pages; Year; Bibtex
327	Behave	A Survey on Agile Practices and Challenges of a Global Software Development Team	The Agile Manifesto describes that the most efficient and effective method of conveying information to and within a development team is through face-to-face conversation. However that is not always possible when teams are working in a Global Software Development (GSD) environment. Based on this scenario, this study presents an exploratory data analysis using survey results to explore agile practices and challenges of a global software development team that uses Scaled Agile Framework (SAFe), which is designed for the need of larger organizations. The goal of this study is to understand the team's level of knowledge in some agile practices and which types of communication are usually prioritized. As in GSD environments team members are geographically spread across multiple regions and time zones, we aim to identify challenges this environment can present. As a result of this exploratory analysis, it has been identified that communication is one of main challenges in GSD environment and that phone calls are considered to be the most efficient type of communication. Additionally, we have also identified that professionals have different levels of confidence in Agile practices and concluded that knowledge transfers among the professionals could help those team members that are not confident in some agile practices to increase their overall confidence and knowledge.	Agile methodologies; Survey; Global Software Development; SAFe	Lautert, Tatiane; Neto, Adolfo Gustavo Serra Seca; Kozievitch, N{\'a}dia P.	Brazilian Workshop on Agile Methods	https://doi.org/10.1007/978-3-030-36701-5_11		128--143	"""@InProceedings{10.1007/978-3-030-36701-5_11,
    author = ""Lautert, Tatiane and Neto, Adolfo Gustavo Serra Seca and Kozievitch, N{\'a}dia P."",
    editor = ""Meirelles, Paulo and Nelson, Maria Augusta and Rocha, Carla"",
    title = ""A Survey on Agile Practices and Challenges of a Global Software Development Team"",
    booktitle = ""Agile Methods"",
    year = ""2019"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""128--143"",
    abstract = ""The Agile Manifesto describes that the most efficient and effective method of conveying information to and within a development team is through face-to-face conversation. However that is not always possible when teams are working in a Global Software Development (GSD) environment. Based on this scenario, this study presents an exploratory data analysis using survey results to explore agile practices and challenges of a global software development team that uses Scaled Agile Framework (SAFe), which is designed for the need of larger organizations. The goal of this study is to understand the team's level of knowledge in some agile practices and which types of communication are usually prioritized. As in GSD environments team members are geographically spread across multiple regions and time zones, we aim to identify challenges this environment can present. As a result of this exploratory analysis, it has been identified that communication is one of main challenges in GSD environment and that phone calls are considered to be the most efficient type of communication. Additionally, we have also identified that professionals have different levels of confidence in Agile practices and concluded that knowledge transfers among the professionals could help those team members that are not confident in some agile practices to increase their overall confidence and knowledge."",
    isbn = ""978-3-030-36701-5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		A Survey on Agile Practices and Challenges of a Global Software Development Team	http://link.springer.com/chapter/10.1007/978-3-030-36701-5_11	Springer International Publishing	nan; References
328	Behave	A Systematic Approach to Automatically Derive Test Cases from Use Cases Specified in Restricted Natural Languages	In many domains, such as avionics, oil and gas, and maritime, a common practice is to derive and execute test cases manually from requirements, where both requirements and test cases are specified in natural language (NL) by domain experts. The manual execution of test cases is largely dependent on the domain experts who wrote the test cases. The process of manual writing of requirements and test cases introduces ambiguity in their description and, in addition, test cases may not be effective since they may not be derived by systematically applying coverage criteria. In this paper, we report on a systematic approach to support automatic derivation of manually executable test cases from use cases. Both use cases and test cases are specified in restricted NLs along with carefully-defined templates implemented in a tool. We evaluate our approach with four case studies (in total having 30 use cases and 579 steps from flows of events), two of which are industrial case studies from the oil/gas and avionics domains. Results show that our tool was able to correctly process all the case studies and systematically (by following carefully-defined structure coverage criteria) generate 30 TCSs and 389 test cases. Moreover, our approach allows defining different test coverage criteria on requirements other than the one already implemented in our tool.		Zhang, Man; Yue, Tao; Ali, Shaukat; Zhang, Huihui; Wu, Ji	International Conference on System Analysis and Modeling	https://doi.org/10.1007/978-3-319-11743-0_10		142--157	"""@InProceedings{10.1007/978-3-319-11743-0_10,
    author = ""Zhang, Man and Yue, Tao and Ali, Shaukat and Zhang, Huihui and Wu, Ji"",
    editor = ""Amyot, Daniel and Fonseca i Casas, Pau and Mussbacher, Gunter"",
    title = ""A Systematic Approach to Automatically Derive Test Cases from Use Cases Specified in Restricted Natural Languages"",
    booktitle = ""System Analysis and Modeling: Models and Reusability"",
    year = ""2014"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""142--157"",
    abstract = ""In many domains, such as avionics, oil and gas, and maritime, a common practice is to derive and execute test cases manually from requirements, where both requirements and test cases are specified in natural language (NL) by domain experts. The manual execution of test cases is largely dependent on the domain experts who wrote the test cases. The process of manual writing of requirements and test cases introduces ambiguity in their description and, in addition, test cases may not be effective since they may not be derived by systematically applying coverage criteria. In this paper, we report on a systematic approach to support automatic derivation of manually executable test cases from use cases. Both use cases and test cases are specified in restricted NLs along with carefully-defined templates implemented in a tool. We evaluate our approach with four case studies (in total having 30 use cases and 579 steps from flows of events), two of which are industrial case studies from the oil/gas and avionics domains. Results show that our tool was able to correctly process all the case studies and systematically (by following carefully-defined structure coverage criteria) generate 30 TCSs and 389 test cases. Moreover, our approach allows defining different test coverage criteria on requirements other than the one already implemented in our tool."",
    isbn = ""978-3-319-11743-0""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		A Systematic Approach to Automatically Derive Test Cases from Use Cases Specified in Restricted Natural Languages	http://link.springer.com/chapter/10.1007/978-3-319-11743-0_10	Springer International Publishing	nan; Keywords; References
329	Behave	A Taxonomy on Continuous Integration and Deployment Tools and Frameworks	Software development has become a critical activity in modern companies. Competitive advantage and customer satisfaction depend strongly on the efficient delivery of new software capabilities. This requires the application of agile methodologies and the use of tools and frameworks which allow a fast and reliable integration and evolution of software systems. Currently, there exist several tools which are used for different purposes all along the software development process. Therefore, it is important for researchers on software engineering and developers to have a wide overview and understanding of the capabilities and limitations of current technology. This paper presents an insightful study of the state of the art on continuous integration and deployment tools. It depicts a taxonomy of current approaches based on their usability during the software development process. Furthermore, it discusses the current challenges and propose a set of study opportunities which could lead further research in this field.		Cano, Patricia Ortegon; Mejia, Ayrton Mondragon; De Gyves Avila, Silvana; Dominguez, Gloria Eva Zagal; Moreno, Ismael Solis; Lepe, Arianne Navarro	International Conference on Software Process Improvement	https://doi.org/10.1007/978-3-030-63329-5_22		323--336	"""@InProceedings{10.1007/978-3-030-63329-5_22,
    author = ""Cano, Patricia Ortegon and Mejia, Ayrton Mondragon and De Gyves Avila, Silvana and Dominguez, Gloria Eva Zagal and Moreno, Ismael Solis and Lepe, Arianne Navarro"",
    editor = ""Mejia, Jezreel and Mu{\\textasciitilde {n}}oz, Mirna and Rocha, {\'A}lvaro and Qui{\\textasciitilde {n}}onez, Yadira"",
    title = ""A Taxonomy on Continuous Integration and Deployment Tools and Frameworks"",
    booktitle = ""New Perspectives in Software Engineering"",
    year = ""2021"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""323--336"",
    abstract = ""Software development has become a critical activity in modern companies. Competitive advantage and customer satisfaction depend strongly on the efficient delivery of new software capabilities. This requires the application of agile methodologies and the use of tools and frameworks which allow a fast and reliable integration and evolution of software systems. Currently, there exist several tools which are used for different purposes all along the software development process. Therefore, it is important for researchers on software engineering and developers to have a wide overview and understanding of the capabilities and limitations of current technology. This paper presents an insightful study of the state of the art on continuous integration and deployment tools. It depicts a taxonomy of current approaches based on their usability during the software development process. Furthermore, it discusses the current challenges and propose a set of study opportunities which could lead further research in this field."",
    isbn = ""978-3-030-63329-5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		A Taxonomy on Continuous Integration and Deployment Tools and Frameworks	http://link.springer.com/chapter/10.1007/978-3-030-63329-5_22	Springer International Publishing	nan; Keywords; References
330	Behave	A Test Specification Language for Information Systems Based on Data Entities, Use Cases and State Machines	Testing is one of the most important activities to ensure the quality of a software system. This paper proposes and discusses the TSL (Test Specification Language) that adopts a model-based testing approach for both human-readable and computer-executable specifications of test cases. TSL is strongly inspired on the grammar, nomenclature and writing style as defined by the RSLingo RSL, which is a rigorous requirements specification language. Both RSL and TSL are controlled natural languages that share common concepts such as data entities, use cases and state machines. However, by applying black-box functional testing design techniques, TSL includes and supports four complementary testing strategies, namely: domain analysis testing; use case tests; state machine testing; and acceptance criteria. This paper focuses on the first three testing strategies of TSL. Finally, a simple but effective case study illustrates the overall approach and supports the discussion.	Test Specification Language (TSL); Test case specification; Model based Testing (MBT); Test case generation	da Silva, Alberto Rodrigues; Paiva, Ana C. R.; da Silva, Valter E. R.	International Conference on Model-Driven Engineering and Software Development	https://doi.org/10.1007/978-3-030-11030-7_20		455--474	"""@InProceedings{10.1007/978-3-030-11030-7_20,
    author = ""da Silva, Alberto Rodrigues and Paiva, Ana C. R. and da Silva, Valter E. R."",
    editor = ""Hammoudi, Slimane and Pires, Lu{\'i}s Ferreira and Selic, Bran"",
    title = ""A Test Specification Language for Information Systems Based on Data Entities, Use Cases and State Machines"",
    booktitle = ""Model-Driven Engineering and Software Development"",
    year = ""2019"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""455--474"",
    abstract = ""Testing is one of the most important activities to ensure the quality of a software system. This paper proposes and discusses the TSL (Test Specification Language) that adopts a model-based testing approach for both human-readable and computer-executable specifications of test cases. TSL is strongly inspired on the grammar, nomenclature and writing style as defined by the RSLingo RSL, which is a rigorous requirements specification language. Both RSL and TSL are controlled natural languages that share common concepts such as data entities, use cases and state machines. However, by applying black-box functional testing design techniques, TSL includes and supports four complementary testing strategies, namely: domain analysis testing; use case tests; state machine testing; and acceptance criteria. This paper focuses on the first three testing strategies of TSL. Finally, a simple but effective case study illustrates the overall approach and supports the discussion."",
    isbn = ""978-3-030-11030-7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		A Test Specification Language for Information Systems Based on Data Entities, Use Cases and State Machines	http://link.springer.com/chapter/10.1007/978-3-030-11030-7_20	Springer International Publishing	nan; References
331	Behave	A Textual Domain Specific Language for User Interface Modelling	User interface development is one of the hardest parts of the software application development. It could be made more efficient by introducing model-driven development approaches and user interface modelling. This paper introduces a textual domain specific language and a corresponding meta-model for describing user interaction using abstract UI patterns that can be transformed into more platform specific UI patterns during application generation. The language also follows use case description format and provides possibilities to add free-form documenting context to the formal constructs used in the language, making the models described in the language suitable both for model driven engineering and requirements elicitation.	User interface modelling; Model driven development; Textual domain specific languages; Domain specific languages; User interface patterns	Karu, Mart	Emerging Trends in Computing, Informatics, Systems Sciences, and Engineering	https://doi.org/10.1007/978-1-4614-3558-7_84		985--996	"""@InProceedings{10.1007/978-1-4614-3558-7_84,
    author = ""Karu, Mart"",
    editor = ""Sobh, Tarek and Elleithy, Khaled"",
    title = ""A Textual Domain Specific Language for User Interface Modelling"",
    booktitle = ""Emerging Trends in Computing, Informatics, Systems Sciences, and Engineering"",
    year = ""2013"",
    publisher = ""Springer New York"",
    address = ""New York, NY"",
    pages = ""985--996"",
    abstract = ""User interface development is one of the hardest parts of the software application development. It could be made more efficient by introducing model-driven development approaches and user interface modelling. This paper introduces a textual domain specific language and a corresponding meta-model for describing user interaction using abstract UI patterns that can be transformed into more platform specific UI patterns during application generation. The language also follows use case description format and provides possibilities to add free-form documenting context to the formal constructs used in the language, making the models described in the language suitable both for model driven engineering and requirements elicitation."",
    isbn = ""978-1-4614-3558-7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		A Textual Domain Specific Language for User Interface Modelling	http://link.springer.com/chapter/10.1007/978-1-4614-3558-7_84	Springer New York	nan; References
332	Behave	A Very Brief History of Test-Driven Development	My intention in writing this chapter is not to copy and paste clich{\'e}s from blogs (the following excerpt aside) or pretend I was part of the historic events (like the agile manifesto or Extreme Programming activities) that led to the creation of test-driven development as a methodology -- trust me, I'm not that old.	General books on testing	Qiu, Juntao	Test-Driven Development with React	https://doi.org/10.1007/978-1-4842-6972-5_1		1--13	"""@Inbook{Qiu2021,
    author = ""Qiu, Juntao"",
    title = ""A Very Brief History of Test-Driven Development"",
    bookTitle = ""Test-Driven Development with React: Apply Test-Driven Development in Your Applications"",
    year = ""2021"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""1--13"",
    abstract = ""My intention in writing this chapter is not to copy and paste clich{\'e}s from blogs (the following excerpt aside) or pretend I was part of the historic events (like the agile manifesto or Extreme Programming activities) that led to the creation of test-driven development as a methodology -- trust me, I'm not that old."",
    isbn = ""978-1-4842-6972-5"",
    doi = ""10.1007/978-1-4842-6972-5\_1"",
    url = ""https://doi.org/10.1007/978-1-4842-6972-5\_1""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		A Very Brief History of Test-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-6972-5_1	Apress	nan; Keywords; References
333	Behave	Acceptance Test Driven Development	Having a good CI/CD pipeline helps a lot in providing fast feedback to the development team about regressions. This is an important part of being agile but is far from enough. For a team to be agile, it needs to be able to respond to customer feedback quickly and do so constantly for the entire life span of the product. In this chapter we'll discuss the Acceptance Test Driven Development (ATDD) methodology (which was introduced briefly in Chapter 5) and see how it helps the team to be much more agile.		Axelrod, Arnon	Complete Guide to Test Automation	https://doi.org/10.1007/978-1-4842-3832-5_16		371--394	"""@Inbook{Axelrod2018,
    author = ""Axelrod, Arnon"",
    title = ""Acceptance Test Driven Development"",
    bookTitle = ""Complete Guide to Test Automation: Techniques, Practices, and Patterns for Building and Maintaining Effective Software Projects"",
    year = ""2018"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""371--394"",
    abstract = ""Having a good CI/CD pipeline helps a lot in providing fast feedback to the development team about regressions. This is an important part of being agile but is far from enough. For a team to be agile, it needs to be able to respond to customer feedback quickly and do so constantly for the entire life span of the product. In this chapter we'll discuss the Acceptance Test Driven Development (ATDD) methodology (which was introduced briefly in Chapter 5) and see how it helps the team to be much more agile."",
    isbn = ""978-1-4842-3832-5"",
    doi = ""10.1007/978-1-4842-3832-5\_16"",
    url = ""https://doi.org/10.1007/978-1-4842-3832-5\_16""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Acceptance Test Driven Development	https://dl.acm.org/doi/10.1145/1988997.1989006	Apress	nan; Keywords; References
334	Behave	Acceptance tests for validating ARIA requirements in widgets	Accessibility refers to a quality requirement for web applications. However, current accessibility automatic evaluation tools cannot evaluate dynamic generated content that characterizes Ajax applications and RIAs. In this context, this paper describes an approach for evaluating Accessible Rich Internet Applications (ARIA) requirements, by using acceptance tests. The authors implemented a set of disabled user interaction scenarios as acceptance tests in order to verify keyboard accessibility in RIA and automatically evaluate ARIA conformance in widgets. The inclusion of disabled user interaction scenarios in the evaluation process is necessary to analyse ARIA requirements since dynamic changes are accommodated in the DOM structure. Two evaluation tool prototypes were developed and validated in separate case studies. The results show evidence that the proposed evaluation approach is capable of evaluating ARIA conformance in RIA widgets.	Artificial Intelligence; Web accessibility; ARIA; Accessible Rich Internet Applications; ARIA evaluation	Willian Massami Watanabe; Renata P. M. Fortes; Ana Luiza Dias	Universal Access in the Information Society	https://doi.org/10.1007/s10209-015-0437-9	"Araujo, B.C., Rocha, A.C., Xavier, A., Muniz, A.I., Garcia, F.P.: Web-based tool for automatic acceptance test execution and scripting for programmers and customers. In: Proceedings of the 2007 Euro American Conference on Telematics and Information Systems, EATIS '07, vol. 1, pp. 56:1-56:4. ACM, New York, NY (2007). doi:
https://doi.org/10.1145/1352694.1352752; Borodin, Y., Bigham, J.P., Dausch, G., Ramakrishnan, I.V.: More than meets the eye: a survey of screen-reader browsing strategies. In: Proceedings of the 2010 International Cross Disciplinary Conference on Web Accessibility (W4A), W4A '10, vol. 1, pp. 13:1-13:10. ACM, New York, NY, USA (2010). doi:
https://doi.org/10.1145/1805986.1806005; Brajnik, G.: Beyond conformance: the role of accessibility evaluation methods. In: Web Information Systems Engineering--WISE 2008 Workshops, Lecture Notes in Computer Science, vol. 5176, pp. 63-80. Springer Berlin/Heidelberg (2008). doi:
https://doi.org/10.1007/978-3-540-85200-1_9

. 
http://www.springerlink.com/content/p3l7030k62j65029/; Brajnik, G., Yesilada, Y., Harper, S.: Testability and validity of WCAG 2.0: the expertise effect. In: Proceedings of the 12th international ACM SIGACCESS Conference on Computers and Accessibility, ASSETS '10, vol. 1, pp. 43-50. ACM, New York, NY (2010). doi:
https://doi.org/10.1145/1878803.1878813; Cannizzo, F., Clutton, R., Ramesh, R.: Pushing the boundaries of testing and continuous integration. In: Proceedings of the Agile 2008, pp. 501-505. IEEE Computer Society, Washington, DC, USA (2008). doi:
https://doi.org/10.1109/Agile.2008.31

. 
http://dl.acm.org/citation.cfm?id=1443221.1443547; citation_journal_title=World Wide Web; citation_title=Widget identification: A high-level approach to accessibility; citation_author=A Chen, S Harper, D Lunn, A Brown; citation_volume=16; citation_issue=1; citation_publication_date=2013; citation_pages=73-89; citation_doi=10.1007/s11280-012-0156-6; citation_id=CR6; Cooper, M.: Accessibility of emerging rich web technologies: web 2.0 and the semantic web. In: Proceedings of the 2007 International Cross-Disciplinary Conference on Web Accessibility (W4A), W4A '07, vol. 1, pp. 93-98. ACM, New York, NY (2007). doi:
https://doi.org/10.1145/1243441.1243463; citation_journal_title=Advances in Engineering Software; citation_title=The design of RIA accessibility evaluation tool; citation_author=Iyad Abu Doush, Faisal Alkhateeb, Eslam Al Maghayreh, Mohammed Azmi Al-Betar; citation_volume=57; citation_publication_date=2013; citation_pages=1-7; citation_doi=10.1016/j.advengsoft.2012.11.004; citation_id=CR8; Fernandes, N., Batista, A.S., Costa, D., Duarte, C., Carrico, L.: Three web accessibility evaluation perspectives for RIA. In: Proceedings of the 10th International Cross-Disciplinary Conference on Web Accessibility, W4A '13, vol. 1, pp. 12:1-12:9. ACM, New York, NY, USA (2013). doi:
https://doi.org/10.1145/2461121.2461122; Fernandes, N., Costa, D., Neves, S., Duarte, C., Carrico, L.: Evaluating the accessibility of rich internet applications. In: Proceedings of the International Cross-Disciplinary Conference on Web Accessibility, W4A '12, vol. 1, pp. 13:1-13:4. ACM, New York, NY, USA (2012). doi:
https://doi.org/10.1145/2207016.2207019; Fernandes, N., Lopes, R., Carrico, L.: On web accessibility evaluation environments. In: Proceedings of the International Cross-Disciplinary Conference on Web Accessibility, W4A '11, vol. 1, pp. 4:1-4:10. ACM, New York, NY, USA (2011). doi:
https://doi.org/10.1145/1969289.1969295; Fowler, M., Foemmel, M.: Continuous integration, 
http://www.martinfowler.com/articles/continuousIntegration.html

 (2005); Freire, A.P.: Disabled people and the web: user-based measurement of accessibility. Ph.D. thesis, University of York, Department of Computer Science, Submitted for the degree of Doctor of Philosophy, York, England (2012); Freire, A.P., Fortes, R.P.M., Turine, M.A.S., Paiva, D.M.B.: An evaluation of web accessibility metrics based on their attributes. In: SIGDOC '08: Proceedings of the 26th Annual ACM International Conference on Design of Communication, vol. 1, pp. 73-80. ACM, New York, NY, USA (2008). doi:
https://doi.org/10.1145/1456536.1456551; Freire, A.P., Goularte, R., Fortes, R.P.M.: Techniques for developing more accessible web applications: a survey towards a process classification. In: SIGDOC '07: Proceedings of the 25th Annual ACM International Conference on Design of Communication, vol. 1, pp. 162-169. ACM, New York, NY, USA (2007). doi:
https://doi.org/10.1145/1297144.1297177; Freire, A.P., Russo, C.M., Fortes, R.P.M.: A survey on the accessibility awareness of people involved in web development projects in Brazil. In: W4A '08: Proceedings of the 2008 International Cross-Disciplinary Conference on Web Accessibility (W4A), vol. 1, pp. 87-96. ACM, New York, NY, USA (2008). doi:
https://doi.org/10.1145/1368044.1368064; Gehtland, J., Almaer, D., Galbraith, B.: Pragmatic Ajax: A Web 2.0 Primer. Pragmatic Bookshelf (2006); Gibson, B.: Enabling an accessible web 2.0. In: Proceedings of the 2007 International Cross-Disciplinary Conference on Web Accessibility (W4A), W4A '07, vol. 1, pp. 1-6. ACM, New York, NY, USA (2007). doi:
https://doi.org/10.1145/1243441.1243442; Henry, S.L., Grossnickle, M.: Accessibility in the User-Centered Design Process. Georgia Tech Research Corporation, Atlanta, Georgia, USA (2004). 
http://www.uaiaccess.com/accessucd

(On-line book); Hsia, P., Gao, J., Samuel, J., Kung, D., Toyoshima, Y., Chen, C.: Behavior-based acceptance testing of software systems: a formal scenario approach. In: Computer Software and Applications Conference, 1994. COMPSAC 94. Proceedings, Eighteenth Annual International, pp. 293 -298 (1994). doi:
https://doi.org/10.1109/CMPSAC.1994.342789; IEEE, I.o.E.a.E.E.: IEEE standard for software verification and validation plans. IEEE Std 1012-1986, pp. I (1986). doi:
https://doi.org/10.1109/IEEESTD.1986.79647; Kelly, B., Sloan, D., Brown, S., Seale, J., Petrie, H., Lauke, P., Ball, S.: Accessibility 2.0: people, policies and processes. In: W4A '07: Proceedings of the 2007 International Cross-Disciplinary Conference on Web Accessibility (W4A), pp. 138-147. ACM, New York, NY, USA (2007). doi:
https://doi.org/10.1145/1243441.1243471; Kelly, B., Sloan, D., Phipps, L., Petrie, H., Hamilton, F.: Forcing standardization or accommodating diversity? A framework for applying the wcag in the real world. In: W4A '05: Proceedings of the 2005 International Cross-Disciplinary Workshop on Web Accessibility (W4A), pp. 46-54. ACM, New York, NY, USA (2005). doi:
https://doi.org/10.1145/1061811.1061820; citation_title=Research Methods in Human-Computer Interaction; citation_publication_date=2010; citation_id=CR24; citation_author=J Lazar; citation_author=JH Feng; citation_author=H Hochheiser; citation_publisher=Wiley; citation_journal_title=Software Quality Control; citation_author=HARETON K.N. LEUNG, PETER W.L. WONG; citation_volume=6; citation_issue=2; citation_publication_date=1997; citation_pages=137-149; citation_doi=10.1023/A:1018503800709; citation_id=CR25; citation_title=Usability Inspection Methods; citation_publication_date=1994; citation_id=CR26; citation_publisher=Wiley; North, D.: Introducing BDD (2006). 
http://dannorth.net/introducing-bdd/; Reid, L.G., Snow-Weaver, A.: WCAG 2.0: a web accessibility standard for the evolving web. In: W4A '08: Proceedings of the 2008 International Cross-Disciplinary Conference on Web Accessibility (W4A), pp. 109-115. ACM, New York, NY, USA (2008). doi:
https://doi.org/10.1145/1368044.1368069; citation_title=The Universal Access Handbook; citation_publication_date=2009; citation_id=CR29; citation_author=C Stephanidis; citation_publisher=CRC Press Inc; Tateishi, T., Miyashita, H., Naoshi, T., Saito, S., Ono, K.: DHTML accessibility checking based on static javascript analysis. In: Stephanidis, C. (ed.) Universal Access in Human-Computer Interaction. Applications and Services, Lecture Notes in Computer Science, vol. 4556, pp. 167-176. Springer, Berlin(2007). doi:
https://doi.org/10.1007/978-3-540-73283-9_20

. 
http://dx.doi.org/10.1007/978-3-540-73283-9_20; Thiessen, P., Hockema, S.: WAI-ARIA live regions: eBuddy IM as a case example. In: Proceedings of the 2010 International Cross Disciplinary Conference on Web Accessibility (W4A), W4A '10, vol. 1, pp. 33:1-33:9. ACM, New York, NY (2010). doi:
https://doi.org/10.1145/1805986.1806030; Velasco, C.A., Denev, D., Stegemann, D., Mohamad, Y.: A web compliance engineering framework to support the development of accessible rich internet applications. In: W4A '08: Proceedings of the 2008 International Cross-Disciplinary Conference on Web Accessibility (W4A), pp. 45-49. ACM, New York, NY (2008). doi:
https://doi.org/10.1145/1368044.1368054; Vigo, M., Arrue, M., Brajnik, G., Lomuscio, R., Abascal, J.: Quantitative metrics for measuring web accessibility. In: W4A '07: Proceedings of the 2007 International Cross-Disciplinary Conference on Web Accessibility (W4A), pp. 99-107. ACM, New York, NY, USA (2007). doi:
https://doi.org/10.1145/1243441.1243465; W3C: Web content accessibility guidelines 1.0. W3C Recommendation (1999). 
http://www.w3.org/TR/WCAG10/; W3C: Web content accessibility guidelines 2.0. W3C Recommendation (2008). 
http://www.w3.org/TR/WCAG20/; W3C: WAI-ARIA 1.0 authoring practices--an author's guide to understanding and implementing accessible rich internet applications. W3C Working Draft (2013). 
http://www.w3.org/TR/wai-aria-practices/; W3C: Accessible rich internet applications--version 1.0. W3C Recommendation (2014). 
http://www.w3.org/TR/wai-aria/; Watanabe, T.: Experimental evaluation of usability and accessibility of heading elements. In: W4A '07: Proceedings of the 2007 International Cross-Disciplinary Conference on Web Accessibility (W4A), pp. 157-164. ACM, New York, NY (2007). doi:
https://doi.org/10.1145/1243441.1243473; Watanabe, W.M., Neto, D.F., Bittar, T.J., Fortes, R.P.M.: WCAG conformance approach based on model-driven development and WebML. In: Proceedings of the 28th ACM International Conference on Design of Communication, SIGDOC '10, vol. 1, pp. 167-174. ACM, New York, NY (2010). doi:
10.1145/1878450.1878479"			Excluded	Excluded	new_screen			2	Springer Link		Acceptance tests for validating ARIA requirements in widgets	http://link.springer.com/article/10.1007/s10209-015-0437-9	Springer Link	nan; Pages; Year; Bibtex
335	Behave	Adopting Agile Software Development Combined with User-Centered Design and Lean Startup: A Systematic Literature Review on Maturity Models	The use of Agile in the software development industry in the past two decades revealed that it is lackluster in some aspects, such as in guaranteeing user involvement and assuring that the right software is being built. There are reports that combining Agile with Lean Startup and User-Centered Design (UCD) helps in overcoming these shortcomings while also yielding several other benefits. However, there is not much documentation on how to use this ``combined approach'' and adapting existing organizations to use it is a challenge in of itself, in which the use of an instrument to guide or assess such transformations is typically pivotal to their success. As such, in this paper we seek to identify maturity models that assess the use of Agile, Lean Startup, and UCD. We conducted a systematic literature review of maturity models for these three methods published between 2001 and 2020. We characterized the maturity models and determined how they see maturity, how they are applied, and how they were evaluated. As an extended version of a previous paper, we augmented our analysis criteria and further classified the models in how they interpret maturity and what strategy they suggest when undergoing an improvement process, in addition to providing new insight on various aspects of the models. We found 35 maturity models, of which 23 were for Agile, 5 for Lean thinking, 5 for UCD, and 2 for Agile and UCD combined. No models for the combination of the three methods were found (nor for Lean Startup), as expected due to the novelty of the approach. Existing models mostly focus on practice adoption and acquiring continuous improvement capabilities, and are typically developed with a specific context in mind. We also note a lack of proper evaluation procedures being conducted on the majority of models, which could be due to the lack of well-established maturity model development methods and guidelines.	Systematic literature review; Maturity model; Agile software development; Lean startup; User-Centered Design	Zorzetti, Maximilian; Moralles, Cassiano; Salerno, Larissa; Pereira, Eliana; Marczak, Sabrina; Bastos, Ricardo	International Conference on Enterprise Information Systems	https://doi.org/10.1007/978-3-030-75418-1_24		517--541	"""@InProceedings{10.1007/978-3-030-75418-1_24,
    author = ""Zorzetti, Maximilian and Moralles, Cassiano and Salerno, Larissa and Pereira, Eliana and Marczak, Sabrina and Bastos, Ricardo"",
    editor = ""Filipe, Joaquim and {\'{S}}mia{\l}ek, Micha{\l} and Brodsky, Alexander and Hammoudi, Slimane"",
    title = ""Adopting Agile Software Development Combined with User-Centered Design and Lean Startup: A Systematic Literature Review on Maturity Models"",
    booktitle = ""Enterprise Information Systems"",
    year = ""2021"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""517--541"",
    abstract = ""The use of Agile in the software development industry in the past two decades revealed that it is lackluster in some aspects, such as in guaranteeing user involvement and assuring that the right software is being built. There are reports that combining Agile with Lean Startup and User-Centered Design (UCD) helps in overcoming these shortcomings while also yielding several other benefits. However, there is not much documentation on how to use this ``combined approach'' and adapting existing organizations to use it is a challenge in of itself, in which the use of an instrument to guide or assess such transformations is typically pivotal to their success. As such, in this paper we seek to identify maturity models that assess the use of Agile, Lean Startup, and UCD. We conducted a systematic literature review of maturity models for these three methods published between 2001 and 2020. We characterized the maturity models and determined how they see maturity, how they are applied, and how they were evaluated. As an extended version of a previous paper, we augmented our analysis criteria and further classified the models in how they interpret maturity and what strategy they suggest when undergoing an improvement process, in addition to providing new insight on various aspects of the models. We found 35 maturity models, of which 23 were for Agile, 5 for Lean thinking, 5 for UCD, and 2 for Agile and UCD combined. No models for the combination of the three methods were found (nor for Lean Startup), as expected due to the novelty of the approach. Existing models mostly focus on practice adoption and acquiring continuous improvement capabilities, and are typically developed with a specific context in mind. We also note a lack of proper evaluation procedures being conducted on the majority of models, which could be due to the lack of well-established maturity model development methods and guidelines."",
    isbn = ""978-3-030-75418-1""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Adopting Agile Software Development Combined with User-Centered Design and Lean Startup: A Systematic Literature Review on Maturity Models	http://link.springer.com/chapter/10.1007/978-3-030-75418-1_24	Springer International Publishing	nan; References
336	Behave	Advanced Guide to Python 3 Programming	http://link.springer.com/book/10.1007/978-3-030-25943-3	Concurrent Python; Games in Python; Databases in Python; Reactive Programming; Python Graphics and Graphical User Interfaces; Graphics; Games; Databases; Logging; Concurrency; Advanced Language Concepts; Networking and Data Science	John Hunt		https://link.springer.com/book/10.1007/978-3-031-40336-1				Excluded	Excluded	new_screen			2	Springer Link		Advanced Guide to Python 3 Programming	https://link.springer.com/book/10.1007/978-3-031-40336-1	Springer Link	nan; Venue; Abstract; References; Pages; Year; Bibtex; DOI
337	Behave	Advances in infrastructures and tools for multiagent systems	http://link.springer.com/article/10.1007/s10796-014-9493-6		Juan M. Alberola; Vicent Botti; Jose M. Such	Information Systems Frontiers	https://doi.org/10.1007/s10796-014-9493-6	"Alberola, J. M., Burdalo, L., Julian, V., Terrasa, A., & Garcia-Fornes, A. (2014). An adaptive framework for monitoring agent organizations. Information Systems Frontiers, 16(2). doi:
                    10.1007/s10796-013-9478-x
                    
                  .; Alfonso, B., Botti, V., Garrido, A., & Giret, A. (2014). A MAS-based infrastructure for negotiation and its application to a water-right market. Information Systems Frontiers, 16(2). doi:
                    10.1007/s10796-013-9443-8
                    
                  .; citation_title=(Social) norm dynamics; citation_inbook_title=Normative multi-agent systems; citation_publication_date=2013; citation_pages=135-170; citation_id=CR3; citation_author=G Andrighetto; citation_author=C Castelfranchi; citation_author=E Mayor; citation_author=J McBreen; citation_author=M Lopez-Sanchez; citation_author=S Parsons; citation_publisher=Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik; citation_journal_title=Artificial Intelligence; citation_title=Evaluating practical negotiating agents: results and analysis of the 2011 international competition; citation_author=T Baarslag, K Fujita, EH Gerding, K Hindriks, T Ito, NR Jennings; citation_volume=198; citation_publication_date=2013; citation_pages=73-103; citation_doi=10.1016/j.artint.2012.09.004; citation_id=CR4; citation_journal_title=Science of Computer Programming; citation_title=Multi-agent oriented programming with JaCaMo; citation_author=O Boissier, RH Bordini, JF Hubner, A Ricci, A Santi; citation_volume=78; citation_issue=6; citation_publication_date=2013; citation_pages=747-761; citation_doi=10.1016/j.scico.2011.10.004; citation_id=CR5; citation_journal_title=Computing; citation_title=Organisational adaptation of multi-agent systems in a peer-to-peer scenario; citation_author=J Campos, M Esteva, M Lopez-Sanchez, J Morales, M Salamo; citation_volume=91; citation_issue=2; citation_publication_date=2011; citation_pages=169-215; citation_doi=10.1007/s00607-010-0141-9; citation_id=CR6; Carrera, A., Iglesias, C. A., & Garijo, M. (2014). Beast methodology: an agile testing methodology for multi-agent systems based on behaviour driven development. Information Systems Frontiers, 16(2). doi:
                    10.1007/s10796-013-9438-5
                    
                  .; Criado, N., Such, J. M., & Botti, V. (2014). Norm reasoning services. Information Systems Frontiers, 16(2). doi:
                    10.1007/s10796-013-9444-7
                    
                  .; citation_journal_title=Journal of Autonomous Agents and Multi-Agent Systems; citation_title=Enhancing decentralized service discovery in open service-oriented multi-agent systems; citation_author=E Val, M Rebollo, V Botti; citation_volume=28; citation_issue=1; citation_publication_date=2014; citation_pages=1-30; citation_doi=10.1007/s10458-012-9210-0; citation_id=CR9; citation_journal_title=Applied Artificial Intelligence; citation_title=Coordination tools for MAS development and deployment; citation_author=E Denti, A Omicini, A Ricci; citation_volume=16; citation_issue=9-10; citation_publication_date=2002; citation_pages=721-752; citation_doi=10.1080/08839510290030462; citation_id=CR10; citation_journal_title=Logic Journal of IGPL; citation_title=A logic of agent organizations; citation_author=V Dignum, F Dignum; citation_volume=20; citation_issue=1; citation_publication_date=2012; citation_pages=283-316; citation_doi=10.1093/jigpal/jzr041; citation_id=CR11; Ferber, J., & Gutknecht, O. (1998). A meta-model for the analysis and design of organizations in multi-agent systems. In Multi agent systems. Proceedings. International Conference on (pp. 128-135). IEEE.; Fogues, R. L., Such, J. M., Espinosa, A., & Garcia-Fornes, A. (2014). BFF: a tool for eliciting tie strength and user communities in social networking services. Information Systems Frontiers, 16(2). doi:
                    10.1007/s10796-013-9453-6
                    
                  .; citation_journal_title=Information and Software Technology; citation_title=Evaluating software engineering techniques for developing complex systems with multiagent approaches; citation_author=E Garcia, A Giret, V Botti; citation_volume=53; citation_issue=5; citation_publication_date=2011; citation_pages=494-506; citation_doi=10.1016/j.infsof.2010.12.012; citation_id=CR14; citation_journal_title=Engineering Applications of Articial Intelligence; citation_title=Infrastructures and tools for multiagent systems for the new generation of distributed systems; citation_author=A Garcia-Fornes, J Hubner, A Omicini, J Rodriguez-Aguilar, V Botti; citation_volume=24; citation_issue=7; citation_publication_date=2011; citation_pages=1095-1097; citation_doi=10.1016/j.engappai.2011.06.012; citation_id=CR15; citation_journal_title=International Journal of Group Decision and Negotiation; citation_title=Automated negotiation: prospects, methods and challenges; citation_author=N Jennings, P Faratin, A Lomuscio, S Parsons, C Sierra, M Wooldridge; citation_volume=10; citation_issue=2; citation_publication_date=2001; citation_pages=199-215; citation_doi=10.1023/A:1008746126376; citation_id=CR16; citation_journal_title=Artificial Intelligence Review; citation_title=A survey of security issue in multi-agent systems; citation_author=Y Jung, M Kim, A Masoumzadeh, JB Joshi; citation_volume=37; citation_issue=3; citation_publication_date=2012; citation_pages=239-260; citation_doi=10.1007/s10462-011-9228-8; citation_id=CR17; citation_journal_title=ACM Transactions on Autonomous and Adaptive Systems (TAAS); citation_title=Decentralized approaches for self-adaptation in agent organizations; citation_author=R Kota, N Gibbins, NR Jennings; citation_volume=7; citation_issue=1; citation_publication_date=2012; citation_pages=1; citation_doi=10.1145/2168260.2168261; citation_id=CR18; citation_journal_title=Artificial Intelligence; citation_title=Negotiation and cooperation in multi-agent environments; citation_author=S Kraus; citation_volume=94; citation_issue=1; citation_publication_date=1997; citation_pages=79-97; citation_doi=10.1016/S0004-3702(97)00025-8; citation_id=CR19; citation_journal_title=Journal of Intelligent Manufacturing; citation_title=Multi-agent negotiation based on price schedules algorithm for distributed collaborative design; citation_author=YI Lin, YW Chou, JY Shiau, CH Chu; citation_volume=24; citation_issue=3; citation_publication_date=2013; citation_pages=545-557; citation_doi=10.1007/s10845-011-0609-2; citation_id=CR20; Luck, M., & McBurney, P. (2008). Computing as interaction: agent and agreement technologies.; Luck, M., McBurney, P., Shehory, O., & Willmott, S. (2005). Agent technology: Computing as interaction (A roadmap for agent based computing). AgentLink.; citation_journal_title=Concurrency and Computation: Practice and Experience; citation_title=On coordination and its significance to distributed and multiagent systems; citation_author=S Ossowski, R Menezes; citation_volume=18; citation_issue=4; citation_publication_date=2006; citation_pages=359-370; citation_doi=10.1002/cpe.943; citation_id=CR23; Ossowski, S., Sierra, C., & Botti. (2013). Agreement technologies: A computing perspective. In Agreement Technologies (pp. 3-16). Springer Netherlands.; citation_journal_title=Artificial Intelligence Review; citation_title=Computational trust and reputation models for open multi-agent systems: a review; citation_author=I Pinyol, J Sabater-Mir; citation_volume=40; citation_issue=1; citation_publication_date=2013; citation_pages=1-25; citation_doi=10.1007/s10462-011-9277-z; citation_id=CR25; citation_journal_title=Autonomous Agents and Multi-Agent Systems; citation_title=Environment programming in multi-agent systems: an artifact-based perspective; citation_author=A Ricci, M Piunti, M Viroli; citation_volume=23; citation_issue=2; citation_publication_date=2011; citation_pages=158-192; citation_doi=10.1007/s10458-010-9140-7; citation_id=CR26; Sierra, C., & Debenham, J. (2006). Trust and honour in information-based agency. In Proceedings of the 5th international conference on autonomous agents and multi agent systems, (p. 1225-1232). New York: ACM.; citation_journal_title=KI-Knstliche Intelligenz; citation_title=Agreement computing; citation_author=C Sierra, V Botti, S Ossowski; citation_volume=25; citation_issue=1; citation_publication_date=2011; citation_pages=57-61; citation_doi=10.1007/s13218-010-0070-y; citation_id=CR28; citation_journal_title=Expert Systems with Applications; citation_title=Distributed norm management for multi-agent systems; citation_author=W Vasconcelos, A Garcia-Camino, D Gaertner, JA Rodriguez-Aguilar, P Noriega; citation_volume=39; citation_issue=5; citation_publication_date=2012; citation_pages=5990-5999; citation_doi=10.1016/j.eswa.2011.11.108; citation_id=CR29; citation_title=An introduction to multiagent systems; citation_publication_date=2002; citation_id=CR30; citation_author=M Wooldridge; citation_publisher=Wiley; citation_journal_title=Knowledge Engineering Review; citation_title=Intelligent agents: theory and practice; citation_author=M Wooldridge, NR Jennings; citation_volume=10; citation_issue=2; citation_publication_date=1995; citation_pages=115-152; citation_doi=10.1017/S0269888900008122; citation_id=CR31"			Excluded	Excluded	new_screen			2	Springer Link		Advances in infrastructures and tools for multiagent systems	http://link.springer.com/article/10.1007/s10796-014-9493-6	Springer Link	nan; Abstract; Keywords; Pages; Year; Bibtex
338	Behave	Agile Android	As a developer, you want to get better at Android development, have fewer bugs, make a better product, or simply make the customer happy. Whether you're developing for the web, mobile, or even the desktop, it pays to adopt an Agile approach to your development and testing.		Nolan, Godfrey; Cinar, Onur; Truxall, David	Android Best Practices	https://doi.org/10.1007/978-1-4302-5858-2_4		75--92	"""@Inbook{Nolan2014,
    author = ""Nolan, Godfrey and Cinar, Onur and Truxall, David"",
    title = ""Agile Android"",
    bookTitle = ""Android Best Practices"",
    year = ""2014"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""75--92"",
    abstract = ""As a developer, you want to get better at Android development, have fewer bugs, make a better product, or simply make the customer happy. Whether you're developing for the web, mobile, or even the desktop, it pays to adopt an Agile approach to your development and testing."",
    isbn = ""978-1-4302-5858-2"",
    doi = ""10.1007/978-1-4302-5858-2\_4"",
    url = ""https://doi.org/10.1007/978-1-4302-5858-2\_4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Agile Android	http://link.springer.com/chapter/10.1007/978-1-4302-5858-2_4	Apress	nan; Keywords; References
339	Behave	Agile Practices in Azure DevOps and TFS	This chapter focuses on more technical aspects of Agile practices. They might not be linked directly to project management or product management, but they are great ways to enhance the quality of your coding efforts. In Chapter 3, you were given a brief overview of eXtreme Programming, or XP, as it is called. As you may remember, Scrum, for example, does not say how you should work using the Scrum framework. XP is much more practice oriented; it gives you hands-on advice on how you should work.		Rossberg, Joachim	Agile Project Management with Azure DevOps	https://doi.org/10.1007/978-1-4842-4483-8_6		197--228	"""@Inbook{Rossberg2019,
    author = ""Rossberg, Joachim"",
    title = ""Agile Practices in Azure DevOps and TFS"",
    bookTitle = ""Agile Project Management with Azure DevOps: Concepts, Templates, and Metrics"",
    year = ""2019"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""197--228"",
    abstract = ""This chapter focuses on more technical aspects of Agile practices. They might not be linked directly to project management or product management, but they are great ways to enhance the quality of your coding efforts. In Chapter 3, you were given a brief overview of eXtreme Programming, or XP, as it is called. As you may remember, Scrum, for example, does not say how you should work using the Scrum framework. XP is much more practice oriented; it gives you hands-on advice on how you should work."",
    isbn = ""978-1-4842-4483-8"",
    doi = ""10.1007/978-1-4842-4483-8\_6"",
    url = ""https://doi.org/10.1007/978-1-4842-4483-8\_6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Agile Practices in Azure DevOps and TFS	http://link.springer.com/chapter/10.1007/978-1-4842-4483-8_6	Apress	nan; Keywords; References
340	Behave	Agile Practices, Collaboration and Experience	Agile Software Development has been around for more than fifteen years and is now widespread. How does experience effect the application of agile methods in organizations and what are the implications on the individual and organizational culture? This paper presents in-depth analysis of the Swiss Agile Study 2014. Switzerland offers an illustrative microcosm of software development, with a range of industry domains and sizes, and well-educated and internationally aware professionals. The study included more than a hundred professionals and managers, contacted through professional and industry associations. The topics addressed included experience with Agile development, motivations for adopting it, barriers perceived, specific practices used, and specific benefits realized. Analysis of the data identified important trends and differences. Agile experience seems to be an important factor, which affects many aspects of practice and workplace culture. More troubling is that it appears stress and overwork may be common among Agile professionals. All these findings illustrate important differences between Agile processes as prescribed, and as actually practiced.	Agile; Software process; Collaboration; Organizational culture; Software practices	Kropp, Martin; Meier, Andreas; Biddle, Robert	International Conference on Product-Focused Software Process Improvement	https://doi.org/10.1007/978-3-319-49094-6_28		416--431	"""@InProceedings{10.1007/978-3-319-49094-6_28,
    author = ""Kropp, Martin and Meier, Andreas and Biddle, Robert"",
    editor = ""Abrahamsson, Pekka and Jedlitschka, Andreas and Nguyen Duc, Anh and Felderer, Michael and Amasaki, Sousuke and Mikkonen, Tommi"",
    title = ""Agile Practices, Collaboration and Experience"",
    booktitle = ""Product-Focused Software Process Improvement"",
    year = ""2016"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""416--431"",
    abstract = ""Agile Software Development has been around for more than fifteen years and is now widespread. How does experience effect the application of agile methods in organizations and what are the implications on the individual and organizational culture? This paper presents in-depth analysis of the Swiss Agile Study 2014. Switzerland offers an illustrative microcosm of software development, with a range of industry domains and sizes, and well-educated and internationally aware professionals. The study included more than a hundred professionals and managers, contacted through professional and industry associations. The topics addressed included experience with Agile development, motivations for adopting it, barriers perceived, specific practices used, and specific benefits realized. Analysis of the data identified important trends and differences. Agile experience seems to be an important factor, which affects many aspects of practice and workplace culture. More troubling is that it appears stress and overwork may be common among Agile professionals. All these findings illustrate important differences between Agile processes as prescribed, and as actually practiced."",
    isbn = ""978-3-319-49094-6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Agile Practices, Collaboration and Experience	https://link.springer.com/chapter/10.1007/978-3-319-49094-6_28	Springer International Publishing	nan; References
341	Behave	Agile Test Automation			Manfred BaumgartnerMartin KlonkChristian MastnakHelmut PichlerRichard SeidlSiegfried Tanczos						Excluded	Excluded	new_screen			2						
342	Behave	Agile Testing	http://link.springer.com/book/10.1007/978-3-030-73209-7	Agile Software Development; Software Quality Assurance; Software Testing; Kanban; Scrum; Software Test Automation	Manfred Baumgartner; Martin Klonk; Christian Mastnak; Helmut Pichler; Richard Seidl; Siegfried Tanczos		https://dl.acm.org/doi/10.1145/3397056.3397085				Excluded	Excluded	new_screen			2	Springer Link		Agile Testing	https://dl.acm.org/doi/10.1145/3397056.3397085	Springer Link	nan; Venue; Abstract; References; Pages; Year; Bibtex; DOI
343	Behave	An Agile Approach to Requirement Specification	This experience report is about how one project in Norway made an agile approach to specifying software requirements for a new intranet. Rather than spending months on trying to detail all requirements and aspects of the solution, the team spent a few weeks specifying a prioritized list of high-level requirements. Further details will emerge by face-to-face communication through the iterations of the project quickly turning in to valuable working software for the customer.	Project Plan; Requirement Specification; User Story; Content Management System; Student Welfare	Bang, Tom J.	International Conference on Extreme Programming and Agile Processes in Software Engineering	https://doi.org/10.1007/978-3-540-73101-6_35		193--197	"""@InProceedings{10.1007/978-3-540-73101-6_35,
    author = ""Bang, Tom J."",
    editor = ""Concas, Giulio and Damiani, Ernesto and Scotto, Marco and Succi, Giancarlo"",
    title = ""An Agile Approach to Requirement Specification"",
    booktitle = ""Agile Processes in Software Engineering and Extreme Programming"",
    year = ""2007"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""193--197"",
    abstract = ""This experience report is about how one project in Norway made an agile approach to specifying software requirements for a new intranet. Rather than spending months on trying to detail all requirements and aspects of the solution, the team spent a few weeks specifying a prioritized list of high-level requirements. Further details will emerge by face-to-face communication through the iterations of the project quickly turning in to valuable working software for the customer."",
    isbn = ""978-3-540-73101-6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		An Agile Approach to Requirement Specification	http://link.springer.com/chapter/10.1007/978-3-540-73101-6_35	Springer Berlin Heidelberg	nan; References
344	Behave	An architecture governance approach for Agile development by tailoring the Spotify model	The role of software architecture in large-scale Agile development is important because several teams need to work together to release a single software product while helping to maximise teams' autonomy. Governing and aligning Agile architecture across autonomous squads (i.e., teams), when using the Spotify model, is a challenge because the Spotify model lacks practices for addressing Agile architecture governance. To explorehow software architecture can be governed and aligned by scaling the Spotify model, we conducted a longitudinal embedded case study in a multinational FinTech organisation. Then, we developed and evaluated an approach for architectural governance by conducting an embedded case study. The collected data was analysed using Thematic Analysis and informed by selected Grounded Theory techniques such as memoing, open coding, constant comparison, and sorting. Our approach for architectural governance comprises an organisational structure change and an architecture change management process. The benefits reported by the practitioners include devolving architectural decision-making to the operational level (i.e., Architecture Owners), enhancing architectural knowledge sharing among squads, minimising wasted effort in architectural refactoring, and other benefits. The practitioners in our case study realised an improved squad autonomy by the ability to govern and align architectural decisions. We provide two key contributions in this paper. First, we present the characteristics of our proposed architectural governance approach, its evaluation, benefits, and challenges. Second, we present how the novel Heterogeneous Tailoring model was enhanced to accommodate our architectural governance approach.	Artificial Intelligence; Large-scale Agile developments; Agile architecture; Spotify Tailoring; FinTech; Thematic analysis; Grounded Theory	Abdallah Salameh; Julian M. Bass	AI & SOCIETY	https://doi.org/10.1007/s00146-021-01240-x	"citation_journal_title=IEEE Softw; citation_title=Agility and architecture: Can they coexist?; citation_author=P Abrahamsson, MA Babar, P Kruchten; citation_volume=27; citation_issue=2; citation_publication_date=2010; citation_pages=16-22; citation_doi=10.1109/MS.2010.36; citation_id=CR2; citation_journal_title=Emergence; citation_title=Of ants and men: self-organized teams in human and insect organizations; citation_author=C Anderson, E McMillan; citation_volume=5; citation_issue=2; citation_publication_date=2003; citation_pages=29-41; citation_doi=10.1207/S15327000EM050205; citation_id=CR3; Bass J, Salameh A (2020) Architectural Governance Interview Guide. University of Salford, UK. 
                  https://doi.org/10.17866/rd.salford.12613424.v1; citation_journal_title=Cut IT J; citation_title=How to Agilely architect an Agile architecture; citation_author=S Bellomo, P Kruchten, RL Nord, I Ozkaya; citation_volume=27; citation_issue=2; citation_publication_date=2014; citation_pages=12-17; citation_id=CR6; citation_journal_title=IEEE Softw; citation_title=The defenestration of superfluous architectural accoutrements; citation_author=G Booch; citation_volume=26; citation_issue=4; citation_publication_date=2009; citation_pages=7-8; citation_doi=10.1109/MS.2009.105; citation_id=CR7; citation_journal_title=Qual Res Psychol; citation_title=Using thematic analysis in psychology; citation_author=V Braun, V Clarke; citation_volume=3; citation_issue=2; citation_publication_date=2006; citation_pages=77-101; citation_doi=10.1191/1478088706qp063oa; citation_id=CR8; citation_journal_title=IEEE Softw; citation_title=Architecture and agility: married, divorced, or just good friends?; citation_author=F Buschmann, K Henney; citation_volume=30; citation_issue=2; citation_publication_date=2013; citation_pages=80-82; citation_doi=10.1109/MS.2013.25; citation_id=CR9; citation_journal_title=Computer; citation_title=Agile software development, the people factor; citation_author=A Cockburn, J Highsmith; citation_volume=34; citation_issue=11; citation_publication_date=2001; citation_pages=131-133; citation_doi=10.1109/2.963450; citation_id=CR10; citation_journal_title=IEEE Softw; citation_title=Implementing large-scale Agile frameworks: challenges and recommendations; citation_author=K Conboy, N Carroll; citation_volume=36; citation_issue=2; citation_publication_date=2019; citation_pages=44-50; citation_doi=10.1109/MS.2018.2884865; citation_id=CR11; citation_title=Agile software development: current research and future directions; citation_publication_date=2010; citation_id=CR12; citation_author=T Dingsoyr; citation_author=T Dyba; citation_author=NB Moe; citation_publisher=Springer Publishing Company; citation_journal_title=IEEE Softw; citation_title=Architecture meets agility; citation_author=H Erdogmus; citation_volume=26; citation_issue=5; citation_publication_date=2009; citation_pages=2-4; citation_doi=10.1109/MS.2009.121; citation_id=CR13; citation_journal_title=Electron Mark; citation_title=Understanding FinTech start-ups--a taxonomy of consumer-oriented service offerings; citation_author=H Gimpel, D Rau, M Roglinger; citation_volume=28; citation_issue=3; citation_publication_date=2018; citation_pages=245-264; citation_doi=10.1007/s12525-017-0275-0; citation_id=CR14; citation_title=Doing grounded theory: issues and discussions; citation_publication_date=1998; citation_id=CR15; citation_author=BG Glaser; citation_publisher=Sociology Press; Hammond S, Umphress D (2012) Test driven development: the state of the practice. In: Proceedings of the 50th Annual Southeast Regional Conference, Tuscaloosa, Alabama; citation_journal_title=IEEE Trans Software Eng; citation_title=Self-organizing roles on Agile software development teams; citation_author=R Hoda, J Noble, S Marshall; citation_volume=39; citation_issue=3; citation_publication_date=2013; citation_pages=422-444; citation_doi=10.1109/TSE.2012.30; citation_id=CR17; Kilu E, Milani F, Scott E, Pfahl D (2019) Agile software process improvement by learning from financial and fintech companies: LHV Bank Case Study. Software Quality: the complexity and challenges of software engineering and software quality in the cloud, Cham; citation_journal_title=Managerial Fin; citation_title=Toward understanding FinTech and its industry; citation_author=HS Knewtson, ZA Rosenbaum; citation_volume=46; citation_issue=8; citation_publication_date=2020; citation_pages=1043-1060; citation_doi=10.1108/MF-01-2020-0024; citation_id=CR19; Kniberg H (2014) Spotify Squad framework. Retrieved July, 2020 from 
                  https://medium.com/project-management-learnings/; Kniberg H, Ivarsson A (2012). Scaling Agile @ Spotify with tribes, squads, chapters & guilds. Retrieved June, 2020 from 
                  https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf; citation_title=Naturalistic inquiry; citation_publication_date=1985; citation_id=CR22; citation_author=YS Lincoln; citation_author=EG Guba; citation_publisher=Sage Publications; Linders B (2016) Don't copy the Spotify model. 
                  https://www.infoq.com/news/2016/10/no-Spotify-model; Martini A, Bosch J (2016) A multiple case study of continuous architecting in large Agile companies: current gaps and the CAFFEA framework. In: 2016 13th Working IEEE/IFIP Conference on Software Architecture (WICSA); citation_title=Scrum and team effectiveness: theory and practice; citation_publication_date=2008; citation_id=CR25; citation_author=NB Moe; citation_author=T Dingsoyr; citation_publisher=Agile Processes in Software Engineering and Extreme Programming; Moe NB, Dingsoyr T, Dyba T (2008) Understanding self-organizing teams in Agile software development. In: Proceedings of the 19th Australian Conference on Software Engineering (aswec 2008); Moe NB, Olsson HH, Dingsoyr T (2016) Trends in large-scale Agile development: a summary of the 4th workshop at XP2016. In: Proceedings of the Scientific Workshop Proceedings of XP2016; Nord RL, Ozkaya I, Kruchten P (2014) Agile in distress: architecture to the rescue. Agile methods. Large-scale development, refactoring, testing, and estimation, Cham; citation_journal_title=Inf Softw Technol; citation_title=Ethnographically-informed empirical studies of software practice; citation_author=H Robinson, J Segal, H Sharp; citation_volume=49; citation_issue=6; citation_publication_date=2007; citation_pages=540-551; citation_doi=10.1016/j.infsof.2007.02.007; citation_id=CR29; Salameh A, Bass JM (2018) Influential factors of aligning Spotify squads in mission-critical and offshore projects--a longitudinal embedded case study. Product-Focused Software Process Improvement, Cham; Salameh A, Bass JM (2019a) Spotify tailoring for B2B product development. In: Proceedings of the 2019 45th Euromicro Conference on Software Engineering and Advanced Applications (SEAA); Salameh A, Bass JM (2019b) Spotify tailoring for promoting effectiveness in cross-functional autonomous squads. Agile processes in software engineering and extreme programming--Workshops, Cham; Salameh A, Bass JM (2020) Heterogeneous tailoring approach using the Spotify model. In: EASE '20 proceedings of the evaluation and assessment on software engineering, Trondheim, Norway; citation_journal_title=IEEE Softw; citation_title=Spotify guilds: how to succeed with knowledge sharing in large-scale Agile organizations; citation_author=D Smite, NB Moe, G Levinta, M Floryan; citation_volume=36; citation_issue=2; citation_publication_date=2019; citation_pages=51-57; citation_doi=10.1109/MS.2018.2886178; citation_id=CR32; citation_journal_title=Commun ACM; citation_title=Spotify guilds; citation_author=D Smite, NB Moe, M Floryan, G Levinta, P Chatzipetrou; citation_volume=63; citation_issue=3; citation_publication_date=2020; citation_pages=56-61; citation_doi=10.1145/3343146; citation_id=CR33; Stray V, Moe NB, Hoda R (2018) Autonomous Agile teams: challenges and future directions for research. In: Proceedings of the 19th international conference on Agile software development: companion, Porto, Portugal; citation_journal_title=J Syst Softw; citation_title=A systematic mapping study on the combination of software architecture and Agile development; citation_author=C Yang, P Liang, P Avgeriou; citation_volume=111; citation_publication_date=2016; citation_pages=157-184; citation_doi=10.1016/j.jss.2015.09.028; citation_id=CR35"			Excluded	Excluded	new_screen			2	Springer Link		An architecture governance approach for Agile development by tailoring the Spotify model	http://link.springer.com/article/10.1007/s00146-021-01240-x	Springer Link	nan; Pages; Year; Bibtex
345	Behave	An Automated Approach for Acceptance Web Test Case Modeling and Executing	This paper proposes an approach for modeling and executing acceptance web test cases and describes a suite of tools to support it. The main objective is to assist the use of Acceptance Test-Driven Development (ATDD) in web applications by providing mechanisms to support customer-developer communication and by helping test case creation. Initially, the set of web pages and relations (links) associated with a user story is modeled. Functional test possibilities involving these relations are automatically summarized in a graph, being each path of the graph a user story testing scenario. Once a testing scenario is accepted by the customer, a testing script is automatically created. A web testing framework then executes the script, triggering the ATDD process.	testing automation; web testing; acceptance web test-driven development; agile methods	Besson, Felipe M.; Beder, Delano M.; Chaim, Marcos L.	International Conference on Agile Software Development	https://doi.org/10.1007/978-3-642-13054-0_12		160--165	"""@InProceedings{10.1007/978-3-642-13054-0_12,
    author = ""Besson, Felipe M. and Beder, Delano M. and Chaim, Marcos L."",
    editor = ""Sillitti, Alberto and Martin, Angela and Wang, Xiaofeng and Whitworth, Elizabeth"",
    title = ""An Automated Approach for Acceptance Web Test Case Modeling and Executing"",
    booktitle = ""Agile Processes in Software Engineering and Extreme Programming"",
    year = ""2010"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""160--165"",
    abstract = ""This paper proposes an approach for modeling and executing acceptance web test cases and describes a suite of tools to support it. The main objective is to assist the use of Acceptance Test-Driven Development (ATDD) in web applications by providing mechanisms to support customer-developer communication and by helping test case creation. Initially, the set of web pages and relations (links) associated with a user story is modeled. Functional test possibilities involving these relations are automatically summarized in a graph, being each path of the graph a user story testing scenario. Once a testing scenario is accepted by the customer, a testing script is automatically created. A web testing framework then executes the script, triggering the ATDD process."",
    isbn = ""978-3-642-13054-0""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		An Automated Approach for Acceptance Web Test Case Modeling and Executing	http://link.springer.com/chapter/10.1007/978-3-642-13054-0_12	Springer Berlin Heidelberg	nan; References
346	Behave	An autonomous performance testing framework using self-adaptive fuzzy reinforcement learning	Test automation brings the potential to reduce costs and human effort, but several aspects of software testing remain challenging to automate. One such example is automated performance testing to find performance breaking points. Current approaches to tackle automated generation of performance test cases mainly involve using source code or system model analysis or use-case-based techniques. However, source code and system models might not always be available at testing time. On the other hand, if the optimal performance testing policy for the intended objective in a testing process instead could be learned by the testing system, then test automation without advanced performance models could be possible. Furthermore, the learned policy could later be reused for similar software systems under test, thus leading to higher test efficiency. We propose SaFReL, a self-adaptive fuzzy reinforcement learning-based performance testing framework. SaFReL learns the optimal policy to generate performance test cases through an initial learning phase, then reuses it during a transfer learning phase, while keeping the learning running and updating the policy in the long term. Through multiple experiments in a simulated performance testing setup, we demonstrate that our approach generates the target performance test cases for different programs more efficiently than a typical testing process and performs adaptively without access to source code and performance models.	Artificial Intelligence; Performance testing; Stress testing; Test case generation; Reinforcement learning; Autonomous testing	Mahshid Helali Moghadam,; Mehrdad Saadatmand; Markus Borg; Markus Bohlin; Bjorn Lisper	Software Quality Journal	https://doi.org/10.1007/s11219-020-09532-z	"citation_journal_title=Software Quality Journal; citation_title=Automated gui performance testing; citation_author=A Adamoli, D Zaparanuks, M Jovic, M Hauswirth; citation_volume=19; citation_issue=4; citation_publication_date=2011; citation_pages=801-839; citation_doi=10.1007/s11219-011-9135-x; citation_id=CR1; Ahmad, T., Ashraf, A., Truscan, D., Porres, I. (2019). Exploratory performance testing using reinforcement learning. In 2019 45th Euromicro Conference on Software Engineering and Advanced Applications (SEAA)(pp. 156-163). IEEE.; Apte, V., Viswanath, T. V. S., Gawali, D., Kommireddy, A., Gupta, A. (2017). AutoPerf: Automated load testing and resource usage profiling of multi-tier internet applications. In Proceedings of the 8th ACM/SPEC on International Conference on Performance Engineering (pp. 115-126).; Avritzer, A., Duarte, F. P., Leao, R. M. M., e Silva, Ed. S., Cohen, M., Costello, D. (2008). Reliability estimation for large distributed software systems. In Cascon, Citeseer (p. 12).; Ayala-Rivera, V., Kaczmarski, M., Murphy, J., Darisa, A., Portillo-Dominguez, AO. (2018). One size does not fit all: In-test workload adaptation for performance testing of enterprise applications. In Proceedings of the 2018 ACM/SPEC International Conference on Performance Engineering, ACM (pp. 211-222).; citation_journal_title=<i>IEEE Access</i>; citation_title=Web performance evaluation for internet of things applications; citation_author=ZB Babovic, J Protic, V Milutinovic; citation_volume=4; citation_publication_date=2016; citation_pages=6974-6992; citation_doi=10.1109/ACCESS.2016.2615181; citation_id=CR6; Briand, LC., Labiche, Y., Shousha, M. (2005). Stress testing real-time systems with genetic algorithms. In Proceedings of the 7th annual conference on Genetic and evolutionary computation, ACM (pp. 1021-1028).; Brunnert, A., van Hoorn, A., Willnecker, F., Danciu, A., Hasselbring, W., Heger, C., et al. (2015). Performance oriented devops: A research agenda. arXiv preprint. 
                  arXiv:150804752; citation_journal_title=<i>ACM computing surveys (CSUR)</i>; citation_title=Anomaly detection: A survey; citation_author=V Chandola, A Banerjee, V Kumar; citation_volume=41; citation_issue=3; citation_publication_date=2009; citation_pages=15; citation_doi=10.1145/1541880.1541882; citation_id=CR9; Chung, L., Nixon, B. A., Yu, E., Mylopoulos, J. (2012). Non-functional requirements in software engineering. Springer Science & Business Media, 5.; Cortellessa, V., Di Marco, A., Inverardi, P. (2011). Model-based software performance analysis. Springer Science & Business Media.; Costa, LT., Czekster, RM., de Oliveira, FM., Rodrigues, EDM., da Silveira, MB., Zorzo, AF. (2012). Generating Performance Test Scripts and Scenarios Based on Abstract Intermediate Models. In SEKE, (pp. 112-117).; citation_journal_title=<i>ACM SIGSOFT Software Engineering Notes</i>; citation_title=Early performance testing of dis- tributed software applications; citation_author=G Denaro, A Polini, W Emmerich; citation_volume=29; citation_publication_date=2004; citation_pages=94-103; citation_doi=10.1145/974043.974059; citation_id=CR13; Di Penta, M., Canfora, G., Esposito, G., Mazza, V., Bruno, M. (2007). Search-based testing of service level agreements. In Proceedings of the 9th annual conference on Genetic and evolutionary computation, ACM (pp. 1090-1097).; Draheim, D., Grundy, J., Hosking, J., Lutteroth, C., Weber, G. (2006). Realistic load testing of web applications. In Conference on Software Maintenance and Reengineering (CSMR'06), IEEE (p. 11).; Ferme, V., & Pautasso, C. (2017). Towards holistic continuous software performance assessment. In Proceedings of the 8th ACM/SPEC on International Conference on Performance Engineering Companion, ACM (pp. 159-164).; Ferme, V., & Pautasso, C. (2018). A declarative approach for performance tests execution in continuous software development environments. In Proceedings of the 2018 ACM/SPEC International Conference on Performance Engineering, ACM (pp. 261-272).; Fowler, K. (2009). Mission-critical and safety-critical systems handbook: Design and development for embedded applications. Newnes.; Garousi, V. (2008). Empirical analysis of a genetic algorithm-based stress test technique. In Proceedings of the 10th annual conference on Genetic and evolutionary computation, ACM (pp. 1743-1750).; citation_journal_title=<i>IEEE Transactions on Software Engineering</i>; citation_title=A genetic algorithm-based stress test requirements generator tool and its empirical evaluation; citation_author=V Garousi; citation_volume=36; citation_issue=6; citation_publication_date=2010; citation_pages=778-797; citation_doi=10.1109/TSE.2010.5; citation_id=CR20; citation_journal_title=<i>Journal of Systems and Software</i>; citation_title=Traffic-aware stress testing of distributed real-time systems based on uml models using genetic algorithms; citation_author=V Garousi, LC Briand, Y Labiche; citation_volume=81; citation_issue=2; citation_publication_date=2008; citation_pages=161-185; citation_doi=10.1016/j.jss.2007.05.037; citation_id=CR21; Glinz, M. (2007). On non-functional requirements. In 15th IEEE International Requirements Engineering Conference (RE 2007), IEEE (pp. 21-26).; Grechanik, M., Fu, C., Xie, Q. (2012). Automatically finding performance problems with feedback-directed learning software testing. In 2012 34th International Conference on Software Engineering (ICSE), IEEE (pp. 156-166).; Gregg, B. (2013). Systems performance: enterprise and the cloud. Pearson Education.; Grinshpan, L. (2012). Solving enterprise applications performance puzzles: queuing models to the rescue. John Wiley & Sons.; Gu, Y., & Ge, Y. (2009). Search-based performance testing of applications with composite services. In 2009 International Conference on Web Information Systems and Mining, IEEE (pp. 320-324).; Harchol-Balter, M. (2013). Performance modeling and design of computer systems: queueing theory in action. Cambridge University Press.; citation_journal_title=<i>IEEE software</i>; citation_title=Tools for continuously evaluating distributed system qualities; citation_author=J Hill, D Schmidt, J Edmondson, A Gokhale; citation_volume=27; citation_issue=4; citation_publication_date=2009; citation_pages=65-71; citation_doi=10.1109/MS.2009.197; citation_id=CR28; citation_journal_title=ACM Computing Surveys (CSUR); citation_title=Performance anomaly detection and bottleneck identification; citation_author=O Ibidunmoye, F Hernandez-Rodriguez, E Elmroth; citation_volume=48; citation_issue=1; citation_publication_date=2015; citation_pages=4; citation_doi=10.1145/2791120; citation_id=CR29; Ibidunmoye, O., Moghadam, M. H., Lakew, E. B., Elmroth, E. (2017). Adaptive service performance control using cooperative fuzzy reinforcement learning in vir- tualized environments. In Proceedings of the10th International Conference on Utility and Cloud Computing, ACM (pp. 19-28).; ISO 25000 (2019). ISO/IEC 25010 - System and software quality models. Available at 
                  https://iso25000.com/index.php/en/iso-25000-standards/iso-25010
                  
                . Retrieved July, 2019.; Jamshidi, P., Sharifloo, A., Pahl, C., Arabnejad, H., Metzger, A., Estrada, G. (2016). Fuzzy self-learning controllers for elasticity management in dynamic cloud architectures. In 2016 12th International ACM SIGSOFT Conference on Quality of Software Architectures (QoSA), IEEE (pp. 70-79).; citation_journal_title=<i>Journal of Network and Systems Management</i>; citation_title=Resource management in clouds: Survey and research challenges; citation_author=B Jennings, R Stadler; citation_volume=23; citation_issue=3; citation_publication_date=2015; citation_pages=567-619; citation_doi=10.1007/s10922-014-9307-7; citation_id=CR33; citation_journal_title=<i>IEEE, Transactions on Software Engineering</i>; citation_title=A survey on load testing of large-scale software systems; citation_author=ZM Jiang, AE Hassan; citation_volume=41; citation_issue=11; citation_publication_date=2015; citation_pages=1091-1118; citation_doi=10.1109/TSE.2015.2445340; citation_id=CR34; Jindal, A., Podolskiy, V., Gerndt, M. (2019). Performance modeling for cloud microservice applications. In Proceedings of the 2019 ACM/SPEC International Conference on Performance Engineering, ACM (pp. 25-32).; Kant, K., & Srinivasan, M. (1992). Introduction to computer system performance evaluation. McGraw-Hill College.; citation_journal_title=<i>Software & Systems Modeling</i>; citation_title=Tradeoffs in modeling performance of highly configurable software systems; citation_author=S Kolesnikov, N Siegmund, C Kastner, A Grebhahn, S Apel; citation_volume=18; citation_issue=3; citation_publication_date=2019; citation_pages=2265-2283; citation_doi=10.1007/s10270-018-0662-9; citation_id=CR37; Koo, J., Saumya, C., Kulkarni, M., Bagchi, S. (2019). Pyse: Automatic worst-case test generation by reinforcement learning. In 2019 12th IEEE Conference on Software Testing, Validation and Verification (ICST), IEEE (pp. 136-147).; citation_journal_title=<i>Fuzzy classifiers. Scholarpedia</i>; citation_author=LI Kuncheva; citation_volume=3; citation_issue=1; citation_publication_date=2008; citation_pages=2925; citation_doi=10.4249/scholarpedia.2925; citation_id=CR39; Lutteroth, C., & Weber, G. (2008). Modeling a realistic workload for performance testing. In 2008 12th International IEEE Enterprise Distributed Object Computing Conference, IEEE (pp. 149-158).; Maddodi, G., Jansen, S., de Jong, R. (2018). Generating workload for erp applications through end-user organization categorization using high level business operation data. In Proceedings of the 2018 ACM/SPEC International Conference on Performance Engineering, ACM (pp. 200-210).; Malik, H., Jiang, Z. M., Adams, B., Hassan, A. E., Flora, P., Hamann, G. (2010). Automatic comparison of load tests to support the performance analysis of large enterprise systems. In 2010 14th European conference on software maintenance and reengineering, IEEE (pp. 222-231).; Malik, H., Hemmati, H., Hassan, A. E. (2013). Automatic detection of performance deviations in the load testing of large scale systems. In Proceedings of the 2013 International Conference on Software Engineering, IEEE Press (pp. 1012-1021).; MathWorks (2019). Fuzzy Inference Process. Retrieved from 
                  https://www.mathworks.com/help/fuzzy/fuzzy-inference-process.html; Menasc'e, DA. (2002). Load testing, benchmarking, and application performance management for the web. In Int. CMG Conference (pp. 271-282).; Michael, N., Ramannavar, N., Shen, Y., Patil, S., Sung, J. L. (2017). Cloudperf: A performance test framework for distributed and dynamic multi-tenant environ- ments. In Proceedings of the 8th ACM/SPEC on International Conference on Performance Engineering, ACM (pp. 189-200).; Moghadam, M. H., Saadatmand, M., Borg, M., Bohlin, M., Lisper, B. (2018). Adaptive runtime response time control in plc-based real-time systems using rein- forcement learning. In 2018 IEEE/ACM 13th International Symposium on Software Engineering for Adaptive and Self-Managing Systems (SEAMS), IEEE (pp. 217-223).; Moghadam, M. H., Saadatmand, M., Borg, M., Bohlin, M., Lisper, B. (2019). Machine learning to guide performance testing: An autonomous test framework. In 2019 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW), IEEE (pp. 164-167).; citation_journal_title=<i>IEEE Access</i>; citation_title=Virtualization on internet of things edge devices with con- tainer technologies: a performance evaluation; citation_author=R Morabito; citation_volume=5; citation_publication_date=2017; citation_pages=8835-8850; citation_doi=10.1109/ACCESS.2017.2704444; citation_id=CR49; NS8 (2018). Did You Know A Slow Webpage Can Cost You 7% of Your Sales. Available at 
                  https://www.ns8.com/en/ns8u/did-you-know/a-slowwebpage-can-cost-you-7-percent-of-your-sales
                  
                . Retrieved July 2019; Schulz, H., Okanovi'c, D., van Hoorn, A., Ferme, V., Pautasso, C. (2019). Behavior- driven load testing using contextual knowledge-approach and experiences. In Proceedings of the 2019 ACM/SPEC International Conference on Performance Engineering, ACM (pp. 265-272).; Shams, M., Krishnamurthy, D., Far, B. (2006). A model-based approach for testing the performance of web applications. In Proceedings of the 3rd international workshop on Software quality assurance, ACM (pp. 54-61).; da Silveira, MB., Rodrigues, EdM., Zorzo, AF., Costa, LT., Vieira, HV., de Oliveira, FM. (2011). Generation of scripts for performance testing based on uml models. In SEKE (pp. 258-263).; Sutton, RS., & Barto, AG. (2018). Reinforcement learning: An introduction. MIT press.; Syer, MD., Adams, B., Hassan, AE. (2011). Identifying performance deviations in thread pools. In 2011 27th IEEE International Conference on Software Maintenance (ICSM), IEEE (pp. 83-92).; Taheri, J., Zomaya, AY., Kassler, A. (2016). vmbbthrpred: A black-box throughput predictor for virtual machines in cloud environments. In European Conference on Service-Oriented and Cloud Computing (pp. 18-33). Springer.; citation_journal_title=<i>International Journal of Big Data Intelligence</i>; citation_title=Auto-scale: automatic scaling of virtualised re- sources using neuro-fuzzy reinforcement learning approach; citation_author=T Veni, SMS Bhanu; citation_volume=3; citation_issue=3; citation_publication_date=2016; citation_pages=145-153; citation_doi=10.1504/IJBDI.2016.078400; citation_id=CR57; Venkataraman, S., Yang, Z., Franklin, M., Recht, B., Stoica, I. (2016). Ernest: ef- ficient performance prediction for large-scale advanced analytics. In 13th USENIX Symposium on Networked Systems Design and Implementation, NSDI (16) (pp. 363-378).; citation_journal_title=<i>Software & Systems Modeling</i>; citation_title=Wessbas: extraction of probabilistic workload specifications for load testing and per- formance prediction-a model-driven approach for session-based application systems; citation_author=C Vogele, A Hoorn, E Schulz, W Hasselbring, H Krcmar; citation_volume=17; citation_issue=2; citation_publication_date=2018; citation_pages=443-477; citation_doi=10.1007/s10270-016-0566-5; citation_id=CR59; Walter, J., van Hoorn, A., Koziolek, H., Okanovic, D., Kounev, S. (2016). Asking what?, automating the how?: The vision of declarative performance engi- neering. In Proceedings of the 7th ACM/SPEC on International Conference on Performance Engineering, ACM (pp. 91-94).; citation_journal_title=<i>IEEE transactions on software engineering</i>; citation_title=Experience with performance testing of software systems: issues, an approach, and case study; citation_author=EJ Weyuker, FI Vokolos; citation_volume=26; citation_issue=12; citation_publication_date=2000; citation_pages=1147-1156; citation_doi=10.1109/32.888628; citation_id=CR61; citation_journal_title=<i>ACM SIGSOFT Software Engineering Notes, ACM</i>; citation_title=Towards a structural load testing tool; citation_author=CSD Yang, LL Pollock; citation_volume=21; citation_publication_date=1996; citation_pages=201-208; citation_doi=10.1145/226295.226318; citation_id=CR62; Zhang, J., & Cheung, SC. (2002). Automated test case generation for the stress testing of multimedia systems. Software: Practice and Experience, 32(15), 1411-1435.; Zhang, P., Elbaum, S., Dwyer, M. B. (2011). Automatic generation of load tests. In Proceedings of the 2011 26th IEEE/ACM International Conference on Automated Software Engineering, IEEE Computer Society (pp. 43-52).; Zhang, P., Elbaum, S., Dwyer, M. B. (2012). Compositional load test generation for software pipelines. In Proceedings of the 2012 International Symposium on Software Testing and Analysis, ACM (pp. 89-99)."			Excluded	Excluded	new_screen			2	Springer Link		An autonomous performance testing framework using self-adaptive fuzzy reinforcement learning	http://link.springer.com/article/10.1007/s11219-020-09532-z	Springer Link	nan; Pages; Year; Bibtex
347	Behave	An Empirical Study on the Adoption of Agile Software Development in Public Organizations	The government has been adopting agile software development in order to improve the results of their IT projects. However, there is a lack of structured information about its adoption in this context. Since the public sector have undergone a significant process of modernization to improve the quality of public service, the goal of this study is to report from an empirical study, provide information that may enhance the understanding of the implications of adopting agile software development within public organizations, proposing a set of recommendations for its adoption.	Empirical software engineering; Agile software development; Agile methodologies; Agile methods; Public organizations; Public sector; Government	Vacari, Isaque; Prikladnicki, Rafael	Brazilian Workshop on Agile Methods	https://doi.org/10.1007/978-3-319-55907-0_1		3--15	"""@InProceedings{10.1007/978-3-319-55907-0_1,
    author = ""Vacari, Isaque and Prikladnicki, Rafael"",
    editor = ""Silva da Silva, Tiago and Est{\'a}cio, Bernardo and Kroll, Josiane and Mantovani Fontana, Rafaela"",
    title = ""An Empirical Study on the Adoption of Agile Software Development in Public Organizations"",
    booktitle = ""Agile Methods"",
    year = ""2017"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""3--15"",
    abstract = ""The government has been adopting agile software development in order to improve the results of their IT projects. However, there is a lack of structured information about its adoption in this context. Since the public sector have undergone a significant process of modernization to improve the quality of public service, the goal of this study is to report from an empirical study, provide information that may enhance the understanding of the implications of adopting agile software development within public organizations, proposing a set of recommendations for its adoption."",
    isbn = ""978-3-319-55907-0""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		An Empirical Study on the Adoption of Agile Software Development in Public Organizations	https://link.springer.com/chapter/10.1007/978-3-319-55907-0_1	Springer International Publishing	nan; References
348	Behave	An Exploratory Study on Applying a Scrum Development Process for Safety-Critical Systems	Background: Agile techniques recently have received attention from the developers of safety-critical systems. However, a lack of empirical knowledge of performing safety assurance techniques, especially safety analysis in a real agile project hampers further steps. Aims: In this article, we aim at (1) understanding and optimizing the S-Scrum development process, a Scrum extension with the integration of a systems theory based safety analysis technique, STPA (System-Theoretic Process Analysis), for safety-critical systems; (2) validating the Optimized S-Scrum development process further. Method: We conducted a two-stage exploratory case study in a student project at the University of Stuttgart, Germany. Results: The results in stage 1 showed that S-Scrum helps to ensure safety of each release but is less agile than the normal Scrum. We explored six challenges on: priority management; communication; time pressure on determining safety requirements; safety planning; time to perform upfront planning; and safety requirements' acceptance criteria. During stage 2, the safety and agility have been improved after the optimizations, including an internal and an external safety expert; pre-planning meeting; regular safety meeting; an agile safety plan; and improved safety epics and safety stories. We have also gained valuable suggestions from industry, but the generalization problem due to the specific context is still unsolved.	Agile software development; Safety-critical systems; Case study	Wang, Yang; Ramadani, Jasmin; Wagner, Stefan	International Conference on Product-Focused Software Process Improvement	https://doi.org/10.1007/978-3-319-69926-4_23		324--340	"""@InProceedings{10.1007/978-3-319-69926-4_23,
    author = ""Wang, Yang and Ramadani, Jasmin and Wagner, Stefan"",
    editor = ""Felderer, Michael and M{\'e}ndez Fern{\'a}ndez, Daniel and Turhan, Burak and Kalinowski, Marcos and Sarro, Federica and Winkler, Dietmar"",
    title = ""An Exploratory Study on Applying a Scrum Development Process for Safety-Critical Systems"",
    booktitle = ""Product-Focused Software Process Improvement"",
    year = ""2017"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""324--340"",
    abstract = ""Background: Agile techniques recently have received attention from the developers of safety-critical systems. However, a lack of empirical knowledge of performing safety assurance techniques, especially safety analysis in a real agile project hampers further steps. Aims: In this article, we aim at (1) understanding and optimizing the S-Scrum development process, a Scrum extension with the integration of a systems theory based safety analysis technique, STPA (System-Theoretic Process Analysis), for safety-critical systems; (2) validating the Optimized S-Scrum development process further. Method: We conducted a two-stage exploratory case study in a student project at the University of Stuttgart, Germany. Results: The results in stage 1 showed that S-Scrum helps to ensure safety of each release but is less agile than the normal Scrum. We explored six challenges on: priority management; communication; time pressure on determining safety requirements; safety planning; time to perform upfront planning; and safety requirements' acceptance criteria. During stage 2, the safety and agility have been improved after the optimizations, including an internal and an external safety expert; pre-planning meeting; regular safety meeting; an agile safety plan; and improved safety epics and safety stories. We have also gained valuable suggestions from industry, but the generalization problem due to the specific context is still unsolved."",
    isbn = ""978-3-319-69926-4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		An Exploratory Study on Applying a Scrum Development Process for Safety-Critical Systems	http://link.springer.com/chapter/10.1007/978-3-319-69926-4_23	Springer International Publishing	nan; References
349	Behave	An Overview of Requirements Evolution	Changing requirements are widely regarded as one of the most significant risks for software systems development. However, in today's business landscape, these changing requirements also represent opportunities to exploit new and evolving business conditions. In consonance with other agile methods, we advocate requirements engineering techniques that embrace and accommodate requirements change. This agile approach to requirements must nonetheless be systematic and incorporate some degree of planning, especially with respect to accommodating quality attributes such as safety and security. This chapter examines the nature of requirements evolution, and the two main problems that it entails. The first is to correctly understand what is changing in the requirements, that is, the elicitation problem. The other is to act on that new information using models and other representations of the requirements, influencing the architecture and implementation of the software system. This chapter first motivates the importance of considering changing requirements in evolving software systems. It then surveys historical and existing approaches to requirements evolution with respect to the elicitation and taking action problems. Finally, the chapter describes a framework for supporting requirements evolution, defining the Requirements Evolution Problem as finding new specifications to satisfy changed requirements and domain assumptions. To motivate this, we discuss a real-life case study of the payment card industry.		Ernst, Neil; Borgida, Alexander; Jureta, Ivan J.; Mylopoulos, John	Evolving Software Systems	https://doi.org/10.1007/978-3-642-45398-4_1		3--32	"""@Inbook{Ernst2014,
    author = ""Ernst, Neil and Borgida, Alexander and Jureta, Ivan J. and Mylopoulos, John"",
    editor = ""Mens, Tom and Serebrenik, Alexander and Cleve, Anthony"",
    title = ""An Overview of Requirements Evolution"",
    bookTitle = ""Evolving Software Systems"",
    year = ""2014"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""3--32"",
    abstract = ""Changing requirements are widely regarded as one of the most significant risks for software systems development. However, in today's business landscape, these changing requirements also represent opportunities to exploit new and evolving business conditions. In consonance with other agile methods, we advocate requirements engineering techniques that embrace and accommodate requirements change. This agile approach to requirements must nonetheless be systematic and incorporate some degree of planning, especially with respect to accommodating quality attributes such as safety and security. This chapter examines the nature of requirements evolution, and the two main problems that it entails. The first is to correctly understand what is changing in the requirements, that is, the elicitation problem. The other is to act on that new information using models and other representations of the requirements, influencing the architecture and implementation of the software system. This chapter first motivates the importance of considering changing requirements in evolving software systems. It then surveys historical and existing approaches to requirements evolution with respect to the elicitation and taking action problems. Finally, the chapter describes a framework for supporting requirements evolution, defining the Requirements Evolution Problem as finding new specifications to satisfy changed requirements and domain assumptions. To motivate this, we discuss a real-life case study of the payment card industry."",
    isbn = ""978-3-642-45398-4"",
    doi = ""10.1007/978-3-642-45398-4\_1"",
    url = ""https://doi.org/10.1007/978-3-642-45398-4\_1""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		An Overview of Requirements Evolution	http://link.springer.com/chapter/10.1007/978-3-642-45398-4_1	Springer Berlin Heidelberg	nan; Keywords; References
350	Behave	AngularJS	"AngularJS is the ""A"" in the MEAN stack. AngularJS enables developers to create front-end rich client side applications. The pieces are loosely coupled and structured in a modular fashion, resulting in less code to write, added flexibility, easier-to-read code, and quicker development time."	Command Line; Config File; Route Service; Directive Template; Search Engine Optimization	Elad Elrom	Pro MEAN Stack Development	https://doi.org/10.1007/978-1-4842-2044-3_5		101–129		Excluded	Excluded	new_screen			2	Springer Link		AngularJS	http://link.springer.com/chapter/10.1007/978-1-4842-2044-3_5	Apress, Berkeley, CA	nan; References; Year; Bibtex
351	Behave	Apogee: Application Ontology Generation with Size Optimization	To obtain runnable knowledge -- convertible into executable software -- from the highest abstraction level of an application, one should start with a neat set of application ontologies. But the latter are not readily available in the literature. One needs to generate dedicated and smaller application ontologies from larger generic domain ontologies. The main problem to be solved is to optimize the size of the generated application ontologies as a trade-off between two opposing tendencies: to enlarge the selected domain ontology segments to include most relationships between relevant concepts, while reducing the same segments to exclude irrelevant terms. This work describes a chain of algorithms and a series of heuristic rules to reach the proposed solution. Finally, case studies are used to actually illustrate the whole approach.		Exman, Iaakov; Iskusnov, Danil	International Joint Conference on Knowledge Discovery, Knowledge Engineering, and Knowledge Management	https://doi.org/10.1007/978-3-319-25840-9_29		477--492	"""@InProceedings{10.1007/978-3-319-25840-9_29,
    author = ""Exman, Iaakov and Iskusnov, Danil"",
    editor = ""Fred, Ana and Dietz, Jan L. G. and Aveiro, David and Liu, Kecheng and Filipe, Joaquim"",
    title = ""Apogee: Application Ontology Generation with Size Optimization"",
    booktitle = ""Knowledge Discovery, Knowledge Engineering and Knowledge Management"",
    year = ""2015"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""477--492"",
    abstract = ""To obtain runnable knowledge -- convertible into executable software -- from the highest abstraction level of an application, one should start with a neat set of application ontologies. But the latter are not readily available in the literature. One needs to generate dedicated and smaller application ontologies from larger generic domain ontologies. The main problem to be solved is to optimize the size of the generated application ontologies as a trade-off between two opposing tendencies: to enlarge the selected domain ontology segments to include most relationships between relevant concepts, while reducing the same segments to exclude irrelevant terms. This work describes a chain of algorithms and a series of heuristic rules to reach the proposed solution. Finally, case studies are used to actually illustrate the whole approach."",
    isbn = ""978-3-319-25840-9""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Apogee: Application Ontology Generation with Size Optimization	http://link.springer.com/chapter/10.1007/978-3-319-25840-9_29	Springer International Publishing	nan; Keywords; References
352	Behave	Appendix	In the following section I will give you some do's and don'ts, based on my personal experience that you might consider helpful. This is the risky part, since every exam taker has his or her own individual style of approaching a goal. So, read it and absorb only the part that you personally connect to it. If it strikes a chord, great! If it doesn't, don't bother.	Test Center; Agile Method; Agile Practice; Parking Spot; Agile Project	Sumanta Boral	Ace the PMI-ACP® exam	https://doi.org/10.1007/978-1-4842-2526-4_10		341–348		Excluded	Excluded	new_screen			2	Springer Link		Appendix	http://link.springer.com/chapter/10.1007/978-1-4842-2526-4_10	Apress, Berkeley, CA	nan; References; Year; Bibtex
353	Behave	Applying TDD and BDD Techniques	If you have been for a few years, chances are that you have been brought on to add new features to an existing app with a large code base that has been built over a few years and has been worked on by dozens of developers, most of whom have moved on to other projects.		Mishra, Abhishek	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_12		351--405	"""@Inbook{Mishra2017,
    author = ""Mishra, Abhishek"",
    title = ""Applying TDD and BDD Techniques"",
    bookTitle = ""iOS Code Testing: Test-Driven Development and Behavior-Driven Development with Swift"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""351--405"",
    abstract = ""If you have been for a few years, chances are that you have been brought on to add new features to an existing app with a large code base that has been built over a few years and has been worked on by dozens of developers, most of whom have moved on to other projects."",
    isbn = ""978-1-4842-2689-6"",
    doi = ""10.1007/978-1-4842-2689-6\_12"",
    url = ""https://doi.org/10.1007/978-1-4842-2689-6\_12""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Applying TDD and BDD Techniques	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_12	Apress	nan; Keywords; References
354	Behave	Applying TDD to Collection View Controllers	This chapter will examine the process of building a collection view controller-based iOS app using TDD techniques. The app will have a single view controller that presents a list of pictures and will be built using the MVVM application architecture. Figure 6-1 depicts the user interface of the finished application.	Collection View Controller; ViewModel; Path Index; Test Menu Item; Import Foundation Class	Mishra, Abhishek	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_6		161--209	"""@Inbook{Mishra2017,
    author = ""Mishra, Abhishek"",
    title = ""Applying TDD to Collection View Controllers"",
    bookTitle = ""iOS Code Testing: Test-Driven Development and Behavior-Driven Development with Swift"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""161--209"",
    abstract = ""This chapter will examine the process of building a collection view controller-based iOS app using TDD techniques. The app will have a single view controller that presents a list of pictures and will be built using the MVVM application architecture. Figure 6-1 depicts the user interface of the finished application."",
    isbn = ""978-1-4842-2689-6"",
    doi = ""10.1007/978-1-4842-2689-6\_6"",
    url = ""https://doi.org/10.1007/978-1-4842-2689-6\_6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Applying TDD to Collection View Controllers	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_6	Apress	nan; References
355	Behave	Applying TDD to the Model	This chapter will examine the process of building the model layer of an app using TDD techniques. Since this chapter focuses on the model layer, you will not be building a user interface or any presentation logic.		Mishra, Abhishek	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_4		61--99	"""@Inbook{Mishra2017,
    author = ""Mishra, Abhishek"",
    title = ""Applying TDD to the Model"",
    bookTitle = ""iOS Code Testing: Test-Driven Development and Behavior-Driven Development with Swift"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""61--99"",
    abstract = ""This chapter will examine the process of building the model layer of an app using TDD techniques. Since this chapter focuses on the model layer, you will not be building a user interface or any presentation logic."",
    isbn = ""978-1-4842-2689-6"",
    doi = ""10.1007/978-1-4842-2689-6\_4"",
    url = ""https://doi.org/10.1007/978-1-4842-2689-6\_4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Applying TDD to the Model	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_4	Apress	nan; Keywords; References
356	Behave	Applying TDD to View Controllers			Abhishek Mishra						Excluded	Excluded	new_screen			2						
357	Behave	Approaches to Business Analysis in Scrum at StepStone---Case Study	Wide adoption of Agile has significantly impacted the sphere of business analysis. Although need for business analysis is widely accepted, it is often unclear how it should be applied. Opinions about the role of a BA (Business Analyst) in Agile teams vary greatly---from negation of its existence to acceptance of a BA as a team member, working side by side with programmers. At StepStone, since our switch to Scrum in 2014, we have experimented with several models of team organization, with or without dedicated BAs. In this paper, the two most prominent cases will be presented: when the BA was a full-time member of the development team, and when the BA's role was distributed between other team members---developers and the Product Owner. Advantages, disadvantages and the transition process will be discussed. In addition, techniques will be proposed which may help in development of necessary analytical skills and transforming team organization - based on our experience.		Forowicz, Piotr	Data-Centric Business and Applications	https://doi.org/10.1007/978-3-030-34706-2_11		211--223	"""@Inbook{Forowicz2020,
    author = ""Forowicz, Piotr"",
    editor = ""Poniszewska-Mara{\'{n}}da, Aneta and Kryvinska, Natalia and Jarz{\k{a}}bek, Stanis{\l}aw and Madeyski, Lech"",
    title = ""Approaches to Business Analysis in Scrum at StepStone---Case Study"",
    bookTitle = ""Data-Centric Business and Applications: Towards Software Development (Volume 4)"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""211--223"",
    abstract = ""Wide adoption of Agile has significantly impacted the sphere of business analysis. Although need for business analysis is widely accepted, it is often unclear how it should be applied. Opinions about the role of a BA (Business Analyst) in Agile teams vary greatly---from negation of its existence to acceptance of a BA as a team member, working side by side with programmers. At StepStone, since our switch to Scrum in 2014, we have experimented with several models of team organization, with or without dedicated BAs. In this paper, the two most prominent cases will be presented: when the BA was a full-time member of the development team, and when the BA's role was distributed between other team members---developers and the Product Owner. Advantages, disadvantages and the transition process will be discussed. In addition, techniques will be proposed which may help in development of necessary analytical skills and transforming team organization - based on our experience."",
    isbn = ""978-3-030-34706-2"",
    doi = ""10.1007/978-3-030-34706-2\_11"",
    url = ""https://doi.org/10.1007/978-3-030-34706-2\_11""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Approaches to Business Analysis in Scrum at StepStone—Case Study	http://link.springer.com/chapter/10.1007/978-3-030-34706-2_11	Springer International Publishing	nan; Keywords; References
358	Behave	Augmented System Verification Using Automated Testing	A verification process is an evaluation of whether or not a product satisfies its requirements, which typically includes a visual verification activity. This is sometimes referred to as acceptance testing. Minimal or no human interaction is the construct of fully automated testing, which is often not sufficient for verification process/user acceptance testing. An approach for writing automated testing is described here, which augments the human verification process while still leveraging the benefits of test automation.	Human-systems integration; Systems engineering; Agile testing; Automated testing	Schur, Amir; Williams, Mike	International Conference on Applied Human Factors and Ergonomics	https://doi.org/10.1007/978-3-319-60366-7_7		64--70	"""@InProceedings{10.1007/978-3-319-60366-7_7,
    author = ""Schur, Amir and Williams, Mike"",
    editor = ""Nunes, Isabel L."",
    title = ""Augmented System Verification Using Automated Testing"",
    booktitle = ""Advances in Human Factors and Systems Interaction"",
    year = ""2018"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""64--70"",
    abstract = ""A verification process is an evaluation of whether or not a product satisfies its requirements, which typically includes a visual verification activity. This is sometimes referred to as acceptance testing. Minimal or no human interaction is the construct of fully automated testing, which is often not sufficient for verification process/user acceptance testing. An approach for writing automated testing is described here, which augments the human verification process while still leveraging the benefits of test automation."",
    isbn = ""978-3-319-60366-7""
}
"""	Included	Included	new_screen			2	Springer Link		Augmented System Verification Using Automated Testing	http://link.springer.com/chapter/10.1007/978-3-319-60366-7_7	Springer International Publishing	nan; References
359	Behave	AutoJet: Web Application Automation Tool	The test automation tools available in the present market is limited in various features, e.g., reporting, debugging, logging, usability, and portability, resulting in need of integration of these features to achieve automation objectives, e.g., positive ROI, stability, and efficiency. In this paper, we propose an innovative tool that proves as a panacea for many of test automation challenges discovered in worldwide surveys. In order to provide these challenging features in Web automation testing domain, an attempt has been made to create a tool called AutoJet. It is a Web automation testing tool that aims to provide a great extent of usability to both automation as well as manual testers. Using AutoJet, paradoxically a manual tester can automate test scenarios smoothly and profitably. Our study shows that it is possible for a manual tester to automate test scenarios effectively with reduced time span as it eliminates the efforts spent by the testers to understand existing test harness or to create a new one.	Page object model; Selenium WebDriver; Test automation; Web automation tool; Web automation testing	Kapoor, Sheetika; Sagar, Kalpna	Towards Extensible and Adaptable Methods in Computing	https://doi.org/10.1007/978-981-13-2348-5_3		27--42	"""@Inbook{Kapoor2018,
    author = ""Kapoor, Sheetika and Sagar, Kalpna"",
    editor = ""Chakraverty, Shampa and Goel, Anil and Misra, Sanjay"",
    title = ""AutoJet: Web Application Automation Tool"",
    bookTitle = ""Towards Extensible and Adaptable Methods in Computing"",
    year = ""2018"",
    publisher = ""Springer Singapore"",
    address = ""Singapore"",
    pages = ""27--42"",
    abstract = ""The test automation tools available in the present market is limited in various features, e.g., reporting, debugging, logging, usability, and portability, resulting in need of integration of these features to achieve automation objectives, e.g., positive ROI, stability, and efficiency. In this paper, we propose an innovative tool that proves as a panacea for many of test automation challenges discovered in worldwide surveys. In order to provide these challenging features in Web automation testing domain, an attempt has been made to create a tool called AutoJet. It is a Web automation testing tool that aims to provide a great extent of usability to both automation as well as manual testers. Using AutoJet, paradoxically a manual tester can automate test scenarios smoothly and profitably. Our study shows that it is possible for a manual tester to automate test scenarios effectively with reduced time span as it eliminates the efforts spent by the testers to understand existing test harness or to create a new one."",
    isbn = ""978-981-13-2348-5"",
    doi = ""10.1007/978-981-13-2348-5\_3"",
    url = ""https://doi.org/10.1007/978-981-13-2348-5\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		AutoJet: Web Application Automation Tool	http://link.springer.com/chapter/10.1007/978-981-13-2348-5_3	Springer Singapore	nan; References
360	Behave	Automated Acceptance Tests as Software Requirements: An Experiment to Compare the Applicability of Fit Tables and Gherkin Language	It is estimated that 85{\%} of the defects in the developed software are originated from ambiguous, incomplete and wishful thinking software requirements. Natural language is often used to write software requirements specifications as well as user requirements. However, natural language specifications can be confusing and hard to understand. Some agile methodologists consider that acceptance tests are more precise and accurate sources of information about the customer's needs than descriptions in natural language. Several studies have addressed the use of acceptance tests as software requirements specification. Therefore, none of the previous studies has performed experiments to compare the applicability of different acceptance testing techniques in order to support an organization in the selection of one technique over another. This paper addresses this problem reporting an experiment conducted with undergraduate students in Computer Science. This experiment compares the applicability of two acceptance testing techniques (Fit tables and Gherkin language) as software requirements specification. This research tries to answer three questions: (a) Which technique is the easiest to learn in order to specify acceptance test scenarios? (b) Which technique requires less effort to specify acceptance tests?	Acceptance testing; Software requirements; Fit tables; Gherkin language; FitNesse; Cucumber; TDD; ATDD; BDD	dos Santos, Ernani C{\'e}sar; Vilain, Patr{\'i}cia	International Conference on Agile Software Development	https://doi.org/10.1007/978-3-319-91602-6_7		104--119	"""@InProceedings{10.1007/978-3-319-91602-6_7,
    author = ""dos Santos, Ernani C{\'e}sar and Vilain, Patr{\'i}cia"",
    editor = ""Garbajosa, Juan and Wang, Xiaofeng and Aguiar, Ademar"",
    title = ""Automated Acceptance Tests as Software Requirements: An Experiment to Compare the Applicability of Fit Tables and Gherkin Language"",
    booktitle = ""Agile Processes in Software Engineering and Extreme Programming"",
    year = ""2018"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""104--119"",
    abstract = ""It is estimated that 85{\\%} of the defects in the developed software are originated from ambiguous, incomplete and wishful thinking software requirements. Natural language is often used to write software requirements specifications as well as user requirements. However, natural language specifications can be confusing and hard to understand. Some agile methodologists consider that acceptance tests are more precise and accurate sources of information about the customer's needs than descriptions in natural language. Several studies have addressed the use of acceptance tests as software requirements specification. Therefore, none of the previous studies has performed experiments to compare the applicability of different acceptance testing techniques in order to support an organization in the selection of one technique over another. This paper addresses this problem reporting an experiment conducted with undergraduate students in Computer Science. This experiment compares the applicability of two acceptance testing techniques (Fit tables and Gherkin language) as software requirements specification. This research tries to answer three questions: (a) Which technique is the easiest to learn in order to specify acceptance test scenarios? (b) Which technique requires less effort to specify acceptance tests? (c) Which technique is the best one to communicate software requirements? The results show that there is no sufficient evidence to affirm that one technique is easier to specify test scenarios or better to communicate software requirements. Whereas, the comparison of effort in terms of time to specify acceptance testing shows that the mean time to specify test scenarios using Gherkin language is lower than Fit tables."",
    isbn = ""978-3-319-91602-6""
}
"""	Included	Included	new_screen			2	Springer Link		Automated Acceptance Tests as Software Requirements: An Experiment to Compare the Applicability of Fit Tables and Gherkin Language	http://link.springer.com/chapter/10.1007/978-3-319-91602-6_7	Springer International Publishing	nan; References
361	Behave	Automated Integration Testing	Automated integration testing is a pig, but it's an important pig. And it's important for precisely the reasons it's so difficult.	Unit Test; Scenario Test; Integration Test; Test Code; Test Database	Matt Stephens; Doug Rosenberg	Design Driven Testing	https://doi.org/10.1007/978-1-4302-2944-5_11		253–276		Excluded	Excluded	new_screen			2	Springer Link		Automated Integration Testing	http://link.springer.com/chapter/10.1007/978-1-4302-2944-5_11	Apress	nan; References; Year; Bibtex
362	Behave	Automated Testing	###		Steve Fenton	Pro TypeScript	https://doi.org/10.1007/978-1-4302-6790-4_9		185–196		Excluded	Excluded	new_screen			2	Springer Link		Automated Testing	http://link.springer.com/chapter/10.1007/978-1-4302-6790-4_9	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
363	Behave	Automating Expert-Defined Tests: A Suitable Approach for the Medical Device Industry?			David ConnollyFergal Mc CafferyFrank Keenan						Excluded	Excluded	new_screen			2						
364	Behave	Basic Concepts	This book follows a practical approach, so most of the tools covered are introduced as we need them. However, we'll go over some core concepts separately because they're either the foundations of our evolving example or used extensively in the code examples, namely, Spring, Spring Boot, testing libraries, Lombok, and logging. These concepts deserve a separate introduction to avoid long interruptions in our learning path, which is why this chapter gives an overview of them.		Moises Macero Garcia	Learn Microservices with Spring Boot	https://doi.org/10.1007/978-1-4842-6131-6_2		9–23		Excluded	Excluded	new_screen			2	Springer Link		Basic Concepts	https://link.springer.com/chapter/10.1007/978-1-4842-6131-6_2	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
365	Behave	Behavior-Driven Development	Behavior-Driven Development (BDD) was created by Dan North. His goal was to improve communication between business and technical teams to aid in the creation of software with business value. Miscommunication between business and technical teams is often the biggest bottleneck in the delivery of software projects, and developers often misunderstand the business goals, and business teams fail to grasp the capabilities of the technical team.		Juntao Qiu	Test-Driven Development with React	https://doi.org/10.1007/978-1-4842-6972-5_10		165–177		Excluded	Excluded	new_screen			2	Springer Link		Behavior-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-6972-5_10	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
366	Behave	Behaviour-Driven Development			Prof. Dr. Stephan Kleuker						Excluded	Excluded	new_screen			2						
367	Behave	Best Practices for OutSystems Development and Its Influence on Test Automation	Low-code development platforms are designed to accelerate software development with a minimum of hand coding. They have allowed professionals with distinct backgrounds to become software developers. This brings more professionals to IT areas, reskilling some of them from different areas of knowledge but, at the same time, it has also brought to the software development area many professionals without a strong background in this area. Although testing should be performed in all applications, regardless of the programming language or the platform used, this reinforces the need for testing low-code developed applications. In this work, we study the test automation process on the OutSystems low-code development platform. The focus is on Unit, Integration/API and System/End-to-End testing levels. Examples illustrate that the implementation of best practices during the development process can have a significant influence on the test automation process. However, it is important to know whether the workload associated with the implementation of the best practices can undermine the benefits of using a low-code platform and it is important to consider that not all test automation tools have the same behavior.		Salgueiro, Joana; Ribeiro, Fernando; Metr{\^o}lho, Jos{\'e}	World Conference on Information Systems and Technologies	https://doi.org/10.1007/978-3-030-72654-6_9		85--95	"""@InProceedings{10.1007/978-3-030-72654-6_9,
    author = ""Salgueiro, Joana and Ribeiro, Fernando and Metr{\^o}lho, Jos{\'e}"",
    editor = ""Rocha, {\'A}lvaro and Adeli, Hojjat and Dzemyda, Gintautas and Moreira, Fernando and Ramalho Correia, Ana Maria"",
    title = ""Best Practices for OutSystems Development and Its Influence on Test Automation"",
    booktitle = ""Trends and Applications in Information Systems and Technologies"",
    year = ""2021"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""85--95"",
    abstract = ""Low-code development platforms are designed to accelerate software development with a minimum of hand coding. They have allowed professionals with distinct backgrounds to become software developers. This brings more professionals to IT areas, reskilling some of them from different areas of knowledge but, at the same time, it has also brought to the software development area many professionals without a strong background in this area. Although testing should be performed in all applications, regardless of the programming language or the platform used, this reinforces the need for testing low-code developed applications. In this work, we study the test automation process on the OutSystems low-code development platform. The focus is on Unit, Integration/API and System/End-to-End testing levels. Examples illustrate that the implementation of best practices during the development process can have a significant influence on the test automation process. However, it is important to know whether the workload associated with the implementation of the best practices can undermine the benefits of using a low-code platform and it is important to consider that not all test automation tools have the same behavior."",
    isbn = ""978-3-030-72654-6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Best Practices for OutSystems Development and Its Influence on Test Automation	http://link.springer.com/chapter/10.1007/978-3-030-72654-6_9	Springer International Publishing	nan; Keywords; References
368	Behave	Blockchain-Based Distributed Marketplace	Developments in Blockchain technology have enabled the creation of smart contracts; i.e., self-executing code that is stored and executed on the Blockchain. This has led to the creation of distributed, decentralised applications, along with frameworks for developing and deploying them easily. This paper describes a proof-of-concept system that implements a distributed online marketplace using the Ethereum framework, where buyers and sellers can engage in e-commerce transactions without the need of a large central entity coordinating the process. The performance of the system was measured in terms of cost of use through the concept of `gas usage'. It was determined that such costs are significantly less than that of Amazon and eBay for high volume users. The findings generally support the ability to use Ethereum to create a distributed on-chain market, however, there are still areas that require further research and development.	Blockchain; Smart contract; Ethereum; E-commerce; Distributed systems	Kabi, Oliver R.; Franqueira, Virginia N. L.	International Conference on Business Information Systems	https://doi.org/10.1007/978-3-030-04849-5_17		197--210	"""@InProceedings{10.1007/978-3-030-04849-5_17,
    author = ""Kabi, Oliver R. and Franqueira, Virginia N. L."",
    editor = ""Abramowicz, Witold and Paschke, Adrian"",
    title = ""Blockchain-Based Distributed Marketplace"",
    booktitle = ""Business Information Systems Workshops"",
    year = ""2019"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""197--210"",
    abstract = ""Developments in Blockchain technology have enabled the creation of smart contracts; i.e., self-executing code that is stored and executed on the Blockchain. This has led to the creation of distributed, decentralised applications, along with frameworks for developing and deploying them easily. This paper describes a proof-of-concept system that implements a distributed online marketplace using the Ethereum framework, where buyers and sellers can engage in e-commerce transactions without the need of a large central entity coordinating the process. The performance of the system was measured in terms of cost of use through the concept of `gas usage'. It was determined that such costs are significantly less than that of Amazon and eBay for high volume users. The findings generally support the ability to use Ethereum to create a distributed on-chain market, however, there are still areas that require further research and development."",
    isbn = ""978-3-030-04849-5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Blockchain-Based Distributed Marketplace	http://link.springer.com/chapter/10.1007/978-3-030-04849-5_17	Springer International Publishing	nan; References
369	Behave	BPMN-Based Model-Driven Testing of Service-Based Processes	Executable Business Processes realized in WS-BPEL and BPMN2 are used more and more for automating digitalized core processes in organizations. Due to their critical nature for the organization, these processes need to be developed with high quality standards. Existing literature concentrates on testing such processes, but do not offer integration into the development lifecycle and validation with other stakeholders. Our approach is based on Test Models that allow both the easier definition of automated test cases as well as discussion with non-technical stakeholders and, thus, can be used for business process validation and process modeling support. We define a meta-model for the BPMN-based Test Models that has been validated in a case study in an industrial project.	BPMN; Model-driven testing; Business process; Service composition; Process validation	"L{\""u}bke, Daniel; van Lessen, Tammo"	International Workshop on Business Process Modeling, Development and Support	https://doi.org/10.1007/978-3-319-59466-8_8		119--133	"""@InProceedings{10.1007/978-3-319-59466-8_8,
    author = {L{\""u}bke, Daniel and van Lessen, Tammo},
    editor = ""Reinhartz-Berger, Iris and Gulden, Jens and Nurcan, Selmin and Gu{\'e}dria, Wided and Bera, Palash"",
    title = ""BPMN-Based Model-Driven Testing of Service-Based Processes"",
    booktitle = ""Enterprise, Business-Process and Information Systems Modeling"",
    year = ""2017"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""119--133"",
    abstract = ""Executable Business Processes realized in WS-BPEL and BPMN2 are used more and more for automating digitalized core processes in organizations. Due to their critical nature for the organization, these processes need to be developed with high quality standards. Existing literature concentrates on testing such processes, but do not offer integration into the development lifecycle and validation with other stakeholders. Our approach is based on Test Models that allow both the easier definition of automated test cases as well as discussion with non-technical stakeholders and, thus, can be used for business process validation and process modeling support. We define a meta-model for the BPMN-based Test Models that has been validated in a case study in an industrial project."",
    isbn = ""978-3-319-59466-8""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		BPMN-Based Model-Driven Testing of Service-Based Processes	http://link.springer.com/chapter/10.1007/978-3-319-59466-8_8	Springer International Publishing	nan; References
370	Behave	Bridging Enterprise and Software Engineering Through an User-Centered Design Perspective	The development of Web-based Information Systems is crucial in the quest to maintain and develop the enterprise competiveness. However, capturing requirements from Business Processes (BP) is still an issue, as existing methods mostly focus, or on human aspects and the user interface, or on business concerns as rules and workflow coordination, and therefore do not specify all the Software Architectural components which are relevant for software development. We present the Goals Approach, which analyzes BPs and User Tasks and details them in the process of methodically designing and structuring the User Interface, the Business Logic and the Database of the Information System given a Model-View-Controller (MVC) architectural pattern. In this paper we focus on how to obtain the Goals business model of requirements based on the DEMO method. The approach can be used for in-house software development, and the method is straightforward fitting Small and Medium Enterprises agility needs.	Web-based applications; Enterprise engineering; Software engineering; User-Centered Design; Software architecture	Valente, Pedro; Silva, Thiago; Winckler, Marco; Nunes, Nuno	International Conference on Web Information Systems Engineering	https://doi.org/10.1007/978-3-319-48743-4_28		349--357	"""@InProceedings{10.1007/978-3-319-48743-4_28,
    author = ""Valente, Pedro and Silva, Thiago and Winckler, Marco and Nunes, Nuno"",
    editor = ""Cellary, Wojciech and Mokbel, Mohamed F. and Wang, Jianmin and Wang, Hua and Zhou, Rui and Zhang, Yanchun"",
    title = ""Bridging Enterprise and Software Engineering Through an User-Centered Design Perspective"",
    booktitle = ""Web Information Systems Engineering -- WISE 2016"",
    year = ""2016"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""349--357"",
    abstract = ""The development of Web-based Information Systems is crucial in the quest to maintain and develop the enterprise competiveness. However, capturing requirements from Business Processes (BP) is still an issue, as existing methods mostly focus, or on human aspects and the user interface, or on business concerns as rules and workflow coordination, and therefore do not specify all the Software Architectural components which are relevant for software development. We present the Goals Approach, which analyzes BPs and User Tasks and details them in the process of methodically designing and structuring the User Interface, the Business Logic and the Database of the Information System given a Model-View-Controller (MVC) architectural pattern. In this paper we focus on how to obtain the Goals business model of requirements based on the DEMO method. The approach can be used for in-house software development, and the method is straightforward fitting Small and Medium Enterprises agility needs."",
    isbn = ""978-3-319-48743-4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Bridging Enterprise and Software Engineering Through an User-Centered Design Perspective	http://link.springer.com/chapter/10.1007/978-3-319-48743-4_28	Springer International Publishing	nan; References
371	Behave	Building Software the Correct Way	Programmers learn very quickly that writing software is hard and error prone. Time and again software projects fail because teams are unable to cope with software complexity. As a result, the project fails to meet the deadline, costs much more than expected, and doesn't deliver the intended business value.		Gulati, Shekhar; Sharma, Rahul	Java Unit Testing with JUnit 5	https://doi.org/10.1007/978-1-4842-3015-2_1		1--23	"""@Inbook{Gulati2017,
    author = ""Gulati, Shekhar and Sharma, Rahul"",
    title = ""Building Software the Correct Way"",
    bookTitle = ""Java Unit Testing with JUnit 5: Test Driven Development with JUnit 5"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""1--23"",
    abstract = ""Programmers learn very quickly that writing software is hard and error prone. Time and again software projects fail because teams are unable to cope with software complexity. As a result, the project fails to meet the deadline, costs much more than expected, and doesn't deliver the intended business value."",
    isbn = ""978-1-4842-3015-2"",
    doi = ""10.1007/978-1-4842-3015-2\_1"",
    url = ""https://doi.org/10.1007/978-1-4842-3015-2\_1""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Building Software the Correct Way	http://link.springer.com/chapter/10.1007/978-1-4842-3015-2_1	Apress	nan; Keywords; References
372	Behave	Business Processes	"As you probably realized from the previous chapters, a test automation project can't stand on its own. Its life cycle is tightly related to the life cycle of the application that it tests. Like any software project, its existence is only relevant if someone uses it; otherwise it's worthless. In the case of test automation, the ""user"" is actually the entire development team. It may seem like the main user is the QA manager or Dev manager, but in fact, they're not using it themselves for their own good. They may require the fancy reports and tell you what they want you to do (and sometimes even how...), but as we discussed in Chapter1, one of the principle advantages of test automation is that it helps theteamdetect and fix the bugs more quickly. But for this to happen, the team needs to learn how to use it effectively, which usually requires some sort of work processes. The processes can be less strict if the team is small and everyone simply understands the value behind such processes. But whether these processes are strictly enforced by management or the team understands their value, these processes need to be followed in order to allow proper collaboration and to get the maximal value from the automation."		Arnon Axelrod	Complete Guide to Test Automation	https://doi.org/10.1007/978-1-4842-3832-5_5		83–97		Excluded	Excluded	new_screen			2	Springer Link		Business Processes	http://link.springer.com/chapter/10.1007/978-1-4842-3832-5_5	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
373	Behave	Cassandra on Docker, Apache Spark, and the Cassandra Cluster Manager			Sam R. Alapati						Excluded	Excluded	new_screen			2						
374	Behave	Challenges of CE	Despite a long pedigree and many positive reports on its use and benefits, concurrent engineering (CE) and its associated research (sub)domains still experience significant development. In this final chapter, a socio-technical framework is applied to classify and analyze challenges identified as part of the foundations, methods and applications discussed in this book. Existing properties and means of CE are abstracted. Subsequently, the main trends and developments in CE research and practice are discussed, followed by expectations for the future. Findings and trends have been identified for strategic issues visible in product requirements and product portfolios, stakeholders including companies involved, multiple functions and disciplines, current and future technologies that are expected to solve at least some of the existing problems, knowledge and skills as brought by people and teams, and structures necessary for making collaboration work, while dealing also with the still very difficult cultural differences. As the chapter shows, CE as a concept is very much alive, requiring even more advanced tools, techniques and methods to contribute to less waste in resources and efforts world-wide and improve quality.		Verhagen, Wim J. C.; Stjepandi{\'{c}}, Josip; Wognum, Nel	Concurrent Engineering in the 21st Century	https://doi.org/10.1007/978-3-319-13776-6_28		807--833	"""@Inbook{Verhagen2015,
    author = ""Verhagen, Wim J. C. and Stjepandi{\'{c}}, Josip and Wognum, Nel"",
    editor = ""Stjepandi{\'{c}}, Josip and Wognum, Nel and J.C. Verhagen, Wim"",
    title = ""Challenges of CE"",
    bookTitle = ""Concurrent Engineering in the 21st Century: Foundations, Developments and Challenges"",
    year = ""2015"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""807--833"",
    abstract = ""Despite a long pedigree and many positive reports on its use and benefits, concurrent engineering (CE) and its associated research (sub)domains still experience significant development. In this final chapter, a socio-technical framework is applied to classify and analyze challenges identified as part of the foundations, methods and applications discussed in this book. Existing properties and means of CE are abstracted. Subsequently, the main trends and developments in CE research and practice are discussed, followed by expectations for the future. Findings and trends have been identified for strategic issues visible in product requirements and product portfolios, stakeholders including companies involved, multiple functions and disciplines, current and future technologies that are expected to solve at least some of the existing problems, knowledge and skills as brought by people and teams, and structures necessary for making collaboration work, while dealing also with the still very difficult cultural differences. As the chapter shows, CE as a concept is very much alive, requiring even more advanced tools, techniques and methods to contribute to less waste in resources and efforts world-wide and improve quality."",
    isbn = ""978-3-319-13776-6"",
    doi = ""10.1007/978-3-319-13776-6\_28"",
    url = ""https://doi.org/10.1007/978-3-319-13776-6\_28""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Challenges of CE	http://link.springer.com/chapter/10.1007/978-3-319-13776-6_28	Springer International Publishing	nan; Keywords; References
375	Behave	Chapter 10 - Development			Lundahl, David						Excluded	Excluded	new_screen			2						
376	Behave	Chasing Mutants	This chapter describes mutation testing, how it has developed, the types of tools associated with it, the benefits to a quality assurance process, and the associated challenges with scaling it as a test design technique and as a consumer of resources.	Software testing; Software quality; Test automation; Mutation testing	Smith, Adam Leon	The Future of Software Quality Assurance	https://doi.org/10.1007/978-3-030-29509-7_12		147--159	"""@Inbook{Smith2020,
    author = ""Smith, Adam Leon"",
    editor = ""Goericke, Stephan"",
    title = ""Chasing Mutants"",
    bookTitle = ""The Future of Software Quality Assurance"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""147--159"",
    abstract = ""This chapter describes mutation testing, how it has developed, the types of tools associated with it, the benefits to a quality assurance process, and the associated challenges with scaling it as a test design technique and as a consumer of resources."",
    isbn = ""978-3-030-29509-7"",
    doi = ""10.1007/978-3-030-29509-7\_12"",
    url = ""https://doi.org/10.1007/978-3-030-29509-7\_12""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Chasing Mutants	http://link.springer.com/chapter/10.1007/978-3-030-29509-7_12	Springer International Publishing	nan; References
377	Behave	Clean C++20	http://link.springer.com/book/10.1007/978-1-4842-5949-8	C++; programming; clean; software; applications; C++20; source; code; development; best practices	Stephan Roth		https://link.springer.com/book/10.1007/978-1-4842-5949-8				Excluded	Excluded	new_screen			2	Springer Link		Clean C++20	https://link.springer.com/book/10.1007/978-1-4842-5949-8	Springer Link	nan; Venue; Abstract; References; Pages; Year; Bibtex; DOI
378	Behave	Cloud and Services Testing Applied in Manufacturing			F. AlvesC. CoutinhoR. Peña-OrtizX. XuA. NietoJ. AholaL. SaariA. Katasonov						Excluded	Excluded	new_screen			2						
379	Behave	Code Organization	It is not the language that makes programs appear simple. It is the programmer that makes the language appear simple!		Steve Fenton	Pro TypeScript	https://doi.org/10.1007/978-1-4842-3249-1_2		63–82		Excluded	Excluded	new_screen			2	Springer Link		Code Organization	http://link.springer.com/chapter/10.1007/978-1-4842-3249-1_2	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
380	Behave	Comparison of national clinical practice guidelines and recommendations on vaccination of adult patients with autoimmune rheumatic diseases	The aim of the study is to identify and compare national recommendations on vaccination of adult patients with autoimmune rheumatic diseases (ARDs) in Europe, North America, and Australia. We conducted a search for recommended immunizations in adult patients with ARDs in the Medline database and the Web sites of National Rheumatologic Societies, Ministries of Health, National Advisory Committees on Immunization, and other relevant National Scientific Societies. We compared national guidelines and identified points of agreement and differences. Guidelines on vaccination of adult patients with ARDs were identified in 21 countries. Points of agreement include administering influenza and pneumococcal vaccines in addition to inactivated age-appropriate or travel-related vaccines, and avoiding the use of live vaccines in immunocompromised patients with ARDs. The most important differences concern the steroid dose that induces immunosuppression, the time interval between live vaccines and the initiation of immunosuppressive treatment, herpes zoster vaccination, and the preferred pneumococcal vaccine in patients with ARDs. We observed significant differences among national recommendations on immunizations in patients with ARDs, reflecting the lack of evidence-based data.	Autoimmune rheumatic disease; Vaccination; Recommendations	Despoina Papadopoulou,; Nikolaos V. Sipsas	Rheumatology International	https://doi.org/10.1007/s00296-013-2907-9	"citation_journal_title=Rheumatology; citation_title=Vaccinations in patients with immune-mediated inflammatory diseases; citation_author=JF Rahier, M Moutschen, A Gompel; citation_volume=49; citation_issue=10; citation_publication_date=2010; citation_pages=1815-1827; citation_doi=10.1093/rheumatology/keq183; citation_id=CR1; citation_journal_title=Best Pract Res Clin Rheumatol; citation_title=Infectious diseases in systemic lupus erythematosus: risk factors, management and prophylaxis; citation_author=BJ Fessler; citation_volume=16; citation_issue=2; citation_publication_date=2002; citation_pages=281-291; citation_doi=10.1053/berh.2001.0226; citation_id=CR2; citation_journal_title=Autoimmun Rev; citation_title=DMARDS and infections in rheumatoid arthritis; citation_author=R Caporali, M Caprioli, F Bobbio-Pallavicini, C Montecucco; citation_volume=8; citation_issue=2; citation_publication_date=2008; citation_pages=139-143; citation_doi=10.1016/j.autrev.2008.05.001; citation_id=CR3; Swiss Society for Rheumatology (2010) Vaccination guidelines for patients with inflammatory rheumatic disease. Available from: 
                    http://www.rheuma-net.ch/download/Content_attachments/FileBaseDoc/recommandations-vaccination-04-2010.pdf
                    
                   (cited 2013 July 10); Goldacker S, Gause A, Warnatz K (2012). German Society for Rheumatology Pharmacotherapy Commission quality assurance for vaccination in adult patients with inflammatory rheumatic diseases. Available from: 
                    http://dgrh.de/fileadmin/media/Praxis_Klinik/Therapie-Empfehlungen/impfung_qualitaetssicherung_final_2012.pdf
                    
                   (cited 2013 July 10); Standing Committee on Vaccination (STIKO) at the Robert Koch Institute (RKI) (2012) Recommendations of the Standing Committee on Vaccination (STIKO) at the Robert Koch Institute. Epidemiol Bull 30:283-310. Available from: 
                    http://www.rki.de/DE/Content/Infekt/EpidBull/Archiv/2012/Ausgaben/30_12.pdf?_blob=publicationFile
                    
                   (cited 2013 July 10); Robert Koch Institute-German Federal Ministry of Health (2012) Vaccination recommendations by STIKO. Available from: 
                    http://www.rki.de/EN/Content/Prevention/Vaccination/recommandations/recommendations_node.html
                    
                   (cited 2013 July 10); Repo H, Peltomaa R, Finnish Rheumatology Association (2012) Vaccination of adults with inflammatory rheumatic diseases. Available from: 
                    http://www.reumatologinenyhdistys.fi/files/rokotus.pdf
                    
                   (cited 2013 July 10); Department of Public Health England (2013) Immunisation against infectious disease: the green book. Available from: 
                    http://immunisation.dh.gov.uk/gb-complete-current-edition/
                    
                   (cited 2013 July 10); Swedish Rheumatology Association (2011) SRF vaccination recommendations in patients with inflammatory rheumatic diseases. Available from: 
                    http://www.svenskreumatologi.se/sites/default/files/8/images/SRFs%20riktlinjer_vaccinationer_2011.pdf
                    
                   (cited 2013 July 10); Dougados M (2010) Recommendations of the French Society for Rheumatology to detect or prevent diseases associated with chronic inflammatory rheumatism. Available from: 
                    http://www.rhumatologie.asso.fr/data/ModuleProgramme/PageSite/2010-1/Resume/6649.asp
                    
                   (cited 2013 July 10); French Club of Rheumatism and Inflammation (2007) CRI factsheets. Available from: 
                    http://www.cri-net.com/recherche/fichesPratiques/
                    
                   (cited 2013 July 10); citation_journal_title=Joint Bone Spine; citation_title=Rituximab (MabThera) therapy and safety management. Clinical tool guide; citation_author=T Pham, B Fautrel, JE Gottenberg; citation_volume=75; citation_issue=Suppl 1; citation_publication_date=2008; citation_pages=S1-S99; citation_id=CR13; citation_journal_title=Joint Bone Spine; citation_title=Abatacept therapy and safety management; citation_author=T Pham, H Bachelez, JM Berthelot; citation_volume=79; citation_issue=Suppl 1; citation_publication_date=2012; citation_pages=3-84; citation_doi=10.1016/S1297-319X(12)70011-8; citation_id=CR14; citation_journal_title=Joint Bone Spine; citation_title=TNF alpha antagonist therapy and safety monitoring; citation_author=T Pham, H Bachelez, JM Berthelot; citation_volume=78; citation_issue=Suppl 1; citation_publication_date=2011; citation_pages=15-185; citation_doi=10.1016/S1297-319X(11)70001-X; citation_id=CR15; citation_journal_title=Joint Bone Spine; citation_title=Recommendations of the French Society for Rheumatology regarding TNFalpha antagonist therapy in patients with rheumatoid arthritis; citation_author=B Fautrel, T Pham, G Mouterde; citation_volume=74; citation_issue=6; citation_publication_date=2007; citation_pages=627-637; citation_doi=10.1016/j.jbspin.2007.10.001; citation_id=CR16; citation_journal_title=Joint Bone Spine; citation_title=Recommendations of the French Society for Rheumatology regarding TNFalpha antagonist therapy in patients with ankylosing spondylitis or psoriatic arthritis: 2007 update; citation_author=T Pham, B Fautrel, E Dernis; citation_volume=74; citation_publication_date=2007; citation_pages=638-646; citation_doi=10.1016/j.jbspin.2007.10.003; citation_id=CR17; citation_journal_title=Joint Bone Spine.; citation_title=Tocilizumab: therapy and safety management; citation_author=T Pham, P Claudepierre, A Constantin; citation_volume=77; citation_issue=Suppl 1; citation_publication_date=2010; citation_pages=S3-S100; citation_doi=10.1016/S1297-319X(10)70001-4; citation_id=CR18; citation_journal_title=Arthritis Care Res (Hoboken); citation_title=2012 update of the 2008 American College of Rheumatology recommendations for the use of disease-modifying antirheumatic drugs and biologic agents in the treatment of rheumatoid arthritis; citation_author=JA Singh, DE Furst, A Bharat; citation_volume=64; citation_issue=5; citation_publication_date=2012; citation_pages=625-639; citation_id=CR19; Public Health Agency of Canada (2012) Immunization and vaccines. Available from: 
                    http://www.phac-aspc.gc.ca/im/index-eng.php
                    
                   (cited 2013 July 10); Public Health Agency of Canada (2007) Recommended Immunizations. Immunization of immunocompromized persons. Canadian immunization guide. Part 3. Available from: 
                    http://www.phac-aspc.gc.ca/publicat/cig-gci/p03-07-eng.php
                    
                   (cited 2013 July 10); Finnish National Institute for Health and Welfare (2013) Vaccination of immunocompromized patients. Available from: 
                    http://www.thl.fi/fi_FI/web/rokottajankasikirja-fi/immuunipuutteiset
                    
                   (cited 2013 July 10); Finnish National Institute for Health and Welfare (2013) Vaccination schedule. (
                    http://www.thl.fi/fi_FI/web/fi/etusivu
                    
                   (cited 2013 July 10. Available from: 
                    http://www.ktl.fi/portal/suomi/terveyden_ammattilaisille/rokottaminen/
                    
                   (cited 2013 July 10); Austrian federal Ministry of health (2013) Austrian vaccination schedule 2013. Available from: 
                    http://bmg.gv.at/cms/home/attachments/3/3/6/CH1100/CMS1327680589121/impfplan2013.pdf
                    
                   (cited 2013 July 10); The British Society for Rheumatology (2011) BSR statement on vaccination in adult patients with rheumatic diseases. Available from: 
                    http://www.rheumatology.org.uk/includes/documents/cm_docs/2011/b/bsr_vaccination_statement_nov_2011.pdf
                    
                   (cited 2013 July 10); The British Society for Rheumatology (2002) Vaccinations in the immunocompromised person. Guidelines for the patient taking immunosuppressants, steroids and biologics therapies Available from: 
                    http://www.rheumatology.org.uk/resources/guidelines/archive_guidelines/default.aspx
                    
                   (cited 2013 July 21); Dutch Society for Rheumatology (2011) Directive on responsible use of biologics. Available from: 
                    http://www.nvr.nl/uploads/Sk/A3/SkA3YYPbz5IMt3e8kt5fFg/Richtlijn_biologicals_geautorisateerde-versie_januari-2011.pdf
                    
                   (cited 2013 July 10); citation_journal_title=Reumatol Clin; citation_title=Consensus statement of the Spanish Society of Rheumatology on risk management of biologic therapy in rheumatic patients; citation_author=J Gomez Reino, E Loza, JL Andreu; citation_volume=7; citation_issue=5; citation_publication_date=2011; citation_pages=284-298; citation_doi=10.1016/j.reuma.2011.05.002; citation_id=CR28; Spanish Ministry of Health. Social Services and Equality (2004) Vaccination in adults-recommendations. Available from: 
                    http://www.msc.es/ciudadanos/proteccionSalud/vacunaciones/docs/recoVacunasAdultos.pdf
                    
                   (cited 2013 July 10); citation_journal_title=Ces Revmatol; citation_title=Safety recommendations on biological treatment; citation_author=J Vencovsky; citation_volume=17; citation_issue=3; citation_publication_date=2009; citation_pages=146-160; citation_id=CR30; citation_journal_title=MMWR Recomm Rep; citation_title=General recommendations on immunization: recommendations of the Advisory Committee on Immunization Practices (ACIP); citation_author=; citation_volume=60; citation_issue=2; citation_publication_date=2011; citation_pages=1-64; citation_id=CR31; Centers for Disease Control and Prevention. (2013) Vaccination of persons with primary and secondary immune deficiencies. Available from: 
                    http://www.cdc.gov/vaccines/pubs/pinkbook/downloads/appendices/A/immuno-table.pdf
                    
                   (cited 2013 July 10); citation_journal_title=J Rheumatol; citation_title=Canadian Rheumatology Association recommendations for the pharmacological management of rheumatoid arthritis with traditional and biologic disease-modifying antirheumatic drugs: part II safety; citation_author=C Bombardier, GS Hazlewood, P Akhavan; citation_volume=39; citation_issue=8; citation_publication_date=2012; citation_pages=1583-1602; citation_doi=10.3899/jrheum.120165; citation_id=CR33; Australian Rheumatology Association (2011) Updated recommendations for the use of biologic agents for the treatment of rheumatic diseases. Available from: 
                    http://www.rheumatology.org.au/downloads/FINAL-BiologicalRecommendations060111_000.pdf
                    
                   (cited 2013 July 10); Italian Society for Rheumatology (2009) New influenza A (H1N1) advice of the Italian Society for Rheumatology for patients suffering from chronic inflammatory rheumatic diseases treated with immunosuppressive drugs and biological. Available from: 
                    http://www.reumatologia.it/cmsx.asp?IDPg=114#alto
                    
                   (cited 2013 July 10); Greek National Organization of Health Services (2012) New national vaccination program of children and adolescents 2011 and adult immunization program. Available from: http://www.eopyy.gov.gr/Eggrapha%20EOPUU/Nea%20-%20Anakoinoseis%20-%20Deltia%20Tupou/EThNIKO%20PROGRAMMA%20EMBOLIASMON%20PAIDION%20KAI%20ENELIKON.pdf (cited 2013 July 10); Swiss Federal Office of Public Health, Swiss Commission for Vaccinations (2013) Immunization: general recommendations. Swiss 2013 vaccinations plan. Available from: 
                    http://www.bag.admin.ch/themen/medizin/00682/00684/02535/index.html?lang=fr
                    
                   (cited 2013 July 10); Spanish National Health System Library of clinical practice guidelines (2011) Update of the clinical practice guide for the management of rheumatoid arthritis in Spain. Available from: 
                    http://www.guiasalud.es/GPC/GPC_503_Guipcar_%28diciembre-2011%29.pdf
                    
                   (cited 2013 July 10); Estonian Society for Rheumatology (2008) Rheumatoid arthritis-patient education material. (
                    http://www.ers.ee/
                    
                  ). Available from: 
                    http://www.ers.ee/index.php?id=112
                    
                   (cited 2013 July 10); Australian Government, Department of Health and Ageing (2013) Groups with special vaccination requirements. The Australian immunisation handbook, 10th edn. Chap 3.3. Available from: 
                    http://www.health.gov.au/internet/immunise/publishing.nsf/Content/handbook10-3-3
                    
                   (cited 2013 July 10); Australian Government, Department of Health and Ageing (2013) Vaccine preventable diseases. The Australian immunisation handbook, 10th edn. Part 4. Available from: 
                    http://www.health.gov.au/internet/immunise/publishing.nsf/Content/handbook10part4
                    
                   (cited 2013 July 10); Rubbert A, Burmester G, The Pharmacotherapy Commission of the German Society for Rheumatology (2007) Recommendations for the use of rituximab in patients with rheumatoid arthritis. Available from: 
                    http://dgrh.de/fileadmin/media/Praxis_Klinik/Therapie-Empfehlungen/rituximab_2013_final.pdf
                    
                   (cited 2013 July 10); citation_journal_title=Rheumatology (Oxford); citation_title=BSR and BHPR guidelines on the use of rituximab in rheumatoid arthritis; citation_author=M Bukhari, R Abernethy, C Deighton; citation_volume=50; citation_issue=12; citation_publication_date=2011; citation_pages=2311-2313; citation_doi=10.1093/rheumatology/ker106a; citation_id=CR43; Kruger K, Gaubitz M, The Pharmacotherapy Commission of the German Society of Rheumatology (2008). Recommendations for the use of abatacept in patients with rheumatoid arthritis. Available from: 
                    http://dgrh.de/fileadmin/media/Praxis___Klinik/Therapie-Empfehlungen/abatacept_final.pdf
                    
                   (cited 2013 July 10); citation_journal_title=Clin Exp Rheumatol; citation_title=Recommendations for the use of biologic therapy in rheumatoid arthritis: update from the Italian society for rheumatology II. Safety; citation_author=EG Favalli, R Caporali, L Sinigaglia; citation_volume=29; citation_issue=3 Suppl 66; citation_publication_date=2011; citation_pages=S15-S27; citation_id=CR45; citation_journal_title=Rheumatology (Oxford); citation_title=BSR and BHPR rheumatoid arthritis guidelines on safety of anti-TNF therapies; citation_author=T Ding, J Ledingham, R Luqmani; citation_volume=49; citation_issue=11; citation_publication_date=2010; citation_pages=2217-2219; citation_doi=10.1093/rheumatology/keq249a; citation_id=CR46; Dutch Society for Rheumatology. Gelre-IJssel Municipal Health Services (2008) Note on travel & vaccinations for patients on DMARDs & Biologics. Available from: 
                    http://www.nvr.nl/uploads/OK/pU/OKpULu4M6uy6R9GiuM9e4A/Notitie-reizen-en-vaccinaties.doc
                    
                   (cited 2013 July 10); Belgian Royal Society for Rheumatology (2009) The Mexican Flu. Available from: 
                    http://www.srbr.be/fr/content/la-grippe-mexicaine
                    
                   (cited 2013 July 10); Centers for Disease Control and Prevention (2013) Recommended adult immunization schedule. Available from: 
                    http://www.cdc.gov/vaccines/schedules/downloads/adult/adult-schedule.pdf
                    
                   (cited 2013 July 10); Australian Rheumatology Association (2013) Patient information. Medicine information sheets. Available from: 
                    http://www.rheumatology.org.au/community/PatientMedicineInformation.asp
                    
                   (cited 2013 July 10); Brezinschek H.P. and the Austrian Society for Rheumatology & Rehabilitation Working Group (2009) Opinion of the Austrian Society for Rheumatology on vaccination of patients with rheumatic diseases ('rheumatologic patients'). Available from: 
                    http://www.rheumatologie.at/pdf/OEGR-Stellungnahme_Impfen_16_Dez_2009.pdf
                    
                   (cited 2013 July 10); citation_journal_title=Clin Exp Rheumatol; citation_title=Recommendations for the use of biologic therapy in the treatment of psoriatic arthritis: update from the Italian Society for Rheumatology; citation_author=C Salvarani, N Pipitone, A Marchesoni; citation_volume=29; citation_issue=3 Suppl 66; citation_publication_date=2011; citation_pages=S28-S41; citation_id=CR52; Italian Ministry of Health (2012) Infectious disease and vaccination: national vaccine prevention plan. Available from: 
                    http://www.salute.gov.it/malattieInfettive/paginaInternaMalattieInfettive.jsp?menu=pianovaccini&id=651&lingua=italiano
                    
                   (cited 2013 July 10); Manger B, Michels H, Nusslein HG, et al (2006) Revision of the recommendations of the German society for rheumatology regarding therapy with tumor necrosis factor inhibitors in inflammatory rheumatic diseases. Available from: 
                    http://dgrh.de/fileadmin/media/Praxis___Klinik/Therapie-Empfehlungen/TNF-Blocker_06.pdf
                    
                   (cited 2013 July 10); French Institute of Health (2010) The immunization schedule and vaccine recommendations in the opinion of the High Council of Public Health. BEH 14-15:121-172 Available from: 
                    www.invs.sante.fr/beh/2010/14_15/beh_14_15.pdf
                    
                   (cited 2013 July 10); Statens Serum Institut- Danish Ministry of Health (2012) Free influenza vaccination. Available from: 
                    http://www.ssi.dk/English/News/EPI-NEWS/2012/No%2039a%20-%202012.aspx
                    
                   (cited 2013 Aug 29); Ireland Health Service Executive-National Immunisation Office (2013) Seasonal flu vaccine. Available from: 
                    http://www.immunisation.ie/en/AdultImmunisation/FluVaccination/
                    
                   (cited 2013 Aug 29); National Institute of Public Health- Republic of Slovenia (2013). Recommendations for vaccination of adults and children aged 5 years and older against pneumococcal infections. Available from: 
                    http://img.ivz.si/janez/2230-6991.doc
                    
                   (cited 2013 Aug 29); Statens Serum Institut- Danish Ministry of Health (2012) Pneumococcal vaccination of persons at increased risk of invasive pneumococcal disease. Available from: 
                    http://www.ssi.dk/English/News/EPI-NEWS/2012/No%2051b%20-%202012.aspx
                    
                   (cited 2013 Aug 29); Ireland Health Service Executive-National Immunisation Office (2013) Pneumococcal. Available from: 
                    http://www.immunisation.ie/en/AdultImmunisation/Pneumococal/
                    
                   (cited 2013 Aug 29); National Institute of Public Health-Republic of Slovenia (2013) Vaccination against pneumococcal infection in adults and children. Available from: 
                    http://www.ivz.si/cepljenje/strokovna_javnost/navodila_in_priporocila?pi=18&_18_view=item&_18_newsid=2230&pl=253-18.0
                    
                   (cited 2013 July 29); Czech National Institute of Health (2011) The vaccination schedule in the Czech Republic. Available from: 
                    http://www.szu.cz/tema/vakciny/ockovaci-kalendar-v-cr?highlightWords=O%C4%8Dkovac%C3%AD+kalend%C3%A1%C5%99+%C4%8CR
                    
                   (cited 2013 Aug 29); Italian Society of Hygiene (2013) Vaccination Board of the Italian Society of Hygiene indications of pneumococcal vaccine in adults at risk. Available from: 
                    http://www.igienistionline.it/docs/2012/30pneumo.pdf
                    
                   (cited 2013 July 29); Mitteilung der Standigen Impfkommission (STIKO) am Robert Koch-Institut (2012) Stellungnahme zur Impfung Erwachsener gegen Pneumokokken. Epidemiologisches Bulletin 7:55-62. Available from: 
                    http://www.rki.de/DE/Content/Infekt/EpidBull/Archiv/2012/Ausgaben/07_12.pdf?__blob=publicationFile
                    
                   (cited 2013 July 10); citation_journal_title=MMWR Morb Mortal Wkly Rep; citation_title=Use of 13-valent pneumococcal conjugate vaccine and 23-valent pneumococcal polysaccharide vaccine for adults with immunocompromising conditions: recommendations of the Advisory Committee on Immunization Practices (ACIP); citation_author=; citation_volume=59; citation_issue=34; citation_publication_date=2010; citation_pages=1102-1106; citation_id=CR65; Community of Madrid-Expert Vaccine Advisory Committee (2012) Pneumococcal vaccination for adults in the community of Madrid. Available from: 
                    http://www.madrid.org/cs/Satellite?c=PTSA_Multimedia_FA&cid=1142695928713&pagename=PortalSalud%2FPTSA_Multimedia_FA%2FPTSA_documentoWebeditpro
                    
                   (cited 2013 July 10); Belgian Superior Health Board (2013). Vaccination of children and immunocompromised adults and chronically ill. Available from: 
                    http://www.cercles.be/base_cercle/fichiers_fiches/10536.pdf
                    
                   (cited 2013 July 29); French High Council for Public Health (2013) Opinion on recommendations of vaccination for adults and children older than 2 years at risk of invasive pneumococcal disease. Available from: 
                    http://www.hcsp.fr/Explore.cgi/Telecharger?NomFichier=hcspa20130425_infectionsinvasivespneumocoque.pdf
                    
                   (cited 2013 Aug 29); citation_journal_title=Rheumatology (Oxford); citation_title=BSR/BHPR guideline for disease-modifying anti-rheumatic drug (DMARD) therapy in consultation with the British Association of Dermatologists; citation_author=K Chakravarty, H McDonald, T Pullar; citation_volume=47; citation_publication_date=2008; citation_pages=924-925; citation_doi=10.1093/rheumatology/kel216a; citation_id=CR69; citation_journal_title=Acta Reumatol Port; citation_title=Portuguese guidelines for the use of biological agents in rheumatoid arthritis--October 2011 update; citation_author=JE Fonseca, M Bernardes, H Canhao; citation_volume=36; citation_publication_date=2011; citation_pages=385-388; citation_id=CR70; citation_journal_title=Ces Revmatol; citation_title=Czech Society for Rheumatology recommendations for monitoring the safety of the treatment of rheumatoid arthritis; citation_author=L Sedova, J Stolfa, P Horak, K Pavelka; citation_volume=17; citation_issue=1; citation_publication_date=2009; citation_pages=4-15; citation_id=CR71; Harpaz R, Ortega-Sanchez IR, Seward JF, Advisory Committee on Immunization Practices (ACIP) Centers for Disease Control and Prevention (CDC) (2008) Prevention of Herpes Zoster. Recommendations of the Advisory Committee on Immunization Practices (ACIP). MMWR Recomm Rep 57(RR-5):1-30; quiz CE2-4; citation_journal_title=MMWR Recomm Rep; citation_title=Measles, mumps, and rubella vaccine use and strategies for elimination of measles, rubella, and congenital rubella syndrome and control of mumps: recommendations of the Advisory Committee on Immunization Practices (ACIP); citation_author=JC Watson, SC Hadler, CA Dykewicz, S Reef, L Phillips; citation_volume=47; citation_issue=RR-8; citation_publication_date=1998; citation_pages=1-57; citation_id=CR73; citation_journal_title=Rheumatology (Oxford); citation_title=BSR/BHPR guideline for disease-modifying anti-rheumatic drug (DMARD) therapy in consultation with the British Association of Dermatologists; citation_author=K Chakravarty, H Mcdonald, T Pullar; citation_publication_date=2008; citation_id=CR74; citation_journal_title=MMWR Recomm Rep; citation_title=Recommendations of the Advisory Committee on Immunization Practices (ACIP): use of vaccines and immune globulins in persons with altered immunocompetence; citation_author=; citation_volume=42; citation_issue=RR-4; citation_publication_date=1993; citation_pages=1-18; citation_id=CR75; Public Health Agency of Canada (2007) Passive Immunization. Canadian Immunization Guide. Part. Available from: 
                    http://www.phac-aspc.gc.ca/publicat/cig-gci/p05-01-eng.php
                    
                   (cited 2013 July 10); Australian Government, Department of Health and Ageing (2013) Passive immunisation. The Australian immunisation handbook, 10th edn. Part 5 Available from: 
                    http://www.health.gov.au/internet/immunise/publishing.nsf/Content/handbook10part5
                    
                   (cited 2013 July 10); Jong E, Freedman D (2012). Immunocompromised travelers. The yellow book. Chap 8. Centers for disease control and prevention. Available from: 
                    http://wwwnc.cdc.gov/travel/page/yellowbook-home-2012
                    
                   (cited 2013 July 10); Public Health Agency of Canada (2007) Recommended Immunizations. Immunization of travelers. Canadian Immunization Guide. Part 3. Available from: 
                    http://www.phac-aspc.gc.ca/publicat/cig-gci/p03-10-eng.php
                    
                   (cited 2013 July 10); Australian Government, Department of Health and Ageing (2013) Vaccination for international travel. The Australian immunisation handbook, 10th edn. Chap 3.2 Available from: 
                    http://www.health.gov.au/internet/immunise/publishing.nsf/Content/handbook10-3-2
                    
                   (cited 2013 July 10); citation_journal_title=Ann Rheum Dis; citation_title=EULAR recommendations for vaccination in adult patients with autoimmune inflammatory rheumatic diseases; citation_author=S Assen, N Agmon-Levin, O Elkayam; citation_volume=70; citation_issue=3; citation_publication_date=2011; citation_pages=414-422; citation_doi=10.1136/ard.2010.137216; citation_id=CR81; citation_journal_title=Autoimmun Rev; citation_title=Vaccination in adult patients with auto-immune inflammatory rheumatic diseases: a systematic literature review for the European League Against Rheumatism evidence-based recommendations for vaccination in adult patients with auto-immune inflammatory rheumatic diseases; citation_author=S Assen, O Elkayam, N Agmon-Levin; citation_volume=10; citation_issue=6; citation_publication_date=2011; citation_pages=341-352; citation_doi=10.1016/j.autrev.2010.12.003; citation_id=CR82; citation_journal_title=Am J Med; citation_title=Infection associated with asplenia: risks, mechanisms, and prevention; citation_author=B Styrt; citation_volume=88; citation_issue=5N; citation_publication_date=1990; citation_pages=33N-42N; citation_id=CR83; citation_journal_title=Clin Exp Immunol; citation_title=Antibody affinity and IgG subclass of responses to tetanus toxoid in patients with rheumatoid arthritis and systemic lupus erythematosus; citation_author=ME Devey, K Bleasdale, DA Isenberg; citation_volume=68; citation_issue=3; citation_publication_date=1987; citation_pages=562-569; citation_id=CR84; citation_journal_title=Lupus; citation_title=Safety and efficacy of hepatitis B vaccine in systemic lupus erythematosus; citation_author=KA Kuruma, EF Borba, MH Lopes, JF Carvalho, E Bonfa; citation_volume=16; citation_issue=5; citation_publication_date=2007; citation_pages=350-354; citation_doi=10.1177/0961203307078225; citation_id=CR85; citation_journal_title=Ann Rheum Dis; citation_title=Safety and efficacy of vaccination against hepatitis B in patients with rheumatoid arthritis; citation_author=O Elkayam, M Yaron, D Caspi; citation_volume=61; citation_issue=7; citation_publication_date=2002; citation_pages=623-625; citation_doi=10.1136/ard.61.7.623; citation_id=CR86; citation_journal_title=Clin Infect Dis; citation_title=Vaccination in patients with chronic rheumatic or autoimmune diseases; citation_author=T Gluck, U Muller-Ladner; citation_volume=46; citation_issue=9; citation_publication_date=2008; citation_pages=1459-1465; citation_doi=10.1086/587063; citation_id=CR87; citation_journal_title=Ann Rheum Dis; citation_title=Vaccination against influenza in patients with rheumatoid arthritis: the effect of rituximab on the humoral response; citation_author=S Oren, M Mandelboim, Y Braun-Moscovici; citation_volume=67; citation_issue=7; citation_publication_date=2007; citation_pages=937-941; citation_doi=10.1136/ard.2007.077461; citation_id=CR88; citation_journal_title=Arthritis Rheum; citation_title=Immunization responses in rheumatoid arthritis patients treated with rituximab: results from a controlled clinical trial; citation_author=CO Bingham, RJ Looney, A Deodhar; citation_volume=62; citation_issue=1; citation_publication_date=2010; citation_pages=64-74; citation_doi=10.1002/art.25034; citation_id=CR89; European Medicines Agency (2011) Assessment report: Prevenar 13. Available from: 
                    http://www.ema.europa.eu/docs/en_GB/document_library/EPAR_-_Assessment_Report_-_Variation/human/001104/WC500119784.pdf
                    
                   (cited 2013 July 29); US Department of Health and Human Services. Food and Drug Administration Vaccines and Related Biological Products Advisory Committee (VRBPAC) (2011) Adult indication briefing document: Prevnar 13. Available from: 
                    http://www.fda.gov/downloads/advisorycommittees/committeesmeetingmaterials/bloodvaccinesandotherbiologics/vaccinesandrelatedbiologicalproductsadvisorycommittee
                    
                   (cited 2013 July 29); European Medicines Agency (2011). Prevenar 13. Summary of product characteristics. Available from: 
                    http://www.ema.europa.eu/docs/en_GB/document_library/EPAR_-_Product_Information/human/001104/WC500057247.pdf
                    
                   (cited 2013 July 29)"			Excluded	Excluded	new_screen			2	Springer Link		Comparison of national clinical practice guidelines and recommendations on vaccination of adult patients with autoimmune rheumatic diseases	http://link.springer.com/article/10.1007/s00296-013-2907-9	Springer Link	nan; Pages; Year; Bibtex
381	Behave	Completeness-Driven Development	Due to the steadily increasing complexity, the design of embedded systems faces serious challenges. To meet these challenges additional abstraction levels have been added to the conventional design flow resulting in Electronic System Level (ESL) design. Besides abstraction, the focus in ESL during the development of a system moves from design to verification, i.e. checking whether or not the system works as intended becomes more and more important. However, at each abstraction level only the validity of certain properties is checked. Completeness, i.e. checking whether or not the entire behavior of the design has been verified, is usually not continuously checked. As a result, bugs may be found very late causing expensive iterations across several abstraction levels. This delays the finalization of the embedded system significantly. In this work, we present the concept of Completeness-Driven Development (CDD). Based on suitable completeness measures, CDD ensures that the next step in the design process can only be entered if completeness at the current abstraction level has been achieved. This leads to an early detection of bugs and accelerates the whole design process. The application of CDD is illustrated by means of an example.	Abstraction Level; Acceptance Test; Transaction Level Modeling; Arithmetic Logic Unit; Test Drive Development	"Drechsler, Rolf; Diepenbeck, Melanie; Gro{\ss}e, Daniel; K{\""u}hne, Ulrich; Le, Hoang M.; Seiter, Julia; Soeken, Mathias; Wille, Robert"	International Conference on Graph Transformation	https://doi.org/10.1007/978-3-642-33654-6_3		38--50	"""@InProceedings{10.1007/978-3-642-33654-6_3,
    author = {Drechsler, Rolf and Diepenbeck, Melanie and Gro{\ss}e, Daniel and K{\""u}hne, Ulrich and Le, Hoang M. and Seiter, Julia and Soeken, Mathias and Wille, Robert},
    editor = {Ehrig, Hartmut and Engels, Gregor and Kreowski, Hans-J{\""o}rg and Rozenberg, Grzegorz},
    title = ""Completeness-Driven Development"",
    booktitle = ""Graph Transformations"",
    year = ""2012"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""38--50"",
    abstract = ""Due to the steadily increasing complexity, the design of embedded systems faces serious challenges. To meet these challenges additional abstraction levels have been added to the conventional design flow resulting in Electronic System Level (ESL) design. Besides abstraction, the focus in ESL during the development of a system moves from design to verification, i.e. checking whether or not the system works as intended becomes more and more important. However, at each abstraction level only the validity of certain properties is checked. Completeness, i.e. checking whether or not the entire behavior of the design has been verified, is usually not continuously checked. As a result, bugs may be found very late causing expensive iterations across several abstraction levels. This delays the finalization of the embedded system significantly. In this work, we present the concept of Completeness-Driven Development (CDD). Based on suitable completeness measures, CDD ensures that the next step in the design process can only be entered if completeness at the current abstraction level has been achieved. This leads to an early detection of bugs and accelerates the whole design process. The application of CDD is illustrated by means of an example."",
    isbn = ""978-3-642-33654-6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Completeness-Driven Development	http://link.springer.com/chapter/10.1007/978-3-642-33654-6_3	Springer Berlin Heidelberg	nan; References
382	Behave	Component architecture of model-based testing environment	In the paper, an approach to constructing architecture of tools for model-based testing that rely on modern component-based technologies is presented. One of the basic ideas underlying this approach consists in application of noninvasive composition techniques, which make it possible to integrate a set of independently developed components into a complex system and reconfigure it without modifying codes of the components. The approach suggested in the paper is one of the first applications of the component-based technologies to designing test systems. A prototype implementation of the suggested approach based on available libraries is described, and an example of its use for test construction is presented.	Artificial Intelligence; Test Suite; Behavior Model; Finite State Machine; Situation Model; Configuration File	V. V. Kuliamin	Programming and Computer Software	https://doi.org/10.1134/S036176881005004X	"citation_title=Component Software: Beyond Object-Oriented Programming; citation_publication_date=2002; citation_id=CR1; citation_author=C. Szyperski; citation_publisher=Addison-Wesley; Heineman, G.T. and Councill, W.T., Component-Based Software Engineering: Putting the Pieces Together, Addison-Wesley, 2001.; Parnas, D., Information Distribution Aspects of Design Methodology, Proc. of 1971 IFIP Congress, North Holland, 1971.; The Economic Impacts of Inadequate Infrastructure for Software Testing, Tassey, G., Ed., NIST Report, 2002.; Hamil, P., Unit Test Frameworks. Tools for High-Quality Software Development, O'Reilly Media, 2004.; http://www.junit.org
                    
                  .; Model-Based Testing of Reactive Systems. Advanced Lectures, Broy, M., Jonsson, B., Katoen, J.-P., Leucker, M., and Pretschner, A., Eds., Lecture Notes in Computer Science, vol. 3472, Springer, 2005.; Utting, M. and Legeard, B., Practical Model-Based Testing: A Tools Approach, Morgan-Kaufmann, 2007.; citation_journal_title=IEEE Trans. Software Engineering; citation_title=Using Test Oracles Generated from Program Documentation; citation_author=D. Peters, D. Parnas; citation_volume=24; citation_issue=3; citation_publication_date=1998; citation_pages=161-173; citation_doi=10.1109/32.667877; citation_id=CR9; Hoffman, D., Analysis of a Taxonomy for Test Oracles, Quality Week, 1998.; Baresi, L. and Young, M., Test Oracles, Tech. Report CIS-TR-01-02, 
                    http://www.cs.uoregon.edu/~michal/pubs/oracles.html
                    
                  .; citation_journal_title=Sci. Comput. Programming; citation_title=Statecharts: A Visual Formalism for Complex Systems; citation_author=D. Harel; citation_volume=8; citation_issue=3; citation_publication_date=1987; citation_pages=231-274; citation_doi=10.1016/0167-6423(87)90035-9; citation_id=CR12; Drusinsky, D., Modeling and Verification Using UML Statecharts, Elsevier, 2006.; citation_journal_title=J. Theor. Comput. Sci.; citation_title=A Theory of Timed Automata; citation_author=R. Alur, D.L. Dill; citation_volume=126; citation_issue=2; citation_publication_date=1994; citation_pages=183-235; citation_doi=10.1016/0304-3975(94)90010-8; citation_id=CR14; citation_journal_title=Theor. Comput. Sci.; citation_author=J. Springintveld, F. Vaandrager, P.R. T. T. A. D'Argenio; citation_volume=254; citation_issue=1-2; citation_publication_date=2001; citation_pages=225-257; citation_doi=10.1016/S0304-3975(99)00134-6; citation_id=CR15; citation_journal_title=ACM Computing Surveys; citation_title=Software Unit Test Coverage and Adequacy; citation_author=H. Zhu, P. Hall, J. May; citation_volume=29; citation_issue=4; citation_publication_date=1997; citation_pages=366-427; citation_doi=10.1145/267580.267590; citation_id=CR16; Kuliamin, V.V., Pakulin, N.V., Petrenko, O.L., Sortov, A.A., Khoroshilov, A.V., Requirement Formalization in Practice, Preprint of Inst. of System Programming, Russ. Acad. Sci., Moscow, 2006, no. 13.; Beck, K., Kent Beck's Guide to Better Smalltalk: A Sorted Collection, Cambridge Univ. Press, 1998.; http://sunit.sourceforge.net/
                    
                  .; Beust, C. and Suleiman, H., Next Generation Java Testing: TestNG and Advanced Concepts, Addison-Wesley, 2007.; http://testng.org/
                    
                  .; http://www.dbunit.org
                    
                  .; http://www.httpunit.org
                    
                  .; http://jbehave.org/
                    
                  .; http://nspecify.sourceforge.net/
                    
                  .; http://mockito.org/
                    
                  .; http://easymock.org/
                    
                  .; Tretmans, J. and Brinksma, E., TorX: Automated Model-Based Testing, Proc. of 1st Eur. Conf. on Model-Driven Software Engineering, Nuremberg, Germany, 2003, pp. 31-43.; http://fmt.cs.utwente.nl/tools/torx/introduction.html
                    
                  .; citation_journal_title=Lecture Notes in Computer Science; citation_title=Using On-the-Fly Verification Techniques for the Generation of Test Suites; citation_author=J.-C. Fernandez, C. Jard, T. Je-ron, L. Nedelka, C. Viho; citation_volume=1102; citation_publication_date=1996; citation_pages=348-359; citation_id=CR30; http://www.inrialpes.fr/vasy/cadp/man/tgv.html
                    
                  .; Ambert, F., Bouquet, F., Chemin, S., Guenaud, S., Legeard, B., Peureux, F., Vacelet, N., and Utting, M., Z-TT: A Tool-set for Test Generation from Z and B Using Constraint Logic Programming, Proc. of Formal Approaches to Testing of Software, Brno, Czech Republic, 2002, pp. 105-119.; Hartman, A. and Nagin, K., TCBeans Software Test Toolkit, Proc. of 12-th Int. Software Quality Week, 1999.; citation_journal_title=IBM Systems J.; citation_title=Using a Model-based Test Generator to Test for Standard Conformance; citation_author=E. Farchi, A. Hartman, S.S. Pinter; citation_volume=41; citation_issue=1; citation_publication_date=2002; citation_pages=89-110; citation_doi=10.1147/sj.411.0089; citation_id=CR34; http://www.conformiq.com/qtronic.php
                    
                  .; http://www.smartesting.com/index.php/cms/en/exp-lore/products
                    
                  .; citation_journal_title=Lecture Notes in Computer Science; citation_title=UniTesK Test Suite Architecture; citation_author=I. Bourdonov, A. Kossatchev, V. Kuliamin, A. Petrenko; citation_volume=2391; citation_publication_date=2002; citation_pages=77-88; citation_doi=10.1007/3-540-45614-7_5; citation_id=CR37; Kuliamin, V.V., Petrenko, A.K., Kossatchev, A.S., and Bourdonov, I.B., The UniTesK Approach to Designing Test Suites, Programmirovanie, 2003, no. 6, pp. 25-43 [Programming Comput. Software (Engl. Transl.), 2003, vol. 29, no. 6, pp. 310-322].; http://www.unitesk.ru
                    
                  .; citation_journal_title=Lecture Notes in Computer Science; citation_title=Testing Concurrent Object-Oriented Systems with Spec Explorer; citation_author=C. Campbell, W. Grieskamp, L. Nachmanson, W. Schulte, N. Tillmann, M. Veanes; citation_volume=582; citation_publication_date=2005; citation_pages=542-547; citation_doi=10.1007/11526841_38; citation_id=CR40; http://research.microsoft.com/en-us/projects/SpecExp-lrer/
                    
                  .; http://www.cs.waikato.ac.nz/~marku/mbt/modeljunit/
                    
                  .; Jacky, J., Veanes, M., Campbell, C., and Schulte, W., Model-based Software Testing and Analysis with C#, Cambridge Univ. Press, 2007.; http://nmodel.codeplex.com/
                    
                  .; http://mbt.tigris.org/
                    
                  .; Barnett, M., Fahndrich, M., de Halleux, P., Logozzo, F., and Tillmann, N., Exploiting the Synergy between Automated-Test-Generation and Programming-by-Contract, Proc. of ICSE 2009, Vancouver, Canada, 2009.; http://research.microsoft.com/en-us/projects/contracts/
                    
                  .; Kaner, C., Bach, J., and Pettichord, B., Lessons Learned in Software Testing, Wiley, 2002.; Kuliamin, V.V., Integration of Verification Methods for Program Systems, Programmirovanie, 2009, no. 4, pp. 41-55 [Programming Comput. Software (Engl. Transl.), 2009, vol. 35, no. 4, pp. 212-222].; citation_journal_title=Lecture Notes in Computer Science; citation_title=Practical Approach to Specification and Conformance Testing of Distributed Network Application; citation_author=V. Kuliamin, A. Petrenko, N. Pakoulin; citation_volume=3694; citation_publication_date=2005; citation_pages=68-83; citation_doi=10.1007/11560333_6; citation_id=CR50; Grinevich, A., Khoroshilov, A., Kuliamin, V., Markovtsev, D., Petrenko, A., and Rubanov, V., Formal Methods in Industrial Software Standards Enforcement, Proc. of PSI'2006, Novosibirsk, Russia, 2006.; Fowler, M., Inversion of Control Containers and the Dependency Injection Pattern, 2004. 
                    http://www.mar-tinfowler.com/articles/injection.html
                    
                  .; Johnson, R., Hoeller, J., Arendsen, A., Risberg, T., and Sampaleanu, C., Professional Java Development with the Spring Framework, Wrox, 2005.; http://www.springsource.org
                    
                  ."			Excluded	Excluded	new_screen			2	Springer Link		Component architecture of model-based testing environment	http://link.springer.com/article/10.1134/S036176881005004X	Springer Link	nan; Pages; Year; Bibtex
383	Behave	Conceptual Design and Controller Testing	As you saw in Chapter 5, unit testing doesn't have to involve exhaustively covering every single line of code, or even every single method, with tests. There's a law of diminishing returns---and increasing difficulty---as you push the code coverage percentile ever higher. By taking a step back and looking at the design on a broader scale, it's possible to pick out the key areas of code that act as input/output junctures, and focus the tests on those areas.	Conceptual Design; Acceptance Criterion; Boundary Object; Unit Test; Test Scenario	Stephens, Matt; Rosenberg, Doug	Design Driven Testing	https://doi.org/10.1007/978-1-4302-2944-5_6		137--162	"""@Inbook{Stephens2010,
    author = ""Stephens, Matt and Rosenberg, Doug"",
    title = ""Conceptual Design and Controller Testing"",
    bookTitle = ""Design Driven Testing: Test Smarter, Not Harder"",
    year = ""2010"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""137--162"",
    abstract = ""As you saw in Chapter 5, unit testing doesn't have to involve exhaustively covering every single line of code, or even every single method, with tests. There's a law of diminishing returns---and increasing difficulty---as you push the code coverage percentile ever higher. By taking a step back and looking at the design on a broader scale, it's possible to pick out the key areas of code that act as input/output junctures, and focus the tests on those areas."",
    isbn = ""978-1-4302-2944-5"",
    doi = ""10.1007/978-1-4302-2944-5\_6"",
    url = ""https://doi.org/10.1007/978-1-4302-2944-5\_6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Conceptual Design and Controller Testing	http://link.springer.com/chapter/10.1007/978-1-4302-2944-5_6	Apress	nan; References
384	Behave	Contents				Procedia Computer Science					Excluded	Excluded	new_screen			2						
385	Behave	Continuous Architecting with Microservices and DevOps: A Systematic Mapping Study	Context: Several companies are migrating their information systems into the Cloud. Microservices and DevOps are two of the most common adopted technologies. However, there is still a lack of understanding how to adopt a microservice-based architectural style and which tools and technique to use in a continuous architecting pipeline.	Cloud-native; Microservice; DevOps; Migration; Orchestration	Taibi, Davide; Lenarduzzi, Valentina; Pahl, Claus	International Conference on Cloud Computing and Services Science	https://doi.org/10.1007/978-3-030-29193-8_7		126--151	"""@InProceedings{10.1007/978-3-030-29193-8_7,
    author = ""Taibi, Davide and Lenarduzzi, Valentina and Pahl, Claus"",
    editor = ""Mu{\\textasciitilde {n}}oz, V{\'i}ctor M{\'e}ndez and Ferguson, Donald and Helfert, Markus and Pahl, Claus"",
    title = ""Continuous Architecting with Microservices and DevOps: A Systematic Mapping Study"",
    booktitle = ""Cloud Computing and Services Science"",
    year = ""2019"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""126--151"",
    abstract = ""Context: Several companies are migrating their information systems into the Cloud. Microservices and DevOps are two of the most common adopted technologies. However, there is still a lack of understanding how to adopt a microservice-based architectural style and which tools and technique to use in a continuous architecting pipeline."",
    isbn = ""978-3-030-29193-8""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Continuous Architecting with Microservices and DevOps: A Systematic Mapping Study	http://link.springer.com/chapter/10.1007/978-3-030-29193-8_7	Springer International Publishing	nan; References
386	Behave	Continuous Integration	Continuous Integration (CI) is an approach to software development that requires developers to push their code into a shared repository frequently, triggering an automated test and build cycle on a dedicated build computer. Build cycles can be triggered either periodically or after each code push.	Continuous Integration (CI); Build Cycle; Push Code; Cloning Service; Developer Team	Abhishek Mishra	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_9		283–316		Excluded	Excluded	new_screen			2	Springer Link		Continuous Integration	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_9	Apress, Berkeley, CA	nan; References; Year; Bibtex
387	Behave	Controllers and Actions	Each time a request comes in to your ASP.NET MVC application, it's dealt with by a controller. The controller is the boss: it can do anything it likes to service that request. It can issue any set of commands to the underlying model tier or database, and it can choose to render any view back to the visitor. It's a .NET class into which you can add any logic needed to handle the request.	Action Method; Unit Test; Context Object; Virtual Property; Public Class	Sanderson, Steven	Pro ASP.NET MVC 2 Framework	https://doi.org/10.1007/978-1-4302-2887-5_9		283--324	"""@Inbook{Sanderson2010,
    author = ""Sanderson, Steven"",
    editor = ""Buckingham, Ewan and Andres, Clay and Anglin, Steve and Beckner, Mark and Buckingham, Ewan and Cornell, Gary and Gennick, Jonathan and Hassell, Jonathan and Lowman, Michelle and Moodie, Matthew and Parkes, Duncan and Pepper, Jeffrey and Pohlmann, Frank and Pundick, Douglas and Renow-Clarke, Ben and Shakeshaft, Dominic and Wade, Matt and Welsh, Tom and Collett, Anne and Larson, Damon"",
    title = ""Controllers and Actions"",
    bookTitle = ""Pro ASP.NET MVC 2 Framework"",
    year = ""2010"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""283--324"",
    abstract = ""Each time a request comes in to your ASP.NET MVC application, it's dealt with by a controller. The controller is the boss: it can do anything it likes to service that request. It can issue any set of commands to the underlying model tier or database, and it can choose to render any view back to the visitor. It's a .NET class into which you can add any logic needed to handle the request."",
    isbn = ""978-1-4302-2887-5"",
    doi = ""10.1007/978-1-4302-2887-5\_9"",
    url = ""https://doi.org/10.1007/978-1-4302-2887-5\_9""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Controllers and Actions	https://link.springer.com/chapter/10.1007/978-1-4302-2887-5_9	Apress	nan; References
388	Behave	Creating Automation Frameworks Using Appium	In this chapter, you will learn how to do the following	Automatic Framework; Behavior-driven Development (BDD); TestNG; Continuous Integration Tools; Maven Project	Garg, Shankar	Appium Recipes	https://doi.org/10.1007/978-1-4842-2418-2_5		101--127	"""@Inbook{Garg2016,
    author = ""Garg, Shankar"",
    title = ""Creating Automation Frameworks Using Appium"",
    bookTitle = ""Appium Recipes"",
    year = ""2016"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""101--127"",
    abstract = ""In this chapter, you will learn how to do the following"",
    isbn = ""978-1-4842-2418-2"",
    doi = ""10.1007/978-1-4842-2418-2\_5"",
    url = ""https://doi.org/10.1007/978-1-4842-2418-2\_5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Creating Automation Frameworks Using Appium	http://link.springer.com/chapter/10.1007/978-1-4842-2418-2_5	Apress	nan; References
389	Behave	Cross-species protein sequence and gene structure prediction with fine-tuned Webscipio 2.0 and Scipio	BackgroundObtaining transcripts of homologs of closely related organisms and retrieving the reconstructed exon-intron patterns of the genes is a very important process during the analysis of the evolution of a protein family and the comparative analysis of the exon-intron structure of a certain gene from different species. Due to the ever-increasing speed of genome sequencing, the gap to genome annotation is growing. Thus, tools for the correct prediction and reconstruction of genes in related organisms become more and more important. The tool Scipio, which can also be used via the graphical interface WebScipio, performs significant hit processing of the output of the Blat program to account for sequencing errors, missing sequence, and fragmented genome assemblies. However, Scipio has so far been limited to high sequence similarity and unable to reconstruct short exons.ResultsScipio and WebScipio have fundamentally been extended to better reconstruct very short exons and intron splice sites and to be better suited for cross-species gene structure predictions. The Needleman-Wunsch algorithm has been implemented for the search for short parts of the query sequence that were not recognized by Blat. Those regions might either be short exons, divergent sequence at intron splice sites, or very divergent exons. We have shown the benefit and use of new parameters with several protein examples from completely different protein families in searches against species from several kingdoms of the eukaryotes. The performance of the new Scipio version has been tested in comparison with several similar tools.ConclusionsWith the new version of Scipio very short exons, terminal and internal, of even just one amino acid can correctly be reconstructed. Scipio is also able to correctly predict almost all genes in cross-species searches even if the ancestors of the species separated more than 100 Myr ago and if the protein sequence identity is below 80%. For our test cases Scipio outperforms all other software tested. WebScipio has been restructured and provides easy access to the genome assemblies of about 640 eukaryotic species. Scipio and WebScipio are freely accessible athttp://www.webscipio.org.	Query Sequence; Scalable Vector Graphic; Myosin Heavy Chain Gene; Short Exon; Dynein Heavy Chain	Klas Hatje; Oliver Keller; Bjorn Hammesfahr; Holger Pillmann; Stephan Waack; Martin Kollmar	BMC Research Notes	https://doi.org/10.1186/1756-0500-4-265	"citation_journal_title=Nature; citation_title=A decade's perspective on DNA sequencing technology; citation_author=ER Mardis; citation_volume=470; citation_issue=7333; citation_publication_date=2011; citation_pages=198-203; citation_doi=10.1038/nature09796; citation_id=CR1; citation_journal_title=Nature; citation_title=Genome sequence of the human malaria parasite Plasmodium falciparum; citation_author=MJ Gardner, N Hall, E Fung, O White, M Berriman, RW Hyman, JM Carlton, A Pain, KE Nelson, S Bowman; citation_volume=419; citation_issue=6906; citation_publication_date=2002; citation_pages=498-511; citation_doi=10.1038/nature01097; citation_id=CR2; citation_journal_title=Science; citation_title=Phytophthora genome sequences uncover evolutionary origins and mechanisms of pathogenesis; citation_author=BM Tyler, S Tripathy, X Zhang, P Dehal, RH Jiang, A Aerts, FD Arredondo, L Baxter, D Bensasson, JL Beynon; citation_volume=313; citation_issue=5791; citation_publication_date=2006; citation_pages=1261-1266; citation_doi=10.1126/science.1128796; citation_id=CR3; citation_journal_title=Nature; citation_title=Evolution of genes and genomes on the Drosophila phylogeny; citation_author=AG Clark, MB Eisen, DR Smith, CM Bergman, B Oliver, TA Markow, TC Kaufman, M Kellis, W Gelbart, VN Iyer; citation_volume=450; citation_issue=7167; citation_publication_date=2007; citation_pages=203-218; citation_doi=10.1038/nature06341; citation_id=CR4; citation_journal_title=Nature; citation_title=Evolution of pathogenicity and sexual reproduction in eight Candida genomes; citation_author=G Butler, MD Rasmussen, MF Lin, MA Santos, S Sakthikumar, CA Munro, E Rheinbay, M Grabherr, A Forche, JL Reedy; citation_volume=459; citation_issue=7247; citation_publication_date=2009; citation_pages=657-662; citation_doi=10.1038/nature08064; citation_id=CR5; citation_journal_title=Nature; citation_title=The Trichoplax genome and the nature of placozoans; citation_author=M Srivastava, E Begovic, J Chapman, NH Putnam, U Hellsten, T Kawashima, A Kuo, T Mitros, A Salamov, ML Carpenter; citation_volume=454; citation_issue=7207; citation_publication_date=2008; citation_pages=955-960; citation_doi=10.1038/nature07191; citation_id=CR6; citation_journal_title=Science; citation_title=Genomic analysis of organismal complexity in the multicellular green alga Volvox carteri; citation_author=SE Prochnik, J Umen, AM Nedelcu, A Hallmann, SM Miller, I Nishii, P Ferris, A Kuo, T Mitros, LK Fritz-Laylin; citation_volume=329; citation_issue=5988; citation_publication_date=2010; citation_pages=223-226; citation_doi=10.1126/science.1188800; citation_id=CR7; citation_journal_title=Methods Mol Biol; citation_title=Computational methods for ab initio and comparative gene finding; citation_author=E Picardi, G Pesole; citation_volume=609; citation_publication_date=2010; citation_pages=269-284; citation_doi=10.1007/978-1-60327-241-4_16; citation_id=CR8; citation_journal_title=BMC Bioinformatics; citation_title=Using ESTs to improve the accuracy of de novo gene prediction; citation_author=C Wei, MR Brent; citation_volume=7; citation_publication_date=2006; citation_pages=327; citation_doi=10.1186/1471-2105-7-327; citation_id=CR9; citation_journal_title=Genome Biol; citation_title=AUGUSTUS at EGASP: using EST, protein and genomic alignments for improved gene prediction in the human genome; citation_author=M Stanke, A Tzvetkova, B Morgenstern; citation_volume=7; citation_issue=Suppl 1; citation_publication_date=2006; citation_pages=S11 11-18; citation_doi=10.1186/gb-2006-7-s1-s11; citation_id=CR10; citation_journal_title=Genome Biol; citation_title=Drawing the tree of eukaryotic life based on the analysis of 2,269 manually annotated myosins from 328 species; citation_author=F Odronitz, M Kollmar; citation_volume=8; citation_issue=9; citation_publication_date=2007; citation_pages=R196; citation_doi=10.1186/gb-2007-8-9-r196; citation_id=CR11; citation_journal_title=Nucleic Acids Res; citation_title=Prevalence of intron gain over intron loss in the evolution of paralogous gene families; citation_author=VN Babenko, IB Rogozin, SL Mekhedov, EV Koonin; citation_volume=32; citation_issue=12; citation_publication_date=2004; citation_pages=3724-3733; citation_doi=10.1093/nar/gkh686; citation_id=CR12; citation_journal_title=Proc Natl Acad Sci USA; citation_title=Rates of intron loss and gain: implications for early eukaryotic evolution; citation_author=SW Roy, W Gilbert; citation_volume=102; citation_issue=16; citation_publication_date=2005; citation_pages=5773-5778; citation_doi=10.1073/pnas.0500383102; citation_id=CR13; citation_journal_title=BMC Bioinformatics; citation_title=Scipio: using protein sequences to determine the precise exon/intron structures of genes and their orthologs in closely related species; citation_author=O Keller, F Odronitz, M Stanke, M Kollmar, S Waack; citation_volume=9; citation_publication_date=2008; citation_pages=278; citation_doi=10.1186/1471-2105-9-278; citation_id=CR14; citation_journal_title=BMC Genomics; citation_title=WebScipio: an online tool for the determination of gene structures using protein sequences; citation_author=F Odronitz, H Pillmann, O Keller, S Waack, M Kollmar; citation_volume=9; citation_publication_date=2008; citation_pages=422; citation_doi=10.1186/1471-2164-9-422; citation_id=CR15; citation_journal_title=Genome Res; citation_title=BLAT--the BLAST-like alignment tool; citation_author=WJ Kent; citation_volume=12; citation_issue=4; citation_publication_date=2002; citation_pages=656-664; citation_doi=10.1101/gr.229202. Article published online before March 2002; citation_id=CR16; citation_journal_title=PLoS Genet; citation_title=SPA: a probabilistic algorithm for spliced alignment; citation_author=E van Nimwegen, N Paul, R Sheridan, M Zavolan; citation_volume=2; citation_issue=4; citation_publication_date=2006; citation_pages=e24; citation_doi=10.1371/journal.pgen.0020024; citation_id=CR17; The Perl Programming Language. [
                    http://www.perl.org
                    
                  ]; Ruby Programming Language. [
                    http://www.ruby-lang.org/
                    
                  ]; Ruby on Rails. [
                    http://rubyonrails.org
                    
                  ]; Prototype JavaScript framework: Easy Ajax and DOM manipulation for dynamic web applications. [
                    http://www.prototypejs.org
                    
                  ]; script.aculo.us - web 2.0 javascript. [
                    http://script.aculo.us
                    
                  ]; citation_journal_title=BMC Genomics; citation_title=Reconstructing the phylogeny of 21 completely sequenced arthropod species based on their motor proteins; citation_author=F Odronitz, S Becker, M Kollmar; citation_volume=10; citation_publication_date=2009; citation_pages=173; citation_doi=10.1186/1471-2164-10-173; citation_id=CR23; CyMoBase. [
                    http://www.cymobase.org/
                    
                  ]; citation_journal_title=BMC Genomics; citation_title=diArk--a resource for eukaryotic genome research; citation_author=F Odronitz, M Hellkamp, M Kollmar; citation_volume=8; citation_publication_date=2007; citation_pages=103; citation_doi=10.1186/1471-2164-8-103; citation_id=CR25; W3C SVG Working Group. [
                    http://www.w3.org/Graphics/SVG/
                    
                  ]; Inkscape. Draw Freely. [
                    http://inkscape.org
                    
                  ]; citation_title=BioRuby: Bioinformatics software for the Ruby programming language; citation_inbook_title=Bioinformatics; citation_publication_date=2010; citation_id=CR28; citation_author=N Goto; citation_author=P Prins; citation_author=M Nakao; citation_author=R Bonnal; citation_author=J Aerts; citation_author=T Katayama; The Official YAML Web Site. [
                    http://www.yaml.org/
                    
                  ]; purzelrakete's workling at master - GitHub. [
                    http://github.com/purzelrakete/workling
                    
                  ]; tra's spawn at master - GitHub. [
                    http://github.com/tra/spawn
                    
                  ]; Tokyo Cabinet: a modern implementation of DBM. [
                    http://fallabs.com/tokyocabinet/
                    
                  ]; Hoptoad: The app error app. [
                    http://hoptoadapp.com
                    
                  ]; RSpec.info: Home. [
                    http://rspec.info
                    
                  ]; Selenium web application testing system. [
                    http://seleniumhq.org
                    
                  ]; citation_journal_title=Proc Natl Acad Sci USA; citation_title=Organization of the human skeletal myosin heavy chain gene cluster; citation_author=SJ Yoon, SH Seiler, R Kucherlapati, L Leinwand; citation_volume=89; citation_issue=24; citation_publication_date=1992; citation_pages=12078-12082; citation_doi=10.1073/pnas.89.24.12078; citation_id=CR36; citation_journal_title=Nucleic Acids Res; citation_title=Intron-exon structures of eukaryotic model organisms; citation_author=M Deutsch, M Long; citation_volume=27; citation_issue=15; citation_publication_date=1999; citation_pages=3219-3228; citation_doi=10.1093/nar/27.15.3219; citation_id=CR37; citation_journal_title=Mol Biol Evol; citation_title=Paleontological evidence to date the tree of life; citation_author=MJ Benton, PC Donoghue; citation_volume=24; citation_issue=1; citation_publication_date=2007; citation_pages=26-53; citation_doi=10.1093/molbev/msl150; citation_id=CR38; Sayers EW, Barrett T, Benson DA, Bolton E, Bryant SH, Canese K, Chetvernin V, Church DM, DiCuccio M, Federhen S: Database resources of the National Center for Biotechnology Information. Nucleic Acids Res. 2011, D38-51. 39 Database; citation_journal_title=BMC Bioinformatics; citation_title=Automated generation of heuristics for biological sequence comparison; citation_author=GS Slater, E Birney; citation_volume=6; citation_publication_date=2005; citation_pages=31; citation_doi=10.1186/1471-2105-6-31; citation_id=CR40; citation_journal_title=Genome Biol; citation_title=Automatic annotation of eukaryotic genes, pseudogenes and promoters; citation_author=V Solovyev, P Kosarev, I Seledsov, D Vorobyev; citation_volume=7; citation_issue=Suppl 1; citation_publication_date=2006; citation_pages=S10 11-12; citation_doi=10.1186/gb-2006-7-s1-s10; citation_id=CR41; citation_journal_title=Genome Res; citation_title=Ab initio gene finding in Drosophila genomic DNA; citation_author=AA Salamov, VV Solovyev; citation_volume=10; citation_issue=4; citation_publication_date=2000; citation_pages=516-522; citation_doi=10.1101/gr.10.4.516; citation_id=CR42; citation_journal_title=Genome Res; citation_title=GeneWise and Genomewise; citation_author=E Birney, M Clamp, R Durbin; citation_volume=14; citation_issue=5; citation_publication_date=2004; citation_pages=988-995; citation_doi=10.1101/gr.1865504; citation_id=CR43; citation_journal_title=Genome Res; citation_title=Computational inference of homologous gene structures in the human genome; citation_author=RF Yeh, LP Lim, CB Burge; citation_volume=11; citation_issue=5; citation_publication_date=2001; citation_pages=803-816; citation_doi=10.1101/gr.175701; citation_id=CR44; citation_journal_title=Bioinformatics; citation_title=Gene prediction with a hidden Markov model and a new intron submodel; citation_author=M Stanke, S Waack; citation_volume=19; citation_issue=Suppl 2; citation_publication_date=2003; citation_pages=ii215-225; citation_doi=10.1093/bioinformatics/btg1080; citation_id=CR45; citation_journal_title=J Mol Biol; citation_title=Prediction of complete gene structures in human genomic DNA; citation_author=C Burge, S Karlin; citation_volume=268; citation_issue=1; citation_publication_date=1997; citation_pages=78-94; citation_doi=10.1006/jmbi.1997.0951; citation_id=CR46; citation_journal_title=Nucleic Acids Res; citation_title=Gapped BLAST and PSI-BLAST: a new generation of protein database search programs; citation_author=SF Altschul, TL Madden, AA Schaffer, J Zhang, Z Zhang, W Miller, DJ Lipman; citation_volume=25; citation_issue=17; citation_publication_date=1997; citation_pages=3389-3402; citation_doi=10.1093/nar/25.17.3389; citation_id=CR47"			Excluded	Excluded	new_screen			2	Springer Link		Cross-species protein sequence and gene structure prediction with fine-tuned Webscipio 2.0 and Scipio	http://link.springer.com/article/10.1186/1756-0500-4-265	Springer Link	nan; Pages; Year; Bibtex
390	Behave	Data-Driven Usability Test Scenario Creation	In this paper, we present a data-driven approach to enable the creation of evidence-based usability test scenarios. By utilising product usage data to create usability test scenarios, we aim to improve the reliability of the test results and to provide better insights into product usability. The approach consists of four elements: the collection of product usage data, the transformation of these data into logs of user activities, the creation of models of user behaviour, and the guided creation of usability test scenarios based on the models. We discuss the challenges that can be encountered when applying this approach based on our experiences with two case studies in product development. We have created a prototype scenario planning tool and performed a preliminary evaluation of the tool with usability engineers working at Philips Healthcare. The evaluation shows that tool-supported evidence-based usability test creation would be valuable in their daily work.	User-centered design; Usability testing; Data-driven design; Process mining	van Eck, Maikel L.; Markslag, Else; Sidorova, Natalia; Brosens-Kessels, Angelique; van der Aalst, Wil M. P.	International Conference on Human-Centred Software Engineering	https://doi.org/10.1007/978-3-030-05909-5_6		88--108	"""@InProceedings{10.1007/978-3-030-05909-5_6,
    author = ""van Eck, Maikel L. and Markslag, Else and Sidorova, Natalia and Brosens-Kessels, Angelique and van der Aalst, Wil M. P."",
    editor = ""Bogdan, Cristian and Kuusinen, Kati and L{\'a}rusd{\'o}ttir, Marta Krist{\'i}n and Palanque, Philippe and Winckler, Marco"",
    title = ""Data-Driven Usability Test Scenario Creation"",
    booktitle = ""Human-Centered Software Engineering"",
    year = ""2019"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""88--108"",
    abstract = ""In this paper, we present a data-driven approach to enable the creation of evidence-based usability test scenarios. By utilising product usage data to create usability test scenarios, we aim to improve the reliability of the test results and to provide better insights into product usability. The approach consists of four elements: the collection of product usage data, the transformation of these data into logs of user activities, the creation of models of user behaviour, and the guided creation of usability test scenarios based on the models. We discuss the challenges that can be encountered when applying this approach based on our experiences with two case studies in product development. We have created a prototype scenario planning tool and performed a preliminary evaluation of the tool with usability engineers working at Philips Healthcare. The evaluation shows that tool-supported evidence-based usability test creation would be valuable in their daily work."",
    isbn = ""978-3-030-05909-5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Data-Driven Usability Test Scenario Creation	http://link.springer.com/chapter/10.1007/978-3-030-05909-5_6	Springer International Publishing	nan; References
391	Behave	Deployment Considerations	Application deployment is an increasingly complex and multi-faceted topic. There is no quick answer as to how to approach it, because every application is unique. However, there are a number of best practices, techniques, and tools available that you should consider integrating into your workflow and build process. While the title of this chapter isDeployment Considerations,much of what is covered is applicable at the outset of a project right through to deployment and beyond.		Andrew Grant	Beginning AngularJS	https://doi.org/10.1007/978-1-4842-0160-2_10		163–176		Excluded	Excluded	new_screen			2	Springer Link		Deployment Considerations	http://link.springer.com/chapter/10.1007/978-1-4842-0160-2_10	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
392	Behave	Description and Analysis of Design Decisions: An Ontological Approach	A success software development process requires a good design stage. During the design, a set of decisions is made in order to improve the productivity, reduce costs for reimplementation and obtain reliable systems, in special for critical domains, such as bank management systems or systems for aeronautics. Nevertheless, it is not easy to find documentation about design decisions or tools which support this process. To address this issue, this article describes a solution based on ontologies to describe design decisions. In order to identify the main elements a systematic literature review was carried out. This review also helped to identify some of the most common design decisions. These elements were used to develop the ontology which allows answering the problem raised. This ontology could be a useful tool for architects and designers during the design stage of a system.	Ontology; Design decision; Software	Cruz Segura, Yordani; Silega Mart{\'i}nez, Nemury; Parra Fern{\'a}ndez, Ail{\'i}a; G{\'o}mez Baryolo, Oiner	International Conference on Technologies and Innovation	https://doi.org/10.1007/978-3-030-00940-3_13		174--185	"""@InProceedings{10.1007/978-3-030-00940-3_13,
    author = ""Cruz Segura, Yordani and Silega Mart{\'i}nez, Nemury and Parra Fern{\'a}ndez, Ail{\'i}a and G{\'o}mez Baryolo, Oiner"",
    editor = ""Valencia-Garc{\'i}a, Rafael and Alcaraz-M{\'a}rmol, Gema and Del Cioppo-Morstadt, Javier and Vera-Lucio, N{\'e}stor and Bucaram-Leverone, Martha"",
    title = ""Description and Analysis of Design Decisions: An Ontological Approach"",
    booktitle = ""Technologies and Innovation"",
    year = ""2018"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""174--185"",
    abstract = ""A success software development process requires a good design stage. During the design, a set of decisions is made in order to improve the productivity, reduce costs for reimplementation and obtain reliable systems, in special for critical domains, such as bank management systems or systems for aeronautics. Nevertheless, it is not easy to find documentation about design decisions or tools which support this process. To address this issue, this article describes a solution based on ontologies to describe design decisions. In order to identify the main elements a systematic literature review was carried out. This review also helped to identify some of the most common design decisions. These elements were used to develop the ontology which allows answering the problem raised. This ontology could be a useful tool for architects and designers during the design stage of a system."",
    isbn = ""978-3-030-00940-3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Description and Analysis of Design Decisions: An Ontological Approach	http://link.springer.com/chapter/10.1007/978-3-030-00940-3_13	Springer International Publishing	nan; References
393	Behave	Design	After going through the DXP requirements in Chapter2, we will now look into designing and building a Digital Experience Platform in detail. As the world moves toward a modern digital economy, the use of DXP is meant to provide an ecosystem for product and service innovations, in addition to providing a space for the organization's activities.		Shailesh Kumar Shivakumar; Sourabhh Sethii	Building Digital Experience Platforms	https://doi.org/10.1007/978-1-4842-4303-9_3		61–115		Excluded	Excluded	new_screen			2	Springer Link		Design	http://link.springer.com/chapter/10.1007/978-1-4842-4303-9_3	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
394	Behave	Design for the Decentralized World: Democratization of Blockchain-Based Software Design			Vladislav GladyshevQiong Wu						Excluded	Excluded	new_screen			2						
395	Behave	Develop	We all come up with lots of ideas every day despite varying levels of intelligence, experience, and exposure. Some people believe we might generate tens of thousands of ideas on a daily basis. While most ideas are fun to think about (imagine if we could move things by mere thoughts or if champagne flowed in municipal taps, just like water!), they are usually too impractical, obscure, wild, or outrageous to follow up on. Only a small percentage of ideas are actually worth pursuing.		Tathagat Varma	Agile Product Development	https://doi.org/10.1007/978-1-4842-1067-3_6		127–167		Excluded	Excluded	new_screen			2	Springer Link		Develop	https://link.springer.com/chapter/10.1007/978-1-4842-1067-3_6	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
396	Behave	Developing a Spiral Curriculum for Teaching Agile at the National Software Academy	The National Software Academy (NSA) was established at Cardiff University in October 2016 as a centre of excellence for Applied Software Engineering. We work in partnership with Welsh Government and industry leaders to address the national shortage of software engineering graduates with the skills, knowledge, and hands-on experience required to be immediately effective as commercial software engineers. We run an innovative, industry-focused B.Sc. which uses agile methods to facilitate our project-based learning (PjBL) approach. The projects are provided by our network of industrial partners and are used across multiple modules as a basis for assessment across the disciplines. Although the degree course has yet to produce any graduates, a significant proportion already hold conditional job offers. A conversion M.Sc. in Applied Software Engineering for STEM graduates has also been developed, and will benefit from lessons learned as we continue to inspect and adapt the undergraduate degree programme. This chapter outlines how a spiral curriculum has been developed for teaching agile that progressively introduces complexity whilst building on previous learning.	Spiral learning; Agile project management; Project-based learning; Industrial collaboration; Applied software engineering	Osborne, James; Ivins, Wendy; Jones, Carl	Agile and Lean Concepts for Teaching and Learning	https://doi.org/10.1007/978-981-13-2751-3_15		303--323	"""@Inbook{Osborne2019,
    author = ""Osborne, James and Ivins, Wendy and Jones, Carl"",
    editor = ""Parsons, David and MacCallum, Kathryn"",
    title = ""Developing a Spiral Curriculum for Teaching Agile at the National Software Academy"",
    bookTitle = ""Agile and Lean Concepts for Teaching and Learning: Bringing Methodologies from Industry to the Classroom"",
    year = ""2019"",
    publisher = ""Springer Singapore"",
    address = ""Singapore"",
    pages = ""303--323"",
    abstract = ""The National Software Academy (NSA) was established at Cardiff University in October 2016 as a centre of excellence for Applied Software Engineering. We work in partnership with Welsh Government and industry leaders to address the national shortage of software engineering graduates with the skills, knowledge, and hands-on experience required to be immediately effective as commercial software engineers. We run an innovative, industry-focused B.Sc. which uses agile methods to facilitate our project-based learning (PjBL) approach. The projects are provided by our network of industrial partners and are used across multiple modules as a basis for assessment across the disciplines. Although the degree course has yet to produce any graduates, a significant proportion already hold conditional job offers. A conversion M.Sc. in Applied Software Engineering for STEM graduates has also been developed, and will benefit from lessons learned as we continue to inspect and adapt the undergraduate degree programme. This chapter outlines how a spiral curriculum has been developed for teaching agile that progressively introduces complexity whilst building on previous learning."",
    isbn = ""978-981-13-2751-3"",
    doi = ""10.1007/978-981-13-2751-3\_15"",
    url = ""https://doi.org/10.1007/978-981-13-2751-3\_15""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Developing a Spiral Curriculum for Teaching Agile at the National Software Academy	https://link.springer.com/chapter/10.1007/978-981-13-2751-3_15	Springer Singapore	nan; References
397	Behave	Directed Multi-target Search Based Unit Tests Generation	Software testing costs are reduced by employing test automation. One of the automation activities is tests generation. The goal of tests generation is to generate tests with large code coverage with the efficient faults detection ability. Search-based tests generation methods are analysed and their experimental comparison is provided in this paper.	Unit tests generation; Unit testing; Search based software testing	Rud{\v{z}}ionien{\.{e}}, Greta; Packevi{\v{c}}ius, {\v{S}}ar{\={u}}nas; Barei{\v{s}}a, Eduardas	International Conference on Information and Software Technologies	https://doi.org/10.1007/978-3-030-30275-7_8		90--109	"""@InProceedings{10.1007/978-3-030-30275-7_8,
    author = ""Rud{\v{z}}ionien{\.{e}}, Greta and Packevi{\v{c}}ius, {\v{S}}ar{\={u}}nas and Barei{\v{s}}a, Eduardas"",
    editor = ""Dama{\v{s}}evi{\v{c}}ius, Robertas and Vasiljevien{\.{e}}, Giedr{\.{e}}"",
    title = ""Directed Multi-target Search Based Unit Tests Generation"",
    booktitle = ""Information and Software Technologies"",
    year = ""2019"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""90--109"",
    abstract = ""Software testing costs are reduced by employing test automation. One of the automation activities is tests generation. The goal of tests generation is to generate tests with large code coverage with the efficient faults detection ability. Search-based tests generation methods are analysed and their experimental comparison is provided in this paper."",
    isbn = ""978-3-030-30275-7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Directed Multi-target Search Based Unit Tests Generation	http://link.springer.com/chapter/10.1007/978-3-030-30275-7_8	Springer International Publishing	nan; References
398	Behave	Documentation, Error Handling, Debugging, and Testing	In this chapter, we're going to look at the finer details of developing reliable programs: documentation, error handling, debugging, and testing. These tasks aren't what most people think of as ``development,'' but are as important to the overall process as general coding tasks. Without documenting, debugging, and testing your code, it's unlikely that anyone but you could work on the code with much success, and you run the risk of releasing faulty scripts and applications.		DiLeo, Carleton; Cooper, Peter	Beginning Ruby 3	https://doi.org/10.1007/978-1-4842-6324-2_8		215--246	"""@Inbook{DiLeo2021,
    author = ""DiLeo, Carleton and Cooper, Peter"",
    title = ""Documentation, Error Handling, Debugging, and Testing"",
    bookTitle = ""Beginning Ruby 3: From Beginner to Pro"",
    year = ""2021"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""215--246"",
    abstract = ""In this chapter, we're going to look at the finer details of developing reliable programs: documentation, error handling, debugging, and testing. These tasks aren't what most people think of as ``development,'' but are as important to the overall process as general coding tasks. Without documenting, debugging, and testing your code, it's unlikely that anyone but you could work on the code with much success, and you run the risk of releasing faulty scripts and applications."",
    isbn = ""978-1-4842-6324-2"",
    doi = ""10.1007/978-1-4842-6324-2\_8"",
    url = ""https://doi.org/10.1007/978-1-4842-6324-2\_8""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Documentation, Error Handling, Debugging, and Testing	http://link.springer.com/chapter/10.1007/978-1-4842-6324-2_8	Apress	nan; Keywords; References
399	Behave	Documenting, Testing, and Verifying	At this point you know many of the features and intricacies of the Haskell language and many of its libraries. This chapter won't teach you any more about the language but rather will focus on some tools that help you in the process of coding libraries and applications. These tools support good engineering practices within Haskell.		Serrano Mena, Alejandro	Practical Haskell	https://doi.org/10.1007/978-1-4842-4480-7_15		525--546	"""@Inbook{SerranoMena2019,
    author = ""Serrano Mena, Alejandro"",
    title = ""Documenting, Testing, and Verifying"",
    bookTitle = ""Practical Haskell: A Real World Guide to Programming"",
    year = ""2019"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""525--546"",
    abstract = ""At this point you know many of the features and intricacies of the Haskell language and many of its libraries. This chapter won't teach you any more about the language but rather will focus on some tools that help you in the process of coding libraries and applications. These tools support good engineering practices within Haskell."",
    isbn = ""978-1-4842-4480-7"",
    doi = ""10.1007/978-1-4842-4480-7\_15"",
    url = ""https://doi.org/10.1007/978-1-4842-4480-7\_15""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Documenting, Testing, and Verifying	http://link.springer.com/chapter/10.1007/978-1-4842-4480-7_15	Apress	nan; Keywords; References
400	Behave	Domain Modeling Based on Requirements Specification and Ontology	Domain model plays an important role in software development. Typically, it is a primary input to elaboration of a system model which in turn is translated into source code and related database schemas. Effective development of domain model is a part of requirement engineering during which domain experts are employed to identify domain entities and relationships among them. We claim that this task can be supported by the use of domain ontologies from which interesting knowledge can be extracted. The starting point to knowledge extraction is an existing requirements specification. In this paper, we investigate how the form of requirements specification influences the quality of extracted model. Some measures allowing to assess the quality are introduced. A case study has shown that in the most cases the simplified version of a requirements specification is enough to obtain a satisfactory domain model, however if the domain is very complex, the extended version of requirements specification could be necessary.	Ontology; Requirements specification; Domain modeling; Knowledge extraction	Dubielewicz, Iwona; Hnatkowska, Bogumi{\l}a; Huzar, Zbigniew; Tuzinkiewicz, Lech	Software Engineering: Challenges and Solutions	https://doi.org/10.1007/978-3-319-43606-7_3		31--45	"""@InProceedings{10.1007/978-3-319-43606-7_3,
    author = ""Dubielewicz, Iwona and Hnatkowska, Bogumi{\l}a and Huzar, Zbigniew and Tuzinkiewicz, Lech"",
    editor = ""Madeyski, Lech and {\'{S}}mia{\l}ek, Micha{\l} and Hnatkowska, Bogumi{\l}a and Huzar, Zbigniev"",
    title = ""Domain Modeling Based on Requirements Specification and Ontology"",
    booktitle = ""Software Engineering: Challenges and Solutions"",
    year = ""2017"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""31--45"",
    abstract = ""Domain model plays an important role in software development. Typically, it is a primary input to elaboration of a system model which in turn is translated into source code and related database schemas. Effective development of domain model is a part of requirement engineering during which domain experts are employed to identify domain entities and relationships among them. We claim that this task can be supported by the use of domain ontologies from which interesting knowledge can be extracted. The starting point to knowledge extraction is an existing requirements specification. In this paper, we investigate how the form of requirements specification influences the quality of extracted model. Some measures allowing to assess the quality are introduced. A case study has shown that in the most cases the simplified version of a requirements specification is enough to obtain a satisfactory domain model, however if the domain is very complex, the extended version of requirements specification could be necessary."",
    isbn = ""978-3-319-43606-7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Domain Modeling Based on Requirements Specification and Ontology	http://link.springer.com/chapter/10.1007/978-3-319-43606-7_3	Springer International Publishing	nan; References
401	Behave	Domain V: Adaptive Planning			Sumanta Boral						Excluded	Excluded	new_screen			2						
402	Behave	Domain VI: Problem Detection and Resolution	Agile teams are self-organized. At the beginning of every iteration, they collectively commit to deliver a certain scope within the timebox based on their capacity. However, even with the best of intentions, surprises do crop up in projects. A characteristics of self-organization involves dealing with problems, identifying them proactively, and responding appropriately by taking either preventive or corrective actions. In the two main sections of this chapter we look at two dimensions of problems -- first, which are uncertain and called risks. The other one is about the methods that Agile teams use to assure quality of their incremental deliverables.	Exploratory Testing; User Story; Continuous Integration; Pair Programming; Product Owner	Boral, Sumanta	Ace the PMI-ACP(r) exam	https://doi.org/10.1007/978-1-4842-2526-4_7		263--300	"""@Inbook{Boral2016,
    author = ""Boral, Sumanta"",
    title = ""Domain VI: Problem Detection and Resolution"",
    bookTitle = ""Ace the PMI-ACP(r) exam: A Quick Reference Guide for the Busy Professional"",
    year = ""2016"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""263--300"",
    abstract = ""Agile teams are self-organized. At the beginning of every iteration, they collectively commit to deliver a certain scope within the timebox based on their capacity. However, even with the best of intentions, surprises do crop up in projects. A characteristics of self-organization involves dealing with problems, identifying them proactively, and responding appropriately by taking either preventive or corrective actions. In the two main sections of this chapter we look at two dimensions of problems -- first, which are uncertain and called risks. The other one is about the methods that Agile teams use to assure quality of their incremental deliverables."",
    isbn = ""978-1-4842-2526-4"",
    doi = ""10.1007/978-1-4842-2526-4\_7"",
    url = ""https://doi.org/10.1007/978-1-4842-2526-4\_7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Domain VI: Problem Detection and Resolution	http://link.springer.com/chapter/10.1007/978-1-4842-2526-4_7	Apress	nan; References
403	Behave	Editorial to the theme section on model-based testing			Mike PapadakisShaukat AliGilles Perrouin						Excluded	Excluded	new_screen			2						
404	Behave	Effective Testing	Automated testing, and unit testing in particular, is now universally regarded as a best practice for software development. A number of testing frameworks are available. There remains plenty of room to debate the merits of unit testing versus integration testing; whether to mock objects with frameworks like Mockito or to take a more classic approach with basic stubs; when to apply test-driven development (TDD); whether behavior-driven development (BDD) will become commonplace; and so on.	Functional Test; Test User; Unit Test; Test Class; Integration Test	Paul Fisher; Brian D. Murphy	Spring Persistence with Hibernate	https://doi.org/10.1007/978-1-4842-0268-5_7		127–139		Excluded	Excluded	new_screen			2	Springer Link		Effective Testing	https://link.springer.com/chapter/10.1007/978-1-4842-0268-5_7	Apress, Berkeley, CA	nan; References; Year; Bibtex
405	Behave	Efficient and Flexible Test Automation in Production Systems Engineering			Dietmar WinklerKristof MeixnerPetr Novak	Keyword -- Behavior Driven Test					Included	Included	new_screen			2						
406	Behave	Engineering Multi-agent Systems with Statecharts	The purpose of this paper is to map the works in the Agent Oriented Software Engineering and Engineering Multi-agent Systems fields that use the statecharts paradigm to aid the software development process. We did not only focus on finding out the methods that employ statecharts, but also on identifying the application domains suitable for this kind of modeling. To achieve this goal we researched the available literature. We found out that statecharts are used by numerous methods that target diverse application domains such as robotics, internet agents, simulation, health and safety. Moreover, statecharts have been employed for modeling different things, such as the behaviour of agents, agent plans, agent interaction protocols. We also found reports of real-world systems and applications that were developed using these methods in the last 20 years and we identified trends and common characteristics that they have. Concluding, we have mapped the area where statecharts meet agent-oriented methodologies both in theory and practice. Moreover, we provide some exciting directions for future works.	Artificial Intelligence; Statecharts; Finite state machines; Agent-Oriented Software Engineering; Engineering Multi-agent Systems; Applications	Nikolaos I. Spanoudakis	SN Computer Science	https://doi.org/10.1007/s42979-021-00706-5	"citation_journal_title=Int J Autom Control.; citation_title=Self-adaptive large-scale SCADA system based on self-organised multi-agent systems; citation_author=HA Abbas, SI Shaheen, MH Amin; citation_volume=10; citation_issue=3; citation_publication_date=2016; citation_pages=234-66; citation_doi=10.1504/IJAAC.2016.077588; citation_id=CR1; Arai T, Stolzenburg F. Multiagent systems specification by UML statecharts aiming at intelligent manufacturing. In: Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS 2002): Part 1, pp. 11-8, 2002. 
                  https://doi.org/10.1145/544741.544745
                  
                .; citation_journal_title=IEEE Robot Autom Mag.; citation_title=Armar-6: a high-performance humanoid for human-robot collaboration in real-world scenarios; citation_author=T Asfour, M Waechter, L Kaul, S Rader, P Weiner, S Ottenhaus, R Grimm, Y Zhou, M Grotz, F Paus; citation_volume=26; citation_issue=4; citation_publication_date=2019; citation_pages=108-21; citation_doi=10.1109/MRA.2019.2941246; citation_id=CR3; citation_title=How to do things with words; citation_publication_date=1975; citation_id=CR4; citation_author=JL Austin; citation_publisher=Harvard University Press; citation_title=Developing multi-agent systems with JADE; citation_publication_date=2007; citation_id=CR5; citation_author=FL Bellifemine; citation_author=G Caire; citation_author=D Greenwood; citation_publisher=Wiley Series in Agent Technology Wiley; Bordini RH, Braubach L, Dastani M, Seghrouchni AEF, Gomez-Sanz JJ, Leite J, O'Hare G, Pokahr A, Ricci A. A survey of programming languages and platforms for multi-agent systems. Informatica. 2006;30(1).; citation_journal_title=J ACM (JACM).; citation_title=On communicating finite-state machines; citation_author=D Brand, P Zafiropulo; citation_volume=30; citation_issue=2; citation_publication_date=1983; citation_pages=323-42; citation_doi=10.1145/322374.322380; citation_id=CR7; citation_title=Extending the capability concept for flexible BDI agent modularization; citation_inbook_title=Programming multi-agent systems; citation_publication_date=2006; citation_pages=139-55; citation_id=CR8; citation_author=L Braubach; citation_author=A Pokahr; citation_author=W Lamersdorf; citation_publisher=Springer; citation_journal_title=Auton Agent Multi-Agent Syst.; citation_title=Tropos: an agent-oriented software development methodology; citation_author=P Bresciani, A Perini, P Giorgini, F Giunchiglia, J Mylopoulos; citation_volume=8; citation_issue=3; citation_publication_date=2004; citation_pages=203-36; citation_doi=10.1023/B:AGNT.0000018806.20944.ef; citation_id=CR9; Broad A, Argall B. Path planning under interface-based constraints for assistive robotics. In: Proceedings of the 26th International Conference on Automated Planning and Scheduling, ICAPS'16, p. 450-8. AAAI Press; 2016.; Crane ML, Dingel J. UML vs. classical vs. rhapsody statecharts: not all models are created equal. In: Briand L, Williams C, editors. Model driven engineering languages and systems. Berlin: Springer; 2005. p. 97-112.; citation_journal_title=Knowl Eng Rev.; citation_title=Programming multi-agent systems; citation_author=M Dastani; citation_volume=30; citation_issue=4; citation_publication_date=2015; citation_pages=394-418; citation_doi=10.1017/S0269888915000077; citation_id=CR12; Dastani M, van BirnaRiemsdijk M, Meyer JJC. Programming multi-agent systems in 3APL. In: Multi-agent programming. Springer: Berlin; 2005. p. 39-67.; DeLoach SA. Developing a multiagent conference management system using the O-MaSE process framework. In: Luck M, Padgham L (eds.) Agent-Oriented Software Engineering VIII: 8th International Workshop, AOSE 2007, Honolulu, HI, USA, May 14, 2007, Revised Selected Papers, pp. 168-181. Berlin: Springer; 2008. 
                  https://doi.org/10.1007/978-3-540-79488-2_13
                  
                .; citation_journal_title=Int J Agent-Oriented Softw Eng.; citation_title=O-MaSE: a customisable approach to designing and building complex, adaptive multi-agent systems; citation_author=SA DeLoach, JC Garcia-Ojeda; citation_volume=4; citation_issue=3; citation_publication_date=2010; citation_pages=244-80; citation_doi=10.1504/IJAOSE.2010.036984; citation_id=CR15; citation_journal_title=Int J Softw Eng Knowl Eng.; citation_title=Multiagent systems engineering; citation_author=SA DeLoach, MF Wood, CH Sparkman; citation_volume=11; citation_issue=03; citation_publication_date=2001; citation_pages=231-58; citation_doi=10.1142/S0218194001000542; citation_id=CR16; citation_journal_title=Electron Commer Res Appl.; citation_title=A formal approach to negotiating agents development; citation_author=M Dumas, G Governatori, AH Hofstede, P Oaks; citation_volume=1; citation_issue=2; citation_publication_date=2002; citation_pages=193-207; citation_doi=10.1016/S1567-4223(02)00016-9; citation_id=CR17; citation_journal_title=Electron Notes Theor Comput Sci.; citation_title=Propositional statecharts for agent interaction protocols; citation_author=H Dunn-Davies, R Cunningham, S Paurobally; citation_volume=134; citation_publication_date=2005; citation_pages=55-75; citation_doi=10.1016/j.entcs.2005.02.020; citation_id=CR18; citation_title=Automata, languages, and machines; citation_publication_date=1974; citation_id=CR19; citation_author=S Eilenberg; citation_publisher=Academic Press; citation_journal_title=Technol Econ Smart Grids Sustain Energy.; citation_title=Secure automated home energy management in multi-agent smart grid architecture; citation_author=H Elshaafi, M Vinyals, I Grimaldi, S Davy; citation_volume=3; citation_issue=1; citation_publication_date=2018; citation_pages=4; citation_doi=10.1007/s40866-018-0042-0; citation_id=CR20; citation_title=Mapping BPMN to Agents: An Analysis; citation_inbook_title=Agent, Web Services, and Ontologies Integrated Methodologies; citation_publication_date=2007; citation_pages=43-58; citation_id=CR21; citation_author=Holger Endert; citation_author=Tobias Kuster; citation_author=Benjamin Hirsch; citation_author=Sahin Albayrak; Fleischmann A. Limitations of choreography specifications with BPMN. In: International Conference on Subject-Oriented Business Process Management, pp. 203-16. Springer; 2020.; citation_journal_title=Int J Agent-Oriented Softw Eng.; citation_title=Using event-driven lightweight DSC-based agents for mas modelling; citation_author=G Fortino, A Garro, S Mascillaro, W Russo; citation_volume=4; citation_issue=2; citation_publication_date=2010; citation_pages=113-40; citation_doi=10.1504/IJAOSE.2010.032798; citation_id=CR23; citation_title=Statecharts-based JADE agents and tools for engineering multi-agent systems; citation_inbook_title=Knowledge-based and intelligent information and engineering systems; citation_publication_date=2010; citation_pages=240-50; citation_id=CR24; citation_author=G Fortino; citation_author=F Rango; citation_author=W Russo; citation_publisher=Springer; citation_journal_title=Eng Appl Artif Intell.; citation_title=Translation of statechart agents into a BDI framework for MAS engineering; citation_author=G Fortino, F Rango, W Russo, C Santoro; citation_volume=41; citation_publication_date=2015; citation_pages=287-97; citation_doi=10.1016/j.engappai.2015.01.012; citation_id=CR25; citation_journal_title=Inf Softw Technol.; citation_title=A statecharts-based software development process for mobile agents; citation_author=G Fortino, W Russo, E Zimeo; citation_volume=46; citation_issue=13; citation_publication_date=2004; citation_pages=907-21; citation_doi=10.1016/j.infsof.2004.04.005; citation_id=CR26; citation_title=Modeling an educational multi-agent system in MaSE; citation_inbook_title=Active Media Technol; citation_publication_date=2009; citation_pages=335-46; citation_id=CR27; citation_author=ISB Gago; citation_author=VMB Werneck; citation_author=RM Costa; citation_publisher=Springer; citation_journal_title=Analele Universitatii din Timisoara Seria Matematica-Informatica.; citation_title=JADE-based multi-agent E-commerce environment: initial implementation; citation_author=M Ganzha, M Paprzycki, A Pirvanescu, C Badica, A Abraham; citation_volume=42; citation_publication_date=2005; citation_pages=79-100; citation_id=CR28; Giese H, Burmester S, Klein F, Schilling D, Tichy M. Multi-agent system design for safety-critical self-optimizing mechatronic systems with uml. In: OOPSLA 2003--Second International Workshop on Agent-Oriented Methodologies, pp. 21-32. 2003.; citation_journal_title=IEEE Trans Comput Aided Des Integr Circuits Syst.; citation_title=Hierarchical finite state machines with multiple concurrency models; citation_author=A Girault, B Lee, EA Lee; citation_volume=18; citation_issue=6; citation_publication_date=1999; citation_pages=742-60; citation_doi=10.1109/43.766725; citation_id=CR30; Goldsby HJ, Cheng BH, McKinley PK, Knoester DB, Ofria CA. Digital evolution of behavioral models for autonomic systems. In: Proceedings of the 5th IEEE International Conference on Autonomic Computing (ICAC 2008), pp. 87-96. Los Alamitos: IEEE Computer Society; 2008.; citation_journal_title=Softw Syst Model.; citation_title=Mixed-semantics composition of statecharts for the component-based design of reactive systems; citation_author=B Graics, V Molnar, A Voros, I Majzik, D Varro; citation_volume=19; citation_issue=6; citation_publication_date=2020; citation_pages=1483-517; citation_doi=10.1007/s10270-020-00806-5; citation_id=CR32; citation_journal_title=Auton Agent Multi-Agent Syst.; citation_title=A platform-independent metamodel for multiagent systems; citation_author=C Hahn, C Madrigal-Mora, K Fischer; citation_volume=18; citation_issue=2; citation_publication_date=2009; citation_pages=239-66; citation_doi=10.1007/s10458-008-9042-0; citation_id=CR33; citation_journal_title=Sci Comput Progr.; citation_title=Statecharts: a visual formalism for complex systems; citation_author=D Harel; citation_volume=8; citation_issue=3; citation_publication_date=1987; citation_pages=231-74; citation_doi=10.1016/0167-6423(87)90035-9; citation_id=CR34; Harel D, Kugler H. The rhapsody semantics of statecharts (or, on the executable core of the uml). In: Ehrig H, Damm W, Desel J, Grosse-Rhode M, Reif W, Schnieder E, Westkamper E (eds) Integration of Software Specification Techniques for Applications in Engineering: Priority Program SoftSpez of the German Research Foundation (DFG), Final Report, pp. 325-54. Berlin: Springer; 2004. 
                  https://doi.org/10.1007/978-3-540-27863-4_19
                  
                .; citation_journal_title=ACM Trans Softw Eng Methodol (TOSEM).; citation_title=The statemate semantics of statecharts; citation_author=D Harel, A Naamad; citation_volume=5; citation_issue=4; citation_publication_date=1996; citation_pages=293-333; citation_doi=10.1145/235321.235322; citation_id=CR36; citation_journal_title=Artif Intell.; citation_title=A blackboard architecture for control; citation_author=B Hayes-Roth; citation_volume=26; citation_issue=3; citation_publication_date=1985; citation_pages=251-321; citation_doi=10.1016/0004-3702(85)90063-3; citation_id=CR37; citation_title=Agent-oriented methodologies; citation_publication_date=2005; citation_id=CR38; citation_publisher=Idea Group Publishing; Hippolyte JL, Howell S, Yuce B, Mourshed M, Sleiman HA, Vinyals M, Vanhee L. Ontology-based demand-side flexibility management in smart grids using a multi-agent system. In: 2016 IEEE International Smart Cities Conference (ISC2), pp. 1-7. IEEE; 2016.; citation_journal_title=IEEE Int Comput.; citation_title=Agent UML notation for multiagent system design; citation_author=MP Huget; citation_volume=8; citation_issue=4; citation_publication_date=2004; citation_pages=63-71; citation_doi=10.1109/MIC.2004.6; citation_id=CR40; Huget MP, Odell J. Representing agent interaction protocols with agent UML. In: International Workshop on Agent-Oriented Software Engineering, pp. 16-30. Springer; 2004.; citation_journal_title=Auton Agent Multi-Agent Syst.; citation_title=An integrated trust and reputation model for open multi-agent systems; citation_author=TD Huynh, NR Jennings, NR Shadbolt; citation_volume=13; citation_issue=2; citation_publication_date=2006; citation_pages=119-54; citation_doi=10.1007/s10458-005-6825-4; citation_id=CR42; citation_journal_title=Commun ACM.; citation_title=Human-agent collectives; citation_author=NR Jennings, L Moreau, D Nicholson, S Ramchurn, S Roberts, T Rodden, A Rogers; citation_volume=57; citation_issue=12; citation_publication_date=2014; citation_pages=80-8; citation_doi=10.1145/2629559; citation_id=CR43; citation_journal_title=Comput Lang Syst Struct.; citation_title=Special issue on model-driven engineering of multi-agent systems in theory and practice; citation_author=G Kardas, JJ Gomez-Sanz; citation_volume=50; citation_publication_date=2017; citation_pages=140-1; citation_doi=10.1016/j.cl.2017.07.002; citation_id=CR44; citation_title=Model-based design of computer-controlled game character behavior; citation_inbook_title=Model driven engineering languages and systems; citation_publication_date=2007; citation_pages=650-65; citation_id=CR45; citation_author=J Kienzle; citation_author=A Denault; citation_author=H Vangheluwe; citation_publisher=Springer; Kir H, Erdogan N. A knowledge-intensive adaptive business process management framework. Inf Syst. 2021;95. 
                  https://doi.org/10.1016/jis2020101639
                  
                .; citation_title=MDA explained: the model driven architecture: practice and promise; citation_publication_date=2003; citation_id=CR47; citation_author=AG Kleppe; citation_author=J Warmer; citation_author=W Bast; citation_publisher=Addison-Wesley; citation_title=State-based modeling method for multiagent conversation protocols and decision activities; citation_inbook_title=Agent technologies, infrastructures, tools, and applications for E-services; citation_publication_date=2003; citation_pages=151-66; citation_id=CR48; citation_author=R Konig; citation_publisher=Springer; citation_title=Developing multiagent systems with agenttool; citation_inbook_title=Intelligent agents VII agent theories architectures and languages; citation_publication_date=2001; citation_pages=46-60; citation_id=CR49; citation_author=SAD Loach; citation_author=M Wood; citation_publisher=Springer; Marron A, Hacohen Y, Harel D, Mulder A, Terfloth A. Embedding scenario-based modeling in statecharts. In: MODELS workshops, pp. 443-52. 2018.; Marron A, Limonad L, Pollack S, Harel D. Expecting the unexpected: developing autonomous-system design principles for reacting to unpredicted events and conditions. 2020.; Mazouzi H, Seghrouchni AEF, Haddad S. Open protocol design for complex interactions in multi-agent systems. In: Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS 2002): Part 2, AAMAS '02, pp. 517-26. New York: Association for Computing Machinery; 2002. 
                  https://doi.org/10.1145/544862.544866
                  
                .; McBurney P, Parsons S. Dialogue games for agent argumentation. In: Simari G, Rahwan I, editors. Argumentation in artificial intelligence. Boston: Springer; 2009. p. 261-80. 
                  https://doi.org/10.1007/978-0-387-98197-0_13
                  
                .; citation_journal_title=Softw Syst Model.; citation_title=A method for testing and validating executable statechart models; citation_author=T Mens, A Decan, NI Spanoudakis; citation_volume=18; citation_issue=2; citation_publication_date=2019; citation_pages=837-63; citation_doi=10.1007/s10270-018-0676-3; citation_id=CR54; citation_title=On conversation policies and the need for exceptions; citation_inbook_title=Issues in agent communication; citation_publication_date=2000; citation_pages=144-59; citation_id=CR55; citation_author=SA Moore; citation_publisher=Springer; Moraitis P, Petraki E, Spanoudakis NI. Engineering JADE agents with the Gaia Methodology. In: Carbonell JG, Siekmann J, Kowalczyk R, Muller JP, Tianfield H, Unland R, editors. Agent technologies, infrastructures, tools, and applications for E-services, lecture notes in computer science, vol. 2592. Berlin: Springer; 2003. p. 77-91. 
                  https://doi.org/10.1007/3-540-36559-1
                  
                .; citation_title=Providing advanced, personalised infomobility services using agent technology; citation_inbook_title=Applications and innovations in intelligent systems XI; citation_publication_date=2004; citation_pages=35-48; citation_id=CR57; citation_author=P Moraitis; citation_author=E Petraki; citation_author=NI Spanoudakis; citation_publisher=Springer; citation_journal_title=Appl Artif Intell.; citation_title=The GAIA2JADE process for multi-agent systems development; citation_author=P Moraitis, N Spanoudakis; citation_volume=20; citation_issue=2-4; citation_publication_date=2006; citation_pages=251-73; citation_doi=10.1080/08839510500484249; citation_id=CR58; citation_title=An overview of distributed artificial intelligence; citation_inbook_title=Foundations of distributed artificial intelligence; citation_publication_date=1996; citation_id=CR59; citation_author=B Moulin; citation_author=B Chaib-Draa; citation_publisher=Wiley; citation_title=Specifying agent behaviors with UML statecharts and statedit; citation_inbook_title=RoboCup 2003: Robot Soccer World Cup VII; citation_publication_date=2004; citation_pages=145-56; citation_id=CR60; citation_author=J Murray; citation_publisher=Springer; citation_title=Robolog koblenz 2000; citation_inbook_title=RoboCup 2000: Robot Soccer World Cup IV; citation_publication_date=2001; citation_pages=469-72; citation_id=CR61; citation_author=J Murray; citation_author=O Obst; citation_author=F Stolzenburg; citation_publisher=Springer; citation_journal_title=Int J Comput Integr Manuf.; citation_title=A hybrid simulation-based assessment framework of smart manufacturing systems; citation_author=K Nagadi, L Rabelo, M Basingab, AT Sarmiento, A Jones, A Rahal; citation_volume=31; citation_issue=2; citation_publication_date=2018; citation_pages=115-28; citation_doi=10.1080/0951192X.2017.1407449; citation_id=CR62; Nickel U, Niere J, Zundorf A. The FUJABA environment. In: Proceedings of the 22nd International Conference on Software Engineering, ICSE '00, pp. 742-5. Association for Computing Machinery; 2000. 
                  https://doi.org/10.1145/337180.337620
                  
                .; citation_journal_title=J Artif Intell Res.; citation_title=Teleo-reactive programs for agent control; citation_author=N Nilsson; citation_volume=1; citation_publication_date=1994; citation_pages=139-58; citation_doi=10.1613/jair.30; citation_id=CR64; citation_journal_title=Appl Artif Intell.; citation_title=Zeus: a toolkit for building distributed multiagent systems; citation_author=HS Nwana, DT Ndumu, LC Lee, JC Collis; citation_volume=13; citation_issue=1-2; citation_publication_date=1999; citation_pages=129-85; citation_doi=10.1080/088395199117513; citation_id=CR65; Obst O. Specifying rational agents with statecharts and utility functions. In: Birk A, Coradeschi S, Tadokoro S, editors. RoboCup 2001: Robot Soccer World Cup V. Berlin: Springer; 2002. p. 173-82.; Ozik J, Collier N, Combs T, Macal CM, Northe M. Repast simphony statecharts. J Artif Soc Soc Simul. 2015;18(3):11. 
                  https://doi.org/10.18564/jasss.2840
                  
                .; citation_title=Extending the kouretes statechart editor for generic agent behavior development; citation_inbook_title=Artificial intelligence applications and innovations; citation_publication_date=2014; citation_pages=182-92; citation_id=CR68; citation_author=GL Papadimitriou; citation_author=NI Spanoudakis; citation_author=MG Lagoudakis; citation_publisher=Springer; Paraschos A, Spanoudakis NI, Lagoudakis MG. Model-driven behavior specification for robotic teams. In: Proceedings of the 11th International Conference on Autonomous Agents and Multiagent Systems--Volume 1, pp. 171-8. International Foundation for Autonomous Agents and Multiagent Systems; 2012.; citation_title=Developing agent interaction protocols using graphical and logical methodologies; citation_inbook_title=Programming multi-agent systems; citation_publication_date=2004; citation_pages=149-68; citation_id=CR70; citation_author=S Paurobally; citation_author=J Cunningham; citation_author=NR Jennings; citation_publisher=Springer; Rao AS, Georgeff MP. Modeling rational agents within a BDI-architecture. KR. 1991, pp. 473-84.; citation_journal_title=IEEE Trans Software Eng.; citation_title=Explaining software developer acceptance of methodologies: a comparison of five theoretical models; citation_author=CK Riemenschneider, BC Hardgrave, FD Davis; citation_volume=28; citation_issue=12; citation_publication_date=2002; citation_pages=1135-45; citation_doi=10.1109/TSE.2002.1158287; citation_id=CR72; citation_title=Artificial intelligence: a modern approach; citation_publication_date=2010; citation_id=CR73; citation_author=S Russell; citation_author=P Norvig; citation_publisher=Prentice Hall; citation_journal_title=J Logic Comput.; citation_title=Engineering executable agents using multi-context systems; citation_author=J Sabater, C Sierra, S Parsons, NR Jennings; citation_volume=12; citation_issue=3; citation_publication_date=2002; citation_pages=413-42; citation_doi=10.1093/logcom/12.3.413; citation_id=CR74; Sakellariou I. Agent based modelling and simulation using state machines. In: Second International Conference on Simulation and Modeling Methodologies, Technologies and Applications (SIMULTECH 2012), pp. 270-9; 2012.; citation_journal_title=J Syst Softw.; citation_title=Embedding statecharts into teleo-reactive programs to model interactions between agents; citation_author=P Sanchez, B Alvarez, R Martinez, A Iborra; citation_volume=131; citation_publication_date=2017; citation_pages=78-97; citation_doi=10.1016/j.jss.2017.05.081; citation_id=CR76; citation_journal_title=IEEE Softw.; citation_title=The pragmatics of model-driven development; citation_author=B Selic; citation_volume=20; citation_issue=5; citation_publication_date=2003; citation_pages=19-25; citation_doi=10.1109/MS.2003.1231146; citation_id=CR77; citation_title=Modeling and testing agent systems based on statecharts; citation_inbook_title=Applying formal methods: testing, performance, and M/E-commerce; citation_publication_date=2004; citation_pages=308-21; citation_id=CR78; citation_author=HS Seo; citation_author=T Araragi; citation_author=YR Kwon; citation_publisher=Springer; Sethuraman A, Yalla KK, Sarin A, Gorthi RP. Agents assisted software project management. In: Proceedings of the 1st Bangalore Annual Compute Conference, COMPUTE '08. New York: Association for Computing Machinery; 2008. 
                  https://doi.org/10.1145/1341771.1341777
                  
                .; citation_journal_title=J Med Syst.; citation_title=Implementing an integrative multi-agent clinical decision support system with open source software; citation_author=JS Shirabad, S Wilk, W Michalowski, K Farion; citation_volume=36; citation_issue=1; citation_publication_date=2012; citation_pages=123-37; citation_doi=10.1007/s10916-010-9452-9; citation_id=CR80; citation_journal_title=Artif Life.; citation_title=Netlogo, a multi-agent simulation environment; citation_author=E Sklar; citation_volume=13; citation_issue=3; citation_publication_date=2007; citation_pages=303-11; citation_doi=10.1162/artl.2007.13.3.303; citation_id=CR81; Smarsly K, Hartmann D. Agent-oriented development of hybrid wind turbine monitoring systems. In: Proceedings of ISCCBE International Conference on Computing in Civil and Building Engineering and the EG-ICE Workshop on Intelligent Computing in Engineering; 2010.; Smarsly K, Law KH. Advanced structural health monitoring based on multi-agent technology. Computation for Humanity: Information Technology to Advance Society. 2012.; Spanoudakis N, Akasiadis C, Kechagias G, Chalkiadakis G. An Open MAS Services Architecture for the V2G/G2V Problem. In: Proceedings of the 18th International Conference on Autonomous Agents and MultiAgent Systems, pp. 2198-200. 2019.; Spanoudakis N, Moraitis P. An agent modeling language implementing protocols through capabilities. In: Proceedings of the 2008 IEEE/WIC/ACM International Conference on Web Intelligence and Intelligent Agent Technology-Volume 02, pp. 578-82. IEEE Computer Society; 2008.; citation_journal_title=Eng Intell Syst.; citation_title=Engineering an agent-based system for product pricing automation; citation_author=N Spanoudakis, P Moraitis; citation_volume=17; citation_issue=2; citation_publication_date=2009; citation_pages=139; citation_id=CR86; citation_title=Gaia agents implementation through models transformation; citation_inbook_title=Principles of practice in multi-agent systems; citation_publication_date=2009; citation_pages=127-42; citation_id=CR87; citation_author=N Spanoudakis; citation_author=P Moraitis; citation_publisher=Springer; citation_journal_title=IEEE Intell Syst.; citation_title=Engineering ambient intelligence systems using agent technology; citation_author=N Spanoudakis, P Moraitis; citation_volume=30; citation_issue=3; citation_publication_date=2015; citation_pages=60-7; citation_doi=10.1109/MIS.2015.3; citation_id=CR88; Spanoudakis NI. Statecharts and AOSE: the past and the future. In: Multi-Agent Systems--17th European Conference, EUMAS 2020. Springer; 2020.; citation_journal_title=Int J Agent-Oriented Softw Eng.; citation_title=Validating mas analysis models with the ASEME methodology; citation_author=NI Spanoudakis, E Floros, N Mitakidis, P Delias; citation_volume=6; citation_issue=2; citation_publication_date=2018; citation_pages=211-40; citation_doi=10.1504/IJAOSE.2018.094380; citation_id=CR90; Spanoudakis NI, Moraitis P. The ASEME methodology. Int J Agent-Oriented Softw Eng (in press); citation_journal_title=Sci Comput Progr.; citation_title=Structure and behavior preserving statecharts refinements; citation_author=E Syriani, V Sousa, L Lucio; citation_volume=170; citation_publication_date=2019; citation_pages=45-79; citation_doi=10.1016/j.scico.2018.10.005; citation_id=CR92; citation_journal_title=IEEE Softw.; citation_title=Microservices; citation_author=J Thones; citation_volume=32; citation_publication_date=2015; citation_pages=1; citation_doi=10.1109/MS.2015.11; citation_id=CR93; citation_title=A case tool for robot behavior development; citation_inbook_title=RoboCup 2012: Robot Soccer World Cup XVI; citation_publication_date=2013; citation_pages=225-36; citation_id=CR94; citation_author=A Topalidou-Kyniazopoulou; citation_author=NI Spanoudakis; citation_author=MG Lagoudakis; citation_publisher=Springer; citation_journal_title=ACM Comput Surv.; citation_title=Cooperative multi-agent planning: a survey; citation_author=A Torreno, E Onaindia, A Komenda, M Stolba; citation_volume=50; citation_issue=6; citation_publication_date=2017; citation_pages=1-32; citation_doi=10.1145/3128584; citation_id=CR95; citation_journal_title=Knowl Inf Syst.; citation_title=Privacy-concerned multiagent planning; citation_author=J Tozicka, J Jakubuv, A Komenda, M Pechoucek; citation_volume=48; citation_issue=3; citation_publication_date=2016; citation_pages=581-618; citation_doi=10.1007/s10115-015-0887-7; citation_id=CR96; citation_journal_title=Sensors.; citation_title=5g support for industrial iot applications-challenges, solutions, and research gaps; citation_author=P Varga, J Peto, A Franko, D Balla, D Haja, F Janky, G Soos, D Ficzere, M Maliosz, L Toka; citation_volume=20; citation_issue=3; citation_publication_date=2020; citation_pages=828; citation_doi=10.3390/s20030828; citation_id=CR97; citation_journal_title=Front Robot AI.; citation_title=The armarx statechart concept: graphical programing of robot behavior; citation_author=M Wachter, S Ottenhaus, M Krohnert, N Vahrenkamp, T Asfour; citation_volume=3; citation_publication_date=2016; citation_pages=33; citation_doi=10.3389/frobt.2016.00033; citation_id=CR98; citation_journal_title=Comput Lang Syst Struct.; citation_title=User-story driven development of multi-agent systems: a process fragment for agile methods; citation_author=Y Wautelet, S Heng, S Kiv, M Kolp; citation_volume=50; citation_publication_date=2017; citation_pages=159-76; citation_doi=10.1016/j.cl.2017.06.007; citation_id=CR99; Wilk S, Michalowski W, O'Sullivan D, Farion K, Matwin S. Engineering of a clinical decision support framework for the point of care use. In: AMIA Annual Symposium Proceedings, vol. 2008, p. 814. American Medical Informatics Association; 2008.; citation_journal_title=Auton Agent Multi-Agent Syst.; citation_title=The gaia methodology for agent-oriented analysis and design; citation_author=M Wooldridge, NR Jennings, D Kinny; citation_volume=3; citation_issue=3; citation_publication_date=2000; citation_pages=285-312; citation_doi=10.1023/A:1010071910869; citation_id=CR101; citation_title=An introduction to multiagent systems; citation_publication_date=2009; citation_id=CR102; citation_author=MJ Wooldridge; citation_publisher=Wiley; citation_title=The cucumber book: behaviour-driven development for testers and developers; citation_publication_date=2012; citation_id=CR103; citation_author=M Wynne; citation_author=A Hellesoy; citation_publisher=Pragmatic Bookshelf; Yu Y, Lapouchnian A, Liaskos S, Mylopoulos J, Leite JCSP. From goals to high-variability software design. In: Foundations of intelligent systems. Berlin: Springer; 2008. p. 1-16.; citation_journal_title=ACM Trans Softw Eng Methodol.; citation_title=Developing multiagent systems: the Gaia methodology; citation_author=F Zambonelli, NR Jennings, M Wooldridge; citation_volume=12; citation_issue=3; citation_publication_date=2003; citation_pages=317-70; citation_doi=10.1145/958961.958963; citation_id=CR105; citation_journal_title=J Intell Robot Syst.; citation_title=Communication within multi-FSM based robotic systems; citation_author=C Zielinski, M Figat, R Hexel; citation_volume=93; citation_issue=3; citation_publication_date=2019; citation_pages=787-805; citation_doi=10.1007/s10846-018-0869-6; citation_id=CR106"			Excluded	Excluded	new_screen			2	Springer Link		Engineering Multi-agent Systems with Statecharts	http://link.springer.com/article/10.1007/s42979-021-00706-5	Springer Link	nan; Pages; Year; Bibtex
407	Behave	Enterprise Information Systems			Prof. Dr. Joaquim FilipeMichał ŚmiałekAlexander BrodskySlimane Hammoudi						Excluded	Excluded	new_screen			2						
408	Behave	Espresso	Android apps fail for a number of reasons other than simple logic errors. At its most basic, the app may not install correctly, or there may be a problem when you move from landscape to portrait and back again. Because of fragmentation, the layout might not work on any number of devices that you haven't had the time to test it on, or it could hang if the network is down.		Godfrey Nolan	Agile Android	https://doi.org/10.1007/978-1-4842-9701-8_5		59–68		Excluded	Excluded	new_screen			2	Springer Link		Espresso	http://link.springer.com/chapter/10.1007/978-1-4842-9701-8_5	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
409	Behave	Every Product Owner Needs Four Things	I sincerely believe there are better Product Owners and not-so-good Product Owners. There are some organizations (teams, companies, enterprises) which offer a better environment for product ownership, and equally there are those which are downright hostile to product ownership.		Kelly, Allan	The Art of Agile Product Ownership	https://doi.org/10.1007/978-1-4842-5168-3_5		39--43	"""@Inbook{Kelly2019,
    author = ""Kelly, Allan"",
    title = ""Every Product Owner Needs Four Things"",
    bookTitle = ""The Art of Agile Product Ownership: A Guide for Product Managers, Business Analysts, and Entrepreneurs"",
    year = ""2019"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""39--43"",
    abstract = ""I sincerely believe there are better Product Owners and not-so-good Product Owners. There are some organizations (teams, companies, enterprises) which offer a better environment for product ownership, and equally there are those which are downright hostile to product ownership."",
    isbn = ""978-1-4842-5168-3"",
    doi = ""10.1007/978-1-4842-5168-3\_5"",
    url = ""https://doi.org/10.1007/978-1-4842-5168-3\_5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Every Product Owner Needs Four Things	http://link.springer.com/chapter/10.1007/978-1-4842-5168-3_5	Apress	nan; Keywords; References
410	Behave	Example-driven modeling: on effects of using examples on structural model comprehension, what makes them useful, and how to create them	We present a controlled experiment for the empirical evaluation of example-driven modeling (EDM), an approach that systematically uses examples for model comprehension and domain knowledge transfer. We conducted the experiment with 26 graduate (Masters and Ph.D. level) and undergraduate (Bachelor level) students from electrical and computer engineering, computer science, and software engineering programs at the University of Waterloo. The experiment involves a domain model, with UML class diagrams representing the domain abstractions and UML object diagrams representing examples of using these abstractions. The goal is to provide empirical evidence of the effects of suitable examples on model comprehension, compared to having model abstractions only, by having the participants perform model comprehension tasks. Our results show that EDM is superior to having model abstractions only, with an improvement of 39% for diagram completeness, 33% for questions completeness, 71% for efficiency, and a reduction in the number of mistakes by 80%. We provide qualitative results showing that participants receiving model abstractions augmented with examples experienced lower perceived difficulty in performing the comprehension tasks, higher perceived confidence in their tasks' solutions, and asked 90% fewer clarifying domain questions. We also present participants' feedback regarding the usefulness of the provided examples, their number and types, as well as the use of partial examples. We present a taxonomy of the different types of examples, explain their significance, and propose guidelines for manual and automatic creation of useful examples.	Artificial Intelligence; Software engineering; Structural modeling; Empirical study; Example-driven modeling	Dina Zayan; Atrisha Sarkar; Michal Antkiewicz; Rita Suzana Pitangueira Maciel; Krzysztof Czarnecki	Software & Systems Modeling	https://doi.org/10.1007/s10270-017-0652-3	"citation_journal_title=Stat. Sci.; citation_title=A survey of exact inference for contingency tables; citation_author=A Agresti; citation_volume=7; citation_publication_date=1992; citation_pages=131-153; citation_doi=10.1214/ss/1177011454; citation_id=CR1; citation_journal_title=Softw. Test. Verif. Reliab.; citation_title=Test adequacy criteria for UML design models; citation_author=A Andrews, R France, S Ghosh, G Craig; citation_volume=13; citation_issue=2; citation_publication_date=2003; citation_pages=95-127; citation_doi=10.1002/stvr.270; citation_id=CR2; Antkiewicz, M., Bak, K., Zayan, D., Czarnecki, K., Wasowski, A., Diskin, Z.: Example-driven modeling using Clafer. In: First International Workshop on Model-driven Engineering By Example (2013); Bak, K., Czarnecki, K., Wasowski, A.: Feature and meta-models in Clafer: mixed, specialized and coupled. In: International Conference on Software Language Engineering, pp. 291-301 (2010); Bak, K., Diskin, Z., Antkiewicz, M., Czarnecki, K., Wasowski, A.: Partial instances via subclassing. In: 6th International Conference on Software Language Engineering (2013); Bak, K., Zayan, D., Czarnecki, K., Antkiewicz, M., Diskin, Z., Wasowski, A., Rayside, D.: Example-driven modeling. Model = Abstractions + Examples. In: New Ideas and Emerging Results (NIER) track of ICSE'13 (2013); Balogh, A., Varro, D.: Advanced model transformation language constructs in the VIATRA2 framework. In: Proceedings of the 2006 ACM Symposium on Applied Computing, pp. 1280-1287. ACM (2006); Batot, E.: Generating examples for knowledge abstraction in MDE: a multi-objective framework. In: SRC@ MoDELS, pp. 1-6 (2015); Bauer, J., Baader, F.: Model exploration to support understanding of ontologies. Ph.D. thesis, Master's thesis, Technische Universitat Dresden (2009); Brosch, P., Langer, P., Seidl, M., Wieland, K., Wimmer, M., Kappel, G., Retschitzegger, W., Schwinger, W.: An example is worth a thousand words: composite operation modeling by-example. In: Model Driven Engineering Languages and Systems, Volume 5795 of Lecture Notes in Computer Science, pp. 271-285 (2009); citation_journal_title=Commun. ACM; citation_title=Why did your project fail?; citation_author=N Cerpa, JM Verner; citation_volume=52; citation_issue=12; citation_publication_date=2009; citation_pages=130-134; citation_doi=10.1145/1610252.1610286; citation_id=CR11; citation_journal_title=Cogn. Sci.; citation_title=Categorization and representation of physics problems by experts and novices; citation_author=MT Chi, PJ Feltovich, R Glaser; citation_volume=5; citation_issue=2; citation_publication_date=1981; citation_pages=121-152; citation_doi=10.1207/s15516709cog0502_2; citation_id=CR12; Cho, H., Gray, J., Syriani, E.: Creating visual domain-specific modeling languages from end-user demonstration. In: Proceedings of the 4th International Workshop on Modeling in Software Engineering, MiSE '12, pp. 22-28 (2012); citation_journal_title=IEEE Trans. Softw. Eng.; citation_title=A systematic survey of program comprehension through dynamic analysis; citation_author=B Cornelissen, A Zaidman, A Deursen, L Moonen, R Koschke; citation_volume=35; citation_issue=5; citation_publication_date=2009; citation_pages=684-702; citation_doi=10.1109/TSE.2009.28; citation_id=CR14; Demuth, B.: The dresden OCL toolkit and its role in information systems development. In: Proceedings of the 13th International Conference on Information Systems Development (ISDS2004), vol. 7 (2004); Dick, J., Faivre, A.: Automating the generation and sequencing of test cases from model-based specifications. In: Woodcock, J., Larsen, P. (eds.) FME '93: Industrial-Strength Formal Methods, volume 670 of Lecture Notes in Computer Science, pp. 268-284. Springer, Berlin (1993); citation_journal_title=Commun. ACM; citation_title=How UML is used; citation_author=B Dobing, J Parsons; citation_volume=49; citation_issue=5; citation_publication_date=2006; citation_pages=109-113; citation_doi=10.1145/1125944.1125949; citation_id=CR17; citation_journal_title=J. Database Manag.; citation_title=Dimensions of UML diagram use: a survey of practitioners; citation_author=B Dobing, J Parsons; citation_volume=19; citation_issue=1; citation_publication_date=2008; citation_pages=1-18; citation_doi=10.4018/jdm.2008010101; citation_id=CR18; citation_journal_title=Softw. Syst. Model.; citation_title=Generating instance models from meta models; citation_author=K Ehrig, J Kuster, G Tantzer; citation_volume=8; citation_issue=4; citation_publication_date=2009; citation_pages=479-500; citation_doi=10.1007/s10270-008-0095-y; citation_id=CR19; Fisler, K., Krishnamurthi, S., Meyerovich, L.A., Tschantz, M.C.: Verification and change-impact analysis of access-control policies. In: Proceedings of the 27th International Conference on Software Engineering, pp. 196-205. ACM (2005); citation_journal_title=Softw. Syst. Model.; citation_title=Qualifying input test data for model transformations; citation_author=F Fleurey, B Baudry, P-A Muller, Y Traon; citation_volume=8; citation_issue=2; citation_publication_date=2009; citation_pages=185-203; citation_doi=10.1007/s10270-007-0074-8; citation_id=CR21; citation_journal_title=Cogn. Psychol.; citation_title=Schema induction and analogical transfer; citation_author=ML Gick, KJ Holyoak; citation_volume=15; citation_issue=1; citation_publication_date=1983; citation_pages=1-38; citation_doi=10.1016/0010-0285(83)90002-6; citation_id=CR22; citation_journal_title=Can. J. Psychol.; citation_title=Do contrasting examples facilitate schema acquisition and analogical transfer?; citation_author=ML Gick, K Paterson; citation_volume=46; citation_issue=4; citation_publication_date=1992; citation_pages=539-550; citation_doi=10.1037/h0084333; citation_id=CR23; citation_journal_title=Sci. Comput. Progr.; citation_title=USE: a UML-based specification environment for validating UML and OCL; citation_author=M Gogolla, F Buttner, M Richters; citation_volume=69; citation_issue=1; citation_publication_date=2007; citation_pages=27-34; citation_doi=10.1016/j.scico.2007.01.013; citation_id=CR24; citation_journal_title=J. Learn. Sci.; citation_title=The transfer of scientific principles using concrete and idealized simulations; citation_author=RL Goldstone, JY Son; citation_volume=14; citation_issue=1; citation_publication_date=2005; citation_pages=69; citation_doi=10.1207/s15327809jls1401_4; citation_id=CR25; citation_journal_title=ACM Trans. Graph.; citation_title=Drape: dressing any person; citation_author=P Guan, L Reiss, DA Hirshberg, A Weiss, MJ Black; citation_volume=31; citation_issue=4; citation_publication_date=2012; citation_pages=35; citation_doi=10.1145/2185520.2185531; citation_id=CR26; Halbert, D.C.: Programming by example. Ph.D. thesis, University of California, Berkeley (1984); citation_journal_title=Commun. ACM; citation_title=Behavioral programming; citation_author=D Harel, A Marron, G Weiss; citation_volume=55; citation_issue=7; citation_publication_date=2012; citation_pages=90-100; citation_doi=10.1145/2209249.2209270; citation_id=CR28; Hutchinson, J., Whittle, J., Rouncefield, M., Kristoffersen, S.: Empirical assessment of MDE in industry. In: Proceedings of the 33rd International Conference on Software Engineering, ICSE '11, pp. 471-480, New York. ACM (2011); citation_title=Software Abstractions: Logic, Language, and Analysis; citation_publication_date=2012; citation_id=CR30; citation_author=D Jackson; citation_publisher=MIT Press; Jackson, E.K., Kang, E., Dahlweid, M., Seifert, D., Santen, T.: Components, platforms and possibilities: towards generic automation for MDA. In: Proceedings of the Tenth ACM International Conference on Embedded Software, pp. 39-48. ACM (2010); citation_journal_title=Computer; citation_title=Test-driven development concepts, taxonomy, and future direction; citation_author=D Janzen, H Saiedian; citation_volume=38; citation_issue=9; citation_publication_date=2005; citation_pages=43-50; citation_doi=10.1109/MC.2005.314; citation_id=CR32; citation_title=Basics of Software Engineering Experimentation; citation_publication_date=2010; citation_id=CR33; citation_author=N Juristo; citation_author=AM Moreno; citation_publisher=Springer; citation_journal_title=Learn. Instr.; citation_title=Knowledge elaboration: a cognitive load perspective. Cognitive load in interactive knowledge construction; citation_author=S Kalyuga; citation_volume=19; citation_issue=5; citation_publication_date=2009; citation_pages=402-410; citation_doi=10.1016/j.learninstruc.2009.02.003; citation_id=CR34; Kappel, G., Langer, P., Retschitzegger, W., Schwinger, W., Wimmer, M.: Conceptual modelling and its theoretical foundations. In: Chapter Model Transformation by-Example: A Survey of the First Wave, pp. 197-215 (2012); Karasneh, B., Jolak, R., Chaudron, M.R.V.: Using examples for teaching software design: an experiment using a repository of UML class diagrams. In: 2015 Asia-Pacific Software Engineering Conference (APSEC), pp. 261-268 (2015); citation_journal_title=Softw. Syst. Model.; citation_title=Search-based model transformation by example; citation_author=M Kessentini, H Sahraoui, M Boukadoum, OB Omar; citation_volume=11; citation_issue=2; citation_publication_date=2012; citation_pages=209-226; citation_doi=10.1007/s10270-010-0175-7; citation_id=CR37; citation_journal_title=IEEE Trans. Softw. Eng.; citation_title=Preliminary guidelines for empirical research in software engineering; citation_author=B Kitchenham, S Pfleeger, L Pickard, P Jones, D Hoaglin, K Emam, J Rosenberg; citation_volume=28; citation_issue=8; citation_publication_date=2002; citation_pages=721-734; citation_doi=10.1109/TSE.2002.1027796; citation_id=CR38; citation_journal_title=IEEE Trans. Softw. Eng.; citation_title=Preliminary guidelines for empirical research in software engineering; citation_author=BA Kitchenham, SL Pfleeger, LM Pickard, PW Jones, DC Hoaglin, K Emam, J Rosenberg; citation_volume=28; citation_issue=8; citation_publication_date=2002; citation_pages=721-734; citation_doi=10.1109/TSE.2002.1027796; citation_id=CR39; citation_journal_title=Requir. Eng.; citation_title=Preventing requirement defects: an experiment in process improvement; citation_author=S Lauesen, O Vinter; citation_volume=6; citation_issue=1; citation_publication_date=2001; citation_pages=37-50; citation_doi=10.1007/PL00010355; citation_id=CR40; citation_journal_title=Arch. Psychol.; citation_title=A technique for the measurement of attitudes; citation_author=R Likert; citation_volume=140; citation_publication_date=1932; citation_pages=1-55; citation_id=CR41; citation_journal_title=Softw. Syst. Model.; citation_title=Example-driven meta-model development; citation_author=JJ Lopez-Fernandez, JS Cuadrado, E Guerra, J Lara; citation_volume=14; citation_publication_date=2013; citation_pages=1-25; citation_id=CR42; citation_journal_title=Inf. Syst.; citation_title=Combining unit and specification-based testing for meta-model validation and verification; citation_author=JJ Lopez-Fernandez, E Guerra, J Lara; citation_volume=62; citation_publication_date=2016; citation_pages=104-135; citation_doi=10.1016/j.is.2016.06.008; citation_id=CR43; Magicdraw. 
                    http://www.nomagic.com/products/magicdraw.html
                    
                  . Accessed 21 Oct 2017; Maoz, S., Ringert, J.O., Rumpe, B.: Modal object diagrams. In: European Conference on Object-Oriented Programming, pp. 281-305. Springer (2011); Mendel, L.: Modeling by example. Ph.D. thesis, Massachusetts Institute of Technology (2007); Montaghami, V., Rayside, D.: Extending alloy with partial instances. In: Proceedings of Abstract State Machines, Alloy, B, VDM, and Z: Third International Conference, ABZ 2012, June 18-21, pp. 122-135 (2012); citation_journal_title=IEEE Trans. Softw. Eng.; citation_title=The; Nebeling, M., Geel, M., Norrie, M.C.: Engineering information management tools by example. In: Proceedings of the 2014 International Working Conference on Advanced Visual Interfaces, pp. 313-320. ACM (2014); Nelson, T., Saghafi, S., Dougherty, D.J., Fisler, K., Krishnamurthi, S.: Aluminum: principled scenario exploration through minimality. In: Proceedings of the 2013 International Conference on Software Engineering, pp. 232-241. IEEE Press (2013); citation_journal_title=Better Softw.; citation_title=Introducing BDD; citation_author=D North; citation_volume=12; citation_publication_date=2006; citation_pages=1; citation_id=CR51; citation_journal_title=Inf. Softw. Technol.; citation_title=Level of detail in UML models and its impact on model comprehension: a controlled experiment; citation_author=A Nugroho; citation_volume=51; citation_issue=12; citation_publication_date=2009; citation_pages=1670-1685; citation_doi=10.1016/j.infsof.2009.04.007; citation_id=CR52; Offutt, J., Abdurazik, A.: Generating tests from UML specifications. In: France, R., Rumpe, B. (eds.) UML'99--The Unified Modeling Language, Volume 1723 of Lecture Notes in Computer Science, pp. 416-429 (1999); citation_title=Contributions to Probability and Statistics: Essays in Honor of Harold Hotelling; citation_publication_date=1960; citation_id=CR54; citation_author=I Olkin; citation_publisher=Stanford University Press; Park, S.S.: Communicating domain knowledge through example-driven story testing. Master's thesis, University of Calgary, Alberta (2011); Petre, M.: UML in practice. In: Proceedings of the 2013 International Conference on Software Engineering, pp. 722-731 (2013); Purchase, H.C., Colpoys, L., McGill, M., Carrington, D., Britton, C.: UML class diagram syntax: an empirical study of comprehension. In: Proceedings of the 2001 Asia-Pacific Symposium on Information Visualisation--Volume 9, APVis'01, pp. 113-120. Australian Computer Society, Inc. (2001); Ricca, F., Di Penta, M., Torchiano, M., Tonella, P., Ceccato, M.: The role of experience and ability in comprehension tasks supported by UML stereotypes. In: 29th International Conference on Software Engineering, pp. 375-384 (2007); Sadilek, D.A., Weissleder, S.: Testing metamodels. In: Model Driven Architecture-Foundations and Applications, pp. 294-309. Springer, Berlin (2008); citation_journal_title=Requir. Eng.; citation_title=Managing requirements uncertainty with partial models; citation_author=R Salay, M Chechik, J Horkoff, AD Sandro; citation_volume=18; citation_issue=2; citation_publication_date=2013; citation_pages=107-128; citation_doi=10.1007/s00766-013-0170-y; citation_id=CR60; Scanniello, G., Ricca, F., Torchiano, M.: On the effectiveness of the UML object diagrams: a replicated experiment. In: 15th Annual Conference on Evaluation Assessment in Software Engineering (EASE 2011), pp. 76-85 (2011); Sun, Y., White, J., Gray, J.: Model transformation by demonstration. In: Schurr, A., Selic, B. (eds.) Model Driven Engineering Languages and Systems, pp. 712-726. Springer, Berlin (2009); Supplemental materials for the controlled experiment presented in Zayan et al.: Effects of Using Examples on Structural Model Comprehension (2013). 
                    http://gsd.uwaterloo.ca/publications/view/541.html
                    
                  . Accessed 21 Oct 2017; The R project for statistical computing. 
                    http://www.r-project.org/
                    
                  . Accessed 21 Oct 2017; Torchiano, M.: Empirical assessment of UML static object diagrams. In: Proceedings of 12th IEEE International Workshop on Program Comprehension, pp. 226-230 (2004); Torlak, E., Jackson, D.: Kodkod: a relational model finder. In: Tools and Algorithms for the Construction and Analysis of Systems, pp. 632-647. Springer, Berlin (2007); citation_journal_title=Contemp. Educ. Psychol.; citation_title=Effects of worked examples, example-problem, and problem-example pairs on novices' learning; citation_author=T Gog, L Kester, F Paas; citation_volume=36; citation_issue=3; citation_publication_date=2011; citation_pages=212-218; citation_doi=10.1016/j.cedpsych.2010.10.004; citation_id=CR67; citation_title=Goal Question Metric (GQM) Approach; citation_publication_date=2002; citation_id=CR68; citation_author=R Solingen; citation_author=V Basili; citation_author=G Caldiera; citation_author=HD Rombach; citation_publisher=Wiley; citation_title=The Object Constraint Language: Getting Your Models Ready for MDA; citation_publication_date=2003; citation_id=CR69; citation_author=J Warmer; citation_author=A Kleppe; citation_publisher=Addison-Wesley Longman Publishing Co. Inc.; Welch's t test. 
                    http://statistics.berkeley.edu/computing/r-t-tests
                    
                  . Accessed 21 Oct 2017; Whittle, J.: What do 449 MDE practitioners think about MDE? In: EESSMod (2011); Wimmer, M., Strommer, M., Kargl, H., Kramler, G.: Towards model transformation generation by-example. In: 40th Annual Hawaii International Conference on System Sciences, 2007. HICSS 2007, pp. 285b-285b. IEEE (2007); citation_title=Experimentation in Software Engineering: An Introduction; citation_publication_date=2000; citation_id=CR73; citation_author=C Wohlin; citation_author=P Runeson; citation_author=M Host; citation_author=MC Ohlsson; citation_author=B Regnell; citation_author=A Wesslen; citation_publisher=Kluwer Academic Publishers; Yusuf, S., Kagdi, H., Maletic, J.I.: Assessing the comprehension of UML class diagrams via eye tracking. In: 15th International Conference on Program Comprehension (ICPC'07), pp. 113-122. IEEE Computer Society (2007); Zayan, D., Antkiewicz, M., Czarnecki, K.: Effects of using examples on structural model comprehension: a controlled experiment. In: Proceedings of the 36th International Conference on Software Engineering, pp. 955-966. ACM (2014); citation_journal_title=Computer; citation_title=QBE/OBE: a language for office and business automation; citation_author=M Zloof; citation_volume=14; citation_issue=5; citation_publication_date=1981; citation_pages=13-22; citation_doi=10.1109/C-M.1981.220446; citation_id=CR76"			Excluded	Excluded	new_screen			2	Springer Link		Example-driven modeling: on effects of using examples on structural model comprehension, what makes them useful, and how to create them	http://link.springer.com/article/10.1007/s10270-017-0652-3	Springer Link	nan; Pages; Year; Bibtex
411	Behave	Extending, Unit Testing, and Packaging	In the first nine chapters of this book we have analyzed various features of Ext JS 4. You learned how to use the UI controls, work with data components, create custom themes, and build applications that follow the MVC architecture. In this chapter you'll find out about some miscellaneous features in Ext JS 4. For example, you'll see how to extend the UI controls by creating custom components. I'll discuss various options involved in creating custom components and plugins. You'll also learn how to write unit tests in JavaScript to test our Ext JS 4 application. Finally you'll learn how to create an Ext JS 4 application from scratch, package it, and deploy it to the web server.	Create Custom Components; Plug-in Time; Sencha; Jasmine; onRender	Sunderaraman, Prabhu	Practical Ext JS 4	https://doi.org/10.1007/978-1-4302-6074-5_10		185--205	"""@Inbook{Sunderaraman2013,
    author = ""Sunderaraman, Prabhu"",
    title = ""Extending, Unit Testing, and Packaging"",
    bookTitle = ""Practical Ext JS 4"",
    year = ""2013"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""185--205"",
    abstract = ""In the first nine chapters of this book we have analyzed various features of Ext JS 4. You learned how to use the UI controls, work with data components, create custom themes, and build applications that follow the MVC architecture. In this chapter you'll find out about some miscellaneous features in Ext JS 4. For example, you'll see how to extend the UI controls by creating custom components. I'll discuss various options involved in creating custom components and plugins. You'll also learn how to write unit tests in JavaScript to test our Ext JS 4 application. Finally you'll learn how to create an Ext JS 4 application from scratch, package it, and deploy it to the web server."",
    isbn = ""978-1-4302-6074-5"",
    doi = ""10.1007/978-1-4302-6074-5\_10"",
    url = ""https://doi.org/10.1007/978-1-4302-6074-5\_10""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Extending, Unit Testing, and Packaging	https://link.springer.com/chapter/10.1007/978-1-4302-6074-5_10	Apress	nan; References
412	Behave	eXtreme Programming	A number of different implementation frameworks have been conceived within the spirit of the Agile Manifesto. eXtreme Programming (XP) is such a framework and focuses on delivering business value through a lean process, customer satisfaction, and short development cycles. Whereas Scrum is primarily focused on the project management side of things, XP is more focused on development details. Thus Scrum and XP are complementary, and are often used together to become more efficient in delivering customer valued software.	Team Member; Iteration Length; User Story; Continuous Integration; Technical Debt	Jerrel Blankenship; Matthew Bussa; Scott Millett	Pro Agile .NET Development with Scrum	https://doi.org/10.1007/978-1-4302-3534-7_3		29–51		Excluded	Excluded	new_screen			2	Springer Link		eXtreme Programming	http://link.springer.com/chapter/10.1007/978-1-4302-3534-7_3	Apress, Berkeley, CA	nan; References; Year; Bibtex
413	Behave	Flipping the Run/Build Ratio: The Business Case for Software Craftsmanship	We introduce the five business advantages of encouraging software craftsmanship among developers. We offer a tour of a sampling of craftsmanship practices and provide a glimpse into the worldview and intention of the software craftsman.	Package Implementation; Enterprise Architecture; Automate Test; Data Migration; User Story	Kulak, Daryl; Li, Hong	The Journey to Enterprise Agility	https://doi.org/10.1007/978-3-319-54087-0_9		137--151	"""@Inbook{Kulak2017,
    author = ""Kulak, Daryl and Li, Hong"",
    title = ""Flipping the Run/Build Ratio: The Business Case for Software Craftsmanship"",
    bookTitle = ""The Journey to Enterprise Agility: Systems Thinking and Organizational Legacy"",
    year = ""2017"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""137--151"",
    abstract = ""We introduce the five business advantages of encouraging software craftsmanship among developers. We offer a tour of a sampling of craftsmanship practices and provide a glimpse into the worldview and intention of the software craftsman."",
    isbn = ""978-3-319-54087-0"",
    doi = ""10.1007/978-3-319-54087-0\_9"",
    url = ""https://doi.org/10.1007/978-3-319-54087-0\_9""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Flipping the Run/Build Ratio: The Business Case for Software Craftsmanship	http://link.springer.com/chapter/10.1007/978-3-319-54087-0_9	Springer International Publishing	nan; References
414	Behave	Formal Specification Level	The steadily increasing complexity of the design of embedded systems led to the development of both an elaborated design flow that includes various abstraction levels and corresponding methods for synthesis and verification. However, until today the initial system specification is provided in natural language which is manually translated into a formal implementation e.g. at the Electronic System Level (ESL) by means of SystemC in a time-consuming and error-prone process.In this chapter, we envision a design flow which incorporates a Formal Specification Level (FSL) aiming at bridging the gap between the informal textbook specification and the formal ESL implementation. Modeling languages such as UML or SysML are envisaged for this purpose. Recent accomplishments towards this envisioned design flow, namely the automatic derivation of formal models from natural language descriptions, verification of formal models in the absence of an implementation, and code generation techniques, are briefly reviewed.		Drechsler, Rolf; Soeken, Mathias; Wille, Robert	Models, Methods, and Tools for Complex Chip Design	https://doi.org/10.1007/978-3-319-01418-0_3		37--52	"""@InProceedings{10.1007/978-3-319-01418-0_3,
    author = ""Drechsler, Rolf and Soeken, Mathias and Wille, Robert"",
    editor = ""Haase, Jan"",
    title = ""Formal Specification Level"",
    booktitle = ""Models, Methods, and Tools for Complex Chip Design"",
    year = ""2014"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""37--52"",
    abstract = ""The steadily increasing complexity of the design of embedded systems led to the development of both an elaborated design flow that includes various abstraction levels and corresponding methods for synthesis and verification. However, until today the initial system specification is provided in natural language which is manually translated into a formal implementation e.g. at the Electronic System Level (ESL) by means of SystemC in a time-consuming and error-prone process.In this chapter, we envision a design flow which incorporates a Formal Specification Level (FSL) aiming at bridging the gap between the informal textbook specification and the formal ESL implementation. Modeling languages such as UML or SysML are envisaged for this purpose. Recent accomplishments towards this envisioned design flow, namely the automatic derivation of formal models from natural language descriptions, verification of formal models in the absence of an implementation, and code generation techniques, are briefly reviewed."",
    isbn = ""978-3-319-01418-0""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Formal Specification Level	http://link.springer.com/chapter/10.1007/978-3-319-01418-0_3	Springer International Publishing	nan; Keywords; References
415	Behave	Formal Testing from Natural Language in an Industrial Context	We present some results on developing formal testing strategies and tools for mobile applications, in the context of a partnership with Motorola, a Lenovo company. Actually, the overall scope is much larger, encompassing image processing, optimisation algorithms, sentiment analysis, energy-aware software design, and other research areas.	Natural Language; Sentiment Analysis; Test Case Generation; Natural Language Description; Manual Execution	Sampaio, Augusto; Arruda, Filipe	Brazilian Symposium on Formal Methods	https://doi.org/10.1007/978-3-319-49815-7_2		21--38	"""@InProceedings{10.1007/978-3-319-49815-7_2,
    author = ""Sampaio, Augusto and Arruda, Filipe"",
    editor = ""Ribeiro, Leila and Lecomte, Thierry"",
    title = ""Formal Testing from Natural Language in an Industrial Context"",
    booktitle = ""Formal Methods: Foundations and Applications"",
    year = ""2016"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""21--38"",
    abstract = ""We present some results on developing formal testing strategies and tools for mobile applications, in the context of a partnership with Motorola, a Lenovo company. Actually, the overall scope is much larger, encompassing image processing, optimisation algorithms, sentiment analysis, energy-aware software design, and other research areas."",
    isbn = ""978-3-319-49815-7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Formal Testing from Natural Language in an Industrial Context	http://link.springer.com/chapter/10.1007/978-3-319-49815-7_2	Springer International Publishing	nan; References
416	Behave	FRAGGLE: A FRamework for AGile Gamification of Learning Experiences			Alberto MoraPanagiotis ZahariasCarina GonzálezJoan Arnedo-Moreno	Framework inspired by BDD					Excluded	Excluded	new_screen			2						
417	Behave	Fragment-based spreadsheet debugging	Faults in spreadsheets can represent a major risk for businesses. To minimize such risks, various automated testing and debugging approaches for spreadsheets were proposed. In such approaches, often one main assumption is that the spreadsheet developer is able to indicate if the outcomes of certain calculations correspond to the intended values. This, however, might require that the user performs calculations manually, a process which can easily become tedious and error-prone for more complex spreadsheets. In this work, we propose an interactive spreadsheet algorithmic debugging method, which is based on partitioning the spreadsheet into fragments. Test cases can then be automatically or manually created for each of these smaller fragments, whose correctness or faultiness can be easier assessed by users than test cases that cover the entire spreadsheet. The annotated test cases are then fed into an algorithmic debugging technique, which returns a set of formulas that could have caused any observed failures, i.e., discrepancies between the expected and computed calculation outcomes. Simulation experiments demonstrate that the suggested decomposition approach can speed up the algorithmic debugging process and significantly reduce the number of fault candidates returned by the algorithm. An additional laboratory study shows that fragmenting a spreadsheet with our method furthermore reduces the time needed by users for creating test cases for a spreadsheet.	Artificial Intelligence; Spreadsheets; Algorithmic testing and debugging; Artificial intelligence; Model-based diagnosis	Dietmar Jannach; Thomas Schmitz; Birgit Hofer; Konstantin Schekotihin; Patrick Koch; Franz Wotawa	Automated Software Engineering	https://doi.org/10.1007/s10515-018-0250-9	"Abraham, R., Erwig, M.: Goal-directed debugging of spreadsheets. In: Proceedings of the IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC 2005), Dallas, TX, USA, pp. 37-44 (2005); Abraham, R., Erwig, M.: AutoTest: a tool for automatic test case generation in spreadsheets. In: Proceedings of the IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC 2006), Brighton, United Kingdom, pp. 43-50 (2006); citation_journal_title=IEEE Trans. Softw. Eng.; citation_title=Mutation operators for spreadsheets; citation_author=R Abraham, M Erwig; citation_volume=35; citation_issue=1; citation_publication_date=2009; citation_pages=94-108; citation_doi=10.1109/TSE.2008.73; citation_id=CR3; citation_journal_title=Softw. Qual. J.; citation_title=Using constraints to diagnose faulty spreadsheets; citation_author=R Abreu, B Hofer, A Perez, F Wotawa; citation_volume=23; citation_issue=2; citation_publication_date=2015; citation_pages=297-322; citation_doi=10.1007/s11219-014-9236-4; citation_id=CR4; Almeida, L., Cirilo, E., Barbosa, E.A.: SS-BDD: automated acceptance testing for spreadsheets. In: Proceedings of the 1st Brazilian Symposium on Systematic and Automated Software Testing (SAST 2016), New York City, NY, USA, pp. 5:1-5:10 (2016); AlTarawneh, G., Thorne, S.: A pilot study exploring spreadsheet risk in scientific research. In: Proceedings of the Annual Spreadsheet Risks Conference (EuSpRIG 2016), London, United Kingdom (2016); citation_journal_title=IEEE Trans. Softw. Eng.; citation_title=Testing homogeneous spreadsheet grids with the; Chen, T.Y.: Metamorphic testing: a simple approach to alleviate the oracle problem. In: Proceedings of the 5th IEEE International Symposium on Service-Oriented System Engineering (SOSE 2010), Nanjing, China, pp. 1-2 (2010); Cunha, J., Fernandes, J.P., Ribeiro, H., Saraiva, J.: Towards a catalog of spreadsheet smells. In: Proceedings of the 12th International Conference on Computational Science and Its Applications (ICCSA 2012), Salvador de Bahia, Brazil, pp. 202-216 (2012); Felfernig, A., Friedrich, G., Jannach, D., Stumptner, M., Zanker, M.: Hierarchical diagnosis of large configurator knowledge bases. In: Proceedings of the Joint German Austrian Conference on AI (KI 2001), Vienna, Austria, pp. 185-197 (2001); citation_journal_title=Artif. Intell.; citation_title=Consistency-based diagnosis of configuration knowledge bases; citation_author=A Felfernig, G Friedrich, D Jannach, M Stumptner; citation_volume=152; citation_issue=2; citation_publication_date=2004; citation_pages=213-234; citation_doi=10.1016/S0004-3702(03)00117-6; citation_id=CR11; Hermans, F.: Improving spreadsheet test practices. In: Proceedings of the 2013 Conference of the Center for Advanced Studies on Collaborative Research (CASCON 2013), Ontario, Canada, pp. 56-69 (2013); Hermans, F., Pinzger, M., van Deursen, A.: Supporting. In: Proceedings of the 33rd International Conference on Software Engineering (ICSE 2011), Waikiki, Honolulu, HI, USA, pp. 451-460 (2011); Hermans, F., Pinzger, M., van Deursen, A.: Detecting code smells in spreadsheet formulas. In: Proceedings of the 28th IEEE International Conference on Software Maintenance (ICSM 2012), Riva del Garda, Trento, Italy, pp. 409-418 (2012); Hodnigg, K., Mittermeir, R.T.: Metrics-based spreadsheet visualization--support for focused maintenance. In: Proceedings of the 9th Annual Spreadsheet Risks Conference (EuSpRIG 2008), London, United Kingdom, pp. 79-94 (2008); Hofer, B., Wotawa, F.: Why does my spreadsheet compute wrong values? In: Proceedings of the 25th IEEE International Symposium on Software Reliability Engineering, (ISSRE 2014), Naples, Italy, pp. 112-121 (2014); Hofer, B., Riboira, A., Wotawa, F., Abreu, R., Getzner, E.: On the empirical evaluation of fault localization techniques for spreadsheets. In: Proceedings of the 16th International Conference on Fundamental Approaches to Software Engineering (FASE 2013), Rome, Italy, pp. 68-82 (2013); citation_journal_title=Autom. Softw. Eng.; citation_title=On the empirical evaluation of similarity coefficients for spreadsheets fault localization; citation_author=B Hofer, A Perez, R Abreu, F Wotawa; citation_volume=22; citation_issue=1; citation_publication_date=2015; citation_pages=47-74; citation_doi=10.1007/s10515-014-0145-3; citation_id=CR18; Hofer, B., Nica, I., Wotawa, F.: AI for localizing faults in spreadsheets. In: Proceedings of the 29th International Conference on Testing Software and Systems (ICTSS 2017), St. Petersburg, Russia, pp. 71-87 (2017); Jannach, D., Engler, U.: Toward model-based debugging of spreadsheet programs. In: Proceedings of the 9th Joint Conference on Knowledge-Based Software Engineering (JCKBSE 2010), Kaunas, Lithuania, pp. 252-262 (2010); citation_journal_title=Autom. Softw. Eng.; citation_title=Model-based diagnosis of spreadsheet programs: a constraint-based debugging approach; citation_author=D Jannach, T Schmitz; citation_volume=23; citation_issue=1; citation_publication_date=2016; citation_pages=105-144; citation_doi=10.1007/s10515-014-0141-7; citation_id=CR21; citation_journal_title=J. Syst. Softw.; citation_title=Avoiding, finding and fixing spreadsheet errors--a survey of automated approaches for spreadsheet QA; citation_author=D Jannach, T Schmitz, B Hofer, F Wotawa; citation_volume=94; citation_publication_date=2014; citation_pages=129-150; citation_doi=10.1016/j.jss.2014.03.058; citation_id=CR22; Mittermeir, R., Clermont, M.: Finding high-level structures in spreadsheet programs. In: Proceedings of the Working Conference on Reverse Engineering, pp. 221-231 (2002); citation_journal_title=Decis. Support Syst.; citation_title=Revising the Panko-Halverson taxonomy of spreadsheet errors; citation_author=RR Panko, S Aurigemma; citation_volume=49; citation_issue=2; citation_publication_date=2010; citation_pages=235-244; citation_doi=10.1016/j.dss.2010.02.009; citation_id=CR24; Parnin, C., Orso, A.: Are automated debugging techniques actually helping programmers? In: Proceedings of the 2011 International Symposium on Software Testing and Analysis, ACM, New York, NY, USA, ISSTA '11, pp. 199-209. (2011). 
                    https://doi.org/10.1145/2001420.2001445; citation_journal_title=IT People; citation_title=How can non-technical end users effectively test their spreadsheets?; citation_author=P Poon, F Kuo, H Liu, TY Chen; citation_volume=27; citation_issue=4; citation_publication_date=2014; citation_pages=440-462; citation_doi=10.1108/ITP-01-2013-0004; citation_id=CR26; Reichwein, J., Rothermel, G., Burnett, M.: Slicing spreadsheets: an integrated methodology for spreadsheet testing and debugging. In: Proceedings of the 2nd Conference on Domain-Specific Languages (DSL 1999), Austin, TX, USA, pp. 25-38 (1999); citation_journal_title=Artif. Intell.; citation_title=A theory of diagnosis from first principles; citation_author=R Reiter; citation_volume=32; citation_issue=1; citation_publication_date=1987; citation_pages=57-95; citation_doi=10.1016/0004-3702(87)90062-2; citation_id=CR28; Rothermel, G., Li, L., Dupuis, C., Burnett, M.: What you see is what you test: a methodology for testing form-based visual programs. In: Proceedings of the 20th International Conference on Software Engineering (ICSE 1998), Kyoto, Japan, pp. 198-207 (1998); Roy, S., Hermans, F., van Deursen, A.: Spreadsheet testing in practice. In: Proceedings of the 24th IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER 2017), Klagenfurt, Austria, pp. 338-348 (2017); citation_title=Artificial Intelligence: A Modern Approach; citation_publication_date=2009; citation_id=CR31; citation_author=S Russell; citation_author=P Norvig; citation_publisher=Prentice Hall; Rust, A., Bishop, B., McDaid, K.: Test-driven development: can it work for spreadsheet engineering? In: Proceedings of the 7th International Conference on Extreme Programming and Agile Processes in Software Engineering (XP 2006), Oulu, Finland, pp. 209-210 (2006); citation_journal_title=J. Vis. Lang. Comput.; citation_title=Interactive, visual fault localization support for end-user programmers; citation_author=JR Ruthruff, S Prabhakararao, J Reichwein, C Cook, E Creswick, M Burnett; citation_volume=16; citation_issue=1-2; citation_publication_date=2005; citation_pages=3-40; citation_doi=10.1016/j.jvlc.2004.07.001; citation_id=CR33; Scaffidi, C., Shaw, M., Myers, B.: Estimating the numbers of end users and end user programmers. In: Proceedings of the IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC 2005), Washington, DC, USA, pp. 207-214 (2005); Schmitz, T., Jannach, D.: Finding errors in the enron spreadsheet corpus. In: Proceedings of the IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC 2016), Cambridge, United Kingdom, pp. 157-161 (2016); Schmitz, T., Jannach, D.: An AI-based interactive tool for spreadsheet debugging. In: Showpieces presented at the IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC 2017), Raleigh, NC, USA (2017); Schmitz, T., Hofer, B., Jannach, D., Wotawa, F.: Fragment-based diagnosis of spreadsheets. In: Proceedings of the 3rd International Workshop on Software Engineering Methods in Spreadsheets (SEMS 2016), Vienna, Austria, pp. 372-387 (2016); Schmitz, T., Jannach, D., Hofer, B., Koch, P., Schekotihin, K., Wotawa, F.: A decomposition-based approach to spreadsheet testing and debugging. In: Proceedings of the IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC 2017), Raleigh, NC, USA (2017); Shchekotykhin, K., Schmitz, T., Jannach, D.: Efficient sequential model-based fault-localization with partial diagnoses. In: Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI 2016), New York City, NY, USA, pp. 1251-1257 (2016); Siddiqi, S., Huang, J.: Hierarchical diagnosis of multiple faults. In: Proceedings of the 20th International Joint Conference on Artifical Intelligence (IJCAI 2007), San Francisco, CA, USA, pp. 581-586 (2007)"			Excluded	Excluded	new_screen			2	Springer Link		Fragment-based spreadsheet debugging	http://link.springer.com/article/10.1007/s10515-018-0250-9	Springer Link	nan; Pages; Year; Bibtex
418	Behave	Framework Options and Design Pattern	In the last chapter, you saw waits and timeouts. Protractor can be used with different types of frameworks. Choosing a framework depends on a lot of different factors. Protractor's flexibility allows it to be implemented using any of the frameworks on the market. This chapter looks at the following, including frameworks that are compatible with Protractor.		Shukla, Shashank	The Protractor Handbook	https://doi.org/10.1007/978-1-4842-7289-3_9		167--179	"""@Inbook{Shukla2021,
    author = ""Shukla, Shashank"",
    title = ""Framework Options and Design Pattern"",
    bookTitle = ""The Protractor Handbook: Understanding and Implementing the Tool Effectively"",
    year = ""2021"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""167--179"",
    abstract = ""In the last chapter, you saw waits and timeouts. Protractor can be used with different types of frameworks. Choosing a framework depends on a lot of different factors. Protractor's flexibility allows it to be implemented using any of the frameworks on the market. This chapter looks at the following, including frameworks that are compatible with Protractor."",
    isbn = ""978-1-4842-7289-3"",
    doi = ""10.1007/978-1-4842-7289-3\_9"",
    url = ""https://doi.org/10.1007/978-1-4842-7289-3\_9""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Framework Options and Design Pattern	http://link.springer.com/chapter/10.1007/978-1-4842-7289-3_9	Apress	nan; Keywords; References
419	Behave	From COBOL to Business Rules---Extracting Business Rules from Legacy Code	The reverse engineering project described in this paper is aimed at documenting a 6.4 million lines of code COBOL/IMS/DB2 system for world-wide car leasing. The ultimate goal is to re-implement that system. The system was originally developed in the 1980s with less than 3 million code lines and has since evolved to its current size. It survived the year 2000 date change and the Euro conversion as well as several major company reorganizations to preserve the continuity of the leasing service. Finally, after 30 years of service it is planned to retire the system. However, the first two attemptsSneed, Harry M. to replace it, one by automatically converting it and the other by replacing it with a standard package ended in failure. It is now planned to rewrite the system based on a specification derivedVerhoef, Chris from the current code base. That specification includes among other documents a documentation of the processing rules. The extracted rules are intended to act as guide to those writing the new code.		Sneed, Harry M.; Verhoef, Chris	Integrating Research and Practice in Software Engineering	https://doi.org/10.1007/978-3-030-26574-8_14		187--208	"""@Inbook{Sneed2020,
    author = ""Sneed, Harry M. and Verhoef, Chris"",
    editor = ""Jarzabek, Stan and Poniszewska-Mara{\'{n}}da, Aneta and Madeyski, Lech"",
    title = ""From COBOL to Business Rules---Extracting Business Rules from Legacy Code"",
    bookTitle = ""Integrating Research and Practice in Software Engineering"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""187--208"",
    abstract = ""The reverse engineering project described in this paper is aimed at documenting a 6.4 million lines of code COBOL/IMS/DB2 system for world-wide car leasing. The ultimate goal is to re-implement that system. The system was originally developed in the 1980s with less than 3 million code lines and has since evolved to its current size. It survived the year 2000 date change and the Euro conversion as well as several major company reorganizations to preserve the continuity of the leasing service. Finally, after 30 years of service it is planned to retire the system. However, the first two attemptsSneed, Harry M. to replace it, one by automatically converting it and the other by replacing it with a standard package ended in failure. It is now planned to rewrite the system based on a specification derivedVerhoef, Chris from the current code base. That specification includes among other documents a documentation of the processing rules. The extracted rules are intended to act as guide to those writing the new code."",
    isbn = ""978-3-030-26574-8"",
    doi = ""10.1007/978-3-030-26574-8\_14"",
    url = ""https://doi.org/10.1007/978-3-030-26574-8\_14""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		From COBOL to Business Rules—Extracting Business Rules from Legacy Code	http://link.springer.com/chapter/10.1007/978-3-030-26574-8_14	Springer International Publishing	nan; Keywords; References
420	Behave	From Requirements to Automated Acceptance Tests with the RSL Language	Software testing can promote software quality. However, this activity is often performed at the end of projects where failures are most difficult to correct. Combining requirements specification activities with test design at an early stage of the software development process can be beneficial. One way to do this is to use a more structured requirements specification language. This allow to reduce typical problems such as ambiguity, inconsistency, and incorrectness in requirements and may allow the automatic generation of (parts of) acceptance test cases reducing the test design effort. In this paper we discuss an approach that promotes the practice of requirements specification combined with testing specification. This is a model-based approach that promotes the alignment between requirements and tests, namely, test cases and also low-level automated test scripts. To show the applicability of this approach, we integrate two complementary languages: (i) the ITLingo RSL (Requirements Specification Language) that is specially designed to support both requirements and tests rigorously and consistently specified; and (ii) the Robot language, which is a low-level keyword-based language for specifying test scripts. This approach includes model-to-model transformation processes, namely a transformation process from requirements (defined in RSL) into test cases (defined in RSL), and a second transformation process from test cases (in RSL) into test scripts (defined according the Robot framework). This approach was applied in a fictitious online store that illustrates the various phases of the proposal.	Requirements Specification Language (RSL); Test case specification; Model-based Testing (MBT); Test case generation; Test case execution	Paiva, Ana C. R.; Maciel, Daniel; da Silva, Alberto Rodrigues	International Conference on Evaluation of Novel Approaches to Software Engineering	https://doi.org/10.1007/978-3-030-40223-5_3		39--57	"""@InProceedings{10.1007/978-3-030-40223-5_3,
    author = ""Paiva, Ana C. R. and Maciel, Daniel and da Silva, Alberto Rodrigues"",
    editor = ""Damiani, Ernesto and Spanoudakis, George and Maciaszek, Leszek A."",
    title = ""From Requirements to Automated Acceptance Tests with the RSL Language"",
    booktitle = ""Evaluation of Novel Approaches to Software Engineering"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""39--57"",
    abstract = ""Software testing can promote software quality. However, this activity is often performed at the end of projects where failures are most difficult to correct. Combining requirements specification activities with test design at an early stage of the software development process can be beneficial. One way to do this is to use a more structured requirements specification language. This allow to reduce typical problems such as ambiguity, inconsistency, and incorrectness in requirements and may allow the automatic generation of (parts of) acceptance test cases reducing the test design effort. In this paper we discuss an approach that promotes the practice of requirements specification combined with testing specification. This is a model-based approach that promotes the alignment between requirements and tests, namely, test cases and also low-level automated test scripts. To show the applicability of this approach, we integrate two complementary languages: (i) the ITLingo RSL (Requirements Specification Language) that is specially designed to support both requirements and tests rigorously and consistently specified; and (ii) the Robot language, which is a low-level keyword-based language for specifying test scripts. This approach includes model-to-model transformation processes, namely a transformation process from requirements (defined in RSL) into test cases (defined in RSL), and a second transformation process from test cases (in RSL) into test scripts (defined according the Robot framework). This approach was applied in a fictitious online store that illustrates the various phases of the proposal."",
    isbn = ""978-3-030-40223-5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		From Requirements to Automated Acceptance Tests with the RSL Language	http://link.springer.com/chapter/10.1007/978-3-030-40223-5_3	Springer International Publishing	nan; References
421	Behave	From Requirements to Verifiable Executable Models Using Rebeca			Marjan SirjaniLuciana ProvenzanoSara Abbaspour AsadollahMahshid Helali Moghadam						Excluded	Excluded	new_screen			2						
422	Behave	Fusing Modeling and Programming into Language-Oriented Programming	Modeling in general is of course different from programming (think: climate models). However, when we consider the role of models in the context of ``model-driven'', i.e., when they are used to automatically construct software, it is much less clear that modeling is different from programming. In this paper, I argue that the two are conceptually indistinguishable, even though in practice they traditionally emphasize different aspects of the (conceptually indistinguishable) common approach. The paper discusses and illustrates language-oriented programming, the approach to {\{}modeling|programming{\}} we have successfully used over the last 7 years to build a range of innovative systems in domains such as insurance, healthcare, tax, engineering and consumer electronics. It relies on domain-specific languages, modular language extension, mixed notations, and in particular, the Jetbrains MPS language workbench.	Domain-specific languages; Language modularity; Function programming; Language engineering; Meta programming	Voelter, Markus	International Symposium on Leveraging Applications of Formal Methods	https://doi.org/10.1007/978-3-030-03418-4_19		309--339	"""@InProceedings{10.1007/978-3-030-03418-4_19,
    author = ""Voelter, Markus"",
    editor = ""Margaria, Tiziana and Steffen, Bernhard"",
    title = ""Fusing Modeling and Programming into Language-Oriented Programming"",
    booktitle = ""Leveraging Applications of Formal Methods, Verification and Validation. Modeling"",
    year = ""2018"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""309--339"",
    abstract = ""Modeling in general is of course different from programming (think: climate models). However, when we consider the role of models in the context of ``model-driven'', i.e., when they are used to automatically construct software, it is much less clear that modeling is different from programming. In this paper, I argue that the two are conceptually indistinguishable, even though in practice they traditionally emphasize different aspects of the (conceptually indistinguishable) common approach. The paper discusses and illustrates language-oriented programming, the approach to {\{}modeling|programming{\}} we have successfully used over the last 7 years to build a range of innovative systems in domains such as insurance, healthcare, tax, engineering and consumer electronics. It relies on domain-specific languages, modular language extension, mixed notations, and in particular, the Jetbrains MPS language workbench."",
    isbn = ""978-3-030-03418-4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Fusing Modeling and Programming into Language-Oriented Programming	http://link.springer.com/chapter/10.1007/978-3-030-03418-4_19	Springer International Publishing	nan; References
423	Behave	Gamification: a systematic review of design frameworks	Learner's motivation difficulties are recognized as a problem in diverse educational scenarios, reaching up to university degrees. Among other techniques that are often applied by instructors to counteract this issue, those related to the use of gaming elements seem to very promising. In this context, considering the use of game-like properties in learning scenarios, known as gamification, has received increasing interest by academia in recent years. However, its application in higher education can be challenging, due to some unwanted effects caused by the lack of proven design methodologies have been detected. Choosing the adequate formal process for gamification design has become an important success requirement. This work presents a systematic review of the gamification design frameworks discussed in the literature, providing a useful resource to educational practitioners as well as gamification designers and researchers. A total of 2314 unique works are initially recorded, based on queries in databases, libraries, journals and search engines. After applying a systematic filtering process, a definitive list of 40 works is more closely analysed. Next to review over relevant literature, an assessment of the main features found in the discussed approaches is given, while also categorizing them according to their main application field and its suitability in higher educational environments.	Artificial Intelligence; Medical Ethics; Digital Education and Educational Technology; Gamification; Frameworks; Game design; Review; Learning; Higher education	Alberto Mora; Daniel Riera; Carina Gonzalez; Joan Arnedo-Moreno	Journal of Computing in Higher Education	https://doi.org/10.1007/s12528-017-9150-4	"citation_journal_title=International Journal for Infonomics; citation_title=SGI: A framework for increasing the sustainability of gamification impact; citation_author=A Almarshedi, G Wills, V Wanick, A Ranchhod; citation_volume=8; citation_issue=1/2; citation_publication_date=2015; citation_pages=1044-1052; citation_doi=10.20533/iji.1742.4712.2015.0123; citation_id=CR1; citation_journal_title=Journal of MUD Research; citation_title=Hearts, clubs, diamonds, spades: Players who suit MUDs; citation_author=R Bartle; citation_volume=1; citation_issue=1; citation_publication_date=1996; citation_pages=19; citation_id=CR2; citation_journal_title=Communications of the ACM; citation_title=Toward an ethics of persuasive technology; citation_author=D Berdichevsky, E Neuenschwander; citation_volume=42; citation_issue=5; citation_publication_date=1999; citation_pages=51-58; citation_doi=10.1145/301353.301410; citation_id=CR3; citation_title=Challenges for game designers; citation_publication_date=2009; citation_id=CR4; citation_author=B Brathwaite; citation_author=I Schreiber; citation_publisher=Charles River Media; Brito, J., Vieira, V., & Duran, A. (2015). Towards a framework for gamification design on crowdsourcing systems: The GAME approach. In Proceeding of the 12th international conference on information technology--new generations (pp. 445-450). Las Vegas, NV: IEEE. doi:
                    10.1109/ITNG.2015.78
                    
                  .; citation_title=Gamification and the trough of disillusionment; citation_inbook_title=Mensch & Computer 2014--Workshop band; citation_publication_date=2014; citation_pages=389-395; citation_id=CR6; citation_author=J Broer; citation_publisher=De Gruyter Oldenbourg; citation_title=Gamify: How gamification motivates people to do extraordinary things; citation_publication_date=2014; citation_id=CR7; citation_author=B Burke; citation_publisher=Bibliomotion; citation_title=Man, play, and games; citation_publication_date=2001; citation_id=CR8; citation_author=R Caillois; citation_publisher=University of Illinois Press; citation_title=Assessing the core elements of the gaming experience; citation_inbook_title=Evaluating user experience in games: Concepts and methods; citation_publication_date=2010; citation_pages=47-72; citation_id=CR9; citation_author=EH Calvillo-Gamez; citation_author=P Cairns; citation_author=AL Cox; citation_publisher=Springer; Charles, D., & McDonough, S. (2014). A participatory design framework for the gamification of rehabilitation systems. In: P. M. Sharkey, L. Pareto, J. Broeren & M. Rydmark (Eds.), Proceedings of the 10th international conference on disability, virtual reality & associated technologies. Gothenburg, Sweden (pp. 293-296). Reading: ICDVRAT.; citation_title=The RSpec book: Behaviour driven development with Rspec, Cucumber, and friends; citation_publication_date=2010; citation_id=CR11; citation_author=D Chelimsky; citation_author=D Astels; citation_author=B Helmkamp; citation_author=D North; citation_publisher=Pragmatic Bookshelf; citation_title=Actionable gamification : Beyond points, badges, and leaderboards; citation_publication_date=2015; citation_id=CR12; citation_author=Y-K Chou; citation_publisher=Octalysis Media; citation_title=Gamification: The measurement of benefits; citation_inbook_title=Gamification in education and business; citation_publication_date=2015; citation_pages=673-688; citation_id=CR13; citation_author=K Conley; citation_author=C Donaldson; citation_publisher=Springer; citation_title=Flow: The psychology of optimal experience; citation_publication_date=1990; citation_id=CR14; citation_author=M Csikszentmihalyi; citation_publisher=Harper & Row; citation_journal_title=Management Science; citation_title=User acceptance of computer technology: A comparison of two theoretical models; citation_author=F Davis, R Bagozzi, P Warshaw; citation_volume=35; citation_issue=8; citation_publication_date=1989; citation_pages=982-1003; citation_doi=10.1287/mnsc.35.8.982; citation_id=CR15; Deterding, S., Dixon, D., Khaled, R., & Nacke, L. (2011). From game design elements to gamefulness: Defining gamification. In Proceedings of the 15th International Academic MindTrek Conference: Envisioning Future Media Environments (pp. 9-25). (MindTrek'11). New York, NY: ACM Press. doi:
                    10.1145/2181037.2181040
                    
                  .; DiTommaso, D. (2011). Beyond gamification: Architecting engagement through game design thinking. Retrieved February 9, 2015, from 
                    http://www.slideshare.net/DiTommaso/beyond-gamification-architecting-engagement-through-game-design-thinking
                    
                  .; citation_journal_title=Computers & Education; citation_title=Gamifying learning experiences: Practical implications and outcomes; citation_author=A Dominguez, J Saenz-de-Navarrete, L de-Marcos, L Fernandez-Sanz, C Pages, J-J Martinez-Herraiz; citation_volume=63; citation_publication_date=2013; citation_pages=380-392; citation_doi=10.1016/j.compedu.2012.12.020; citation_id=CR18; citation_journal_title=International Journal of Human-Computer Studies; citation_title=A person-artefact-task (PAT) model of flow antecedents in computer-mediated environments; citation_author=CM Finneran, P Zhang; citation_volume=59; citation_issue=4; citation_publication_date=2003; citation_pages=475-496; citation_doi=10.1016/S1071-5819(03)00112-5; citation_id=CR19; Fitz-Walter, Z. J. (2015). Achievement unlocked: Investigating the design of effective gamification experiences for mobile applications and devices. School of Information Systems; Science & Engineering Faculty. Queensland University of Technology, Brisbane. Ph.D. thesis.; Francisco-Aparicio, A., Gutierrez-Vela, F. L., Isla-Montes, J. L., & Sanchez, J. L. G. (2013). Gamification: Analysis and application. In New trends in interaction, virtual reality and modeling (pp. 113-126). Springer London. doi:
                    10.1007/978-1-4471-5445-7_9
                    
                  .; Gartner. (2013). Gartner's 2013 hype cycle for emerging technologies maps out evolving relationship between humans and machines. Retrieved January 20, 2015, from 
                    http://www.gartner.com/newsroom/id/2575515
                    
                  .; Gartner. (2014). Gartner's 2014 hype cycle for emerging technologies maps the journey to digital business. Retrieved January 20, 2015, from 
                    http://www.gartner.com/newsroom/id/2819918
                    
                  .; Gears, D., & Braun, K. (2013). Gamification in business: Designing motivating solutions to problem situations. In Proceedings of the CHI 2013 workshop; citation_title=Lean UX: Applying lean principles to improve user experience; citation_publication_date=2013; citation_id=CR25; citation_author=J Gothelf; citation_author=J Seiden; citation_publisher=O'Reilly Media, Ed.; citation_journal_title=Journal of Computing in Higher Education; citation_title=Technology and student-centered learning in higher education: Issues and practices; citation_author=MJ Hannafin, SM Land; citation_volume=12; citation_issue=1; citation_publication_date=2000; citation_pages=3-30; citation_doi=10.1007/BF03032712; citation_id=CR26; Harms, J., Wimmer, C., Kappel, K., & Grechenig, T. (2014). Gamification of online surveys: Conceptual foundations and a design process based on the MDA Framework. In Proceedings of the 8th Nordic conference on human-computer interaction: Fun, fast, foundational. Helsinki, Finland (pp. 565-568). New York, NY: ACM. doi:
                    10.1145/2639189.2639230
                    
                  .; Herzig, P. (2014). Gamification as a service. Technische Universitat Dresden, Dresden, Ph.D. Thesis.; Hunicke, R., LeBlanc, M., & Zubek, R. (2004). MDA: A formal approach to game design and game research. In D. Fu & J. Orkin (Eds.) Proceedings of the challenges in Game AI Workshop, nineteenth national conference on artificial intelligence, San Jose, California (p. 4). Menlo Park, CA: AAAI Press.; Jacobs, H. (2013). Gamification: A framework for the workplace. University of Liverpool, Liverpool. Ph.D. dissertation.; Jimenez, S. (2013). Gamification model canvas. Retrieved January 5, 2015, from 
                    http://www.gameonlab.es/canvas/
                    
                  .; citation_title=The NMC Horizon Report: 2014; citation_publication_date=2014; citation_id=CR32; citation_author=L Johnson; citation_author=S Becker; citation_author=V Estrada; citation_author=A Freeman; citation_publisher=New Media Consortium; Julius, K., & Salo, J. (2013). Designing gamification. Marketing. University of Oulu, Oulu. Master's Thesis.; citation_title=The gamification of learning and instruction fieldbook: Ideas into practice; citation_publication_date=2014; citation_id=CR34; citation_author=K Kapp; citation_publisher=Wiley; Kappen, D. L. D., & Nacke, L. E. (2013). The kaleidoscope of effective gamification: Deconstructing gamification in business applications. In 1st international conference on gameful design, research, and applications, gamification 2013 (pp. 119-122). New York, NY: ACM. doi:
                    10.1145/2583008.2583029
                    
                  .; Klock, A., & da Cunha, L. (2015). Gamification in e-learning systems: A conceptual model to engage students and its application in an adaptive e-learning system. In Learning and collaboration technologies (Vol. 9192, pp. 595-607). Berlin: Springer. doi:
                    10.1007/978-3-319-20609-7_56
                    
                  .; citation_journal_title=Gamification in Education and Business; citation_title=A gamification-based framework for developing learning activities of computational thinking; citation_author=I Kotini, S Tzelepi; citation_publication_date=2015; citation_id=CR37; Kumar, J. (2013). Gamification at work: Designing engaging business software. In Design, user experience, and usability. Health, learning, playing, cultural, and cross-cultural user experience (Vol. 8013, pp. 528-537). Berlin: Springer. doi:
                    10.1007/978-3-642-39241-2_58
                    
                  .; Li, C. (2014). Evaluation of a theoretical model for gamification in workplace IS context. University of British Columbia, Vancouver. Doctoral dissertation.; Liu, Y., Alexandrova, T., & Nakajima, T. (2011). Gamifying intelligent environments. In Proceedings of the 2011 international ACM workshop on Ubiquitous meta user interfaces, Scottsdale, AZ. (pp. 7-12). New York, NY: ACM. doi:
                    10.1145/2072652.2072655
                    
                  .; citation_journal_title=SSRN Electronic Journal; citation_title=Towards meaningful engagement: Gamification designs for gameful interaction with information systems; citation_author=D Liu, R Santhanam; citation_volume=8; citation_issue=2; citation_publication_date=2015; citation_pages=128-140; citation_id=CR41; citation_journal_title=Research Synthesis Methods; citation_title=Searching for grey literature for systematic reviews: Challenges and benefits; citation_author=Q Mahood, D Eerd, E Irvin; citation_volume=5; citation_publication_date=2014; citation_pages=221-234; citation_doi=10.1002/jrsm.1106; citation_id=CR42; Manrique, V. (2013). Gamification design framework: The SMA model. Retrieved January 20, 2015, from 
                    http://www.gamasutra.com/blogs/VictorManrique/20130618/194563/Gamification_Design_Framework_The_SMA_Model.php
                    
                  .; Marache-Francisco, C., & Brangier, E. (2013). Process of gamification. From the consideration of gamification to its practical implementation. In Proceeding of the CENTRIC 2013: The sixth international conference on advances in human oriented and personalized mechanisms, technologies, and services, Venice, Italy (pp. 126-131). IARIA XPS Press.; citation_title=Gamification: A simple introduction; citation_publication_date=2013; citation_id=CR45; citation_author=A Marczewski; citation_publisher=Lulu; Marczewski, A. (2014). Gamification design vs game design. Retrieved February 1, 2015, from 
                    http://www.gamified.uk/2014/03/25/gamification-design-vs-game-design/
                    
                  .; Merino de Paz, B. (2013). Gamification: A tool to improve sustainability efforts. University of Manchester, Manchester. Master's Thesis.; Mora, A., Riera, D., Gonzalez, C., & Arnedo-Moreno, J. (2015). A literature review of gamification design frameworks. In Proceedings of 7th international conference on games and virtual worlds for serious applications (VS-Games), Skovde, Sweden (pp. 1-8). IEEE. doi:
                    10.1109/VS-GAMES.2015.7295760
                    
                  .; Mora, A., Zaharias, P., Gonzalez, C., & Arnedo-Moreno, J. (2016). FRAGGLE: A FRamework for AGile Gamification of Learning Experiences, Rome, Italy (pp. 530-539). Berlin: Springer. doi:
                    10.1007/978-3-319-40216-1_57
                    
                  .; Nah, F.-H., Telaprolu, V., Rallapalli, S., & Venkata, P. (2013). Gamification of education using computer games. In S. Yamamoto (Ed.), Human interface and the management of information. Information and interaction for learning, culture, collaboration and business. JOUR, Springer Berlin Heidelberg. doi:
                    10.1007/978-3-642-39226-9_12
                    
                  .; Neeli, B. K. (2015). Gamification in the enterprise: Differences from consumer market, implications, and a method to manage them. In Gamification in education and business (pp. 489-511). Cham: Springer. doi:
                    10.1007/978-3-319-10208-5_25
                    
                  .; Nicholson, S. (2012). A user-centered theoretical framework for meaningful gamification. In Games + Learning + Society 8.0 Conference Proceedings, Madison, WI (pp. 223-230). Pittsburgh, PA: ETC Press.; O'Donovan, S., Gain, J., & Marais, P. (2013). A case study in the gamification of a university-level games development course. In P. Machanick & M. Tsietsi (Eds.), Proceedings of the South African Institute for Computer Scientists and Information Technologists Conference, East London, South Africa (pp. 242-251). New York, NY: ACM. doi:
                    10.1145/2513456.2513469
                    
                  .; citation_title=Business model generation: A handbook for visionaries, game changers, and challengers; citation_publication_date=2010; citation_id=CR54; citation_author=A Osterwalder; citation_author=Y Pigneur; citation_publisher=Wiley; citation_journal_title=Journal of Management Information Systems; citation_title=A design science research methodology for information systems research; citation_author=K Peffers, T Tuunanen, M Rothenberger, S Chatterjee; citation_volume=24; citation_issue=3; citation_publication_date=2007; citation_pages=45-77; citation_doi=10.2753/MIS0742-1222240302; citation_id=CR55; Pelling, N. (2011). The (Short) prehistory of gamification. Funding Startups (& Other Impossibilities). Retrieved January 20, 2015, from 
                    https://nanodome.wordpress.com/2011/08/09/the-short-prehistory-of-gamification/
                    
                  .; citation_title=Drive: The surprising truth about what motivates us; citation_publication_date=2011; citation_id=CR57; citation_author=D Pink; citation_publisher=Penguin Books; Popa, D. M. (2013). Gamification of productivity software: A user-centered design approach. University of Copenhagen, Copenhagen. Master's Thesis.; citation_journal_title=Journal of Gaming & Virtual Worlds; citation_title=Towards gamification transparency: A conceptual framework for the development of responsible gamified enterprise systems; citation_author=M Raftopoulos; citation_volume=6; citation_issue=2; citation_publication_date=2014; citation_pages=159-178; citation_doi=10.1386/jgvw.6.2.159_1; citation_id=CR59; citation_title=Total engagement: How games and virtual worlds are changing the way people work and businesses compete; citation_publication_date=2009; citation_id=CR60; citation_author=B Reeves; citation_author=J Read; citation_publisher=Harvard Business Review Press; citation_journal_title=Business Horizons; citation_title=Is it all a game? Understanding the principles of gamification; citation_author=K Robson, K Plangger, JH Kietzmann, I McCarthy, L Pitt; citation_volume=58; citation_issue=4; citation_publication_date=2015; citation_pages=411-420; citation_doi=10.1016/j.bushor.2015.03.006; citation_id=CR61; Rojas, D., Kapralos, B., & Dubrowski, A. (2014). Gamification for internet based learning in health professions education. In Proceedings of the 14th IEEE international conference on advanced learning technologies, ICALT 2014, Athens, Greece (pp. 281-282). IEEE Computer Society. doi:
                    10.1109/ICALT.2014.87
                    
                  .; citation_journal_title=Technology Innovation Management Review; citation_title=Level up your strategy: Towards a descriptive framework for meaningful enterprise gamification; citation_author=U Ruhi; citation_volume=5; citation_issue=8; citation_publication_date=2015; citation_pages=5-16; citation_id=CR63; citation_journal_title=American Psychologist; citation_title=Self-determination theory and the facilitation of intrinsic motivation, social development, and well-being; citation_author=R Ryan, E Deci; citation_volume=55; citation_issue=1; citation_publication_date=2000; citation_pages=68-78; citation_doi=10.1037/0003-066X.55.1.68; citation_id=CR64; Sakamoto, M., Nakajima, T., & Alexandrova, T. (2012). Value-based design for gamifying daily activities. In 11th international conference on entertainment computing, ICEC 2012, Bremen, Germany (Vol. 7522, pp. 421-424). Springer International Publishing. doi:
                    10.1007/978-3-642-33542-6_43
                    
                  .; citation_title=Rules of play: Game design fundamentals; citation_publication_date=2003; citation_id=CR66; citation_author=K Salen; citation_author=E Zimmerman; citation_publisher=The MIT Press; citation_title=The art of game design: A book of lenses; citation_publication_date=2008; citation_id=CR67; citation_author=J Schell; citation_publisher=Elsevier Inc; Schonen, R. (2014). Gamification in change management processes. Munich University, Munich. Bachelor Thesis.; Shahri, A., Hosseini, M., Phalp, K., Taylor, J., & Ali, R. (2014). Towards a code of ethics for gamification at enterprise. In The practice of enterprise modeling: 7th IFIP WG 8.1 Working Conference, PoEM 2014, Manchester, UK (Vol. 197, pp. 235-245). Berlin: Springer. doi:
                    10.1007/978-3-662-45501-2_17
                    
                  .; citation_journal_title=Computers in Human Behavior; citation_title=A social gamification framework for a K-6 learning platform; citation_author=J Simoes, R Diaz Redondo, A Fernandez Vilas; citation_volume=29; citation_issue=2; citation_publication_date=2012; citation_pages=345-353; citation_doi=10.1016/j.chb.2012.06.007; citation_id=CR70; Tuunanen, J., & Hamari, J. (2012). Meta-synthesis of player typologies. In Proceedings of Nordic Digra 2012 conference: Local and global--Games in culture and society, Tampere, Finland (Vol 10). Digital Games Research Association DiGRA.; Tzouvara, K., & Zaharias, P. (2013). Towards a framework for applying Gamification in Education. In 7th international conference in open and distance learning (ICODL 2013) Athens, Greece.; Vargas-Enriquez, J., Garcia-Mundo, L., Genero, M., & Piattini, M. (2015). Analisis de uso de la gamificacion en la ensenanza de la informatica. Actas de las XXI Jornadas de la Ensenanza Universitaria de la Informatica, Andorra La Vella, Andorra (pp. 105-112). JENUI.; Versteeg, M. (2013). Ethics & Gamification design: A moral framework for taking responsibility. Utrech University, Utrecht. Master's thesis.; citation_title=For the win: How game thinking can revolutionize your business; citation_publication_date=2012; citation_id=CR75; citation_author=K Werbach; citation_author=D Hunter; citation_publisher=Wharton Digital Press; Wongso, O., Rosmansyah, Y., & Bandung, Y. (2015). Gamification framework model, based on social engagement in e-learning 2.0. In Proccedings of the 2nd international conference on technology, informatics, management, engineering and environment (TIME 2014), Bandung, Indonesia (pp. 10-14). IEEE. doi:
                    10.1109/TIME-E.2014.7011583
                    
                  .; citation_journal_title=Cyber Psychology & Behavior; citation_title=Motivations for play in online games; citation_author=N Yee; citation_volume=9; citation_issue=6; citation_publication_date=2007; citation_pages=772-775; citation_doi=10.1089/cpb.2006.9.772; citation_id=CR77; citation_title=Gamification by design: Implementing game mechanics in web and mobile apps; citation_publication_date=2011; citation_id=CR78; citation_author=G Zichermann; citation_author=C Cunningham; citation_publisher=O'Reilly Media Inc"			Excluded	Excluded	new_screen			2	Springer Link		Gamification: a systematic review of design frameworks	http://link.springer.com/article/10.1007/s12528-017-9150-4	Springer Link	nan; Pages; Year; Bibtex
424	Behave	Getting Coaching That Really Helps	We examine the current state of Agile coaching, which relies on the flawed shu-ha-ri model. As an alternative, we look back to the International Institute of Rural Reconstruction and James Yen's work with poor Chinese villagers for a less patronizing, more effective coaching worldview. We also show how the various certification programs in the Agile world tend to reinforce mechanical knowledge and behavior.	Enterprise Architecture; Training Class; User Story; Agile Practice; Product Owner	Kulak, Daryl; Li, Hong	The Journey to Enterprise Agility	https://doi.org/10.1007/978-3-319-54087-0_13		197--209	"""@Inbook{Kulak2017,
    author = ""Kulak, Daryl and Li, Hong"",
    title = ""Getting Coaching That Really Helps"",
    bookTitle = ""The Journey to Enterprise Agility: Systems Thinking and Organizational Legacy"",
    year = ""2017"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""197--209"",
    abstract = ""We examine the current state of Agile coaching, which relies on the flawed shu-ha-ri model. As an alternative, we look back to the International Institute of Rural Reconstruction and James Yen's work with poor Chinese villagers for a less patronizing, more effective coaching worldview. We also show how the various certification programs in the Agile world tend to reinforce mechanical knowledge and behavior."",
    isbn = ""978-3-319-54087-0"",
    doi = ""10.1007/978-3-319-54087-0\_13"",
    url = ""https://doi.org/10.1007/978-3-319-54087-0\_13""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Getting Coaching That Really Helps	http://link.springer.com/chapter/10.1007/978-3-319-54087-0_13	Springer International Publishing	nan; References
425	Behave	Getting Started	http://link.springer.com/chapter/10.1007/978-1-4842-7289-3_1		Shashank Shukla		https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2585239/				Excluded	Excluded	new_screen			2	Pub Med Central		Getting Started	https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2585239/		nan; Venue; Authors; Abstract; Keywords; References; Pages; Year; Bibtex; DOI; Publisher
426	Behave	Getting Started with Selenium and Visual Studio			Chaminda ChandrasekaraPushpa Herath						Excluded	Excluded	new_screen			2						
427	Behave	Getting Started with Test-Driven Development	This chapter introduces the basic concepts of Test-Driven Development in Swift with XCTest by implementing the leap year evaluation algorithm. You'll learn how to practice the Red, green, refactor cycle, about the Test List, Fake It, and Wishful Coding patterns, and how the compiler fits in the TDD workflow.		Lodi, Gio	Test-Driven Development in Swift	https://doi.org/10.1007/978-1-4842-7002-8_3		27--42	"""@Inbook{Lodi2021,
    author = ""Lodi, Gio"",
    title = ""Getting Started with Test-Driven Development"",
    bookTitle = ""Test-Driven Development in Swift: Compile Better Code with XCTest and TDD"",
    year = ""2021"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""27--42"",
    abstract = ""This chapter introduces the basic concepts of Test-Driven Development in Swift with XCTest by implementing the leap year evaluation algorithm. You'll learn how to practice the Red, green, refactor cycle, about the Test List, Fake It, and Wishful Coding patterns, and how the compiler fits in the TDD workflow."",
    isbn = ""978-1-4842-7002-8"",
    doi = ""10.1007/978-1-4842-7002-8\_3"",
    url = ""https://doi.org/10.1007/978-1-4842-7002-8\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Getting Started with Test-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-7002-8_3	Apress	nan; Keywords; References
428	Behave	Groovy Awesomeness	This short chapter introduces various useful frameworks within the Groovy ecosystem. Some of these will be described more fully in later chapters.	Cloud Computing; Maintenance Mode; Static Code Analysis; Java Project; Instal Programming	Davis, Adam L.	Learning Groovy	https://doi.org/10.1007/978-1-4842-2117-4_11		61--64	"""@Inbook{Davis2016,
    author = ""Davis, Adam L."",
    title = ""Groovy Awesomeness"",
    bookTitle = ""Learning Groovy"",
    year = ""2016"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""61--64"",
    abstract = ""This short chapter introduces various useful frameworks within the Groovy ecosystem. Some of these will be described more fully in later chapters."",
    isbn = ""978-1-4842-2117-4"",
    doi = ""10.1007/978-1-4842-2117-4\_11"",
    url = ""https://doi.org/10.1007/978-1-4842-2117-4\_11""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Groovy Awesomeness	http://link.springer.com/chapter/10.1007/978-1-4842-2117-4_11	Apress	nan; References
429	Behave	Hamcrest vs AssertJ: An Empirical Assessment of Tester Productivity	Context. Extensive unit testing is worth its costs in terms of the higher quality of the final product and reduced development expenses, though it may consume more than fifty percent of the overall project budget. Thus, even a tiny percentage of saving can significantly decrease the costs. Since recently competing assertion libraries emerged, we need empirical evidence to gauge them in terms of developer productivity, allowing SQA Managers and Testers to select the best.	Hamcrest; AssertJ; Empirical study	Leotta, Maurizio; Cerioli, Maura; Olianas, Dario; Ricca, Filippo	International Conference on the Quality of Information and Communications Technology	https://doi.org/10.1007/978-3-030-29238-6_12		161--176	"""@InProceedings{10.1007/978-3-030-29238-6_12,
    author = ""Leotta, Maurizio and Cerioli, Maura and Olianas, Dario and Ricca, Filippo"",
    editor = ""Piattini, Mario and Rupino da Cunha, Paulo and Garc{\'i}a Rodr{\'i}guez de Guzm{\'a}n, Ignacio and P{\'e}rez-Castillo, Ricardo"",
    title = ""Hamcrest vs AssertJ: An Empirical Assessment of Tester Productivity"",
    booktitle = ""Quality of Information and Communications Technology"",
    year = ""2019"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""161--176"",
    abstract = ""Context. Extensive unit testing is worth its costs in terms of the higher quality of the final product and reduced development expenses, though it may consume more than fifty percent of the overall project budget. Thus, even a tiny percentage of saving can significantly decrease the costs. Since recently competing assertion libraries emerged, we need empirical evidence to gauge them in terms of developer productivity, allowing SQA Managers and Testers to select the best."",
    isbn = ""978-3-030-29238-6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Hamcrest vs AssertJ: An Empirical Assessment of Tester Productivity	http://link.springer.com/chapter/10.1007/978-3-030-29238-6_12	Springer International Publishing	nan; References
430	Behave	How Do Software Architects Specify and Validate Quality Requirements?			Andrea CaraccioloMircea Filip LunguOscar Nierstrasz						Excluded	Excluded	new_screen			2						
431	Behave	ICITPM: Integrity Validation of Software in Iterative Continuous Integration Through the Use of Trusted Platform Module (TPM)	Software development has passed from being rigid and not very flexible, to be automated with constant changes. This happens due to the creation of continuous integration and delivery environments. Nevertheless, developers often rely on such environments due to the large number of amenities they offer. They focus on authentication only, without taking into consideration other aspects of security such as the integrity of the source code and of the compiled binaries. The source code of a software project must not be maliciously modified. Notwithstanding, there is no safe method to verify that its integrity has not been violated. Trusted computing technology, in particular, the Trusted Platform Module (TPM) can be used to implement that secure method.	CI/CD pipeline; Code integrity; Trusted computing; TPM	Mu{\~{n}}oz, Antonio; Farao, Aristeidis; Correia, Jordy Ryan Casas; Xenakis, Christos	European Symposium on Research in Computer Security	https://doi.org/10.1007/978-3-030-66504-3_9		147--165	"""@InProceedings{10.1007/978-3-030-66504-3_9,
    author = ""Mu{\\textasciitilde {n}}oz, Antonio and Farao, Aristeidis and Correia, Jordy Ryan Casas and Xenakis, Christos"",
    editor = {Boureanu, Ioana and Dr{\u{a}}gan, Constantin C{\u{a}}t{\u{a}}lin and Manulis, Mark and Giannetsos, Thanassis and Dadoyan, Christoforos and Gouvas, Panagiotis and Hallman, Roger A. and Li, Shujun and Chang, Victor and Pallas, Frank and Pohle, J{\""o}rg and Sasse, Angela},
    title = ""ICITPM: Integrity Validation of Software in Iterative Continuous Integration Through the Use of Trusted Platform Module (TPM)"",
    booktitle = ""Computer Security"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""147--165"",
    abstract = ""Software development has passed from being rigid and not very flexible, to be automated with constant changes. This happens due to the creation of continuous integration and delivery environments. Nevertheless, developers often rely on such environments due to the large number of amenities they offer. They focus on authentication only, without taking into consideration other aspects of security such as the integrity of the source code and of the compiled binaries. The source code of a software project must not be maliciously modified. Notwithstanding, there is no safe method to verify that its integrity has not been violated. Trusted computing technology, in particular, the Trusted Platform Module (TPM) can be used to implement that secure method."",
    isbn = ""978-3-030-66504-3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		ICITPM: Integrity Validation of Software in Iterative Continuous Integration Through the Use of Trusted Platform Module (TPM)	https://link.springer.com/chapter/10.1007/978-3-030-66504-3_9	Springer International Publishing	nan; References
432	Behave	Implement Tests in Our Daily Work Routine	We discussed many types of tests -- unit, integration, performance, UI, and snapshot tests. But if you ask me what the most challenging task in writing tests is, I would say actually writing them.		Tsadok, Avi	Pro iOS Testing	https://doi.org/10.1007/978-1-4842-6382-2_10		261--283	"""@Inbook{Tsadok2020,
    author = ""Tsadok, Avi"",
    title = ""Implement Tests in Our Daily Work Routine"",
    bookTitle = ""Pro iOS Testing: XCTest Framework for UI and Unit Testing"",
    year = ""2020"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""261--283"",
    abstract = ""We discussed many types of tests -- unit, integration, performance, UI, and snapshot tests. But if you ask me what the most challenging task in writing tests is, I would say actually writing them."",
    isbn = ""978-1-4842-6382-2"",
    doi = ""10.1007/978-1-4842-6382-2\_10"",
    url = ""https://doi.org/10.1007/978-1-4842-6382-2\_10""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Implement Tests in Our Daily Work Routine	https://link.springer.com/chapter/10.1007/978-1-4842-6382-2_10	Apress	nan; Keywords; References
433	Behave	In the right order of brush strokes: a sketch of a software philosophy retrospective	This paper follows a discourse on software recognized as a product of art and human creativity progressing probably for as long as software exists. A retrospective view on computer science and software philosophy development is introduced. In so doing we discover parallels between software and various branches of human creative manifestations. Aesthetic properties and mutual dependency of the form and matter of art works are examined in their application to software programs. While exploring some philosophical and even artistic reflection on software we consider extended comprehension of technical sciences of programming and software engineering within the realm of liberal arts.	Artificial Intelligence; Software philosophy; Art; Software aesthetics; Liberal arts; Computer science education	Evgeny Pyshkin	SpringerPlus	https://doi.org/10.1186/2193-1801-3-186	citation_title=Thinking about programming: from Aristotle to Wittgenstein; citation_inbook_title=Software engineering conference in Russia (CEE-SECR), 2012 8th Central and Eastern European; citation_publication_date=2012; citation_id=CR1; citation_author=S Arkhipenkov; citation_publisher=Moscow; citation_journal_title=Softw IEEE; citation_title=Aim, fire [test-first coding]; citation_author=K Beck; citation_volume=18; citation_issue=5; citation_publication_date=2001; citation_pages=87-89; citation_doi=10.1109/52.951502; citation_id=CR2; citation_title=The philosophy of software; citation_publication_date=2011; citation_id=CR3; citation_author=DM Berry; citation_publisher=Palgrave Macmillan; citation_journal_title=Commun ACM; citation_title=Software as art; citation_author=GW Bond; citation_volume=48; citation_issue=8; citation_publication_date=2005; citation_pages=118-124; citation_doi=10.1145/1076211.1076215; citation_id=CR4; citation_title=Chapter III: Hierarchical program structures; citation_inbook_title=Structured Programming; citation_publication_date=1972; citation_id=CR5; citation_author=OJ Dahl; citation_author=CAR Hoare; citation_publisher=Academic Press Ltd.; citation_journal_title=IEEE Softw; citation_title=Software engineering: an idea whose time has come and gone; citation_author=T DeMarco; citation_volume=26; citation_issue=4; citation_publication_date=2009; citation_pages=95-96; citation_doi=10.1109/MS.2009.101; citation_id=CR6; citation_title=A discipline of programming; citation_publication_date=1976; citation_id=CR7; citation_author=EW Dijkstra; citation_publisher=Prentice-Hall; citation_journal_title=Minds Mach; citation_title=Three paradigms of computer science; citation_author=AH Eden; citation_volume=17; citation_issue=2; citation_publication_date=2007; citation_pages=135-167; citation_doi=10.1007/s11023-007-9060-8; citation_id=CR8; citation_journal_title=Front Artif Intell Appl; citation_title=The art of programming or programs as art; citation_author=E Edmonds; citation_volume=161; citation_publication_date=2007; citation_pages=119; citation_id=CR9; citation_journal_title=Commun ACM; citation_title=Aesthetics and the human factor in programming; citation_author=AP Ershov; citation_volume=15; citation_issue=7; citation_publication_date=1972; citation_pages=501-505; citation_doi=10.1145/361454.361458; citation_id=CR10; citation_title=Analiz prostranstvennosti v khudozhestvennykh proizvedeniyakh; citation_inbook_title=; citation_journal_title=Minds Mach; citation_title=Problems for a philosophy of software engineering; citation_author=S Gruner; citation_volume=21; citation_issue=2; citation_publication_date=2011; citation_pages=275-299; citation_doi=10.1007/s11023-011-9234-2; citation_id=CR12; citation_title=Listen; citation_inbook_title=The Princeton encyclopedia of poetry and poetics, 4th ed., vol 2012; citation_publication_date=1995; citation_pages=396-397; citation_id=CR13; citation_author=S Hopkins; citation_publisher=Princeton University Press; citation_title=Lost Japan; citation_publication_date=1996; citation_id=CR14; citation_author=A Kerr; citation_publisher=Lonely Planet; citation_journal_title=Commun ACM; citation_title=Computer programming as an art; citation_author=DE Knuth; citation_volume=17; citation_issue=12; citation_publication_date=1974; citation_pages=667-673; citation_doi=10.1145/361604.361612; citation_id=CR15; citation_journal_title=Comput J; citation_title=Literate programming; citation_author=; citation_volume=27; citation_issue=2; citation_publication_date=1984; citation_pages=97-111; citation_doi=10.1093/comjnl/27.2.97; citation_id=CR16; citation_title=Things a computer scientist rarely talks about; citation_publication_date=2001; citation_id=CR17; citation_author=DE Knuth; citation_publisher=CSLI Publications; citation_title=Aesthetics in software engineering; citation_inbook_title=Tech. rep.,; citation_publication_date=2006; citation_id=CR18; citation_author=BJ MacLennan; citation_journal_title=Mod Lang Notes; citation_title=Matter and manner in literary composition; citation_author=JG McElroy; citation_volume=3; citation_publication_date=1888; citation_pages=29-33; citation_doi=10.2307/2918451; citation_id=CR19; citation_title=The art of software testing; citation_publication_date=2011; citation_id=CR20; citation_author=GJ Myers; citation_author=C Sandler; citation_author=T Badgett; citation_publisher=Wiley; citation_journal_title=J Gen Philos Sci; citation_title=Towards a philosophy of software development: 40 years after the birth of software engineering; citation_author=M Northover, DG Kourie, A Boake, S Gruner, A Northover; citation_volume=39; citation_issue=1; citation_publication_date=2008; citation_pages=85-113; citation_doi=10.1007/s10838-008-9068-7; citation_id=CR21; citation_title=Programming as a best creative specialty; citation_publication_date=1997; citation_id=CR22; citation_author=R O'Bower; citation_title=Beautiful code: leading programmers explain how they think; citation_publication_date=2007; citation_id=CR23; citation_author=A Oram; citation_author=G Wilson; citation_publisher=O'Reilly Media, Inc.; citation_title=La vie mode d'emploi; citation_publication_date=1978; citation_id=CR24; citation_author=G Perec; citation_publisher=Hachette; citation_title=The zen of python; citation_inbook_title=Available from any Python interpreter by typing import this; citation_publication_date=2004; citation_id=CR25; citation_author=T Peters; citation_title=Teaching programming: What we miss in academia; citation_inbook_title=Software engineering conference in Russia (CEE-SECR), 2011 7th Central and Eastern European; citation_publication_date=2011; citation_pages=1-6; citation_id=CR26; citation_author=E Pyshkin; citation_publisher=IEEE Computer Society; citation_journal_title=Educom Rev; citation_title=Information literacy as a liberal art?; citation_author=JJ Shapiro, SK Hughes; citation_volume=31; citation_publication_date=1996; citation_pages=31-35; citation_id=CR27; citation_inbook_title=Creative project invites developers to write 'code poems'; citation_publication_date=2012; citation_id=CR28; citation_author=O Solon; citation_journal_title=Trans Comput Educ; citation_title=Computer science and the liberal arts: a philosophical examination; citation_author=M Walker, C Kelemen; citation_volume=10; citation_issue=1; citation_publication_date=2009; citation_pages=2:1-2:10; citation_id=CR29; citation_journal_title=Commun ACM; citation_title=Computational thinking; citation_author=JM Wing; citation_volume=49; citation_issue=3; citation_publication_date=2006; citation_pages=33-35; citation_doi=10.1145/1118178.1118215; citation_id=CR30; citation_title=Inner vision: an exploration of art and the brain, vol 415; citation_publication_date=1999; citation_id=CR31; citation_author=S Zeki; citation_author=J Nash; citation_publisher=Oxford University Press			Excluded	Excluded	new_screen			2	Springer Link		In the right order of brush strokes: a sketch of a software philosophy retrospective	http://link.springer.com/article/10.1186/2193-1801-3-186	Springer Link	nan; Pages; Year; Bibtex
434	Behave	Incident Management Adaption	Whenever somebody refers to IT service management or ITIL, the first process that comes up on the table for discussion is the incident management process. No matter how far away one might be from the service management area, they always seem to be quite familiar with the process and its relevance. It is a highly popular process that finds its rightful place in every single organization. Since this process makes or breaks an organization's service delivery, service providers often give plenty of weight to the process, and as a result, the incident management process is perhaps the most mature of all the ITIL processes.		Krishna Kaiser, Abhinav	Reinventing ITIL(r) in the Age of DevOps	https://doi.org/10.1007/978-1-4842-3976-6_7		163--199	"""@Inbook{KrishnaKaiser2018,
    author = ""Krishna Kaiser, Abhinav"",
    title = ""Incident Management Adaption"",
    bookTitle = ""Reinventing ITIL(r) in the Age of DevOps: Innovative Techniques to Make Processes Agile and Relevant"",
    year = ""2018"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""163--199"",
    abstract = ""Whenever somebody refers to IT service management or ITIL, the first process that comes up on the table for discussion is the incident management process. No matter how far away one might be from the service management area, they always seem to be quite familiar with the process and its relevance. It is a highly popular process that finds its rightful place in every single organization. Since this process makes or breaks an organization's service delivery, service providers often give plenty of weight to the process, and as a result, the incident management process is perhaps the most mature of all the ITIL processes."",
    isbn = ""978-1-4842-3976-6"",
    doi = ""10.1007/978-1-4842-3976-6\_7"",
    url = ""https://doi.org/10.1007/978-1-4842-3976-6\_7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Incident Management Adaption	http://link.springer.com/chapter/10.1007/978-1-4842-3976-6_7	Apress	nan; Keywords; References
435	Behave	Index									Excluded	Excluded	new_screen			2						
436	Behave	Industry practices and challenges for the evolvability assurance of microservices	ContextMicroservices as a lightweight and decentralized architectural style with fine-grained services promise several beneficial characteristics for sustainable long-term software evolution. Success stories from early adopters like Netflix, Amazon, or Spotify have demonstrated that it is possible to achieve a high degree of flexibility and evolvability with these systems. However, the described advantageous characteristics offer no concrete guidance and little is known about evolvability assurance processes for microservices in industry as well as challenges in this area. Insights into the current state of practice are a very important prerequisite for relevant research in this field.ObjectiveWe therefore wanted to explore how practitioners structure the evolvability assurance processes for microservices, what tools, metrics, and patterns they use, and what challenges they perceive for the evolvability of their systems.MethodWe first conducted 17 semi-structured interviews and discussed 14 different microservice-based systems and their assurance processes with software professionals from 10 companies. Afterwards, we performed a systematic grey literature review (GLR) and used the created interview coding system to analyze 295 practitioner online resources.ResultsThe combined analysis revealed the importance of finding a sensible balance between decentralization and standardization. Guidelines like architectural principles were seen as valuable to ensure a base consistency for evolvability and specialized test automation was a prevalent theme. Source code quality was the primary target for the usage of tools and metrics for our interview participants, while testing tools and productivity metrics were the focus of our GLR resources. In both studies, practitioners did not mention architectural or service-oriented tools and metrics, even though the most crucial challenges likeService CuttingorMicroservices Integrationwere of an architectural nature.ConclusionsPractitioners relied on guidelines, standardization, or patterns likeEvent-Driven Messagingto partially address some reported evolvability challenges. However, specialized techniques, tools, and metrics are needed to support industry with the continuous evaluation of service granularity and dependencies. Future microservices research in the areas of maintenance, evolution, and technical debt should take our findings and the reported industry sentiments into account.	Artificial Intelligence; Microservices; Evolvability; Assurance; Industry; Interviews; Grey literature review	Justus Bogner; Jonas Fritzsch; Stefan Wagner; Alfred Zimmermann	Empirical Software Engineering	https://doi.org/10.1007/s10664-021-09999-9	"citation_journal_title=J Softw Maint Evol Res Pract; citation_title=Software maintenance maturity model (SMmm): the software maintenance process model; citation_author=A April, J Huffman Hayes, A Abran, R Dumke; citation_volume=17; citation_issue=3; citation_publication_date=2005; citation_pages=197-223; citation_doi=10.1002/smr.311; citation_id=CR1; citation_journal_title=Dagstuhl Rep.; citation_title=Managing technical debt in software engineering; citation_author=P Avgeriou, P Kruchten, I Ozkaya, C Seaman; citation_volume=6; citation_issue=4; citation_publication_date=2016; citation_pages=110-138; citation_id=CR2; Bandeira A, Medeiros C A, Paixao M, Maia PH (2019) We need to talk about microservices: an analysis from the discussions on stackoverflow. In: 2019 IEEE/ACM 16th international conference on mining software repositories, (MSR) IEEE, pp 255-259. 
                  https://doi.org/10.1109/MSR.2019.00051; citation_journal_title=J Comput Inf Syst; citation_title=Architecting microservices: Practical opportunities and challenges; citation_author=S Baskarada, V Nguyen, A Koronios; citation_volume=00; citation_issue=00; citation_publication_date=2018; citation_pages=1-9; citation_id=CR4; Bogner J, Wagner S, Zimmermann A (2017) Automatically measuring the maintainability of service- and microservice-based systems: a literature review. In: Proceedings of the 27th international workshop on software measurement and 12th international conference on software process and product measurement on - IWSM Mensura '17, ACM Press, New York, New York, USA, pp 107-115. 
                  https://doi.org/10.1145/3143434.3143443; Bogner J, Fritzsch J, Wagner S, Zimmermann A (2018) Limiting technical debt with maintainability assurance: An industry survey on used techniques and differences with service- and microservice-based systems. In: Proceedings of the 2018 international conference on technical debt - TechDebt '18, ACM Press, New York, New York, USA, pp 125-133. 
                  https://doi.org/10.1145/3194164.3194166; Bogner J, Fritzsch J, Wagner S, Zimmermann A (2019a) Assuring the evolvability of microservices: Insights into industry practices and challenges. In: 2019 IEEE International conference on software maintenance and evolution (ICSME), IEEE, Cleveland, Ohio, USA, pp 546-556. 
                  https://doi.org/10.1109/ICSME.2019.00089; Bogner J, Fritzsch J, Wagner S, Zimmermann A (2019b) Microservices in industry: Insights into technologies, characteristics, and software quality. In: 2019 IEEE international conference on software architecture companion (ICSA-C), IEEE, Hamburg, Germany, pp 187-195. 
                  https://doi.org/10.1109/ICSA-C.2019.00041; Carrasco A, van Bladel B, Demeyer S (2018) Migrating towards microservices: migration and architecture smells. In: Proceedings of the 2nd international workshop on refactoring - IWoR, 2018, ACM Press, New York, New York, USA, pp 1-6. 
                  https://doi.org/10.1145/3242163.3242164; citation_journal_title=Educ Psychol Meas; citation_title=A coefficient of agreement for nominal scales; citation_author=J Cohen; citation_volume=20; citation_issue=1; citation_publication_date=1960; citation_pages=37-46; citation_doi=10.1177/001316446002000104; citation_id=CR10; Easterbrook S, Singer J, Storey MA, Damian D (2008) Selecting empirical methods for software engineering research. In: Guide to advanced empirical software engineering, Springer London, London, pp 285-311 
                  https://doi.org/10.1007/978-1-84800-044-5_11; citation_journal_title=Queue; citation_title=Tracking and controlling microservice dependencies; citation_author=S Esparrachiari, T Reilly, A Rentz; citation_volume=16; citation_issue=4; citation_publication_date=2018; citation_pages=44-65; citation_doi=10.1145/3277539.3277541; citation_id=CR12; Fowler M (2019) Microservices resource guide. 
                  http://martinfowler.com/microservices; Fritzsch J, Bogner J, Wagner S, Zimmermann A (2019a) Microservices migration in industry: Intentions, strategies, and challenges. In: 2019 IEEE International conference on software maintenance and evolution (ICSME), IEEE, Cleveland, Ohio, USA, pp 481-490. 
                  https://doi.org/10.1109/ICSME.2019.00081; Fritzsch J, Bogner J, Zimmermann A, Wagner S (2019b) From monolith to microservices: A classification of refactoring approaches. In: Bruel JM, Mazzara M, Meyer B (eds) Software engineering aspects of continuous development and new paradigms of software production and deployment. 
                  https://doi.org/10.1007/978-3-030-06019-0_10
                  
                . Springer, Toulouse, pp 128-141; Garousi V, Felderer M, Mantyla MV (2016) The need for multivocal literature reviews in software engineering. In: Proceedings of the 20th international conference on evaluation and assessment in software engineering - EASE '16, ACM Press, New York, New York, USA, vol 01-03-June, pp 1-6 
                  https://doi.org/10.1145/2915970.2916008; citation_journal_title=Inf Softw Technol; citation_title=Guidelines for including grey literature and conducting multivocal literature reviews in software engineering; citation_author=V Garousi, M Felderer, MV Mantyla; citation_volume=106; citation_issue=September 2018; citation_publication_date=2019; citation_pages=101-121; citation_doi=10.1016/j.infsof.2018.09.006; citation_id=CR17; Ghofrani J, Lubke D (2018) Challenges of microservices architecture: A survey on the state of the practice. In: 10th Central European workshop on services and their composition (ZEUS), CEUR-WS.org, Dresden, Germany, vol 10th; Haselbock S, Weinreich R, Buchgeher G (2018) An expert interview study on areas of microservice design; Hove S, Anda B (2005) Experiences from conducting semi-structured interviews in empirical software engineering research. In: 11th IEEE international software metrics symposium (METRICS'05), IEEE, Metrics, pp 23-23. 
                  https://doi.org/10.1109/METRICS.2005.24; citation_journal_title=Biometrics; citation_title=The measurement of observer agreement for categorical data; citation_author=JR Landis, GG Koch; citation_volume=33; citation_issue=1; citation_publication_date=1977; citation_pages=159; citation_doi=10.2307/2529310; citation_id=CR21; citation_journal_title=Proc. IEEE; citation_title=Programs, life cycles, and laws of software evolution; citation_author=M Lehman; citation_volume=68; citation_issue=9; citation_publication_date=1980; citation_pages=1060-1076; citation_doi=10.1109/PROC.1980.11805; citation_id=CR22; Lenarduzzi V, Taibi D (2018) Microservices, Continuous Architecture, and Technical Debt Interest: An Empirical Study. In: Euromicro SEAA Prague, Czech Republic, June; Neri D, Soldani J, Zimmermann O, Brogi A (2019) Design principles, architectural smells and refactorings for microservices: a multivocal review. SICS Software-Intensive Cyber-Physical Systems. 
                  https://doi.org/10.1007/s00450-019-00407-8
                  
                , 
                  1906.01553; Neto GTG, Santos WB, Endo PT, Fagundes RA (2019) Multivocal literature reviews in software engineering: Preliminary findings from a tertiary study. In: 2019 ACM/IEEE International symposium on empirical software engineering and measurement (ESEM), IEEE, vol 2019-Septe, pp 1-6 
                  https://doi.org/10.1109/ESEM.2019.8870142; citation_title=Building Microservices: Designing Fine-Grained Systems; citation_publication_date=2015; citation_id=CR26; citation_author=S Newman; citation_publisher=O'Reilly Media Sebastopol; citation_journal_title=J Softw Evol Process; citation_title=Five recommendations for software evolvability; citation_author=V Rajlich; citation_volume=30; citation_issue=9; citation_publication_date=2018; citation_pages=e1949; citation_doi=10.1002/smr.1949; citation_id=CR27; Rowe D, Leaney J, Lowe D (1998) Defining systems architecture evolvability - a taxonomy of change. In: International conference on the engineering of computer-based systems, IEEE, pp 45-52 
                  https://doi.org/10.1109/ECBS.1998.10027; citation_journal_title=Emp Softw Eng; citation_title=Guidelines for conducting and reporting case study research in software engineering; citation_author=P Runeson, M Host; citation_volume=14; citation_issue=2; citation_publication_date=2009; citation_pages=131-164; citation_doi=10.1007/s10664-008-9102-8; citation_id=CR29; Schermann G, Cito J, Leitner P (2016) All the services large and micro: Revisiting industrial practice in services computing. In: Norta A, Gaaloul W, Gangadharan GR, Dam HK (eds) Lecture notes in computer science (including subseries lecture notes in artificial intelligence and lecture notes in bioinformatics), lecture notes in computer science. 
                  https://doi.org/10.1007/978-3-662-50539-7_4
                  
                , vol 9586. Springer, Berlin, pp 36-47; Seaman CB (2008) Qualitative methods. In: Guide to advanced empirical software engineering. 
                  https://doi.org/10.1007/978-1-84800-044-5_2
                  
                . Springer, London, pp 35-62; Software Engineering Institute (2010) CMMI(r); for Development, Version 1.3 (CMMI-DEV V1.3). Tech. rep. Software Engineering Institute; citation_journal_title=J Syst Softw; citation_title=The pains and gains of microservices: A Systematic grey literature review; citation_author=J Soldani, DA Tamburri, WJ Den Heuvel; citation_volume=146; citation_issue=September; citation_publication_date=2018; citation_pages=215-232; citation_doi=10.1016/j.jss.2018.09.082; citation_id=CR33; Taibi D, Lenarduzzi V, Pahl C (2020) Microservices anti-patterns: A taxonomy, Springer International Publishing, Cham. 
                  https://doi.org/10.1007/978-3-030-31646-4_5
                  
                , 
                  1908.04101; citation_title=Software Product Quality Control; citation_publication_date=2013; citation_id=CR35; citation_author=S Wagner; citation_publisher=Springer; Wohlin C, Host M, Henningsson K (2003) Empirical research methods in software engineering. In: Esernet. 
                  https://doi.org/10.1007/978-3-540-45143-3_2
                  
                , vol 2765. Springer, Berlin, pp 7-23"			Excluded	Excluded	new_screen			2	Springer Link		Industry practices and challenges for the evolvability assurance of microservices	https://link.springer.com/article/10.1007/s10664-021-09999-9	Springer Link	nan; Pages; Year; Bibtex
437	Behave	InstAL: An Institutional Action Language	InstAL denotes both a declarative domain-specific language for the specification of collections of interacting normative systems and a framework for a set of associated tools. The computational model is realized by translating the specification language to AnsProlog (Baral 2003), a logic programming language under the answer set semantics (ASP) (Gelfond and Lifschitz 1991), and is underpinned by a set-theoretic formal model and a formalized translation process.	AnsProlog; Answer Set; Declarative Domain-specific Languages; Tendency Scenario; Clingo	Padget, Julian; ElDeen Elakehal, Emad; Li, Tingting; De Vos, Marina	Social Coordination Frameworks for Social Technical Systems	https://doi.org/10.1007/978-3-319-33570-4_6		101--124	"""@Inbook{Padget2016,
    author = ""Padget, Julian and ElDeen Elakehal, Emad and Li, Tingting and De Vos, Marina"",
    editor = ""Aldewereld, Huib and Boissier, Olivier and Dignum, Virginia and Noriega, Pablo and Padget, Julian"",
    title = ""InstAL: An Institutional Action Language"",
    bookTitle = ""Social Coordination Frameworks for Social Technical Systems"",
    year = ""2016"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""101--124"",
    abstract = ""InstAL denotes both a declarative domain-specific language for the specification of collections of interacting normative systems and a framework for a set of associated tools. The computational model is realized by translating the specification language to AnsProlog (Baral 2003), a logic programming language under the answer set semantics (ASP) (Gelfond and Lifschitz 1991), and is underpinned by a set-theoretic formal model and a formalized translation process."",
    isbn = ""978-3-319-33570-4"",
    doi = ""10.1007/978-3-319-33570-4\_6"",
    url = ""https://doi.org/10.1007/978-3-319-33570-4\_6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		InstAL: An Institutional Action Language	http://link.springer.com/chapter/10.1007/978-3-319-33570-4_6	Springer International Publishing	nan; References
438	Behave	Installing Quick	If you have been for a few years, chances are that you have been brought on to add new features to an existing app with a large code base that has been built over a few years and has been worked on by dozens of developers, most of whom have moved on to other projects.		Mishra, Abhishek	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_11		329--349	"""@Inbook{Mishra2017,
    author = ""Mishra, Abhishek"",
    title = ""Installing Quick"",
    bookTitle = ""iOS Code Testing: Test-Driven Development and Behavior-Driven Development with Swift"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""329--349"",
    abstract = ""If you have been for a few years, chances are that you have been brought on to add new features to an existing app with a large code base that has been built over a few years and has been worked on by dozens of developers, most of whom have moved on to other projects."",
    isbn = ""978-1-4842-2689-6"",
    doi = ""10.1007/978-1-4842-2689-6\_11"",
    url = ""https://doi.org/10.1007/978-1-4842-2689-6\_11""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Installing Quick	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_11	Apress	nan; Keywords; References
439	Behave	Integrating Quality Tooling into the Chef Development Life Cycle	The Chef ecosystem is fortunate to have many tools available to it to help in the quest for quality. This chapter introduces some of the tools that are publicly available to help. Eventually we will be using these tools as part of a Continuous Delivery pipeline, and it is important to get an understanding of how each tool can be executed individually.	Acceptance Test; Configuration File; Text Editor; Special Symbol; Code Coverage	Preston, Stuart	Using Chef with Microsoft Azure	https://doi.org/10.1007/978-1-4842-1476-3_6		131--162	"""@Inbook{Preston2016,
    author = ""Preston, Stuart"",
    title = ""Integrating Quality Tooling into the Chef Development Life Cycle"",
    bookTitle = ""Using Chef with Microsoft Azure"",
    year = ""2016"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""131--162"",
    abstract = ""The Chef ecosystem is fortunate to have many tools available to it to help in the quest for quality. This chapter introduces some of the tools that are publicly available to help. Eventually we will be using these tools as part of a Continuous Delivery pipeline, and it is important to get an understanding of how each tool can be executed individually."",
    isbn = ""978-1-4842-1476-3"",
    doi = ""10.1007/978-1-4842-1476-3\_6"",
    url = ""https://doi.org/10.1007/978-1-4842-1476-3\_6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Integrating Quality Tooling into the Chef Development Life Cycle	https://link.springer.com/chapter/10.1007/978-1-4842-1476-3_6	Apress	nan; References
440	Behave	Integration of Security Standards in DevOps Pipelines: An Industry Case Study	In the last decade, companies adopted DevOps as a fast path to deliver software products according to customer expectations, with well aligned teams and in continuous cycles. As a basic practice, DevOps relies on pipelines that simulate factory swim-lanes. The more automation in the pipeline, the shorter a lead time is supposed to be. However, applying DevOps is challenging, particularly for industrial control systems (ICS) that support critical infrastructures and that must obey to rigorous requirements from security regulations and standards. Current research on security compliant DevOps presents open gaps for this particular domain and in general for systematic application of security standards. In this paper, we present a systematic approach to integrate standard-based security activities into DevOps pipelines and highlight their automation potential. Our intention is to share our experiences and help practitioners to overcome the trade-off between adding security activities into the development process and keeping a short lead time. We conducted an evaluation of our approach at a large industrial company considering the IEC 62443-4-1 security standard that regulates ICS. The results strengthen our confidence in the usefulness of our approach and artefacts, and in that they can support practitioners to achieve security compliance while preserving agility including short lead times.	Secure software engineering; Security standards; Agile software engineering; DevOps pipeline; DevSecOps; Industrial control systems	Moy{\'o}n, Fabiola; Soares, Rafael; Pinto-Albuquerque, Maria; Mendez, Daniel; Beckers, Kristian	International Conference on Product-Focused Software Process Improvement	https://doi.org/10.1007/978-3-030-64148-1_27		434--452	"""@InProceedings{10.1007/978-3-030-64148-1_27,
    author = ""Moy{\'o}n, Fabiola and Soares, Rafael and Pinto-Albuquerque, Maria and Mendez, Daniel and Beckers, Kristian"",
    editor = ""Morisio, Maurizio and Torchiano, Marco and Jedlitschka, Andreas"",
    title = ""Integration of Security Standards in DevOps Pipelines: An Industry Case Study"",
    booktitle = ""Product-Focused Software Process Improvement"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""434--452"",
    abstract = ""In the last decade, companies adopted DevOps as a fast path to deliver software products according to customer expectations, with well aligned teams and in continuous cycles. As a basic practice, DevOps relies on pipelines that simulate factory swim-lanes. The more automation in the pipeline, the shorter a lead time is supposed to be. However, applying DevOps is challenging, particularly for industrial control systems (ICS) that support critical infrastructures and that must obey to rigorous requirements from security regulations and standards. Current research on security compliant DevOps presents open gaps for this particular domain and in general for systematic application of security standards. In this paper, we present a systematic approach to integrate standard-based security activities into DevOps pipelines and highlight their automation potential. Our intention is to share our experiences and help practitioners to overcome the trade-off between adding security activities into the development process and keeping a short lead time. We conducted an evaluation of our approach at a large industrial company considering the IEC 62443-4-1 security standard that regulates ICS. The results strengthen our confidence in the usefulness of our approach and artefacts, and in that they can support practitioners to achieve security compliance while preserving agility including short lead times."",
    isbn = ""978-3-030-64148-1""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Integration of Security Standards in DevOps Pipelines: An Industry Case Study	http://link.springer.com/chapter/10.1007/978-3-030-64148-1_27	Springer International Publishing	nan; References
441	Behave	Inter-organizational Co-development with Scrum: Experiences and Lessons Learned from a Distributed Corporate Development Environment	Distributed development within a single organization adds a lot of overhead to every software development process. When a second organization joins for co-development, complexity reaches the next level. This case study investigates an agile approach from a real world project involving two unaffiliated IT organizations that collaborate in a distributed development environment. Adaptations to the regular Scrum process are identified and evaluated over a six-month-long period of time. The evaluation involves a detailed problem root cause analysis and suggestions on what issues to act first. Key lessons learned include that team members of one Scrum team should not be distributed over several sites and that every site should have at least one Scrum master and one product owner.	distributed development; agile development; Scrum; software development process; subcontracting; virtual teams	Vallon, Raoul; Strobl, Stefan; Bernhart, Mario; Grechenig, Thomas	International Conference on Agile Software Development	https://doi.org/10.1007/978-3-642-38314-4_11		150--164	"""@InProceedings{10.1007/978-3-642-38314-4_11,
    author = ""Vallon, Raoul and Strobl, Stefan and Bernhart, Mario and Grechenig, Thomas"",
    editor = ""Baumeister, Hubert and Weber, Barbara"",
    title = ""Inter-organizational Co-development with Scrum: Experiences and Lessons Learned from a Distributed Corporate Development Environment"",
    booktitle = ""Agile Processes in Software Engineering and Extreme Programming"",
    year = ""2013"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""150--164"",
    abstract = ""Distributed development within a single organization adds a lot of overhead to every software development process. When a second organization joins for co-development, complexity reaches the next level. This case study investigates an agile approach from a real world project involving two unaffiliated IT organizations that collaborate in a distributed development environment. Adaptations to the regular Scrum process are identified and evaluated over a six-month-long period of time. The evaluation involves a detailed problem root cause analysis and suggestions on what issues to act first. Key lessons learned include that team members of one Scrum team should not be distributed over several sites and that every site should have at least one Scrum master and one product owner."",
    isbn = ""978-3-642-38314-4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Inter-organizational Co-development with Scrum: Experiences and Lessons Learned from a Distributed Corporate Development Environment	http://link.springer.com/chapter/10.1007/978-3-642-38314-4_11	Springer Berlin Heidelberg	nan; References
442	Behave	Interpreter Pattern	Silvia Broome: What do you do when you can't sleep? Tobin Keller: I stay awake.	Translation Patterns; Domain-specific Language; Kwargs; Composite Pattern; Behavior-driven Development	Wessel Badenhorst	Practical Python Design Patterns	https://doi.org/10.1007/978-1-4842-2680-3_12		179–202		Excluded	Excluded	new_screen			2	Springer Link		Interpreter Pattern	http://link.springer.com/chapter/10.1007/978-1-4842-2680-3_12	Apress, Berkeley, CA	nan; References; Year; Bibtex
443	Behave	Interviews and Case Studies	A collection of interviews from various thought leaders in the DevOps community.		Harrison, Dave; Lively, Knox	Achieving DevOps	https://doi.org/10.1007/978-1-4842-4388-6_9		379--483	"""@Inbook{Harrison2019,
    author = ""Harrison, Dave and Lively, Knox"",
    title = ""Interviews and Case Studies"",
    bookTitle = ""Achieving DevOps: A Novel About Delivering the Best of Agile, DevOps, and Microservices"",
    year = ""2019"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""379--483"",
    abstract = ""A collection of interviews from various thought leaders in the DevOps community."",
    isbn = ""978-1-4842-4388-6"",
    doi = ""10.1007/978-1-4842-4388-6\_9"",
    url = ""https://doi.org/10.1007/978-1-4842-4388-6\_9""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Interviews and Case Studies	http://link.springer.com/chapter/10.1007/978-1-4842-4388-6_9	Apress	nan; Keywords; References
444	Behave	Introducing a New Agile Development for Web Applications Using a Groupware as Example	The purpose of this paper is introduce a new agile methodology for Web development based on User Stories and that use some concepts of Scrum like Product Backlog and Sprint. The methodology is divided in three disciplines: Communication, Modeling and Construction; each one refining the User Stories, from requirements specification with the User and the use of the Navigation Model and Story Cards until the execution of these User Stories to guide the coding. Thus, the development team can use these User Stories as acceptance tests, which represent the User behavior when using the system. The code written to pass in those tests can generate, through reverse engineering, design for the team to evaluate how the Web application is being developed and evolved. In the end, the team has more guarantees that the Web application developed represents what the User wanted in the beginning.	Agile Process; User Story; Navigation Model; Web Development	Pereira, Vinicius; do Prado, Antonio Francisco	International Conference on Integrated Computing Technology	https://doi.org/10.1007/978-3-642-22247-4_13		144--160	"""@InProceedings{10.1007/978-3-642-22247-4_13,
    author = ""Pereira, Vinicius and do Prado, Antonio Francisco"",
    editor = ""Hruschka, Estevam Rafael and Watada, Junzo and do Carmo Nicoletti, Maria"",
    title = ""Introducing a New Agile Development for Web Applications Using a Groupware as Example"",
    booktitle = ""Integrated Computing Technology"",
    year = ""2011"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""144--160"",
    abstract = ""The purpose of this paper is introduce a new agile methodology for Web development based on User Stories and that use some concepts of Scrum like Product Backlog and Sprint. The methodology is divided in three disciplines: Communication, Modeling and Construction; each one refining the User Stories, from requirements specification with the User and the use of the Navigation Model and Story Cards until the execution of these User Stories to guide the coding. Thus, the development team can use these User Stories as acceptance tests, which represent the User behavior when using the system. The code written to pass in those tests can generate, through reverse engineering, design for the team to evaluate how the Web application is being developed and evolved. In the end, the team has more guarantees that the Web application developed represents what the User wanted in the beginning."",
    isbn = ""978-3-642-22247-4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Introducing a New Agile Development for Web Applications Using a Groupware as Example	http://link.springer.com/chapter/10.1007/978-3-642-22247-4_13	Springer Berlin Heidelberg	nan; References
445	Behave	Introduction to Behavior-Driven Development	Behavior-Driven Development (BDD) is an approach to software development that was built with the aim of formalizing the best practices followed by Test-Driven Development practitioners. This chapter will introduce you to BDD concepts and techniques.		Mishra, Abhishek	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_10		317--327	"""@Inbook{Mishra2017,
    author = ""Mishra, Abhishek"",
    title = ""Introduction to Behavior-Driven Development"",
    bookTitle = ""iOS Code Testing: Test-Driven Development and Behavior-Driven Development with Swift"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""317--327"",
    abstract = ""Behavior-Driven Development (BDD) is an approach to software development that was built with the aim of formalizing the best practices followed by Test-Driven Development practitioners. This chapter will introduce you to BDD concepts and techniques."",
    isbn = ""978-1-4842-2689-6"",
    doi = ""10.1007/978-1-4842-2689-6\_10"",
    url = ""https://doi.org/10.1007/978-1-4842-2689-6\_10""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Introduction to Behavior-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_10	Apress	nan; Keywords; References
446	Behave	Introduction to Cucumber	Cucumber (Figure 6-1) is an awesome tool that allows you to develop your software using a Behavior-Driven Approach (BDA). It makes sure that business stakeholders transfer the software requirements to developers in an accurate and rigorous way so that the final software delivered fully satisfies those requirements. Also, the requirements are turned into executable specifications of the application developed, and they are executed on every new commit to make sure that no old features are broken when new ones are introduced. Cucumber is a great tool of collaboration, documentation, and test automation.		Matsinopoulos, Panos	Practical Test Automation	https://doi.org/10.1007/978-1-4842-6141-5_6		199--230	"""@Inbook{Matsinopoulos2020,
    author = ""Matsinopoulos, Panos"",
    title = ""Introduction to Cucumber"",
    bookTitle = ""Practical Test Automation: Learn to Use Jasmine, RSpec, and Cucumber Effectively for Your TDD and BDD"",
    year = ""2020"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""199--230"",
    abstract = ""Cucumber (Figure 6-1) is an awesome tool that allows you to develop your software using a Behavior-Driven Approach (BDA). It makes sure that business stakeholders transfer the software requirements to developers in an accurate and rigorous way so that the final software delivered fully satisfies those requirements. Also, the requirements are turned into executable specifications of the application developed, and they are executed on every new commit to make sure that no old features are broken when new ones are introduced. Cucumber is a great tool of collaboration, documentation, and test automation."",
    isbn = ""978-1-4842-6141-5"",
    doi = ""10.1007/978-1-4842-6141-5\_6"",
    url = ""https://doi.org/10.1007/978-1-4842-6141-5\_6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Introduction to Cucumber	http://link.springer.com/chapter/10.1007/978-1-4842-6141-5_6	Apress	nan; Keywords; References
447	Behave	Introduction to DevOps	New ways of working or new methodologies begin to unearth because of a problem---yes, it all starts with a problem. DevOps too had its own reasons. Businesses craved for fast turnarounds of their solutions. And often businesses found out in the midst of development that they didn't have all the information they needed to make the right decisions. They wanted to recommend a few more changes to the requirements and still expected the delivery to happen on time. DevOps was born to solve this problem.		Krishna Kaiser, Abhinav	Reinventing ITIL(r) in the Age of DevOps	https://doi.org/10.1007/978-1-4842-3976-6_1		1--35	"""@Inbook{KrishnaKaiser2018,
    author = ""Krishna Kaiser, Abhinav"",
    title = ""Introduction to DevOps"",
    bookTitle = ""Reinventing ITIL(r) in the Age of DevOps: Innovative Techniques to Make Processes Agile and Relevant"",
    year = ""2018"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""1--35"",
    abstract = ""New ways of working or new methodologies begin to unearth because of a problem---yes, it all starts with a problem. DevOps too had its own reasons. Businesses craved for fast turnarounds of their solutions. And often businesses found out in the midst of development that they didn't have all the information they needed to make the right decisions. They wanted to recommend a few more changes to the requirements and still expected the delivery to happen on time. DevOps was born to solve this problem."",
    isbn = ""978-1-4842-3976-6"",
    doi = ""10.1007/978-1-4842-3976-6\_1"",
    url = ""https://doi.org/10.1007/978-1-4842-3976-6\_1""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Introduction to DevOps	http://link.springer.com/chapter/10.1007/978-1-4842-3976-6_1	Apress	nan; Keywords; References
448	Behave	Introduction to RSpec	RSpec advertises as being the tool that makes TDD (Test-Driven Development) and BDD (Behavior-Driven Development) fun. This is an introduction to RSpec that will give you enough knowledge to write your first Ruby application and cover it with RSpec specifications -- or, actually, since you are doing TDD, to first write the specifications and then implement the application. It is the foundation for the next chapters that deal with more advanced concepts of RSpec and testing in general.		Matsinopoulos, Panos	Practical Test Automation	https://doi.org/10.1007/978-1-4842-6141-5_4		109--157	"""@Inbook{Matsinopoulos2020,
    author = ""Matsinopoulos, Panos"",
    title = ""Introduction to RSpec"",
    bookTitle = ""Practical Test Automation: Learn to Use Jasmine, RSpec, and Cucumber Effectively for Your TDD and BDD"",
    year = ""2020"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""109--157"",
    abstract = ""RSpec advertises as being the tool that makes TDD (Test-Driven Development) and BDD (Behavior-Driven Development) fun. This is an introduction to RSpec that will give you enough knowledge to write your first Ruby application and cover it with RSpec specifications -- or, actually, since you are doing TDD, to first write the specifications and then implement the application. It is the foundation for the next chapters that deal with more advanced concepts of RSpec and testing in general."",
    isbn = ""978-1-4842-6141-5"",
    doi = ""10.1007/978-1-4842-6141-5\_4"",
    url = ""https://doi.org/10.1007/978-1-4842-6141-5\_4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Introduction to RSpec	http://link.springer.com/chapter/10.1007/978-1-4842-6141-5_4	Apress	nan; Keywords; References
449	Behave	Introduction to Security and Quality Improvement in Complex Cyber-Physical Systems Engineering	Providing Complex Cyber-Physical Systems (C-CPSs) more efficiently and faster is a goal that requires improvements in engineering process for producing high-quality, advanced engineering artifacts. Furthermore, information security must be a top priority when engineering C-CPSs as the engineering artifacts represent assets of high value.	Complex cyber-physical systems; Engineering process; Multidisciplinary engineering; AutomationML; Information security	"Biffl, Stefan; Eckhart, Matthias; L{\""u}der, Arndt; Weippl, Edgar"	Security and Quality in Cyber-Physical Systems Engineering	https://doi.org/10.1007/978-3-030-25312-7_1		1--29	"""@Inbook{Biffl2019,
    author = {Biffl, Stefan and Eckhart, Matthias and L{\""u}der, Arndt and Weippl, Edgar},
    editor = {Biffl, Stefan and Eckhart, Matthias and L{\""u}der, Arndt and Weippl, Edgar},
    title = ""Introduction to Security and Quality Improvement in Complex Cyber-Physical Systems Engineering"",
    bookTitle = ""Security and Quality in Cyber-Physical Systems Engineering: With Forewords by Robert M. Lee and Tom Gilb"",
    year = ""2019"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""1--29"",
    abstract = ""Providing Complex Cyber-Physical Systems (C-CPSs) more efficiently and faster is a goal that requires improvements in engineering process for producing high-quality, advanced engineering artifacts. Furthermore, information security must be a top priority when engineering C-CPSs as the engineering artifacts represent assets of high value."",
    isbn = ""978-3-030-25312-7"",
    doi = ""10.1007/978-3-030-25312-7\_1"",
    url = ""https://doi.org/10.1007/978-3-030-25312-7\_1""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Introduction to Security and Quality Improvement in Complex Cyber-Physical Systems Engineering	http://link.springer.com/chapter/10.1007/978-3-030-25312-7_1	Springer International Publishing	nan; References
450	Behave	Introduction to Test-Driven Development	Well over a billion apps have been developed for the iOS platform since its inception. Most of the early apps were rather simple and often developed by a single developer. Over the years, iOS apps have become increasingly complex pieces of software that often involve large, distributed teams of developers working in Agile environments with complex build and release pipelines.		Mishra, Abhishek	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_1		1--11	"""@Inbook{Mishra2017,
    author = ""Mishra, Abhishek"",
    title = ""Introduction to Test-Driven Development"",
    bookTitle = ""iOS Code Testing: Test-Driven Development and Behavior-Driven Development with Swift"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""1--11"",
    abstract = ""Well over a billion apps have been developed for the iOS platform since its inception. Most of the early apps were rather simple and often developed by a single developer. Over the years, iOS apps have become increasingly complex pieces of software that often involve large, distributed teams of developers working in Agile environments with complex build and release pipelines."",
    isbn = ""978-1-4842-2689-6"",
    doi = ""10.1007/978-1-4842-2689-6\_1"",
    url = ""https://doi.org/10.1007/978-1-4842-2689-6\_1""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Introduction to Test-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_1	Apress	nan; Keywords; References
451	Behave	Introduction to Testing with Rspec	Before we move into our main project for this book, we still have another very important topic to cover--testing.	Category Model; Controller Action; Test Code; Sample Category; User Story	John Hunt	Foundation Rails 2	https://doi.org/10.1007/978-1-4302-1040-5_10		253–289		Excluded	Excluded	new_screen			2	Springer Link		Introduction to Testing	http://link.springer.com/chapter/10.1007/978-1-4302-1040-5_10	Apress	nan; Authors; References; Year; Bibtex
452	Behave	Introduction to Testing with Rspec	Before we move into our main project for this book, we still have another very important topic to cover---testing.	Category Model; Controller Action; Test Code; Sample Category; User Story		Foundation Rails 2	https://doi.org/10.1007/978-1-4302-1040-5_10		253--289	"""@Inbook{Alameda2009,
    title = ""Introduction to Testing with Rspec"",
    bookTitle = ""Foundation Rails 2"",
    year = ""2009"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""253--289"",
    abstract = ""Before we move into our main project for this book, we still have another very important topic to cover---testing."",
    isbn = ""978-1-4302-1040-5"",
    doi = ""10.1007/978-1-4302-1040-5\_10"",
    url = ""https://doi.org/10.1007/978-1-4302-1040-5\_10""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Introduction to Testing with Rspec	https://link.springer.com/chapter/10.1007/978-1-4302-1040-5_10	Apress	nan; Authors; References
453	Behave	iOS Code Testing	https://link.springer.com/book/10.1007/978-1-4842-2689-6	Swift; programming; software; engineering; Test-Driven Development; Behavior-Driven Development; Code testing; iOS; Xcode; Mac	Abhishek Mishra		https://link.springer.com/book/10.1007/978-1-4842-2689-6				Excluded	Excluded	new_screen			2	Springer Link		iOS Code Testing	https://link.springer.com/book/10.1007/978-1-4842-2689-6	Springer Link	nan; Venue; Abstract; References; Pages; Year; Bibtex; DOI
454	Behave	Iterative and Scenario-Based Requirements Specification in a System of Systems Context	[Context {\&} Motivation] Due to the managerial, operational and evolutionary independence of constituent systems (CSs) in a System of Systems (SoS) context, top-down and linear requirements engineering (RE) approaches are insufficient. RE techniques for SoS must support iterating, changing, synchronizing, and communicating requirements across different abstraction and hierarchy levels as well as scopes of responsibility. [Question/Problem] We address the challenge of SoS requirements specification, where requirements can describe the SoS behavior, but also the behavior of CSs that are developed independently. [Principal Ideas] To support the requirements specification in an SoS environment, we propose a scenario-based and iterative specification technique. This allows requirements engineers to continuously model and jointly execute and test the system behavior for the SoS and the CS in order to detect contradictions in the requirement specifications at an early stage. [Contribution] In this paper, we describe an extension for the scenario-modeling language for Kotlin (SMLK) to continuously and formally model requirements on SoS and CS level. To support the iterative requirements specification and modeling we combine SMLK with agile development techniques. We demonstrate the applicability of our approach with the help of an example from the field of e-mobility.	System of systems engineering; Requirements analysis; Requirements specification; Scenario-based requirements modeling	Wiecher, Carsten; Greenyer, Joel; Wolff, Carsten; Anacker, Harald; Dumitrescu, Roman	International Working Conference on Requirements Engineering: Foundation for Software Quality	https://doi.org/10.1007/978-3-030-73128-1_12		165--181	"""@InProceedings{10.1007/978-3-030-73128-1_12,
    author = ""Wiecher, Carsten and Greenyer, Joel and Wolff, Carsten and Anacker, Harald and Dumitrescu, Roman"",
    editor = ""Dalpiaz, Fabiano and Spoletini, Paola"",
    title = ""Iterative and Scenario-Based Requirements Specification in a System of Systems Context"",
    booktitle = ""Requirements Engineering: Foundation for Software Quality"",
    year = ""2021"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""165--181"",
    abstract = ""[Context {\\&} Motivation] Due to the managerial, operational and evolutionary independence of constituent systems (CSs) in a System of Systems (SoS) context, top-down and linear requirements engineering (RE) approaches are insufficient. RE techniques for SoS must support iterating, changing, synchronizing, and communicating requirements across different abstraction and hierarchy levels as well as scopes of responsibility. [Question/Problem] We address the challenge of SoS requirements specification, where requirements can describe the SoS behavior, but also the behavior of CSs that are developed independently. [Principal Ideas] To support the requirements specification in an SoS environment, we propose a scenario-based and iterative specification technique. This allows requirements engineers to continuously model and jointly execute and test the system behavior for the SoS and the CS in order to detect contradictions in the requirement specifications at an early stage. [Contribution] In this paper, we describe an extension for the scenario-modeling language for Kotlin (SMLK) to continuously and formally model requirements on SoS and CS level. To support the iterative requirements specification and modeling we combine SMLK with agile development techniques. We demonstrate the applicability of our approach with the help of an example from the field of e-mobility."",
    isbn = ""978-3-030-73128-1""
}
"""	Included	Included	new_screen			2	Springer Link		Iterative and Scenario-Based Requirements Specification in a System of Systems Context	http://link.springer.com/chapter/10.1007/978-3-030-73128-1_12	Springer International Publishing	nan; References
455	Behave	JavaScript Unit Testing	Unit testing is an important and crucial part of the development process. A unit test is a way to evaluate a unit, which is a small piece of code, and determine if it satisfies the relevant requirements. Unit tests help to create robust code that isn't malfunctioning during runtime. They act as a safety net when developers continue to develop a feature and might make changes to existing features. Without unit tests, application developers can't be sure that their changes haven't broken the application logic and requirements.		Gil Fink; Ido Flatow	Pro Single Page Application Development	https://doi.org/10.1007/978-1-4302-6674-7_10		207–227		Excluded	Excluded	new_screen			2	Springer Link		JavaScript Unit Testing	https://link.springer.com/chapter/10.1007/978-1-4302-6674-7_10	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
456	Behave	KODEGEN: A Code Generation and Testing Tool Using Runnable Knowledge	KDE -- Knowledge Driven Engineering -- is a generalization of MDE -- Model Driven Engineering -- to a higher level of abstraction than the standard UML software models, aiming to be closer to the system designer concepts. But in order to reach an effective technology applicable in industry, one needs to implement it in a tool using Runnable Knowledge, i.e. which can be run and tested. This work describes KODEGEN -- a KDE tool for testing while generating code -- whose input consists of system ontologies, ontology states and scenario files. Incidental concepts not part of the ontologies are replaced by mock objects. The implementation uses a modified Gherkin syntax. The tool is demonstrated in practice by generating the actual code for a few case-studies.		Exman, Iaakov; Litovka, Anton; Yagel, Reuven	International Joint Conference on Knowledge Discovery, Knowledge Engineering, and Knowledge Management	https://doi.org/10.1007/978-3-662-46549-3_17		260--275	"""@InProceedings{10.1007/978-3-662-46549-3_17,
    author = ""Exman, Iaakov and Litovka, Anton and Yagel, Reuven"",
    editor = ""Fred, Ana and Dietz, Jan L.G. and Liu, Kecheng and Filipe, Joaquim"",
    title = ""KODEGEN: A Code Generation and Testing Tool Using Runnable Knowledge"",
    booktitle = ""Knowledge Discovery, Knowledge Engineering and Knowledge Management"",
    year = ""2015"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""260--275"",
    abstract = ""KDE -- Knowledge Driven Engineering -- is a generalization of MDE -- Model Driven Engineering -- to a higher level of abstraction than the standard UML software models, aiming to be closer to the system designer concepts. But in order to reach an effective technology applicable in industry, one needs to implement it in a tool using Runnable Knowledge, i.e. which can be run and tested. This work describes KODEGEN -- a KDE tool for testing while generating code -- whose input consists of system ontologies, ontology states and scenario files. Incidental concepts not part of the ontologies are replaced by mock objects. The implementation uses a modified Gherkin syntax. The tool is demonstrated in practice by generating the actual code for a few case-studies."",
    isbn = ""978-3-662-46549-3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		KODEGEN: A Code Generation and Testing Tool Using Runnable Knowledge	http://link.springer.com/chapter/10.1007/978-3-662-46549-3_17	Springer Berlin Heidelberg	nan; Keywords; References
457	Behave	Languages, Frameworks, Libraries, and Tools	Building hybrid mobile apps with Ionic requires mostly front-end skills, including HTML, JavaScript, and CSS. You should have basic knowledge of these programming languages before reading this book. This chapter doesn't contain a basic introduction of these languages. You can find a lot of online resources if you do need to learn HTML, JavaScript, and CSS. Modern front-end development requires a lot more than just simple HTML, JavaScript, and CSS code. We need to deal with different languages, frameworks, libraries, and tools.	Angular App; UserService; TypeScript Compiler; TypeScript Code; Literal Template	Cheng, Fu	Build Mobile Apps with Ionic 4 and Firebase	https://doi.org/10.1007/978-1-4842-3775-5_2		29--66	"""@Inbook{Cheng2018,
    author = ""Cheng, Fu"",
    title = ""Languages, Frameworks, Libraries, and Tools"",
    bookTitle = ""Build Mobile Apps with Ionic 4 and Firebase: Hybrid Mobile App Development"",
    year = ""2018"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""29--66"",
    abstract = ""Building hybrid mobile apps with Ionic requires mostly front-end skills, including HTML, JavaScript, and CSS. You should have basic knowledge of these programming languages before reading this book. This chapter doesn't contain a basic introduction of these languages. You can find a lot of online resources if you do need to learn HTML, JavaScript, and CSS. Modern front-end development requires a lot more than just simple HTML, JavaScript, and CSS code. We need to deal with different languages, frameworks, libraries, and tools."",
    isbn = ""978-1-4842-3775-5"",
    doi = ""10.1007/978-1-4842-3775-5\_2"",
    url = ""https://doi.org/10.1007/978-1-4842-3775-5\_2""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Languages, Frameworks, Libraries, and Tools	http://link.springer.com/chapter/10.1007/978-1-4842-3775-5_2	Apress	nan; References
458	Behave	Lean R&D: An Agile Research and Development Approach for Digital Transformation			Marcos KalinowskiHélio LopesAlex Furtado TeixeiraGabriel da Silva CardosoAndré KuramotoBruno ItagybaSolon Tarso BatistaJuliana Alves PereiraThuener SilvaJorge Alam WarrakMarcelo da CostaMarinho FischerCristiane SalgadoBianca TeixeiraJacques ChuekeBruna Ferreira						Excluded	Excluded	new_screen			2						
459	Behave	Lean Software Development -- What Exactly Are We Talking About?	As the Software Engineering landscape continues to evolve and new paradigms are introduced, there can be a tendency for both industry and academia to enthusiastically embrace new approaches and march forward under whatever banner conventional wisdom has decided to adopt. One such banner is Lean Software Development, a paradigm that continues to see a growth in interest driven by the need for cost reductions within industry. The term lean attracts the attention of business, but precisely how it applies within software development is still being debated. In addition, its relationship to the better understood agile methodologies is also a topic for debate. Having been drawn into this research area ourselves, we present here a review of Lean Software Development and try to distil out for the reader some understanding of this somewhat undefined topic. We conclude with some thoughts on where this subject might go to from here.	Software Engineering; Software Development; Lean; Agile	Cawley, Ois{\'i}n; Wang, Xiaofeng; Richardson, Ita	International Conference on Lean Enterprise Software and Systems	https://doi.org/10.1007/978-3-642-44930-7_2		16--31	"""@InProceedings{10.1007/978-3-642-44930-7_2,
    author = ""Cawley, Ois{\'i}n and Wang, Xiaofeng and Richardson, Ita"",
    editor = ""Fitzgerald, Brian and Conboy, Kieran and Power, Ken and Valerdi, Ricardo and Morgan, Lorraine and Stol, Klaas-Jan"",
    title = ""Lean Software Development -- What Exactly Are We Talking About?"",
    booktitle = ""Lean Enterprise Software and Systems"",
    year = ""2013"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""16--31"",
    abstract = ""As the Software Engineering landscape continues to evolve and new paradigms are introduced, there can be a tendency for both industry and academia to enthusiastically embrace new approaches and march forward under whatever banner conventional wisdom has decided to adopt. One such banner is Lean Software Development, a paradigm that continues to see a growth in interest driven by the need for cost reductions within industry. The term lean attracts the attention of business, but precisely how it applies within software development is still being debated. In addition, its relationship to the better understood agile methodologies is also a topic for debate. Having been drawn into this research area ourselves, we present here a review of Lean Software Development and try to distil out for the reader some understanding of this somewhat undefined topic. We conclude with some thoughts on where this subject might go to from here."",
    isbn = ""978-3-642-44930-7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Lean Software Development – What Exactly Are We Talking About?	http://link.springer.com/book/10.1007/978-3-030-76020-5	Springer Berlin Heidelberg	nan; References
460	Behave	Logic, Computation and Rigorous Methods			Alexander RaschkeElvinia RiccobeneProf. Klaus-Dieter Schewe						Excluded	Excluded	new_screen			2						
461	Behave	Making It Better	As mentioned before, the term ``Admin'' in Salesforce is overloaded. It can refer to the traditional role of monitoring a production system to ensure it is stable and available to users, but it is just as likely to refer to a user who makes click-based changes to build or improve Salesforce. That latter role is better described as an ``App Builder,'' but that term hasn't gotten much traction beyond being the name of a Salesforce certification. For example, the Admin Zone at Salesforce conferences or the Awesome Admin community online spends most of its energy explaining the click-based Builders and techniques for innovating on the platform without code.		Davis, Andrew	Mastering Salesforce DevOps	https://doi.org/10.1007/978-1-4842-5473-8_12		427--437	"""@Inbook{Davis2019,
    author = ""Davis, Andrew"",
    title = ""Making It Better"",
    bookTitle = ""Mastering Salesforce DevOps : A Practical Guide to Building Trust While Delivering Innovation"",
    year = ""2019"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""427--437"",
    abstract = ""As mentioned before, the term ``Admin'' in Salesforce is overloaded. It can refer to the traditional role of monitoring a production system to ensure it is stable and available to users, but it is just as likely to refer to a user who makes click-based changes to build or improve Salesforce. That latter role is better described as an ``App Builder,'' but that term hasn't gotten much traction beyond being the name of a Salesforce certification. For example, the Admin Zone at Salesforce conferences or the Awesome Admin community online spends most of its energy explaining the click-based Builders and techniques for innovating on the platform without code."",
    isbn = ""978-1-4842-5473-8"",
    doi = ""10.1007/978-1-4842-5473-8\_12"",
    url = ""https://doi.org/10.1007/978-1-4842-5473-8\_12""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Making It Better	http://link.springer.com/chapter/10.1007/978-1-4842-5473-8_12	Apress	nan; Keywords; References
462	Behave	Measuring Test Case Similarity to Support Test Suite Understanding	In order to support test suite understanding, we investigate whether we can automatically derive relations between test cases. In particular, we search for trace-based similarities between (high-level) end-to-end tests on the one hand and fine grained unit tests on the other. Our approach uses the shared word count metric to determine similarity. We evaluate our approach in two case studies and show which relations between end-to-end and unit tests are found by our approach, and how this information can be used to support test suite understanding.		Greiler, Michaela; van Deursen, Arie; Zaidman, Andy	OBJECTS, MODELS, COMPONENTS, PATTERNS, TOOLS 2012	https://www.webofscience.com/wos/woscc/full-record/WOS:000320619000008		91-107	"""@inproceedings{WOS:000320619000008,
    Author = ""Greiler, Michaela and van Deursen, Arie and Zaidman, Andy"",
    Editor = ""Furia, CA and Nanz, S"",
    Title = ""Measuring Test Case Similarity to Support Test Suite Understanding"",
    Booktitle = ""OBJECTS, MODELS, COMPONENTS, PATTERNS, TOOLS 2012"",
    Series = ""Lecture Notes in Computer Science"",
    Year = ""2012"",
    Volume = ""7304"",
    Pages = ""91-107"",
    Note = ""50th International Conference on Objects, Models, Components, Patterns (TOOLS), Prague, CZECH REPUBLIC, MAY 29-31, 2012"",
    Organization = ""Microsoft Res; European Assoc Programming Languages \\& Syst"",
    Abstract = ""In order to support test suite understanding, we investigate whether we can automatically derive relations between test cases. In particular, we search for trace-based similarities between (high-level) end-to-end tests on the one hand and fine grained unit tests on the other. Our approach uses the shared word count metric to determine similarity. We evaluate our approach in two case studies and show which relations between end-to-end and unit tests are found by our approach, and how this information can be used to support test suite understanding."",
    Publisher = ""SPRINGER-VERLAG BERLIN"",
    Address = ""HEIDELBERGER PLATZ 3, D-14197 BERLIN, GERMANY"",
    Type = ""Proceedings Paper"",
    Language = ""English"",
    Affiliation = ""Greiler, M (Corresponding Author), Delft Univ Technol, NL-2600 AA Delft, Netherlands. Greiler, Michaela; van Deursen, Arie; Zaidman, Andy, Delft Univ Technol, NL-2600 AA Delft, Netherlands."",
    ISSN = ""0302-9743"",
    EISSN = ""1611-3349"",
    ISBN = ""978-3-642-30561-0"",
    Research-Areas = ""Computer Science"",
    Web-of-Science-Categories = ""Computer Science, Software Engineering"",
    Author-Email = ""m.s.greiler@tudelft.nl arie.vandeursen@tudelft.nl a.e.zaidman@tudelft.nl"",
    Affiliations = ""Delft University of Technology"",
    ResearcherID-Numbers = ""van Deursen, Arie/G-3084-2011 Zaidman, Andy/O-6542-2014"",
    ORCID-Numbers = ""van Deursen, Arie/0000-0003-4850-3312 Zaidman, Andy/0000-0003-2413-3935"",
    Number-of-Cited-References = ""16"",
    Times-Cited = ""6"",
    Usage-Count-Last-180-days = ""0"",
    Usage-Count-Since-2013 = ""0"",
    Doc-Delivery-Number = ""BFN43"",
    Web-of-Science-Index = ""Conference Proceedings Citation Index - Science (CPCI-S)"",
    Unique-ID = ""WOS:000320619000008"",
    DA = ""2024-12-04""
}
"""	Excluded	Excluded	new_screen			2	Web of Science		Measuring Test Case Similarity to Support Test Suite Understanding	https://www.webofscience.com/wos/woscc/full-record/WOS:000320619000008	SPRINGER-VERLAG BERLIN	nan; Keywords; References; DOI
463	Behave	Meshing agile and plan-driven development in safety-critical software: a case study	Organizations developing safety-critical software are increasingly seeking to create better practices by meshing agile and plan-driven development processes. Significant differences between the agile and the plan-driven processes make meshing difficult, and very little empirical evidence on using agile processes for safety-critical software development exists. There are four areas of concern, in particular, for meshing the development of safety-critical software concerning: documentation, requirements, life cycle and testing. We report on a case study of a pharmaceutical organization in which a Scrum process was implemented to support agile software development in a plan-driven safety-critical project. The purpose was to answer the following research question: For safety-critical software, what can a software team do to mesh agile and plan-driven processes effectively? The main contribution of the paper is an elaborated understanding of meshing in the four areas of concern and how the conditions for safety-critical software influence them. We discuss how meshing within the four areas of concern is a contribution to existing research.	Agile software development; Plan-driven software development; Process; Safety-critical software meshing compliance scrum; FDA; Agile software development;  Plan-driven software development;  Process;  Safety-critical software meshing compliance scrum;  FDA	Heeager, Lise Tordrup; Nielsen, Peter Axel	EMPIRICAL SOFTWARE ENGINEERING	https://doi.org/10.1007/s10664-020-09804-z	Abdelaziz A, El-Tahir Y, Osman R (2015) Adaptive software development for developing safety critical software. International Conference on Computing, Control, Networking, Electronics and Embedded Systems Engineering (ICCNEEE), Khartoum, Sudan; Bedoll R (2003) A tail of two projects: how 'agile' methods succeeded after 'traditional' methods had failed in a critical system-development project. Conference on Extreme Programming and Agile Methods; Beznosov K (2003) Extreme Security Engineering: On Employing XP Practices to Achieve 'Good Enough Security' without Defining It X. The First ACM Workshop on Business Driven Security Engineering, BizSec, Fairfax; Beznosov K, Kruchten P (2004) Towards agile security assurance. Proceedings of the 2004 Workshop on New Security Paradigms, Nova Scotia; citation_title=Balancing agility and discipline: a guide for the perplexed; citation_publication_date=2005; citation_id=CR5; citation_author=B Boehm; citation_author=R Turner; citation_publisher=Addison-Wesley Professional; Bostrom G, Wayrynen J, Boden M, Beznosov K, Kruchten P (2006) Extending XP practices to support security requirements engineering. Proceedings of the 2006 international workshop on software engineering for secure systems, Shanghai; citation_title=Agile software development: the cooperative game; citation_publication_date=2006; citation_id=CR7; citation_author=A Cockburn; citation_publisher=Addison-Wesley Professional; citation_journal_title=Inf Syst Res; citation_title=Agility from first principles: reconstructing the concept of agility in information systems development; citation_author=K Conboy; citation_volume=20; citation_issue=3; citation_publication_date=2009; citation_pages=329-354; citation_doi=10.1287/isre.1090.0236; citation_id=CR8; citation_title=Investigating the Suitability of Using Agile for Medical Embedded Software Development; citation_inbook_title=Communications in Computer and Information Science; citation_publication_date=2016; citation_pages=409-416; citation_id=CR9; citation_author=Surafel Demissie; citation_author=Frank Keenan; citation_author=Fergal McCaffery; citation_publisher=Springer International Publishing; citation_journal_title=IEEE Softw; citation_title=Piloting XP on four mission-critical projects; citation_author=J Drobka, D Noftz, R Raghu; citation_volume=21; citation_issue=6; citation_publication_date=2004; citation_pages=70; citation_doi=10.1109/Ms.2004.47; citation_id=CR10; Fitzgerald B, Stol K-J, O'Sullivan R, O'Brien D (2013) Scaling agile methods to regulated environments: An industry case study. Proceedings of the 2013 International Conference on Software Engineering, San Francisco; citation_journal_title=Softw - Pract Exper; citation_title=Agile methods for open source safety-critical software; citation_author=K Gary, A Enquobahrie, L Ibanez, P Cheng, Z Yaniv, K Cleary, S Kokoori, B Muffih, J Heidenreich; citation_volume=41; citation_issue=9; citation_publication_date=2011; citation_pages=945-962; citation_doi=10.1002/spe.1075; citation_id=CR12; citation_title=An iterative approach for development of safety-critical software and safety arguments; citation_publication_date=2010; citation_id=CR13; citation_author=X Ge; citation_author=RF Paige; citation_author=JA McDermid; citation_publisher=The Agile Conference (AGILE); citation_journal_title=Comput Therm Sci; citation_title=Assessment of risks introduced to safety critical software by agile practices-a software engineer's perspective; citation_author=J Gorski, K Lukasiewicz; citation_volume=13; citation_issue=4; citation_publication_date=2012; citation_pages=165-182; citation_id=CR14; Gorski J, Lukasiewicz K (2013) Towards agile development of critical software. The International Workshop on Software Engineering for Resilient Systems; citation_journal_title=MIS Q; citation_title=The nature of theory in information systems; citation_author=S Gregor; citation_volume=30; citation_issue=3; citation_publication_date=2006; citation_pages=611-642; citation_doi=10.2307/25148742; citation_id=CR16; citation_journal_title=IEEE Softw; citation_title=Launching extreme programming at a process-intensive company; citation_author=J Grenning; citation_volume=18; citation_issue=6; citation_publication_date=2001; citation_pages=27; citation_doi=10.1109/52.965799; citation_id=CR17; citation_journal_title=Lect Notes Softw Eng; citation_title=An insight into the difficulties of software development projects in the pharmaceutical industry; citation_author=A Hajou, R Batenburg, S Jansen; citation_volume=3; citation_issue=4; citation_publication_date=2015; citation_pages=267; citation_doi=10.7763/LNSE.2015.V3.202; citation_id=CR18; citation_journal_title=Lect Notes Softw Eng; citation_title=Method ae, the agile software development method tailored for the pharmaceutical industry; citation_author=A Hajou, R Batenburg, S Jansen; citation_volume=3; citation_issue=4; citation_publication_date=2015; citation_pages=251; citation_doi=10.7763/LNSE.2015.V3.200; citation_id=CR19; citation_journal_title=J Info Technol Case Appl Res; citation_title=Introducing agile practices in a documentation-driven software development practice: a case study; citation_author=L Heeager; citation_volume=14; citation_issue=1; citation_publication_date=2012; citation_pages=3-24; citation_id=CR20; Heeager L, Nielsen PA (2009) Agile software development and its compatibility with a document-driven approach? A Case Study. The Australasian Conference on Information Systems, Melbourne; citation_journal_title=Inf Softw Technol; citation_title=A conceptual model of agile software development in a safety-critical context: a systematic literature review; citation_author=LT Heeager, PA Nielsen; citation_volume=103; citation_publication_date=2018; citation_pages=22-39; citation_doi=10.1016/j.infsof.2018.06.004; citation_id=CR22; Jonsson H, Larsson S, Punnekkat S (2012) Agile Practices in Regulated Railway Software Development. The 23rd International Symposium on Software Reliability Engineering Workshops (ISSREW); citation_journal_title=Empir Softw Eng; citation_title=Integrating agile software development into stage-gate managed product development; citation_author=D Karlstrom, P Runeson; citation_volume=11; citation_publication_date=2006; citation_pages=203-225; citation_doi=10.1007/s10664-006-6402-8; citation_id=CR24; Kasauli R, Knauss E, Kanagwa B, Nilsson A, Calikli G (2018) Safety-Critical Systems and Agile Development: A Mapping Study. The 2018 44th Euromicro Conference on Software Engineering and Advanced Applications (SEAA); Kuhrmann M, Diebold P, Munch J, Tell P, Garousi V, Felderer M, Trektere K, McCaffery F, Linssen O, Hanser E, Prause CR (2017) Hybrid Software and System Development in Practice: Waterfall, Scrum, and Beyond. Proceedings of the 2017 International Conference on Software and System Process; citation_journal_title=MIS Q; citation_title=Toward agile: an integrated analysis of quantitative and qualitative field data on software development agility; citation_author=G Lee, WD Xia; citation_volume=34; citation_issue=1; citation_publication_date=2010; citation_pages=87-114; citation_doi=10.2307/20721416; citation_id=CR27; Lin W, Fan X (2009) Software Development Practice for FDA-Compliant Medical Devices. International Joint Conference on Computational Sciences and Optimization (CSO), Hainan, Sanya; McCaffery F, Trektere K, Ozcan-Top O (2016) Agile-Is it Suitable for Medical Device Software Development? International Conference on Software Process Improvement and Capability Determination (SPICE), Dublin; citation_title=Barriers to Adopting Agile Practices When Developing Medical Device Software; citation_inbook_title=Communications in Computer and Information Science; citation_publication_date=2012; citation_pages=141-147; citation_id=CR30; citation_author=Martin McHugh; citation_author=Fergal McCaffery; citation_author=Valentine Casey; citation_publisher=Springer Berlin Heidelberg; McHugh M, Cawley O, McCaffery F, Richardson I, Wang X (2013) An Agile V-Model for Medical Device Software Development to Overcome the Challenges with Plan-Driven Software Development Lifecycles. 5th International Workshop onSoftware Engineering in Health Care (SEHC), San Francisco; citation_journal_title=J Softw-Evol Process; citation_title=Adopting agile practices when developing software for use in the medical domain; citation_author=M McHugh, F McCaffery, V Casey; citation_volume=26; citation_issue=5; citation_publication_date=2014; citation_pages=504-512; citation_doi=10.1002/smr.1608; citation_id=CR32; McHugh, M., McCaffery, F., & Coady, G. (2014b). An Agile Implementation within a Medical Device Software Organisation. International Conference on Software Process Improvement and Capability Determination, Vilnius, Lithuania; Mehrfard H, Pirzadeh H, Hamou-Lhadj A (2010) Investigating the capability of agile processes to support life-science regulations: the case of XP and FDA regulations with a focus on human factor requirements. In Software Engineering Research, Management and Applications 2010 (pp. 241-255): Springer; citation_journal_title=Int J Qual Reliabil Manag; citation_title=Identifying some critical changes required in adopting agile practices in traditional software development projects; citation_author=S Misra, V Kumar, U Kumar; citation_volume=27; citation_issue=4; citation_publication_date=2010; citation_pages=451-474; citation_doi=10.1108/02656711011035147; citation_id=CR35; Myklebust T, Stalhane T (2016) Safety Stories-A New Concept in Agile Development. International Conference on Computer Safety, Reliability, and Security (SAFECOMP 2016); citation_title=The Agile Safety Case: springer; citation_publication_date=2018; citation_id=CR37; citation_author=T Myklebust; citation_author=T Stalhane; Notander JP, Host M, Runeson P (2013a) Challenges in flexible safety-critical software development-an industrial qualitative survey. International Conference on Product Focused Software Process Improvement, paphos, Cyprus; Notander JP, Runeson P, Host M (2013b) A model-based framework for flexible safety-critical software development: a design study. The 28th Annual ACM Symposium on Applied Computing, Coimbra; Ozcan-Top O, McCaffery F (2019) To what extent the medical device software regulations can be achieved with agile software development methods? XP--DSDM--scrum. J Supercomput:1-34; Paige RF, Chivers H, McDermid JA, Stephenson ZR (2005) High-integrity extreme programming. The ACM symposium on Applied computing, Santa Fe; Paige RF, Charalambous R, Ge X, Brooke PJ (2008) Towards agile engineering of high-integrity systems. International Conference on Computer Safety, Reliability, and Security, Newcastle upon Tyne; Rasmussen R, Hughes T, Jenks J, Skach J (2009) Adopting agile in an FDA regulated environment. Agile Conference (AGILE), Chigaco; Ronkainen J, Abrahamsson P (2003) Software development under stringent hardware constraints: Do agile methods have a chance? International Conference on Extreme Programming and Agile Processes in Software Engineering, New Orleans; Rottier PA, Rodrigues V (2008) Agile development in a medical device company. Agile Conference (AGILE), Toronto; citation_journal_title=Empir Softw Eng; citation_title=Guidelines for conducting and reporting case study research in software engineering; citation_author=P Runeson, M Host; citation_volume=14; citation_issue=2; citation_publication_date=2009; citation_pages=131; citation_doi=10.1007/s10664-008-9102-8; citation_id=CR46; citation_title=Agile software development with scrum; citation_publication_date=2001; citation_id=CR47; citation_author=K Schwaber; citation_author=M Beedle; citation_publisher=Prentice Hall; Shafiq S, Minhas NM (2014) Integrating formal methods in XP--A conceptual solution. J Softw Eng Appl 2014; Sidky A, Arthur J (2007) Determining the applicability of agile practices to mission and life-critical systems. Paper presented at the Software Engineering Workshop (SEW), Columbia; Spence J (2005) There has to be a better way![software development]. Paper presented at the Agile Development Conference (ADC'05), Denver; Stalhane T, Myklebust T, Hanssen G (2012) The application of safe scrum to IEC 61508 certifiable software. Paper presented at the European Safety and Reliability Conference (ESREL), Helsinki; U. S. Department of Health and Human Services (2010) FDA U.S. Food and Drug Administration. In: U.S. Department of Health and Human Services; citation_title=Agile methods for safety-critical systems: a primer using medical device example; citation_publication_date=2018; citation_id=CR53; citation_author=N Schooenderwoert; citation_author=B Shoemaker; citation_publisher=CreateSpace Publishing; VanderLeest SH, Buter A (2009) Escape the waterfall: agile for aerospace. The 28th Digital Avionics Systems Conference, Orlanda; Vogel D (2006) Agile methods: Most are not ready for prime time in medical device software design and development. DesignFax Online:1-6; citation_journal_title=Eur J Inf Syst; citation_title=Doing interpretive research; citation_author=G Walsham; citation_volume=15; citation_issue=3; citation_publication_date=2006; citation_pages=320-330; citation_doi=10.1057/palgrave.ejis.3000589; citation_id=CR56; Wang Y, Wagner S (2018) Combining STPA and BDD for safety analysis and verification in agile development: a controlled experiment. International Conference on Agile Software Development; Wang Y, Ramadani J, Wagner S (2017) An exploratory study on applying a scrum development process for safety-critical systems. International Conference on Product-Focused Software Process Improvement; citation_journal_title=LNCS; citation_title=Security engineering and eXtreme programming: an impossible marriage? XP/Agile Universe 2004; citation_author=J Wayrynen, M Boden, G Bostrom; citation_volume=3134; citation_publication_date=2004; citation_pages=117-128; citation_id=CR59; citation_title=Agility in the Avionics Software World; citation_inbook_title=Extreme Programming and Agile Processes in Software Engineering; citation_publication_date=2006; citation_pages=123-132; citation_id=CR60; citation_author=Andrew Wils; citation_author=Stefan Van Baelen; citation_author=Tom Holvoet; citation_author=Karel De Vlaminck; citation_publisher=Springer Berlin Heidelberg; citation_title=Effective Project Management: traditional, agile; citation_publication_date=2011; citation_id=CR61; citation_author=RK Wysocki; citation_publisher=Wiley; citation_title=Case study research: design and methods; citation_publication_date=2009; citation_id=CR62; citation_author=RK Yin; citation_publisher=Sage Publications Inc.	1035-1062	"""@article{WOS:000515762900001,
    Author = ""Heeager, Lise Tordrup and Nielsen, Peter Axel"",
    Title = ""Meshing agile and plan-driven development in safety-critical software: a case study"",
    Journal = ""EMPIRICAL SOFTWARE ENGINEERING"",
    Year = ""2020"",
    Volume = ""25"",
    Number = ""2, SI"",
    Pages = ""1035-1062"",
    Month = ""MAR"",
    Abstract = ""Organizations developing safety-critical software are increasingly seeking to create better practices by meshing agile and plan-driven development processes. Significant differences between the agile and the plan-driven processes make meshing difficult, and very little empirical evidence on using agile processes for safety-critical software development exists. There are four areas of concern, in particular, for meshing the development of safety-critical software concerning: documentation, requirements, life cycle and testing. We report on a case study of a pharmaceutical organization in which a Scrum process was implemented to support agile software development in a plan-driven safety-critical project. The purpose was to answer the following research question: For safety-critical software, what can a software team do to mesh agile and plan-driven processes effectively? The main contribution of the paper is an elaborated understanding of meshing in the four areas of concern and how the conditions for safety-critical software influence them. We discuss how meshing within the four areas of concern is a contribution to existing research."",
    Publisher = ""SPRINGER"",
    Address = ""VAN GODEWIJCKSTRAAT 30, 3311 GZ DORDRECHT, NETHERLANDS"",
    Type = ""Article"",
    Language = ""English"",
    Affiliation = ""Nielsen, PA (Corresponding Author), Aalborg Univ, Dept Comp Sci, Selma Lagerlofs Vej 300, DK-9220 Aalborg O, Denmark. Heeager, Lise Tordrup, Aarhus Univ, Dept Management, Fuglesangs Alle 4, DK-8210 Aarhus V, Denmark. Nielsen, Peter Axel, Aalborg Univ, Dept Comp Sci, Selma Lagerlofs Vej 300, DK-9220 Aalborg O, Denmark."",
    DOI = ""10.1007/s10664-020-09804-z"",
    EarlyAccessDate = ""FEB 2020"",
    ISSN = ""1382-3256"",
    EISSN = ""1573-7616"",
    Keywords = ""Agile software development; Plan-driven software development; Process; Safety-critical software meshing compliance scrum; FDA"",
    Keywords-Plus = ""XP"",
    Research-Areas = ""Computer Science"",
    Web-of-Science-Categories = ""Computer Science, Software Engineering"",
    Author-Email = ""lith@mgmt.au.dk pan@cs.aau.dk"",
    Affiliations = ""Aarhus University; Aalborg University"",
    ResearcherID-Numbers = ""Nielsen, Peter/K-1952-2019"",
    ORCID-Numbers = ""Nielsen, Peter Axel/0000-0002-0282-7445 Tordrup, Lise/0000-0003-4495-3084"",
    Number-of-Cited-References = ""61"",
    Times-Cited = ""9"",
    Usage-Count-Last-180-days = ""4"",
    Usage-Count-Since-2013 = ""18"",
    Journal-ISO = ""Empir. Softw. Eng."",
    Doc-Delivery-Number = ""KT0VU"",
    Web-of-Science-Index = ""Science Citation Index Expanded (SCI-EXPANDED)"",
    Unique-ID = ""WOS:000515762900001"",
    DA = ""2024-12-04""
}
"""	Excluded	Excluded	new_screen			2	Web of Science		Meshing agile and plan-driven development in safety-critical software: a case study	https://link.springer.com/article/10.1007/s10664-020-09804-z	SPRINGER	
464	Behave	Microservices: The Evolution and Extinction of Web Services?	In the early 2000s, service-oriented architectures (SOA) emerged as a paradigm for distributed computing, e-business processing, and enterprise integration. Rapidly, SOA and web services became the subject of hype, and virtually every organization tried to adopt them, no matter their actual suitability. Even worse, there were nearly as many definitions of SOA as people adopting it. This led to a big fail on many of those attempts, as they tried to change the problem to fit the solution. Nowadays, microservices are the new weapon of choice to achieve the same (and even more) goals posed to SOA years ago. Microservices (``SOA done right'') describe a particular way of designing software applications as suites of independently deployable services, bringing dynamism, modularity, distributed development, and integration of heterogeneous systems. However, nothing comes for free: new (and old) challenges appeared, including service design and specification, data integrity, and consistency management. In this chapter, we identify such challenges through an evolutionary view from the early years of SOA to microservices, and beyond. Our findings are backed by a literature review, comprising both academic and gray literature. Afterwards, we analyze how such challenges are addressed in practice, and which challenges remain open, by inspecting microservice-related projects on GitHub, the largest open-source repository to date.		Baresi, Luciano; Garriga, Martin	Microservices	https://doi.org/10.1007/978-3-030-31646-4_1		3--28	"""@Inbook{Baresi2020,
    author = ""Baresi, Luciano and Garriga, Martin"",
    editor = ""Bucchiarone, Antonio and Dragoni, Nicola and Dustdar, Schahram and Lago, Patricia and Mazzara, Manuel and Rivera, Victor and Sadovykh, Andrey"",
    title = ""Microservices: The Evolution and Extinction of Web Services?"",
    bookTitle = ""Microservices: Science and Engineering"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""3--28"",
    abstract = ""In the early 2000s, service-oriented architectures (SOA) emerged as a paradigm for distributed computing, e-business processing, and enterprise integration. Rapidly, SOA and web services became the subject of hype, and virtually every organization tried to adopt them, no matter their actual suitability. Even worse, there were nearly as many definitions of SOA as people adopting it. This led to a big fail on many of those attempts, as they tried to change the problem to fit the solution. Nowadays, microservices are the new weapon of choice to achieve the same (and even more) goals posed to SOA years ago. Microservices (``SOA done right'') describe a particular way of designing software applications as suites of independently deployable services, bringing dynamism, modularity, distributed development, and integration of heterogeneous systems. However, nothing comes for free: new (and old) challenges appeared, including service design and specification, data integrity, and consistency management. In this chapter, we identify such challenges through an evolutionary view from the early years of SOA to microservices, and beyond. Our findings are backed by a literature review, comprising both academic and gray literature. Afterwards, we analyze how such challenges are addressed in practice, and which challenges remain open, by inspecting microservice-related projects on GitHub, the largest open-source repository to date."",
    isbn = ""978-3-030-31646-4"",
    doi = ""10.1007/978-3-030-31646-4\_1"",
    url = ""https://doi.org/10.1007/978-3-030-31646-4\_1""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Microservices: The Evolution and Extinction of Web Services?	https://link.springer.com/chapter/10.1007/978-3-030-31646-4_1	Springer International Publishing	nan; Keywords; References
465	Behave	Microservices: Yesterday, Today, and Tomorrow	Microservices is an architectural style inspired by service-oriented computing that has recently started gaining popularity. Before presenting the current state of the art in the field, this chapter reviews the history of software architecture, the reasons that led to the diffusion of objects and services first, and microservices later. Finally, open problems and future challenges are introduced. This survey primarily addresses newcomers to the discipline, while offering an academic viewpoint on the topic. In addition, we investigate some practical issues and point out a few potential solutions.		Dragoni, Nicola; Giallorenzo, Saverio; Lafuente, Alberto Lluch; Mazzara, Manuel; Montesi, Fabrizio; Mustafin, Ruslan; Safina, Larisa	Present and Ulterior Software Engineering	https://doi.org/10.1007/978-3-319-67425-4_12		195--216	"""@Inbook{Dragoni2017,
    author = ""Dragoni, Nicola and Giallorenzo, Saverio and Lafuente, Alberto Lluch and Mazzara, Manuel and Montesi, Fabrizio and Mustafin, Ruslan and Safina, Larisa"",
    editor = ""Mazzara, Manuel and Meyer, Bertrand"",
    title = ""Microservices: Yesterday, Today, and Tomorrow"",
    bookTitle = ""Present and Ulterior Software Engineering"",
    year = ""2017"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""195--216"",
    abstract = ""Microservices is an architectural style inspired by service-oriented computing that has recently started gaining popularity. Before presenting the current state of the art in the field, this chapter reviews the history of software architecture, the reasons that led to the diffusion of objects and services first, and microservices later. Finally, open problems and future challenges are introduced. This survey primarily addresses newcomers to the discipline, while offering an academic viewpoint on the topic. In addition, we investigate some practical issues and point out a few potential solutions."",
    isbn = ""978-3-319-67425-4"",
    doi = ""10.1007/978-3-319-67425-4\_12"",
    url = ""https://doi.org/10.1007/978-3-319-67425-4\_12""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Microservices: Yesterday, Today, and Tomorrow	http://link.springer.com/chapter/10.1007/978-3-319-67425-4_12	Springer International Publishing	nan; Keywords; References
466	Behave	Migrating to Microservices			Alexis HenryYoussef Ridene						Excluded	Excluded	new_screen			2						
467	Behave	Mobile Testing	A few years back at a conference I heard this analogy between modern software engineers and civil engineers. The story went something like this: suppose you were building a bridge that had never been built before and you were using a new architecture on which the previous equations you used to solve bridge problems did not apply. How would you know if the bridge could support the proposed weight?	Simple Loop; Companion Site; Mobile Test; Native Selector; Test Harness	Scott Preston	Learn HTML5 and JavaScript for iOS	https://doi.org/10.1007/978-1-4302-4039-6_13		203–217		Excluded	Excluded	new_screen			2	Springer Link		Mobile Testing	http://link.springer.com/chapter/10.1007/978-1-4302-4039-6_13	Apress	nan; References; Year; Bibtex
468	Behave	Mock objects for testing java systems	When testing software artifacts that have several dependencies, one has the possibility of either instantiating these dependencies or using mock objects to simulate the dependencies' expected behavior. Even though recent quantitative studies showed that mock objects are widely used both in open source and proprietary projects, scientific knowledge is still lacking on how and why practitioners use mocks. An empirical understanding of the situations where developers have (and have not) been applying mocks, as well as the impact of such decisions in terms of coupling and software evolution can be used to help practitioners adapt and improve their future usage. To this aim, we study the usage of mock objects in three OSS projects and one industrial system. More specifically, we manually analyze more than 2,000 mock usages. We then discuss our findings with developers from these systems, and identify practices, rationales, and challenges. These results are supported by a structured survey with more than 100 professionals. Finally, we manually analyze how the usage of mock objects in test code evolve over time as well as the impact of their usage on the coupling between test and production code. Our study reveals that the usage of mocks is highly dependent on the responsibility and the architectural concern of the class. Developers report to frequently mock dependencies that make testing difficult (e.g., infrastructure-related dependencies) and to not mock classes that encapsulate domain concepts/rules of the system. Among the key challenges, developers report that maintaining the behavior of the mock compatible with the behavior of original class is hard and that mocking increases the coupling between the test and the production code. Their perceptions are confirmed by our data, as we observed that mocks mostly exist since the very first version of the test class, and that they tend to stay there for its whole lifetime, and that changes in production code often force the test code to also change.	Artificial Intelligence; Software testing; Mocking practices; Mockito; Empirical software engineering	Davide Spadini,; Mauricio Aniche; Magiel Bruntink; Alberto Bacchelli	Empirical Software Engineering	https://doi.org/10.1007/s10664-018-9663-0	"Alves TL, Ypma C, Visser J (2010) Deriving metric thresholds from benchmark data. In: IEEE international conference on software maintenance ICSM. 
                    https://doi.org/10.1109/ICSM.2010.5609747; Aniche M, Treude C, Zaidman A, Deursen AV, Gerosa MA (2016) SATT: tailoring code metric thresholds for different software architectures. In: Proceedings - 2016 IEEE 16th international working conference on source code analysis and manipulation, SCAM 2016, pp 41-50. 
                    https://doi.org/10.1109/SCAM.2016.19; Arcuri A, Fraser G, Galeotti JP (2014) Automated unit test generation for classes with environment dependencies. In: Proceedings of the 29th ACM/IEEE international conference on automated software engineering, pp 79-90. ACM; Arcuri A, Fraser G, Just R (2017) Private api access and functional mocking in automated unit test generation. In: 2017 IEEE international conference on software testing, verification and validation (ICST), pp 126-137. IEEE; citation_title=Modern information retrieval, vol 463; citation_publication_date=1999; citation_id=CR5; citation_author=R Baeza-Yates; citation_author=B Ribeiro-Neto; citation_publisher=ACM Press; citation_journal_title=Empir Softw Eng; citation_title=Are test smells really harmful? An empirical study; citation_author=G Bavota, A Qusef, R Oliveto, A Lucia, D Binkley; citation_volume=20; citation_issue=4; citation_publication_date=2015; citation_pages=1052-1094; citation_doi=10.1007/s10664-014-9313-0; citation_id=CR6; citation_title=Test-driven development: by example; citation_publication_date=2003; citation_id=CR7; citation_author=K Beck; citation_publisher=Addison-Wesley Professional; Biegel B, Soetens QD, Hornig W, Diehl S, Demeyer S (2011) Comparison of similarity metrics for refactoring detection. In: Proceedings of the 8th working conference on mining software repositories, pp 53-62. ACM; Bruntink M, Van Deursen A (2004) Predicting class testability using object-oriented metrics. In: 4th IEEE international workshop on source code analysis and manipulation, 2004. pp 136-145. IEEE; D'Ambros M, Lanza M, Robbes R (2010) An extensive comparison of bug prediction approaches. In: 2010 7th IEEE working conference on mining software repositories (MSR), p 31-41. IEEE; EasyMock (2016) 
                    http://easymock.org
                    
                  . Online, Accessed 3 Feb 2016; citation_title=Domain-driven design: tackling complexity in the heart of software; citation_publication_date=2004; citation_id=CR12; citation_author=E Evans; citation_publisher=Addison-Wesley Professional; citation_title=Patterns of enterprise application architecture; citation_publication_date=2002; citation_id=CR13; citation_author=M Fowler; citation_publisher=Addison-wesley Longman Publishing Co. Inc; Fowler M, Beck K, Hansson DH (2014) Is tdd dead? 
                    https://plus.google.com/events/ci2g23mk0lh9too9bgbp3rbut0k
                    
                  . Last access in July, 2018; Fraser G, Arcuri A (2011) Evosuite: automatic test suite generation for object-oriented software. In: Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on foundations of software engineering, pp 416-419. ACM; Freeman S, Mackinnon T, Pryce N, Walnes J (2004) Mock roles, objects. In: Companion to the 19th annual ACM SIGPLAN conference on object-oriented programming systems, languages, and applications, pp 236-246. ACM; citation_title=Growing object-oriented software, guided by tests; citation_publication_date=2009; citation_id=CR17; citation_author=S Freeman; citation_author=N Pryce; citation_publisher=Pearson Education; Greiler M, van Deursen A, Storey MA (2013) Automated detection of test fixture strategies and smells. In: 2013 IEEE 6th international conference on software testing, verification and validation, pp 322-331. 
                    https://doi.org/10.1109/ICST.2013.45; Greiler M, Zaidman A, van Deursen A, Storey MA (2013) Strategies for avoiding text fixture smells during software evolution. In: Proceedings of the 10th Working Conference on Mining Software Repositories (MSR), pp 387-396. IEEE; Hamill P (2004) Unit test frameworks: tools for high-quality software development. O'Reilly Media; citation_title=Universal methods of design: 100 ways to research complex problems, develop innovative ideas, and design effective solutions; citation_publication_date=2012; citation_id=CR21; citation_author=B Hanington; citation_author=B Martin; citation_publisher=Rockport Publishers; Henderson F (2017) Software Engineering at Google. arXiv:
                    1702.01715; citation_title=Robust confidence intervals for effect sizes: a comparative study of cohen's d and cliff's delta under non-normality and heterogeneous variances; citation_publication_date=2004; citation_id=CR23; citation_author=MR Hess; citation_author=JD Kromrey; citation_publisher=American Educational Research Association; Hunt A, Thomas D (2004) Pragmatic unit testing in c# with nunit. The Pragmatic Programmers; JMock (2016) 
                    http://www.jmock.org
                    
                  . Online, Accessed 3 Feb 2016; Kaczanowski T (2012) Practical Unit Testing with testNG and Mockito. Tomasz Kaczanowski; Karlesky M, Williams G, Bereza W, Fletcher M (2007) Mocking the embedded world: test-driven development, continuous integration, and design patterns. In: Embedded systems conference Silicon Valley (San Jose, California) ESC 413, april 2007. ESC 413; Kim SS (2016) Mocking embedded hardware for software validation. Ph.D thesis; Kotlin (2016) 
                    https://kotlinlang.org
                    
                  . Online; Accessed 3 Feb 2016; Langr J, Hunt A, Thomas D (2015) Pragmatic unit testing in java 8 with JUnit. Pragmatic Bookshelf; Li B, Vendome C, Linares-Vasquez M, Poshyvanyk D, Kraft NA (2016) Automatically documenting unit test cases. In: 2016 IEEE international conference on software testing, verification and validation (ICST), pp 341-352. IEEE; citation_title=Extreme Programming Examined; citation_publication_date=2001; citation_id=CR32; citation_author=T Mackinnon; citation_author=S Freeman; citation_author=P Craig; citation_publisher=Addison-Wesley Longman Publishing Co., Inc.; citation_journal_title=AST; citation_title=An empirical study of testing file-system-dependent software with mock objects; citation_author=MR Marri, T Xie, N Tillmann, J Halleux, W Schulte; citation_volume=9; citation_publication_date=2009; citation_pages=149-153; citation_id=CR33; citation_journal_title=IEEE Trans Softw Eng; citation_title=A complexity measure; citation_author=T McCabe; citation_volume=SE-2; citation_issue=4; citation_publication_date=1976; citation_pages=308-320; citation_doi=10.1109/TSE.1976.233837; citation_id=CR34; citation_title=xUnit test patterns: Refactoring test code; citation_publication_date=2007; citation_id=CR35; citation_author=G Meszaros; citation_publisher=Pearson Education; Mostafa S, Wang X (2014) An empirical study on the usage of mocking frameworks in software testing. In: 2014 14th international conference on quality software, pp 127-132. IEEE. 
                    https://doi.org/10.1109/QSIC.2014.19
                    
                  . 
                    http://ieeexplore.ieee.org/document/6958396/; Mock (2016) 
                    https://github.com/testing-cabal/mock
                    
                  . Online, Accessed 3 Feb 2016; Mocker (2016) 
                    https://labix.org/mocker
                    
                  . Online, Accessed 3 Feb 2016; Mockito (2016) 
                    http://site.mockito.org
                    
                  . Online, Accessed 3 Feb 2016; MyBatis (2016) 
                    http://www.mybatis.org/
                    
                  . Online, Accessed 3 Feb 2016; citation_journal_title=Eur J Social Psychol; citation_title=Methods of coping with social desirability bias: a review; citation_author=AJ Nederhof; citation_volume=15; citation_issue=3; citation_publication_date=1985; citation_pages=263-280; citation_doi=10.1002/ejsp.2420150303; citation_id=CR41; Osherove R (2009) The art of unit testing: with examples in.NET Manning; Palomba F, Di Nucci D, Panichella A, Oliveto R, De Lucia A (2016) On the diffusion of test smells in automatically generated test code: an empirical study. In: Proceedings of the 9th international workshop on search-based software testing, pp 5-14. ACM; Pereira F (2014) Mockists are dead. long live classicists. 
                    https://www.thoughtworks.com/insights/blog/mockists-are-dead-long-live-classicists
                    
                  . Last access in July, 2018; PowerMock (2016) 
                    https://github.com/powermock/powermock
                    
                  . Online, Accessed 3 Feb 2016; citation_journal_title=J Statist Model Anal; citation_title=Power comparisons of Shapiro-Wilk, Kolmogorov-Smirnov, Lilliefors and Anderson-Darling tests; citation_author=NM Razali, YB Wah; citation_volume=2; citation_issue=1; citation_publication_date=2011; citation_pages=21-33; citation_id=CR46; citation_journal_title=Computing; citation_title=Article picture sorts and item sorts; citation_author=G Rugg; citation_volume=22; citation_issue=3; citation_publication_date=2005; citation_pages=94; citation_id=CR47; citation_journal_title=IEEE Softw; citation_title=A survey of unit testing practices; citation_author=P Runeson; citation_volume=23; citation_issue=4; citation_publication_date=2006; citation_pages=22-29; citation_doi=10.1109/MS.2006.91; citation_id=CR48; Samimi H, Hicks R, Fogel A, Millstein T (2013) Declarative mocking categories and subject descriptors, pp 246-256; Spadini D (2017) To Mock or Not To Mock? Online Appendix. 
                    https://doi.org/10.4121/uuid:fce8653c-344c-4dcb-97ab-c9c1407ad2f0; Spadini D, Aniche M, Bacchelli A, Bruntink M (2017) MockExtractor. The tool is available at 
                    http://www.doi.org/10.5281/zenodo.1475900; Spadini D, Aniche M, Bruntink M, Bacchelli A (2017) To mock or not to mock?: an empirical study on mocking practices. In: Proceedings of the 14th international conference on mining software repositories, pp 402-412. IEEE Press; Spencer D (2004) Card sorting: a definitive guide. 
                    http://boxesandarrows.com/card-sorting-a-definitive-guide/; Taneja K, Zhang Y, Xie T (2010) MODA: automated test generation for database applications via mock objects. In: Proceedings of the IEEE/ACM international conference on Automated software engineering - ASE '10, p 289. ACM Press, New York. 
                    https://doi.org/10.1145/1858996.1859053
                    
                  . 
                    http://portal.acm.org/citation.cfm?doid=1858996.1859053; Tufano M, Palomba F, Bavota G, Di Penta M, Oliveto R, De Lucia A, Poshyvanyk D (2016) An empirical investigation into the nature of test smells. In: Proceedings of the 31st IEEE/ACM international conference on automated software engineering, ASE 2016, pp 4-15. ACM, New York; Vahabzadeh A, Fard AM, Mesbah A (2015) An empirical study of bugs in test code. In: 2015 IEEE international conference on software maintenance and evolution (ICSME), pp 101-110. IEEE; van Deursen A, Moonen L, Bergh A, Kok G (2001) Refactoring test code. In: Proceedings of the 2nd international conference on extreme programming and flexible processes in software engineering (XP), pp 92-95; citation_journal_title=IEEE Trans Softw Eng; citation_title=On the detection of test smells: a metrics-based approach for general fixture and eager test; citation_author=B Rompaey, B Du Bois, S Demeyer, M Rieger; citation_volume=33; citation_issue=12; citation_publication_date=2007; citation_pages=800-817; citation_doi=10.1109/TSE.2007.70745; citation_id=CR58; Vonken F, Zaidman A (2012) Refactoring with unit testing: a match made in heaven?. In: 2012 19th working conference on reverse engineering (WCRE), pp 29-38. IEEE; citation_journal_title=IEEE Softw; citation_title=Testing component-based software: a cautionary tale; citation_author=E Weyuker; citation_volume=15; citation_issue=5; citation_publication_date=1998; citation_pages=54-59; citation_doi=10.1109/52.714817; citation_id=CR60; citation_journal_title=J Econ Entomol; citation_title=Individual comparisons of grouped data by ranking methods; citation_author=F Wilcoxon; citation_volume=39; citation_issue=6; citation_publication_date=1946; citation_pages=269; citation_doi=10.1093/jee/39.2.269; citation_id=CR61; Wynne M, Hellesoy A (2012) The cucumber book: behaviour-driven development for testers and developers. Pragmatic Bookshelf; Wynne M, Hellesoy A (2012) The cucumber book: Behaviour-driven development for testers and developers. Pragmatic Bookshelf; Xie T, Tillmann N, De Halleux J, Schulte W (2010) Future of developer testing: Building quality in code. In: Proceedings of the FSE/SDP workshop on Future of software engineering research, pp 415-420. ACM; Zaidman A, Rompaey BV, Demeyer S, Deursen AV (2008) Mining software repositories to study co-evolution of production and test code. In: 2008 1st international conference on software testing, verification, and validation, vol 3, pp 220-229. 
                    https://doi.org/10.1109/ICST.2008.47; Zaidman A, Van Rompaey B, Demeyer S, Van Deursen A (2008) Mining software repositories to study co-evolution of production & test code. In: 2008 1St international conference on software testing, verification, and validation, pp 220-229. IEEE"			Excluded	Excluded	new_screen			2	Springer Link		Mock objects for testing java systems	http://link.springer.com/article/10.1007/s10664-018-9663-0	Springer Link	nan; Pages; Year; Bibtex
469	Behave	Modeling and Analyzing Using ASMs: The Landing Gear System Case Study	The paper presents an Abstract State Machine (ASM) specification of the Landing Gear System case study, and shows how the ASMETA framework can be used to support the modeling and analysis (validation and verification) activities for developing a rigorous and correct model in terms of ASMs. We exploit the two fundamental concepts of the ASM method, i.e., the notion of ground model and the refinement principle, and we achieve model development and model analysis by the combined use of formal methods for specification and for verification.		Arcaini, Paolo; Gargantini, Angelo; Riccobene, Elvinia	International Conference on Abstract State Machines, Alloy, B, TLA, VDM, and Z	https://doi.org/10.1007/978-3-319-07512-9_3		36--51	"""@InProceedings{10.1007/978-3-319-07512-9_3,
    author = ""Arcaini, Paolo and Gargantini, Angelo and Riccobene, Elvinia"",
    editor = ""Boniol, Fr{\'e}d{\'e}ric and Wiels, Virginie and Ait Ameur, Yamine and Schewe, Klaus-Dieter"",
    title = ""Modeling and Analyzing Using ASMs: The Landing Gear System Case Study"",
    booktitle = ""ABZ 2014: The Landing Gear Case Study"",
    year = ""2014"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""36--51"",
    abstract = ""The paper presents an Abstract State Machine (ASM) specification of the Landing Gear System case study, and shows how the ASMETA framework can be used to support the modeling and analysis (validation and verification) activities for developing a rigorous and correct model in terms of ASMs. We exploit the two fundamental concepts of the ASM method, i.e., the notion of ground model and the refinement principle, and we achieve model development and model analysis by the combined use of formal methods for specification and for verification."",
    isbn = ""978-3-319-07512-9""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Modeling and Analyzing Using ASMs: The Landing Gear System Case Study	http://link.springer.com/chapter/10.1007/978-3-319-07512-9_3	Springer International Publishing	nan; Keywords; References
470	Behave	Modeling in Agile Software Development: Decomposing Use Cases Towards Logical Architecture Design	[Context and motivation] There are a plethora of agile practices that relate to management (e.g., Sprints, Scrum ceremonies), development (e.g., pair programming, TDD, BDD, DevOps) or strategy (e.g., Lean Startup), [Question/problem] but lack a comprehensive description on how its adoption influences requirements modeling and ``You Aren't Gonna Need It'' (YAGNI) features. [Principal ideas/results] This paper presents Agile Modeling Process for Logical Architectures (AMPLA), an Agile Modeling (AM) oriented process composed by UML diagrams (namely, Sequence, Use Cases and Component). [Contributions] AMPLA uses agile practices in order to deliver small increments (of a requirements package) and to promote continuous customer feedback. The proposed AM process also includes a candidate architecture and further requirements refinement in parallel with a software increment delivery.	Agile modeling; Agile RE; UML use cases; Logical architectures; Agile modeling;  Agile RE;  UML use cases;  Logical architectures	Santos, Nuno; Pereira, Jaime; Ferreira, Nuno; Machado, Ricardo J.	International Conference on Product-Focused Software Process Improvement	https://doi.org/10.1007/978-3-030-03673-7\_31		396--408	"""@InProceedings{10.1007/978-3-030-03673-7_31,
    author = ""Santos, Nuno and Pereira, Jaime and Ferreira, Nuno and Machado, Ricardo J."",
    editor = {Kuhrmann, Marco and Schneider, Kurt and Pfahl, Dietmar and Amasaki, Sousuke and Ciolkowski, Marcus and Hebig, Regina and Tell, Paolo and Kl{\""u}nder, Jil and K{\""u}pper, Steffen},
    title = ""Modeling in Agile Software Development: Decomposing Use Cases Towards Logical Architecture Design"",
    booktitle = ""Product-Focused Software Process Improvement"",
    year = ""2018"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""396--408"",
    abstract = ""[Context and motivation] There are a plethora of agile practices that relate to management (e.g., Sprints, Scrum ceremonies), development (e.g., pair programming, TDD, BDD, DevOps) or strategy (e.g., Lean Startup), [Question/problem] but lack a comprehensive description on how its adoption influences requirements modeling and ``You Aren't Gonna Need It'' (YAGNI) features. [Principal ideas/results] This paper presents Agile Modeling Process for Logical Architectures (AMPLA), an Agile Modeling (AM) oriented process composed by UML diagrams (namely, Sequence, Use Cases and Component). [Contributions] AMPLA uses agile practices in order to deliver small increments (of a requirements package) and to promote continuous customer feedback. The proposed AM process also includes a candidate architecture and further requirements refinement in parallel with a software increment delivery."",
    isbn = ""978-3-030-03673-7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Modeling in Agile Software Development: Decomposing Use Cases Towards Logical Architecture Design	https://link.springer.com/chapter/10.1007/978-3-030-03673-7_31	Springer International Publishing	nan; References
471	Behave	Modeling Software Requirements	Enhancing requirements elicitation and specification extraction has always been of added value to software engineering, as it expedites the software development life cycle. In this context, the main challenge is to construct formal models that are capable of storing requirements from multimodal formats and can facilitate requirements reuse. In this chapter, we present an approach that captures the static and dynamic view of software projects and generates traceable system specifications. Our ontology-based approach can receive input in the form of functional requirements, UML use case and activity diagrams, and storyboards and allows for reasoning over the stored requirements for validation and reuse purposes.		Diamantopoulos, Themistoklis; Symeonidis, Andreas L.	Mining Software Engineering Data for Software Reuse	https://doi.org/10.1007/978-3-030-30106-4_3		47--74	"""@Inbook{Diamantopoulos2020,
    author = ""Diamantopoulos, Themistoklis and Symeonidis, Andreas L."",
    title = ""Modeling Software Requirements"",
    bookTitle = ""Mining Software Engineering Data for Software Reuse"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""47--74"",
    abstract = ""Enhancing requirements elicitation and specification extraction has always been of added value to software engineering, as it expedites the software development life cycle. In this context, the main challenge is to construct formal models that are capable of storing requirements from multimodal formats and can facilitate requirements reuse. In this chapter, we present an approach that captures the static and dynamic view of software projects and generates traceable system specifications. Our ontology-based approach can receive input in the form of functional requirements, UML use case and activity diagrams, and storyboards and allows for reasoning over the stored requirements for validation and reuse purposes."",
    isbn = ""978-3-030-30106-4"",
    doi = ""10.1007/978-3-030-30106-4\_3"",
    url = ""https://doi.org/10.1007/978-3-030-30106-4\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Modeling Software Requirements	https://link.springer.com/chapter/10.1007/978-3-030-30106-4_3	Springer International Publishing	nan; Keywords; References
472	Behave	NLP-Assisted Model Generation	Until today natural language text still is the universal communication mean between stakeholders and engineers in the design of highly complex systems. Although formal models offer a unique interpretation since they are based on a formal semantic, they are hard to incorporate at this early stage since they require expert knowledge. Textual specifications on the other side are often comprehensible immediately, but allow lots of space for interpretation due to ambiguities and different text understanding of the readers. However, these ambiguities and differences in text understanding can lead to severe errors in a later stage of the design flow if they are not detected as early as possible [47].		Soeken, Mathias; Drechsler, Rolf	Formal Specification Level	https://doi.org/10.1007/978-3-319-08699-6_3		23--55	"""@Inbook{Soeken2015,
    author = ""Soeken, Mathias and Drechsler, Rolf"",
    title = ""NLP-Assisted Model Generation"",
    bookTitle = ""Formal Specification Level: Concepts, Methods, and Algorithms"",
    year = ""2015"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""23--55"",
    abstract = ""Until today natural language text still is the universal communication mean between stakeholders and engineers in the design of highly complex systems. Although formal models offer a unique interpretation since they are based on a formal semantic, they are hard to incorporate at this early stage since they require expert knowledge. Textual specifications on the other side are often comprehensible immediately, but allow lots of space for interpretation due to ambiguities and different text understanding of the readers. However, these ambiguities and differences in text understanding can lead to severe errors in a later stage of the design flow if they are not detected as early as possible [47]."",
    isbn = ""978-3-319-08699-6"",
    doi = ""10.1007/978-3-319-08699-6\_3"",
    url = ""https://doi.org/10.1007/978-3-319-08699-6\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		NLP-Assisted Model Generation	https://link.springer.com/chapter/10.1007/978-3-319-08699-6_3	Springer International Publishing	nan; Keywords; References
473	Behave	Node Modules	A typical MEAN application can often depend on up to hundreds of packages. These modules are often small and consist of both Node.js and Bower libraries. By combining libraries, you are able to create a mashup of small-shared building blocks and custom apps for the purpose of solving a larger problem.	Version Option; Command Line; Open Source Project; Node Module; Test Drive Development	Elrom, Elad	Pro MEAN Stack Development	https://doi.org/10.1007/978-1-4842-2044-3_3		51--73	"""@Inbook{Elrom2016,
    author = ""Elrom, Elad"",
    title = ""Node Modules"",
    bookTitle = ""Pro MEAN Stack Development"",
    year = ""2016"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""51--73"",
    abstract = ""A typical MEAN application can often depend on up to hundreds of packages. These modules are often small and consist of both Node.js and Bower libraries. By combining libraries, you are able to create a mashup of small-shared building blocks and custom apps for the purpose of solving a larger problem."",
    isbn = ""978-1-4842-2044-3"",
    doi = ""10.1007/978-1-4842-2044-3\_3"",
    url = ""https://doi.org/10.1007/978-1-4842-2044-3\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Node Modules	https://link.springer.com/chapter/10.1007/978-1-4842-2044-3_3	Apress	nan; References
474	Behave	Normen, Standards, Practices	"Die folgenden Unterkapitel geben einen kurzen Abriss einiger Normen, Standards und Practices, die in Bezug zum Sicherheits-, Kontinuit{\""a}ts- und Risikomanagement stehen. Hierzu geh{\""o}ren die Standards und das IT-Grundschutz-Kompendium des BSI, die ISO/IEC-27000-Familie zur Informationssicherheit, die ISO/IEC 20000 sowie ITIL(r) und COBIT(r). Der Abriss erm{\""o}glicht zum einen den {\""u}berblicksartigen Vergleich des Vorgehensmodells und der Inhalte der Sicherheitspyramide mit Normen, Standards und Practices sowie zum anderen verschiedentlich die Herstellung von Bez{\""u}gen von der Sicherheitspyramide auf Normen, Standards und Practices und das Aufzeigen von Entwicklungen."		"M{\""u}ller, Klaus-Rainer"	IT-Sicherheit mit System	https://doi.org/10.1007/978-3-658-22065-5_5		90--196	"""@Inbook{Muller2018,
    author = {M{\""u}ller, Klaus-Rainer},
    title = ""Normen, Standards, Practices"",
    bookTitle = {IT-Sicherheit mit System: Integratives IT-Sicherheits-, Kontinuit{\""a}ts- und Risikomanagement -- Sichere Anwendungen -- Standards und Practices},
    year = ""2018"",
    publisher = ""Springer Fachmedien Wiesbaden"",
    address = ""Wiesbaden"",
    pages = ""90--196"",
    abstract = {Die folgenden Unterkapitel geben einen kurzen Abriss einiger Normen, Standards und Practices, die in Bezug zum Sicherheits-, Kontinuit{\""a}ts- und Risikomanagement stehen. Hierzu geh{\""o}ren die Standards und das IT-Grundschutz-Kompendium des BSI, die ISO/IEC-27000-Familie zur Informationssicherheit, die ISO/IEC 20000 sowie ITIL(r) und COBIT(r). Der Abriss erm{\""o}glicht zum einen den {\""u}berblicksartigen Vergleich des Vorgehensmodells und der Inhalte der Sicherheitspyramide mit Normen, Standards und Practices sowie zum anderen verschiedentlich die Herstellung von Bez{\""u}gen von der Sicherheitspyramide auf Normen, Standards und Practices und das Aufzeigen von Entwicklungen.},
    isbn = ""978-3-658-22065-5"",
    doi = ""10.1007/978-3-658-22065-5\_5"",
    url = ""https://doi.org/10.1007/978-3-658-22065-5\_5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Normen, Standards, Practices	https://link.springer.com/chapter/10.1007/978-3-658-22065-5_5	Springer Fachmedien Wiesbaden	nan; Keywords; References
475	Behave	Onstage Product Owner	Writing user stories, refine stories, administerting the backlog, prioritiser in chief, work with the team, 3 Amigos, testing, estimating - these are a few of the more visable things Product Owners do.		Kelly, Allan	The Art of Agile Product Ownership	https://doi.org/10.1007/978-1-4842-5168-3_8		57--61	"""@Inbook{Kelly2019,
    author = ""Kelly, Allan"",
    title = ""Onstage Product Owner"",
    bookTitle = ""The Art of Agile Product Ownership: A Guide for Product Managers, Business Analysts, and Entrepreneurs"",
    year = ""2019"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""57--61"",
    abstract = ""Writing user stories, refine stories, administerting the backlog, prioritiser in chief, work with the team, 3 Amigos, testing, estimating - these are a few of the more visable things Product Owners do."",
    isbn = ""978-1-4842-5168-3"",
    doi = ""10.1007/978-1-4842-5168-3\_8"",
    url = ""https://doi.org/10.1007/978-1-4842-5168-3\_8""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Onstage Product Owner	http://link.springer.com/chapter/10.1007/978-1-4842-5168-3_8	Apress	nan; Keywords; References
476	Behave	Open Debates	Technology has fundamentally changed how we communicate with each other. New tools and platforms allow us to share our stories more vibrantly than ever before. In this chapter, we focus on a cornerstone of discourse: debates. We build a Jekyll-based debate platform that can leverage the full capabilities of GitHub to host open debates. We begin with an introduction to the debate platform and the rules of an Oxford-style debate. After that, we provide an in-depth overview of GitHub and all of its features, including some features of GitHub Pages that we have not yet had a chance to cover. We then create a prototype based on the rules to help us find a theme. When we have found a suitable theme and understood the requirements for this project, we can start editing the theme to obtain our final debate platform. Finally, we end this chapter with a discussion of how our platform can take advantage of the open standards and use them in conducting the debates.	Home Page; Current Debate; Project Site; Organization Site; Domain Name System	Dhillon, Vikram	Creating Blogs with Jekyll	https://doi.org/10.1007/978-1-4842-1464-0_10		163--193	"""@Inbook{Dhillon2016,
    author = ""Dhillon, Vikram"",
    title = ""Open Debates"",
    bookTitle = ""Creating Blogs with Jekyll"",
    year = ""2016"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""163--193"",
    abstract = ""Technology has fundamentally changed how we communicate with each other. New tools and platforms allow us to share our stories more vibrantly than ever before. In this chapter, we focus on a cornerstone of discourse: debates. We build a Jekyll-based debate platform that can leverage the full capabilities of GitHub to host open debates. We begin with an introduction to the debate platform and the rules of an Oxford-style debate. After that, we provide an in-depth overview of GitHub and all of its features, including some features of GitHub Pages that we have not yet had a chance to cover. We then create a prototype based on the rules to help us find a theme. When we have found a suitable theme and understood the requirements for this project, we can start editing the theme to obtain our final debate platform. Finally, we end this chapter with a discussion of how our platform can take advantage of the open standards and use them in conducting the debates."",
    isbn = ""978-1-4842-1464-0"",
    doi = ""10.1007/978-1-4842-1464-0\_10"",
    url = ""https://doi.org/10.1007/978-1-4842-1464-0\_10""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Open Debates	http://link.springer.com/chapter/10.1007/978-1-4842-1464-0_10	Apress	nan; References
477	Behave	Organization of the Software Test in Agile Projects	This chapter examines multiple approaches, all of which have proven to be useful models in the respective project environment. Thus, the applicability of the traditional test process according to ISTQB in the agile context is considered and the Four Test Quadrants in Agile Testing are discussed. Another important topic for agile companies is scaling - therefore the approaches LeSS and SAFe are briefly presented. Additionally, case studies are outlined to illustrate what an agile test organization can look like.		Baumgartner, Manfred; Klonk, Martin; Mastnak, Christian; Pichler, Helmut; Seidl, Richard; Tanczos, Siegfried	Agile Testing	https://doi.org/10.1007/978-3-030-73209-7_3		37--77	"""@Inbook{Baumgartner2021,
    author = ""Baumgartner, Manfred and Klonk, Martin and Mastnak, Christian and Pichler, Helmut and Seidl, Richard and Tanczos, Siegfried"",
    title = ""Organization of the Software Test in Agile Projects"",
    bookTitle = ""Agile Testing: The Agile Way to Quality"",
    year = ""2021"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""37--77"",
    abstract = ""This chapter examines multiple approaches, all of which have proven to be useful models in the respective project environment. Thus, the applicability of the traditional test process according to ISTQB in the agile context is considered and the Four Test Quadrants in Agile Testing are discussed. Another important topic for agile companies is scaling - therefore the approaches LeSS and SAFe are briefly presented. Additionally, case studies are outlined to illustrate what an agile test organization can look like."",
    isbn = ""978-3-030-73209-7"",
    doi = ""10.1007/978-3-030-73209-7\_3"",
    url = ""https://doi.org/10.1007/978-3-030-73209-7\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Organization of the Software Test in Agile Projects	http://link.springer.com/chapter/10.1007/978-3-030-73209-7_3	Springer International Publishing	nan; Keywords; References
478	Behave	Patterns -- Wie geht es weiter?	"In diesem Kapitel m{\""o}chten wir Ihnen einige andere Bereiche vorstellen, in denen Sie Wissen und Erfahrungen {\""u}ber Patterns ver{\""o}ffentlicht finden k{\""o}nnen. In diesem Sinne verstehen Sie es bitte als eine Art kommentierte Literaturliste, die Ihnen als Anregung dienen soll."		Eilebrecht, Karl; Starke, Gernot	Patterns kompakt	https://doi.org/10.1007/978-3-642-34718-4_11		205--211	"""@Inbook{Eilebrecht2013,
    author = ""Eilebrecht, Karl and Starke, Gernot"",
    title = ""Patterns -- Wie geht es weiter?"",
    bookTitle = {Patterns kompakt: Entwurfsmuster f{\""u}r effektive Software-Entwicklung},
    year = ""2013"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""205--211"",
    abstract = {In diesem Kapitel m{\""o}chten wir Ihnen einige andere Bereiche vorstellen, in denen Sie Wissen und Erfahrungen {\""u}ber Patterns ver{\""o}ffentlicht finden k{\""o}nnen. In diesem Sinne verstehen Sie es bitte als eine Art kommentierte Literaturliste, die Ihnen als Anregung dienen soll.},
    isbn = ""978-3-642-34718-4"",
    doi = ""10.1007/978-3-642-34718-4\_11"",
    url = ""https://doi.org/10.1007/978-3-642-34718-4\_11""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Patterns – Wie geht es weiter?	http://link.springer.com/chapter/10.1007/978-3-642-34718-4_11	Springer Berlin Heidelberg	nan; Keywords; References
479	Behave	People and Tools	As a consultant, most customers that call me to help them start working with test automation start with the questions: ``Which tools are there?'' and ``which tools should I use''? If you're in that situation yourself, then you're probably asking this question too. The short answer to the first question is that there are a bazillion tools out there for test automation. Oh, and there's Selenium, too, of course, so there are bazillion and one. And the short answer to the second question is the classical consultant's answer: ``It depends.''		Axelrod, Arnon	Complete Guide to Test Automation	https://doi.org/10.1007/978-1-4842-3832-5_3		31--61	"""@Inbook{Axelrod2018,
    author = ""Axelrod, Arnon"",
    title = ""People and Tools"",
    bookTitle = ""Complete Guide to Test Automation: Techniques, Practices, and Patterns for Building and Maintaining Effective Software Projects"",
    year = ""2018"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""31--61"",
    abstract = ""As a consultant, most customers that call me to help them start working with test automation start with the questions: ``Which tools are there?'' and ``which tools should I use''? If you're in that situation yourself, then you're probably asking this question too. The short answer to the first question is that there are a bazillion tools out there for test automation. Oh, and there's Selenium, too, of course, so there are bazillion and one. And the short answer to the second question is the classical consultant's answer: ``It depends.''"",
    isbn = ""978-1-4842-3832-5"",
    doi = ""10.1007/978-1-4842-3832-5\_3"",
    url = ""https://doi.org/10.1007/978-1-4842-3832-5\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		People and Tools	http://link.springer.com/chapter/10.1007/978-1-4842-3832-5_3	Apress	nan; Keywords; References
480	Behave	Planning Your Work	Developers who are just starting out often believe that their job is to build what they're told to build by their managers or clients. The more experienced a developer becomes, the more they realize that building the right thing is more important than building the thing right. Effectively planning your work before you do it increases your effectiveness, as it ensures you properly understand the problem you're trying to solve.		Northwood, Chris	The Full Stack Developer	https://doi.org/10.1007/978-1-4842-4152-3_2		11--46	"""@Inbook{Northwood2018,
    author = ""Northwood, Chris"",
    title = ""Planning Your Work"",
    bookTitle = ""The Full Stack Developer: Your Essential Guide to the Everyday Skills Expected of a Modern Full Stack Web Developer"",
    year = ""2018"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""11--46"",
    abstract = ""Developers who are just starting out often believe that their job is to build what they're told to build by their managers or clients. The more experienced a developer becomes, the more they realize that building the right thing is more important than building the thing right. Effectively planning your work before you do it increases your effectiveness, as it ensures you properly understand the problem you're trying to solve."",
    isbn = ""978-1-4842-4152-3"",
    doi = ""10.1007/978-1-4842-4152-3\_2"",
    url = ""https://doi.org/10.1007/978-1-4842-4152-3\_2""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Planning Your Work	http://link.springer.com/chapter/10.1007/978-1-4842-4152-3_2	Apress	nan; Keywords; References
481	Behave	Polytrix: A Pacto-Powered Polyglot Test Matrix	We have created a polyglot test framework named Polytrix to compare, benchmark, and independently verify a suite of open-source OpenStack SDKs that each target a different programming language. The framework validates sample code from each SDK against a shared test scenario to validate that each SDK correctly implements a given scenario. It uses Pacto for integration contract testing between the SDKs and the OpenStack services, and generates test reports that help compare and document each SDK. It is designed so interactive training materials can be generated in future versions.	Public Cloud; Sample Code; Private Cloud; Literate Program; Test Code	Lincoln, Max; Alves, Fernando	IFIP International Conference on Open Source Systems	https://doi.org/10.1007/978-3-642-55128-4_27		191--194	"""@InProceedings{10.1007/978-3-642-55128-4_27,
    author = ""Lincoln, Max and Alves, Fernando"",
    editor = ""Corral, Luis and Sillitti, Alberto and Succi, Giancarlo and Vlasenko, Jelena and Wasserman, Anthony I."",
    title = ""Polytrix: A Pacto-Powered Polyglot Test Matrix"",
    booktitle = ""Open Source Software: Mobile Open Source Technologies"",
    year = ""2014"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""191--194"",
    abstract = ""We have created a polyglot test framework named Polytrix to compare, benchmark, and independently verify a suite of open-source OpenStack SDKs that each target a different programming language. The framework validates sample code from each SDK against a shared test scenario to validate that each SDK correctly implements a given scenario. It uses Pacto for integration contract testing between the SDKs and the OpenStack services, and generates test reports that help compare and document each SDK. It is designed so interactive training materials can be generated in future versions."",
    isbn = ""978-3-642-55128-4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Polytrix: A Pacto-Powered Polyglot Test Matrix	http://link.springer.com/chapter/10.1007/978-3-642-55128-4_27	Springer Berlin Heidelberg	nan; References
482	Behave	Poor Foundations	What can be done early on to set your teams up for success? What kinds of things are worth investing time in and how much do you try to solve for not knowing exactly what is needed in the long run? Furthermore, how do you front load a project with all the foundational-type work (think continuous integration, frameworks, etc.) that will make the rest of the project go smoothly? Once you think you know what those things are, how do you convince management that this upfront cost will pay off in the long run? One thing is fairly certain: if you don't invest in a solid foundation your Agile project will pay for it in the long run.		Brizard, Tim	Broken Agile	https://doi.org/10.1007/978-1-4842-1745-0_4		15--18	"""@Inbook{Brizard2015,
    author = ""Brizard, Tim"",
    title = ""Poor Foundations"",
    bookTitle = ""Broken Agile: Stories from the Trenches"",
    year = ""2015"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""15--18"",
    abstract = ""What can be done early on to set your teams up for success? What kinds of things are worth investing time in and how much do you try to solve for not knowing exactly what is needed in the long run? Furthermore, how do you front load a project with all the foundational-type work (think continuous integration, frameworks, etc.) that will make the rest of the project go smoothly? Once you think you know what those things are, how do you convince management that this upfront cost will pay off in the long run? One thing is fairly certain: if you don't invest in a solid foundation your Agile project will pay for it in the long run."",
    isbn = ""978-1-4842-1745-0"",
    doi = ""10.1007/978-1-4842-1745-0\_4"",
    url = ""https://doi.org/10.1007/978-1-4842-1745-0\_4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Poor Foundations	http://link.springer.com/chapter/10.1007/978-1-4842-1745-0_4	Apress	nan; Keywords; References
483	Behave	PowerShell-Skripte testen mit Pester	"Je umfangreicher ein Skript wird, desto h{\""o}her ist die Wahrscheinlichkeit, dass irgendetwas nicht so ausgef{\""u}hrt wird, wie es sich der Autor des Skriptes vorgestellt hat. Das gilt vor allem, wenn es mehrere Autoren gibt, die in zeitlich versetzten Abst{\""a}nden irgendwelche {\""A}nderungen vornehmen. An diesem Punkt muss eine wichtige Entscheidung getroffen werden. Soll das Skript wie bisher weiterentwickelt und gepflegt werden? Oder sollen Methoden eingef{\""u}hrt werden, wie sie auch in der Software-Entwicklung {\""u}blich sind? Das bedeutet vor allem zwei Dinge: Eine Versionsverwaltung und das Testen einzelner Funktionalit{\""a}ten mit Hilfe eines daf{\""u}r vorgesehenen Werkzeugs. Das Thema Versionsverwaltung ist in Kap. 7an der Reihe, das Thema Testen mit Hilfe des Pester-Moduls wird in diesem Kapitel vorgestellt. Pester ist ein Modul, das bei Windows Server 2016 und Windows 10 von Anfang an dabei ist. Es enth{\""a}lt eine Reihe von Functions, mit deren Hilfe sich Skripte, DSC-Ressourcen, Server-Konfigurationen und alles das, was per Befehlszeile abfragbar ist, automatisiert testen lassen. Das Besondere an den Functions ist, dass ihre Namen so gew{\""a}hlt wurden, dass sie an ein in der Software-Entwicklung {\""u}bliches Testverfahren orientieren."		Monadjemi, Peter	Windows Server-Administration mit PowerShell 5.1	https://doi.org/10.1007/978-3-658-17666-2_6		87--98	"""@Inbook{Monadjemi2017,
    author = ""Monadjemi, Peter"",
    title = ""PowerShell-Skripte testen mit Pester"",
    bookTitle = {Windows Server-Administration mit PowerShell 5.1: Eine kompakte und praxisorientierte Einf{\""u}hrung},
    year = ""2017"",
    publisher = ""Springer Fachmedien Wiesbaden"",
    address = ""Wiesbaden"",
    pages = ""87--98"",
    abstract = {Je umfangreicher ein Skript wird, desto h{\""o}her ist die Wahrscheinlichkeit, dass irgendetwas nicht so ausgef{\""u}hrt wird, wie es sich der Autor des Skriptes vorgestellt hat. Das gilt vor allem, wenn es mehrere Autoren gibt, die in zeitlich versetzten Abst{\""a}nden irgendwelche {\""A}nderungen vornehmen. An diesem Punkt muss eine wichtige Entscheidung getroffen werden. Soll das Skript wie bisher weiterentwickelt und gepflegt werden? Oder sollen Methoden eingef{\""u}hrt werden, wie sie auch in der Software-Entwicklung {\""u}blich sind? Das bedeutet vor allem zwei Dinge: Eine Versionsverwaltung und das Testen einzelner Funktionalit{\""a}ten mit Hilfe eines daf{\""u}r vorgesehenen Werkzeugs. Das Thema Versionsverwaltung ist in Kap. 7an der Reihe, das Thema Testen mit Hilfe des Pester-Moduls wird in diesem Kapitel vorgestellt. Pester ist ein Modul, das bei Windows Server 2016 und Windows 10 von Anfang an dabei ist. Es enth{\""a}lt eine Reihe von Functions, mit deren Hilfe sich Skripte, DSC-Ressourcen, Server-Konfigurationen und alles das, was per Befehlszeile abfragbar ist, automatisiert testen lassen. Das Besondere an den Functions ist, dass ihre Namen so gew{\""a}hlt wurden, dass sie an ein in der Software-Entwicklung {\""u}bliches Testverfahren orientieren.},
    isbn = ""978-3-658-17666-2"",
    doi = ""10.1007/978-3-658-17666-2\_6"",
    url = ""https://doi.org/10.1007/978-3-658-17666-2\_6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		PowerShell-Skripte testen mit Pester	http://link.springer.com/chapter/10.1007/978-3-658-17666-2_6	Springer Fachmedien Wiesbaden	nan; Keywords; References
484	Behave	Preparing the Project	In the early days of agile, agilists wanted to avoid all upfront work before the iterations of requirements, coding, and testing started: no architecture, no initial requirements, not even getting their development environment set up. (The emergent design fans still use this approach.) I think this is an overreaction to the waterfall method. The pendulum of popular development style swung from too-much-upfront work to no-upfront work. Fortunately, that pendulum is swinging back to some upfront work that some agilists call upfront learning.		Cline, Alan	Agile Development in the Real World	https://doi.org/10.1007/978-1-4842-1679-8_4		75--90	"""@Inbook{Cline2015,
    author = ""Cline, Alan"",
    title = ""Preparing the Project"",
    bookTitle = ""Agile Development in the Real World"",
    year = ""2015"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""75--90"",
    abstract = ""In the early days of agile, agilists wanted to avoid all upfront work before the iterations of requirements, coding, and testing started: no architecture, no initial requirements, not even getting their development environment set up. (The emergent design fans still use this approach.) I think this is an overreaction to the waterfall method. The pendulum of popular development style swung from too-much-upfront work to no-upfront work. Fortunately, that pendulum is swinging back to some upfront work that some agilists call upfront learning."",
    isbn = ""978-1-4842-1679-8"",
    doi = ""10.1007/978-1-4842-1679-8\_4"",
    url = ""https://doi.org/10.1007/978-1-4842-1679-8\_4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Preparing the Project	http://link.springer.com/chapter/10.1007/978-1-4842-1679-8_4	Apress	nan; Keywords; References
485	Behave	Prerequisites	Before next chapter's deep dive into a real ASP.NET MVC e-commerce development experience, it's important to make sure you're familiar with the architecture, design patterns, tools, and techniques that we'll be using. By the end of this chapter, you'll know about the following:	Domain Model; Unit Test; Visual Studio; View Model; Lambda Method	Steven Sanderson	Pro ASP.NET MVC 2 Framework	https://doi.org/10.1007/978-1-4302-2887-5_3		43–89		Excluded	Excluded	new_screen			2	Springer Link		Prerequisites	http://link.springer.com/chapter/10.1007/978-1-4302-2887-5_3	Apress	nan; References; Year; Bibtex
486	Behave	Prioritization of User Story Acceptance Tests in Agile Software Development Using Meta-Heuristic Techniques and Comparative Analysis	User stories that are the requirements engineering artifacts in agile software development must be accepted by the end user before being implemented. Acceptance testing is used to confirm the acceptance of user stories. User story acceptance tests are driven by user-defined acceptance criteria. The number of acceptance tests increases as the application size increases. One of the prominent reasons for adopting agile software development is quicker delivery of working software. In this paper, we attempt to prioritize acceptance tests in order to identify critical tests. Execution of critical acceptance tests is sufficient to satisfy the acceptance criteria for a user story and reduces the time to delivery of software. Prioritization of acceptance tests is realized by application of meta-heuristic techniques, i.e., genetic algorithm (GA), cuckoo search algorithm, and micro-GA algorithm. The information flow (IF) model is used as a basis of fitness function to ensure maximum coverage of user acceptance criteria. We demonstrate the applicability and effectiveness of the proposed approach with the help of a realistic example. A comparative analysis of the application of meta-heuristic techniques is performed to choose the best one.	Agile software development; Acceptance testing; Genetic algorithm; Cuckoo search; Micro-GA	Sibal, Ritu; Kaur, Preeti; Sharma, Chayanika	Towards Extensible and Adaptable Methods in Computing	https://doi.org/10.1007/978-981-13-2348-5_4		43--55	"""@Inbook{Sibal2018,
    author = ""Sibal, Ritu and Kaur, Preeti and Sharma, Chayanika"",
    editor = ""Chakraverty, Shampa and Goel, Anil and Misra, Sanjay"",
    title = ""Prioritization of User Story Acceptance Tests in Agile Software Development Using Meta-Heuristic Techniques and Comparative Analysis"",
    bookTitle = ""Towards Extensible and Adaptable Methods in Computing"",
    year = ""2018"",
    publisher = ""Springer Singapore"",
    address = ""Singapore"",
    pages = ""43--55"",
    abstract = ""User stories that are the requirements engineering artifacts in agile software development must be accepted by the end user before being implemented. Acceptance testing is used to confirm the acceptance of user stories. User story acceptance tests are driven by user-defined acceptance criteria. The number of acceptance tests increases as the application size increases. One of the prominent reasons for adopting agile software development is quicker delivery of working software. In this paper, we attempt to prioritize acceptance tests in order to identify critical tests. Execution of critical acceptance tests is sufficient to satisfy the acceptance criteria for a user story and reduces the time to delivery of software. Prioritization of acceptance tests is realized by application of meta-heuristic techniques, i.e., genetic algorithm (GA), cuckoo search algorithm, and micro-GA algorithm. The information flow (IF) model is used as a basis of fitness function to ensure maximum coverage of user acceptance criteria. We demonstrate the applicability and effectiveness of the proposed approach with the help of a realistic example. A comparative analysis of the application of meta-heuristic techniques is performed to choose the best one."",
    isbn = ""978-981-13-2348-5"",
    doi = ""10.1007/978-981-13-2348-5\_4"",
    url = ""https://doi.org/10.1007/978-981-13-2348-5\_4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Prioritization of User Story Acceptance Tests in Agile Software Development Using Meta-Heuristic Techniques and Comparative Analysis	http://link.springer.com/chapter/10.1007/978-981-13-2348-5_4	Springer Singapore	nan; References
487	Behave	Product Planning	Product planning is a core activity of a software product manager as described in the Software Product Management Framework. In this book, we differentiate the following processes:Roadmapping: the strategic and long-range planning of how a software product shall evolve.Product Requirements Engineering: the collection, analysis, and documentation of the software product's requirements.Release Planning: the definition of the detailed contents and schedule of a forthcoming product release.	Requirement Engineering; Product Category; Product Organization; Product Manager; Release Planning	Hans-Bernd Kittlaus; Samuel A. Fricker	Software Product Management	https://doi.org/10.1007/978-3-642-55140-6_4		119–187		Excluded	Excluded	new_screen			2	Springer Link		Product Planning	http://link.springer.com/chapter/10.1007/978-3-642-55140-6_4	Springer, Berlin, Heidelberg	nan; References; Year; Bibtex
488	Behave	Program comprehension of domain-specific and general-purpose languages: replication of a family of experiments using integrated development environments	Domain-specific languages (DSLs) allow developers to write code at a higher level of abstraction compared with general-purpose languages (GPLs). Developers often use DSLs to reduce the complexity of GPLs. Our previous study found that developers performed program comprehension tasks more accurately and efficiently with DSLs than with corresponding APIs in GPLs. This study replicates our previous study to validate and extend the results when developers use IDEs to perform program comprehension tasks. We performed a dependent replication of a family of experiments. We made two specific changes to the original study: (1) participants used IDEs to perform the program comprehension tasks, to address a threat to validity in the original experiment and (2) each participant performed program comprehension tasks on either DSLs or GPLs, not both as in the original experiment. The results of the replication are consistent with and expanded the results of the original study. Developers are significantly more effective and efficient in tool-based program comprehension when using a DSL than when using a corresponding API in a GPL. The results indicate that, where a DSL is available, developers will perform program comprehension better using the DSL than when using the corresponding API in a GPL.	Problem oriented languages; Controlled experiment; Domain specific languages; General purpose languages; Program comprehension; Replication; Digital subscriber lines; Problem oriented languages;  Controlled experiment;  Domain specific languages;  General purpose languages;  Program comprehension;  Replication;  Digital subscriber lines	Kosar, Tomaz; Gaberc, Saso; Carver, Jeffrey C.; Mernik, Marjan	Empirical Software Engineering	https://doi.org/10.1007/s10664-017-9593-2		2734 - 2763	"""@ARTICLE{Kosar20182734,
    author = ""Kosar, Tomaz and Gaberc, Saso and Carver, Jeffrey C. and Mernik, Marjan"",
    title = ""Program comprehension of domain-specific and general-purpose languages: replication of a family of experiments using integrated development environments"",
    year = ""2018"",
    journal = ""Empirical Software Engineering"",
    volume = ""23"",
    number = ""5"",
    pages = ""2734 - 2763"",
    doi = ""10.1007/s10664-017-9593-2"",
    url = ""https://www.scopus.com/inward/record.uri?eid=2-s2.0-85041817185\&doi=10.1007\%2fs10664-017-9593-2\&partnerID=40\&md5=08584b57449331c4801a21d3a4bc386c"",
    affiliations = ""Faculty of Electrical Engineering and Computer Science, University of Maribor, Koroska cesta 46, Maribor, 2000, Slovenia; Department of Computer Science, University of Alabama, Tuscaloosa, AL, United States"",
    abstract = ""Domain-specific languages (DSLs) allow developers to write code at a higher level of abstraction compared with general-purpose languages (GPLs). Developers often use DSLs to reduce the complexity of GPLs. Our previous study found that developers performed program comprehension tasks more accurately and efficiently with DSLs than with corresponding APIs in GPLs. This study replicates our previous study to validate and extend the results when developers use IDEs to perform program comprehension tasks. We performed a dependent replication of a family of experiments. We made two specific changes to the original study: (1) participants used IDEs to perform the program comprehension tasks, to address a threat to validity in the original experiment and (2) each participant performed program comprehension tasks on either DSLs or GPLs, not both as in the original experiment. The results of the replication are consistent with and expanded the results of the original study. Developers are significantly more effective and efficient in tool-based program comprehension when using a DSL than when using a corresponding API in a GPL. The results indicate that, where a DSL is available, developers will perform program comprehension better using the DSL than when using the corresponding API in a GPL. (c) 2018, Springer Science+Business Media, LLC, part of Springer Nature."",
    author_keywords = ""Controlled experiment; Domain-specific languages; General-purpose languages; Program comprehension; Replication"",
    keywords = ""Problem oriented languages; Controlled experiment; Domain specific languages; General purpose languages; Program comprehension; Replication; Digital subscriber lines"",
    correspondence_address = ""T. Kosar; Faculty of Electrical Engineering and Computer Science, University of Maribor, Maribor, Koroska cesta 46, 2000, Slovenia; email: tomaz.kosar@um.si"",
    publisher = ""Springer New York LLC"",
    issn = ""13823256"",
    coden = ""ESENF"",
    language = ""English"",
    abbrev_source_title = ""Empir Software Eng"",
    type = ""Article"",
    publication_stage = ""Final"",
    source = ""Scopus"",
    note = ""Cited by: 28""
}
"""	Excluded	Excluded	new_screen			2	Scopus Signed In		Program comprehension of domain-specific and general-purpose languages: replication of a family of experiments using integrated development environments	https://www.scopus.com/record/display.uri?eid=2-s2.0-85041817185&origin=resultslist&sort=plf-f&src=s&sid=c90b5bbc91466be5a8ba1d9ad5261c2b&sot=b&sdt=b&s=TITLE-ABS-KEY%28program+comprehension+of+domain+specific+and+general+purpose+languages+replication+of+a+family+of+experiments+using+integrated+development+environments%29&sl=166&sessionSearchId=c90b5bbc91466be5a8ba1d9ad5261c2b&relpos=0	Springer New York LLC	nan; References
489	Behave	PTCWA: Performance Testing of Cloud Based Web Applications	Testing in a cloud environment involves a range of tests to analyze various aspects of the system in various cloud adoption scenarios such as public, private, or hybrid. Performance testing is a key aspect of the cloud testing strategy and it evaluates the application/software for various issues such as speed, stability, and scalability under varying load conditions. The key issues that must be considered in a cloud set-up as a part of the performance testing strategy are collection of statistics on the load, conducting stress test, monitoring the memory, checking for elasticity and scalability. This paper focuses on testing the resource utilization in cloud infrastructure in general and memory utilization in particular. The memory utilization is evaluated in public and private cloud environment with simulation of 10 users to 10,000 users.	Performance testing; Public cloud; Private cloud; Memory and CPU utilization	Geetha Devasena, M. S.; Kingsy Grace, R.; Manju, S.; Krishna Kumar, V.	New Trends in Computational Vision and Bio-inspired Computing	https://doi.org/10.1007/978-3-030-41862-5_32		345--356	"""@Inbook{GeethaDevasena2020,
    author = ""Geetha Devasena, M. S. and Kingsy Grace, R. and Manju, S. and Krishna Kumar, V."",
    editor = ""Smys, S. and Iliyasu, Abdullah M. and Bestak, Robert and Shi, Fuqian"",
    title = ""PTCWA: Performance Testing of Cloud Based Web Applications"",
    bookTitle = ""New Trends in Computational Vision and Bio-inspired Computing: Selected works presented at the ICCVBIC 2018, Coimbatore, India"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""345--356"",
    abstract = ""Testing in a cloud environment involves a range of tests to analyze various aspects of the system in various cloud adoption scenarios such as public, private, or hybrid. Performance testing is a key aspect of the cloud testing strategy and it evaluates the application/software for various issues such as speed, stability, and scalability under varying load conditions. The key issues that must be considered in a cloud set-up as a part of the performance testing strategy are collection of statistics on the load, conducting stress test, monitoring the memory, checking for elasticity and scalability. This paper focuses on testing the resource utilization in cloud infrastructure in general and memory utilization in particular. The memory utilization is evaluated in public and private cloud environment with simulation of 10 users to 10,000 users."",
    isbn = ""978-3-030-41862-5"",
    doi = ""10.1007/978-3-030-41862-5\_32"",
    url = ""https://doi.org/10.1007/978-3-030-41862-5\_32""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		PTCWA: Performance Testing of Cloud Based Web Applications	http://link.springer.com/chapter/10.1007/978-3-030-41862-5_32	Springer International Publishing	nan; References
490	Behave	Public Administration for the Next Generation	Public Administration incorporates the development of statutes and regulations to bring order and control to aspects of society. In democratic societies this is accompanied by gathering opinion from the population on the span and degree of this control and on some of the details. This essay explores ways in which developments in digital technologies can facilitate this process, aid policymakers in ensuring consistency of regulations, and streamline the process between regulation and software in situations where this is relevant and helpful. It looks forward to what the coming generation of citizens might expect from their public administrators.		Winstanley, Peter	Government 3.0 - Next Generation Government Technology Infrastructure and Services	https://doi.org/10.1007/978-3-319-63743-3_2		27--36	"""@Inbook{Winstanley2017,
    author = ""Winstanley, Peter"",
    editor = ""Ojo, Adegboyega and Millard, Jeremy"",
    title = ""Public Administration for the Next Generation"",
    bookTitle = ""Government 3.0 -- Next Generation Government Technology Infrastructure and Services: Roadmaps, Enabling Technologies {\\&} Challenges"",
    year = ""2017"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""27--36"",
    abstract = ""Public Administration incorporates the development of statutes and regulations to bring order and control to aspects of society. In democratic societies this is accompanied by gathering opinion from the population on the span and degree of this control and on some of the details. This essay explores ways in which developments in digital technologies can facilitate this process, aid policymakers in ensuring consistency of regulations, and streamline the process between regulation and software in situations where this is relevant and helpful. It looks forward to what the coming generation of citizens might expect from their public administrators."",
    isbn = ""978-3-319-63743-3"",
    doi = ""10.1007/978-3-319-63743-3\_2"",
    url = ""https://doi.org/10.1007/978-3-319-63743-3\_2""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Public Administration for the Next Generation	http://link.springer.com/chapter/10.1007/978-3-319-63743-3_2	Springer International Publishing	nan; Keywords; References
491	Behave	Putting ASP.NET MVC in Context			Adam Freeman						Excluded	Excluded	new_screen			2						
492	Behave	QTREDS: a Ruby on Rails-based platform for omics laboratories			Piergiorgio PallaGianfranco FrauLaura VargiuPatricia Rodriguez-Tomé						Excluded	Excluded	new_screen			2						
493	Behave	Quality and Testing			Andrew Davis						Excluded	Excluded	new_screen			2						
494	Behave	Reengineering and Reverse Engineering			Ervin Varga						Excluded	Excluded	new_screen			2						
495	Behave	Refactoring Tools	Without tools helping us with refactoring, doing a good job could be very difficult. We need a test framework to perform all refactoring activities and some automated tools to increase our productivity.	Test Suite; Functional Test; System Under Test; Test Execution; Integrate Development Environment	Francesco Trucchia; Jacopo Romei	Pro PHP Refactoring	https://doi.org/10.1007/978-1-4302-2728-1_6		63–84		Excluded	Excluded	new_screen			2	Springer Link		Refactoring Tools	http://link.springer.com/chapter/10.1007/978-1-4302-2728-1_6	Apress	nan; References; Year; Bibtex
496	Behave	Requirement Engineering as a Software Development Process	The paper introduces a novel requirements management tool, incorporating software development practices into requirements engineering. It is motivated by an expectation that using well-established techniques should provide benefits such as increase of requirements quality, better alignment of tooling to organization needs and support for Agile project management techniques. Our aim, therefore, is to provide an open architecture for various requirements engineering activities, as till now, many of existing requirements management tools do not follow the latest developments in software development practices. In this paper, we propose a mapping of various aspects of software development based on Continuous Integration to requirements engineering and describe a prototype requirements management tool built to validate the proposed concept.		Baszuro, Pawel; Swacha, Jakub	Data-Centric Business and Applications	https://doi.org/10.1007/978-3-030-34706-2_2		21--39	"""@Inbook{Baszuro2020,
    author = ""Baszuro, Pawel and Swacha, Jakub"",
    editor = ""Poniszewska-Mara{\'{n}}da, Aneta and Kryvinska, Natalia and Jarz{\k{a}}bek, Stanis{\l}aw and Madeyski, Lech"",
    title = ""Requirement Engineering as a Software Development Process"",
    bookTitle = ""Data-Centric Business and Applications: Towards Software Development (Volume 4)"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""21--39"",
    abstract = ""The paper introduces a novel requirements management tool, incorporating software development practices into requirements engineering. It is motivated by an expectation that using well-established techniques should provide benefits such as increase of requirements quality, better alignment of tooling to organization needs and support for Agile project management techniques. Our aim, therefore, is to provide an open architecture for various requirements engineering activities, as till now, many of existing requirements management tools do not follow the latest developments in software development practices. In this paper, we propose a mapping of various aspects of software development based on Continuous Integration to requirements engineering and describe a prototype requirements management tool built to validate the proposed concept."",
    isbn = ""978-3-030-34706-2"",
    doi = ""10.1007/978-3-030-34706-2\_2"",
    url = ""https://doi.org/10.1007/978-3-030-34706-2\_2""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Requirement Engineering as a Software Development Process	http://link.springer.com/chapter/10.1007/978-3-030-34706-2_2	Springer International Publishing	nan; Keywords; References
497	Behave	Requirements Engineering and Semantic Web*	The author discusses modern methods of requirements engineering oriented on human communication and proposes the way for their transformation into semantic annotation of these requirements, suitable for manipulation in the Semantic Web environment.	Artificial Intelligence; requirementsengineering; semantic annotation; Semantic Web; specification by examples; teamcommunications	L. P. Babenko	Cybernetics and Systems Analysis	https://doi.org/10.1007/s10559-016-9808-3	"citation_title=Specification by Example; citation_publication_date=2011; citation_id=CR1; citation_author=G Adzic; citation_publisher=How Successful Teams Deliver the Right Software, Manning Publications; citation_title=The RSpec Book: Behaviour-Driven Development with Rspec, Cucumber, and Friends; citation_publication_date=2010; citation_id=CR2; citation_author=D Chelimsky; citation_author=D Astels; citation_author=D Zach; citation_author=A Hellesoy; citation_author=B Helmkamp; citation_author=D North; citation_publisher=The Pragmatic Bookshelf; M. Bolton, Acceptance Tests: Let's Change the Title, Too, 
                    http://www.developsense.com/blog/2010/08/acceptance-tests-lets-changethe-title-too/
                    
                  .; citation_title=Bridging the Communication Gap: Specification by Example and Agile Acceptance Testing; citation_publication_date=2009; citation_id=CR4; citation_author=G Adzic; citation_publisher=Neuri Limited; citation_journal_title=Global J. Research and Development; citation_title=The use of ontologies in requirements engineering; citation_author=V Castaneda, L Ballejos, ML Caliusco, MR Galli; citation_volume=10; citation_issue=6; citation_publication_date=2010; citation_pages=2-8; citation_id=CR5; K. Ellis,; K. I. Siegemund, E. J. Thomas, Yuting Zhao, J. Pan, and U. Assmann,; D. Fritsch, J. Lehmann, K. Lauenroth, S. Lohmann, Th. Riechert, and S. Dietzold,; L. P. Babenko,; Web Service Description Language. W3C Recommendation, 
                    http://www.w3.org/TR/2007/REC-wsdl20-20070626
                    
                  . 11. Semantic Annotations for WSDL and XML Schema. W3C recommendation, 
                    http://www.w3.org/TR/sawsdl/
                    
                  .; Semantic Annotations for WSDL and XML Schema. W3C recommendation, http://www.w3.org/TR/sawsdl/.; Web Service Modeling Ontology, WSMO, 
                    http://www.w3.org/Submission/WSMO/
                    
                  .; citation_journal_title=Transactions on Services Computing; citation_title=Identification and analysis of business and software services. A consolidated approach; citation_author=T Kohlborn, A Korthaus, T Chan, M Rosemann; citation_volume=2; citation_issue=1; citation_publication_date=2009; citation_pages=81-96; citation_id=CR13; citation_journal_title=Cybern. Syst. Analysis; citation_title=Method of normalization of knowledge on the software development infrastructure; citation_author=LP Babenko, SL Polyanichko; citation_volume=42; citation_issue=1; citation_publication_date=2006; citation_pages=147-152; citation_doi=10.1007/s10559-006-0046-y; citation_id=CR14"			Excluded	Excluded	new_screen			2	Springer Link		Requirements Engineering and Semantic Web*	http://link.springer.com/article/10.1007/s10559-016-9808-3	Springer Link	nan; Pages; Year; Bibtex
498	Behave	Requirements Engineering for Cyber-Physical Systems	According to a widely shared view, manufacturing is currently un- dergoing its fourth industrial revolution, termed ``Industrie 4.0'' in the high-tech strategy of the German government. Smart Factories with vertically and hori- zontally integrated production systems are enabled through the realization of machines, storage systems and utilities as Cyber-Physical Systems (CPS), which are able to share information, act, and control each other autonomously. The development of CPS requires the collaboration of different disciplines, like mechanical engineering, electrical engineering and computer science. This cre- ates new challenges for Requirements Engineering (RE), which needs to estab- lish a common perception of the targeted CPS for the involved stakeholders. This paper will elaborate the specific challenges in RE for CPS based on a lit- erature review. Natural Language Processing (NLP) is used as an approach to automatically translate shared informal requirements specifications to formal domain specific models for the involved disciplines, to develop a comprehen- sive RE methodology for CPS.	Requirements Engineering; Industrie 4.0; Cyber-Physical Systems; Natural Language Processing; MSEE Integrated Project	Wiesner, Stefan; Gorldt, Christian; Soeken, Mathias; Thoben, Klaus-Dieter; Drechsler, Rolf	IFIP International Conference on Advances in Production Management Systems	https://doi.org/10.1007/978-3-662-44739-0_35		281--288	"""@InProceedings{10.1007/978-3-662-44739-0_35,
    author = ""Wiesner, Stefan and Gorldt, Christian and Soeken, Mathias and Thoben, Klaus-Dieter and Drechsler, Rolf"",
    editor = ""Grabot, Bernard and Vallespir, Bruno and Gomes, Samuel and Bouras, Abdelaziz and Kiritsis, Dimitris"",
    title = ""Requirements Engineering for Cyber-Physical Systems"",
    booktitle = ""Advances in Production Management Systems. Innovative and Knowledge-Based Production Management in a Global-Local World"",
    year = ""2014"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""281--288"",
    abstract = ""According to a widely shared view, manufacturing is currently un- dergoing its fourth industrial revolution, termed ``Industrie 4.0'' in the high-tech strategy of the German government. Smart Factories with vertically and hori- zontally integrated production systems are enabled through the realization of machines, storage systems and utilities as Cyber-Physical Systems (CPS), which are able to share information, act, and control each other autonomously. The development of CPS requires the collaboration of different disciplines, like mechanical engineering, electrical engineering and computer science. This cre- ates new challenges for Requirements Engineering (RE), which needs to estab- lish a common perception of the targeted CPS for the involved stakeholders. This paper will elaborate the specific challenges in RE for CPS based on a lit- erature review. Natural Language Processing (NLP) is used as an approach to automatically translate shared informal requirements specifications to formal domain specific models for the involved disciplines, to develop a comprehen- sive RE methodology for CPS."",
    isbn = ""978-3-662-44739-0""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Requirements Engineering for Cyber-Physical Systems	http://link.springer.com/chapter/10.1007/978-3-662-44739-0_35	Springer Berlin Heidelberg	nan; References
499	Behave	Requirements Thread	Chapter 8gave an overview of the iteration process, tasks, and artifacts for the team as a whole. This chapter contains a detailed look at the work of a Business Analyst (BA). It shows how the BA uses inputs from other team members and produces outputs for them. This chapter compares use cases and user stories, and describes a guideline for how agile BAs may do their job. It should help other team members understand the BA on their team, and possibly allow novice BAs working in an agile team to perform the business analysis and requirements function better. If the team does not have a BA, then this chapter may help others complete the requirements-centric tasks normally performed by the BA.		Cline, Alan	Agile Development in the Real World	https://doi.org/10.1007/978-1-4842-1679-8_9		165--195	"""@Inbook{Cline2015,
    author = ""Cline, Alan"",
    title = ""Requirements Thread"",
    bookTitle = ""Agile Development in the Real World"",
    year = ""2015"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""165--195"",
    abstract = ""Chapter 8gave an overview of the iteration process, tasks, and artifacts for the team as a whole. This chapter contains a detailed look at the work of a Business Analyst (BA). It shows how the BA uses inputs from other team members and produces outputs for them. This chapter compares use cases and user stories, and describes a guideline for how agile BAs may do their job. It should help other team members understand the BA on their team, and possibly allow novice BAs working in an agile team to perform the business analysis and requirements function better. If the team does not have a BA, then this chapter may help others complete the requirements-centric tasks normally performed by the BA."",
    isbn = ""978-1-4842-1679-8"",
    doi = ""10.1007/978-1-4842-1679-8\_9"",
    url = ""https://doi.org/10.1007/978-1-4842-1679-8\_9""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Requirements Thread	http://link.springer.com/chapter/10.1007/978-1-4842-1679-8_9	Apress	nan; Keywords; References
500	Behave	Resolving Interoperability in Concurrent Engineering	To face an increasingly competitive environment within a globalization context, and to focus on core high-added value business activities, enterprises have to establish partnerships with other companies specialized in complementary domains. Such an approach, primarily based on optimization of the value chain, is called virtualization of the Enterprise. Enterprises relying on virtualization, sub-contracting and outsourcing have to coordinate activities of all the partners, to integrate the results of their activities, to manage federated information coming from the different implied information systems and to re-package them as a product for the clients. The adopted organization, which is considering as well as the internal and external resources, is called ``Extended Enterprise''. Nevertheless, in such complex emerging networked organizations, it is more and more challenging to be able to interchange, to share and to manage internal and external resources such as digital information, digital services and computer-enacted processes. In addition, digital artifacts produced by enterprise activities are more and more heterogeneous and complex. After characterizing expected interoperability for collaborative platform systems and highlighting interoperability issues and brakes not yet addressed, this chapter describes an innovative approach to build interoperability based on a Federated Framework of legacy eBusiness standards of a given ecosystem. It implies facing important issues related to semantic preservation along the lifecycle of the artifacts and infrastructures required to define and exploit an application. We present two use case studies that apply interoperability strategies.		Figay, Nicolas; da Silva, Catarina Ferreira; Ghodous, Parisa; Jardim-Goncalves, Ricardo	Concurrent Engineering in the 21st Century	https://doi.org/10.1007/978-3-319-13776-6_6		133--163	"""@Inbook{Figay2015,
    author = ""Figay, Nicolas and da Silva, Catarina Ferreira and Ghodous, Parisa and Jardim-Goncalves, Ricardo"",
    editor = ""Stjepandi{\'{c}}, Josip and Wognum, Nel and J.C. Verhagen, Wim"",
    title = ""Resolving Interoperability in Concurrent Engineering"",
    bookTitle = ""Concurrent Engineering in the 21st Century: Foundations, Developments and Challenges"",
    year = ""2015"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""133--163"",
    abstract = ""To face an increasingly competitive environment within a globalization context, and to focus on core high-added value business activities, enterprises have to establish partnerships with other companies specialized in complementary domains. Such an approach, primarily based on optimization of the value chain, is called virtualization of the Enterprise. Enterprises relying on virtualization, sub-contracting and outsourcing have to coordinate activities of all the partners, to integrate the results of their activities, to manage federated information coming from the different implied information systems and to re-package them as a product for the clients. The adopted organization, which is considering as well as the internal and external resources, is called ``Extended Enterprise''. Nevertheless, in such complex emerging networked organizations, it is more and more challenging to be able to interchange, to share and to manage internal and external resources such as digital information, digital services and computer-enacted processes. In addition, digital artifacts produced by enterprise activities are more and more heterogeneous and complex. After characterizing expected interoperability for collaborative platform systems and highlighting interoperability issues and brakes not yet addressed, this chapter describes an innovative approach to build interoperability based on a Federated Framework of legacy eBusiness standards of a given ecosystem. It implies facing important issues related to semantic preservation along the lifecycle of the artifacts and infrastructures required to define and exploit an application. We present two use case studies that apply interoperability strategies."",
    isbn = ""978-3-319-13776-6"",
    doi = ""10.1007/978-3-319-13776-6\_6"",
    url = ""https://doi.org/10.1007/978-3-319-13776-6\_6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Resolving Interoperability in Concurrent Engineering	http://link.springer.com/chapter/10.1007/978-3-319-13776-6_6	Springer International Publishing	nan; Keywords; References
501	Behave	REST API	In this tutorial, we'll build a RESTful API. In addition to Express.js, we'll use MongoDB via the Mongoskin library. We'll also use Mocha and SuperAgent to write functional tests.		Mardan, Azat	Pro Express.js	https://doi.org/10.1007/978-1-4842-0037-7_21		249--261	"""@Inbook{Mardan2014,
    author = ""Mardan, Azat"",
    title = ""REST API"",
    bookTitle = ""Pro Express.js"",
    year = ""2014"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""249--261"",
    abstract = ""In this tutorial, we'll build a RESTful API. In addition to Express.js, we'll use MongoDB via the Mongoskin library. We'll also use Mocha and SuperAgent to write functional tests."",
    isbn = ""978-1-4842-0037-7"",
    doi = ""10.1007/978-1-4842-0037-7\_21"",
    url = ""https://doi.org/10.1007/978-1-4842-0037-7\_21""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		REST API	http://link.springer.com/chapter/10.1007/978-1-4842-0037-7_21	Apress	nan; Keywords; References
502	Behave	Rigorous development process of a safety-critical system: from ASM models to Java code	The paper presents an approach for rigorous development of safety-critical systems based on the Abstract State Machine formal method. The development process starts from a high levelformalview of the system and, throughrefinement, derives more detailed models till the desired level of specification. Along the process, different validation and verification activities are available, as simulation, model review, and model checking. Moreover, each refinement step can be proved correct using an SMT-based approach. As last step of the refinement process, a Java implementation can be developed and linked to the formal specification. The correctness of the implementation w.r.t. its formal specification can be proved by means of model-based testing and runtime verification. The process is exemplified by using a Landing Gear System as case study.	Abstract State Machines; Landing Gear System; Refinement; Validation and verification; Model-based testing; Runtime verification	Paolo Arcaini; Angelo Gargantini; Elvinia Riccobene	International Journal on Software Tools for Technology Transfer	https://doi.org/10.1007/s10009-015-0394-x	citation_title=Modeling in Event-B: System and Software Engineering; citation_publication_date=2010; citation_id=CR1; citation_author=J-R Abrial; citation_publisher=Cambridge University Press; Arcaini, P., Gargantini, A., Riccobene, E.: AsmetaSMV: a way to link high-level ASM models to low-level NuSMV specifications. In: Proceedings of the 2nd International Conference on Abstract State Machines, Alloy, B and Z (ABZ 2010), volume 5977 of Lecture Notes in Computer Science, pages 61-74. Springer (2010); Arcaini, P., Gargantini, A., Riccobene, E.: Automatic Review of Abstract State Machines by Meta-Property Verification. In: Munoz, C. (ed.) Proceedings of the Second NASA Formal Methods Symposium (NFM 2010), NASA/CP-2010-216215, pp. 4-13. NASA (2010); Arcaini, P., Gargantini, A., Riccobene, E.: CoMA: Conformance monitoring of Java programs by Abstract State Machines. In: Khurshid, S., Sen, K. (eds.) Runtime Verification volume 7186 of Lecture Notes in Computer Science, pp. 223-238. Springer (2012); Arcaini, P., Gargantini, A., Riccobene, E.: Combining model-based testing and runtime monitoring for program testing in the presence of nondeterminism. In: 2013 IEEE Sixth International Conference on Software Testing, Verification and Validation, Workshops Proceedings, Luxembourg, March 18-22, 2013, pp. 178-187. IEEE (2013); Arcaini, P., Gargantini, A., Riccobene, E.: Modeling and Analyzing Using ASMs: The Landing Gear System Case Study. In: Boniol, F., Wiels, V., Ait Ameur, Y., Schewe, K.D. (eds.) ABZ 2014: The Landing Gear Case Study volume 433 of Communications in Computer and Information Science, pp. 36-51. Springer International Publishing (2014); Arcaini, P., Gargantini, A., Riccobene, E.: Offline Model-Based Testing and Runtime Monitoring of the Sensor Voting Module. In: Boniol, F., Wiels, V., Ait Ameur, Y., Schewe, K.D. (eds.) ABZ 2014: The Landing Gear Case Study volume 433 of Communications in Computer and Information Science, pp. 95-109. Springer International Publishing (2014); Arcaini, P., Gargantini, A., Riccobene, E.: Using SMT for dealing with nondeterminism in ASM-based runtime verification. ECEASST 70 (2014); citation_journal_title=Softw.: Pract. Exp.; citation_title=A model-driven process for engineering a toolset for a formal method; citation_author=P Arcaini, A Gargantini, E Riccobene, P Scandurra; citation_volume=41; citation_publication_date=2011; citation_pages=155-166; citation_id=CR9; Banach, R.: The Landing Gear Case Study in Hybrid Event-B. In: Boniol, F., Wiels, V., Ait Ameur, Y., Schewe, K.D. (eds.) ABZ 2014: The Landing Gear Case Study volume 433 of Communications in Computer and Information Science, pp. 126-141. Springer International Publishing (2014); citation_journal_title=J. Syst. Softw.; citation_title=Runtime verification of NET contracts; citation_author=M Barnett, W Schulte; citation_volume=65; citation_issue=3; citation_publication_date=2003; citation_pages=199-208; citation_doi=10.1016/S0164-1212(02)00041-9; citation_id=CR11; Bauer, A., Leucker, M., Schallhart, C.: Runtime verification for LTL and TLTL. ACM Trans. Softw. Method. (TOSEM) 20 (2011); Berthomieu, B., Dal Zilio, S., Fronc, L.: Model-Checking Real-Time Properties of an Aircraft Landing Gear System Using Fiacre. In: Boniol, F., Wiels, V., Ait Ameur, Y., Schewe, K.D. (eds.) ABZ 2014: The Landing Gear Case Study, volume 433 of Communications in Computer and Information Science, pp. 110-125. Springer International Publishing (2014); Boniol, F., Wiels, V.: The Landing Gear System Case Study. In: Boniol, F., Wiels, V., Ait Ameur, Y., Schewe, K.D. (eds.) ABZ 2014: The Landing Gear Case Study, volume 433 of Communications in Computer and Information Science, pp. 1-18. Springer International Publishing (2014); Boniol, F., Wiels, V., Ameur, Y.A., Schewe, K.-D.: ABZ 2014: The Landing Gear Case Study Case Study Track, Held at the 4th International Conference on Abstract State Machines, Alloy, B, TLA, VDM, and Z Toulouse, France, June 2-6, 2014, Proceedings. Springer International Publishing (2014); citation_journal_title=Form. Aspects Comput.; citation_title=The ASM refinement method; citation_author=E Borger; citation_volume=15; citation_publication_date=2003; citation_pages=237-257; citation_doi=10.1007/s00165-003-0012-7; citation_id=CR16; Borger, E.: The ASM method for system design and analysis. A tutorial introduction. In: Gramlich, B. (ed.) Proceedings of Frontiers of Combining Systems, 5th International Workshop, FroCoS 2005, Vienna, Austria, September 19-21, 2005, volume 3717 of Lecture Notes in Computer Science, pp. 264-283. Springer (2005); citation_title=Abstract State Machines: A Method for High-Level System Design and Analysis; citation_publication_date=2003; citation_id=CR18; citation_author=E Borger; citation_publisher=Springer; Carioni, A., Gargantini, A., Riccobene, E., Scandurra, P.: A Scenario-Based Validation Language for ASMs. In: Proceedings of the 1st International Conference on Abstract State Machines, B and Z (ABZ 2008), volume 5238 of Lecture Notes in Computer Science, pp. 71-84. Springer-Verlag (2008); Chen, F., D'Amorim, M., Rosu, G.: A formal monitoring-based framework for software development and analysis. In: Davies, J., Schulte, W., Barnett, M. (eds.) Formal Methods and Software Engineering, volume of 3308 LNCS, pp. 357-372. Springer, Berlin / Heidelberg (2004); citation_title=Model Checking; citation_publication_date=1999; citation_id=CR21; citation_author=EM Clarke; citation_author=O Grumberg; citation_author=DA Peled; citation_publisher=MIT Press; Dausend, M., Raschke, A.: Introducing Aspect-Oriented Specification for Abstract State Machines. In: Ait Ameur, Y., Schewe, K.-D. (eds.) Abstract State Machines, Alloy, B, TLA, VDM, and Z, volume 8477 of Lecture Notes in Computer Science, pp. 174-187. Springer Berlin Heidelberg (2014); Dausend, M., Stegmaier, M., Raschke, A.: Debugging Abstract State Machine Specifications: An Extension of CoreASM. In: Mazzanti, F., Trentanni, G. (eds.) Proceedings of iFM 2012 & ABZ 2012 - Posters & Tool demos Session, pp. 21-25 (2012); citation_journal_title=IEEE Trans. Softw. Eng.; citation_title=A taxonomy and catalog of runtime software-fault monitoring tools; citation_author=N Delgado, AQ Gates, S Roach; citation_volume=30; citation_issue=12; citation_publication_date=2004; citation_pages=859-872; citation_doi=10.1109/TSE.2004.91; citation_id=CR24; Dhaussy, P., Teodorov, C.: Context-Aware Verification of a Landing Gear System. In: Boniol, F., Wiels, V., Ait Ameur, Y., Schewe, K.-D. (eds.) ABZ 2014: The Landing Gear Case Study, volume 433 of Communications in Computer and Information Science, pp. 52-65. Springer International Publishing (2014); Falcone, Y., Havelund, K., Reger, G.: A Tutorial on Runtime Verification. In: Engineering Dependable Software Systems, volume 34 of NATO Science for Peace and Security Series--D: Information and Communication Security, pp. 141-175. IOS Press (2013); citation_journal_title=Softw., Pract. Exp.; citation_title=The CoreASM modeling framework; citation_author=R Farahbod, U Glasser; citation_volume=41; citation_issue=2; citation_publication_date=2011; citation_pages=167-178; citation_doi=10.1002/spe.1029; citation_id=CR27; citation_journal_title=J. Univ. Comput. Sci.; citation_title=ASM-based testing: coverage criteria and automatic test sequence generation; citation_author=A Gargantini, E Riccobene; citation_volume=7; citation_publication_date=2001; citation_pages=262-265; citation_id=CR28; Gargantini, A., Riccobene, E., Rinzivillo, S.: Using Spin to Generate Tests from ASM Specifications. In: Borger, E., Gargantini, A., Riccobene, E. (eds.) Abstract State Machines 2003, volume of 2589 Lecture Notes in Computer Science, pp. 263-277. Springer, Berlin Heidelberg (2003); citation_journal_title=J. Univ. Comput. Sci.; citation_title=A metamodel-based language and a simulation engine for abstract state machines; citation_author=A Gargantini, E Riccobene, P Scandurra; citation_volume=14; citation_issue=12; citation_publication_date=2008; citation_pages=1949-1983; citation_id=CR30; citation_journal_title=Dagstuhl Rep.; citation_title=Integration of tools for rigorous software construction and analysis (Dagstuhl Seminar 13372); citation_author=U Glasser, S Hallerstede, M Leuschel, E Riccobene; citation_volume=3; citation_issue=9; citation_publication_date=2013; citation_pages=74-105; citation_id=CR31; Hansen, D., Ladenberger, L., Wiegard, H., Bendisposto, J., Leuschel, M.: Validation of the ABZ Landing Gear System Using ProB. In: Boniol, F., Wiels, V., Ait Ameur, Y., Schewe, K.-D. (eds.) ABZ 2014: The Landing Gear Case Study volume 433 of Communications in Computer and Information Science, pp. 66-79.Springer International Publishing (2014); citation_journal_title=Softw. Test. Verif. Reliab.; citation_title=Editorial: special issue on specification-based testing; citation_author=R Hierons, J Derrick; citation_volume=10; citation_issue=4; citation_publication_date=2000; citation_pages=201-202; citation_doi=10.1002/1099-1689(200012)10:4<201::AID-STVR214>3.0.CO;2-Z; citation_id=CR33; Kossak, F.: Landing Gear System: An ASM-Based Solution for the ABZ Case Study. In: Boniol, F., Wiels, V., Ait Ameur, Y., Schewe, K.-D. (eds.) ABZ 2014: The Landing Gear Case Study, volume 433 of Communications in Computer and Information Science, pp. 142-147. Springer International Publishing (2014); citation_title=AspectJ in Action: Practical Aspect-Oriented Programming; citation_publication_date=2003; citation_id=CR35; citation_author=R Laddad; citation_publisher=Manning Publications Co.; citation_journal_title=Innov. Syst. Soft. Eng.; citation_title=Software monitoring through formal specification animation; citation_author=H Liang, J Dong, J Sun, W Wong; citation_volume=5; citation_publication_date=2009; citation_pages=231-241; citation_doi=10.1007/s11334-009-0096-1; citation_id=CR36; Mammar, A., Laleau, R.: Modeling a Landing Gear System in Event-B. In: Boniol, F., Wiels, V., Ait Ameur, Y., Schewe, K.-D. (eds.) ABZ 2014: The Landing Gear Case Study, volume 433 of Communications in Computer and Information Science, pp. 80-94. Springer International Publishing (2014); Mery, D., Singh, N. K.: Modeling an Aircraft Landing System in Event-B. In: Boniol, F., Wiels, V., Ait Ameur, Y., Schewe, K.-D., (eds.) ABZ 2014: The Landing Gear Case Study, volume 433 of Communications in Computer and Information Science, pp. 154-159. Springer International Publishing (2014); citation_journal_title=J. Univ. Comput. Sci.; citation_title=Verification of ASM refinements using generalized forward simulation; citation_author=G Schellhorn; citation_volume=7; citation_issue=11; citation_publication_date=2001; citation_pages=952-979; citation_id=CR39; citation_journal_title=J. Univ. Comput. Sci.; citation_title=Simulation of timed abstract state machines with predicate logic model-checking; citation_author=A Slissenko, P Vasilyev; citation_volume=14; citation_issue=12; citation_publication_date=2008; citation_pages=1984-2006; citation_id=CR40; Stark, R.F., Schmid, J., Borger, E.: Java and the Java Virtual Machine: Definition, Verification, Validation. Springer (2001); Su, W., Abrial, J.-R.: Aircraft Landing Gear System: Approaches with Event-B to the Modeling of an Industrial System. In: Boniol, F., Wiels, V., Ait Ameur, Y., Schewe, K.-D. (eds.) ABZ 2014: The Landing Gear Case Study, volume 433 of Communications in Computer and Information Science, pp. 19-35. Springer International Publishing (2014); citation_title=Practical Model-Based Testing: A Tools Approach; citation_publication_date=2006; citation_id=CR43; citation_author=M Utting; citation_author=B Legeard; citation_publisher=Morgan-Kaufmann; citation_journal_title=ACM Comput. Surv.; citation_title=Formal methods: practice and experience; citation_author=J Woodcock, PG Larsen, J Bicarregui, J Fitzgerald; citation_volume=41; citation_issue=4; citation_publication_date=2009; citation_pages=19:1-19:36; citation_doi=10.1145/1592434.1592436; citation_id=CR44			Excluded	Excluded	new_screen			2	Springer Link		Rigorous development process of a safety-critical system: from ASM models to Java code	http://link.springer.com/article/10.1007/s10009-015-0394-x	Springer Link	nan; Pages; Year; Bibtex
503	Behave	Robust Design of a Collaborative Platform for Model-Based System Engineering: Experience from an Industrial Deployment	Model-Based System Engineering is gaining momentum in the industry. In order to be successful, it requires adequate tooling support. In addition to functional requirements related to model edition, verification and transformation, key non-functional requirements need to be carefully addressed such as versioning, usability/team work, reliability, security, ease of integration. In this paper, we first give an overview of how we dealt with such requirements in the context of the development of a real world platform for a global telecom operator, with a focus on early steps of system modelling. We then present a more detailed design of the tooling architecture and a high availability protocol for accessing a mainstream model repository. The proposed protocol is modelled and verified using the Alloy language and model-checker.	Model-Based System Engineering; Tool support; Modelling; Industrial transfer; High availability; Alloy; Model-checking	Ponsard, Christophe; Darimont, Robert; Touzani, Mounir	International Conference on Model and Data Engineering	https://doi.org/10.1007/978-3-030-32065-2_23		333--347	"""@InProceedings{10.1007/978-3-030-32065-2_23,
    author = ""Ponsard, Christophe and Darimont, Robert and Touzani, Mounir"",
    editor = ""Schewe, Klaus-Dieter and Singh, Neeraj Kumar"",
    title = ""Robust Design of a Collaborative Platform for Model-Based System Engineering: Experience from an Industrial Deployment"",
    booktitle = ""Model and Data Engineering"",
    year = ""2019"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""333--347"",
    abstract = ""Model-Based System Engineering is gaining momentum in the industry. In order to be successful, it requires adequate tooling support. In addition to functional requirements related to model edition, verification and transformation, key non-functional requirements need to be carefully addressed such as versioning, usability/team work, reliability, security, ease of integration. In this paper, we first give an overview of how we dealt with such requirements in the context of the development of a real world platform for a global telecom operator, with a focus on early steps of system modelling. We then present a more detailed design of the tooling architecture and a high availability protocol for accessing a mainstream model repository. The proposed protocol is modelled and verified using the Alloy language and model-checker."",
    isbn = ""978-3-030-32065-2""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Robust Design of a Collaborative Platform for Model-Based System Engineering: Experience from an Industrial Deployment	http://link.springer.com/chapter/10.1007/978-3-030-32065-2_23	Springer International Publishing	nan; References
504	Behave	ROM: An Approach to Self-consistency Verification of a Runnable Ontology Model	In the quest for the highest possible abstraction of software systems, Runnable Knowledge has been proposed for MDA. But in order to be useful in practice as a system design, it must be amenable to verification. This work precisely describes the necessary steps by which ROM -- a Runnable Ontology Model tool -- concurrently generates a running model and its respective test script from the designed Runnable Knowledge, allowing verification that the model is self-consistent. The novel implementation idea is to use ready-made mock object libraries to efficiently obtain the code for a running model. Detailed examples are provided to illustrate each of the ROM generation steps.	Runnable Knowledge; Ontology; Ontology States; Model Testing; Mock Objects; Self-consistency; Verification	Exman, Iaakov; Yagel, Reuven	International Joint Conference on Knowledge Discovery, Knowledge Engineering, and Knowledge Management	https://doi.org/10.1007/978-3-642-54105-6_18		271--283	"""@InProceedings{10.1007/978-3-642-54105-6_18,
    author = ""Exman, Iaakov and Yagel, Reuven"",
    editor = ""Fred, Ana and Dietz, Jan L. G. and Liu, Kecheng and Filipe, Joaquim"",
    title = ""ROM: An Approach to Self-consistency Verification of a Runnable Ontology Model"",
    booktitle = ""Knowledge Discovery, Knowledge Engineering and Knowledge Management"",
    year = ""2013"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""271--283"",
    abstract = ""In the quest for the highest possible abstraction of software systems, Runnable Knowledge has been proposed for MDA. But in order to be useful in practice as a system design, it must be amenable to verification. This work precisely describes the necessary steps by which ROM -- a Runnable Ontology Model tool -- concurrently generates a running model and its respective test script from the designed Runnable Knowledge, allowing verification that the model is self-consistent. The novel implementation idea is to use ready-made mock object libraries to efficiently obtain the code for a running model. Detailed examples are provided to illustrate each of the ROM generation steps."",
    isbn = ""978-3-642-54105-6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		ROM: An Approach to Self-consistency Verification of a Runnable Ontology Model	http://link.springer.com/chapter/10.1007/978-3-642-54105-6_18	Springer Berlin Heidelberg	nan; References
505	Behave	SAFECode Whitepaper: Fundamental Practices for Secure Software Development 2nd Edition			Stacy Simpson						Excluded	Excluded	new_screen			2						
506	Behave	Scala Testing	This chapter examines the various facilities available within Scala to perform a range of tests.	Scale Tests; IntelliJ; Assert Class; Test-driven Development; Refactoring	Hunt, John	A Beginner's Guide to Scala, Object Orientation and Functional Programming	https://doi.org/10.1007/978-3-319-75771-1_37		415--429	"""@Inbook{Hunt2018,
    author = ""Hunt, John"",
    title = ""Scala Testing"",
    bookTitle = ""A Beginner's Guide to Scala, Object Orientation and Functional Programming"",
    year = ""2018"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""415--429"",
    abstract = ""This chapter examines the various facilities available within Scala to perform a range of tests."",
    isbn = ""978-3-319-75771-1"",
    doi = ""10.1007/978-3-319-75771-1\_37"",
    url = ""https://doi.org/10.1007/978-3-319-75771-1\_37""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Scala Testing	http://link.springer.com/chapter/10.1007/978-3-319-75771-1_37	Springer International Publishing	nan; References
507	Behave	Scaling Your Team			David Pollak						Excluded	Excluded	new_screen			2						
508	Behave	Scripting			Gennadiy Alpaev						Excluded	Excluded	new_screen			2						
509	Behave	Scrum Framework und Praxis	"Das handlungsorientierte Framework Scrum, das bereits sehr breit in der Softwareentwicklung, aber auch in anderen Bereichen der fertigenden Industrie etabliert ist, eignet sich als guter Start, um den praktischen Einsatz agiler Arbeitsweise zu diskutieren. Ich gehe auf die wesentlichen Artefakte des Frameworks ein, um an diesem Beispiel die Frage des Warums f{\""u}r die drei Zielgruppen des Buches (Unternehmer, Kunden, Mitarbeiter) praktisch zu diskutieren. Das Kapitel greift Entwicklungen der Scrum Community auf und zeigt Weiterentwicklungen des Frameworks gegen{\""u}ber seinem Erscheinen im Jahre 2001 auf und geht auf die Gr{\""u}nde und {\""U}berlegungen ein, die zu diesen Ver{\""a}nderungen gef{\""u}hrt haben. Vom Verst{\""a}ndnis des Team-Commitments {\""u}ber die Notwendigkeit der Sch{\""a}tzung bis zur praktischen Anwendbarkeit des Verfahrens in Vertr{\""a}gen werden die Artefakte der Methodik greifbar."		"B{\""o}hm, Janko"	Erfolgsfaktor Agilitat	https://doi.org/10.1007/978-3-658-25085-0_3		35--74	"""@Inbook{Bohm2019,
    author = {B{\""o}hm, Janko},
    title = ""Scrum Framework und Praxis"",
    bookTitle = {Erfolgsfaktor Agilit{\""a}t : Warum Scrum und Kanban zu zufriedenen Mitarbeitern und erfolgreichen Kunden f{\""u}hren},
    year = ""2019"",
    publisher = ""Springer Fachmedien Wiesbaden"",
    address = ""Wiesbaden"",
    pages = ""35--74"",
    abstract = {Das handlungsorientierte Framework Scrum, das bereits sehr breit in der Softwareentwicklung, aber auch in anderen Bereichen der fertigenden Industrie etabliert ist, eignet sich als guter Start, um den praktischen Einsatz agiler Arbeitsweise zu diskutieren. Ich gehe auf die wesentlichen Artefakte des Frameworks ein, um an diesem Beispiel die Frage des Warums f{\""u}r die drei Zielgruppen des Buches (Unternehmer, Kunden, Mitarbeiter) praktisch zu diskutieren. Das Kapitel greift Entwicklungen der Scrum Community auf und zeigt Weiterentwicklungen des Frameworks gegen{\""u}ber seinem Erscheinen im Jahre 2001 auf und geht auf die Gr{\""u}nde und {\""U}berlegungen ein, die zu diesen Ver{\""a}nderungen gef{\""u}hrt haben. Vom Verst{\""a}ndnis des Team-Commitments {\""u}ber die Notwendigkeit der Sch{\""a}tzung bis zur praktischen Anwendbarkeit des Verfahrens in Vertr{\""a}gen werden die Artefakte der Methodik greifbar.},
    isbn = ""978-3-658-25085-0"",
    doi = ""10.1007/978-3-658-25085-0\_3"",
    url = ""https://doi.org/10.1007/978-3-658-25085-0\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Scrum Framework und Praxis	http://link.springer.com/chapter/10.1007/978-3-658-25085-0_3	Springer Fachmedien Wiesbaden	nan; Keywords; References
510	Behave	Semi-automated Design Guidance Enhancer (SADGE): A Framework for Architectural Guidance Development			Mohsen AnvaariOlaf Zimmermann						Excluded	Excluded	new_screen			2						
511	Behave	Shorter Feedback Loops By Means of Continuous Deployment	Gathering early feedback on features is critical to many projects. Many Agile methodologies define feedback loops. Often, the feedback loop for completed features only closes after the iteration finishes. In this paper we will introduce a way of closing this feedback loop early, by means of continuous deployment. This also lowers the deployment effort for developers, increasing their happiness.		Claassen, Arjan; Boekhorst, Laurens	International Conference on Agile Software Development	https://doi.org/10.1007/978-3-319-18612-2_24		248--253	"""@InProceedings{10.1007/978-3-319-18612-2_24,
    author = ""Claassen, Arjan and Boekhorst, Laurens"",
    editor = ""Lassenius, Casper and Dings{\o}yr, Torgeir and Paasivaara, Maria"",
    title = ""Shorter Feedback Loops By Means of Continuous Deployment"",
    booktitle = ""Agile Processes in Software Engineering and Extreme Programming"",
    year = ""2015"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""248--253"",
    abstract = ""Gathering early feedback on features is critical to many projects. Many Agile methodologies define feedback loops. Often, the feedback loop for completed features only closes after the iteration finishes. In this paper we will introduce a way of closing this feedback loop early, by means of continuous deployment. This also lowers the deployment effort for developers, increasing their happiness."",
    isbn = ""978-3-319-18612-2""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Shorter Feedback Loops By Means of Continuous Deployment	http://link.springer.com/chapter/10.1007/978-3-319-18612-2_24	Springer International Publishing	nan; Keywords; References
512	Behave	Software Processes in the Software Product Life Cycle	Apart from the different formats of software process descriptions and life cycle models as discussed in the previous chapter, there are many different types of such models. The basis for these models is formed by several fundamental life cycles, in particular sequential models such as the waterfall model or the V-shaped model, and iterative-incremental models such as the spiral model or Scrum. These fundamental life cycles can be varied in many forms, or extended by adding information leading to detailed process models such as the (Rational) Unified Process. The models can also include different sets of processes, where at one end of the spectrum, software processes support software development by structuring the different development-related activities. At the other end of the spectrum, software processes also provide a more comprehensive perspective, e.g. including operation and IT service management, or interfacing with organisational and administrative tasks. Depending on the purpose of the model, there are some very different types of process reference models available, including for example method-driven life cycle models, agile methodologies, process assessment models. In this chapter, we survey these different types of software processes and their role in the software life cycle. We provide a categorization of software processes, introduce the basic life cycle models, and present some selected reference models.		Kneuper, Ralf	Software Processes and Life Cycle Models	https://doi.org/10.1007/978-3-319-98845-0_3		69--157	"""@Inbook{Kneuper2018,
    author = ""Kneuper, Ralf"",
    title = ""Software Processes in the Software Product Life Cycle"",
    bookTitle = ""Software Processes and Life Cycle Models: An Introduction to Modelling, Using and Managing Agile, Plan-Driven and Hybrid Processes"",
    year = ""2018"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""69--157"",
    abstract = ""Apart from the different formats of software process descriptions and life cycle models as discussed in the previous chapter, there are many different types of such models. The basis for these models is formed by several fundamental life cycles, in particular sequential models such as the waterfall model or the V-shaped model, and iterative-incremental models such as the spiral model or Scrum. These fundamental life cycles can be varied in many forms, or extended by adding information leading to detailed process models such as the (Rational) Unified Process. The models can also include different sets of processes, where at one end of the spectrum, software processes support software development by structuring the different development-related activities. At the other end of the spectrum, software processes also provide a more comprehensive perspective, e.g. including operation and IT service management, or interfacing with organisational and administrative tasks. Depending on the purpose of the model, there are some very different types of process reference models available, including for example method-driven life cycle models, agile methodologies, process assessment models. In this chapter, we survey these different types of software processes and their role in the software life cycle. We provide a categorization of software processes, introduce the basic life cycle models, and present some selected reference models."",
    isbn = ""978-3-319-98845-0"",
    doi = ""10.1007/978-3-319-98845-0\_3"",
    url = ""https://doi.org/10.1007/978-3-319-98845-0\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Software Processes in the Software Product Life Cycle	http://link.springer.com/chapter/10.1007/978-3-319-98845-0_3	Springer International Publishing	nan; Keywords; References
513	Behave	Software Quality Assurance During Implementation: Results of a Survey in Software Houses from Germany, Austria and Switzerland	Context: Quality assurance performed during the implementation phase, e.g., by coding guidelines, static analysis or unit testing, is of high importance to ensure quality of software, but there is a lack of common knowledge and best practices on it. Objective: The goal of this paper is to investigate the state-of-practice of quality assurance during the implementation phase in software houses. Method: For this purpose, we conducted a survey in Germany, Austria, and Switzerland where 57 software houses participated. The questionnaire comprised questions regarding techniques, tools, and effort for software quality assurance during implementation as well as the perceived quality after implementation. The results were complemented by interviews and results from other surveys on software quality in general. Results: Results from the survey show that the most common software quality assurance techniques used during implementation are unit testing, code reviews and coding guidelines. Most tool support is used in the areas of bug tracking, version control and project management. Due to relationships between the used tool types, it seems that the introduction of one tool leads to the adoption of several others. Also quality assurance techniques and tools are correlated. Bug fixing takes a significant ratio of the overall project effort assigned to implementation. Furthermore, we found that the more developers a software company has, the more effort is spent on bug fixing. Finally, more than half of all companies rated the quality after implementation as rather good to good. Conclusion: For the most important quality assurance techniques and supporting tool types clear usage patterns can be seen and serve as a basis to provide guidelines on their application in practice.	Software quality assurance; Implementation; Software development; Software quality; Software houses; Survey	Felderer, Michael; Auer, Florian	International Conference on Software Quality	https://doi.org/10.1007/978-3-319-49421-0_7		87--102	"""@InProceedings{10.1007/978-3-319-49421-0_7,
    author = ""Felderer, Michael and Auer, Florian"",
    editor = ""Winkler, Dietmar and Biffl, Stefan and Bergsmann, Johannes"",
    title = ""Software Quality Assurance During Implementation: Results of a Survey in Software Houses from Germany, Austria and Switzerland"",
    booktitle = ""Software Quality. Complexity and Challenges of Software Engineering in Emerging Technologies"",
    year = ""2017"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""87--102"",
    abstract = ""Context: Quality assurance performed during the implementation phase, e.g., by coding guidelines, static analysis or unit testing, is of high importance to ensure quality of software, but there is a lack of common knowledge and best practices on it. Objective: The goal of this paper is to investigate the state-of-practice of quality assurance during the implementation phase in software houses. Method: For this purpose, we conducted a survey in Germany, Austria, and Switzerland where 57 software houses participated. The questionnaire comprised questions regarding techniques, tools, and effort for software quality assurance during implementation as well as the perceived quality after implementation. The results were complemented by interviews and results from other surveys on software quality in general. Results: Results from the survey show that the most common software quality assurance techniques used during implementation are unit testing, code reviews and coding guidelines. Most tool support is used in the areas of bug tracking, version control and project management. Due to relationships between the used tool types, it seems that the introduction of one tool leads to the adoption of several others. Also quality assurance techniques and tools are correlated. Bug fixing takes a significant ratio of the overall project effort assigned to implementation. Furthermore, we found that the more developers a software company has, the more effort is spent on bug fixing. Finally, more than half of all companies rated the quality after implementation as rather good to good. Conclusion: For the most important quality assurance techniques and supporting tool types clear usage patterns can be seen and serve as a basis to provide guidelines on their application in practice."",
    isbn = ""978-3-319-49421-0""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Software Quality Assurance During Implementation: Results of a Survey in Software Houses from Germany, Austria and Switzerland	http://link.springer.com/chapter/10.1007/978-3-319-49421-0_7	Springer International Publishing	nan; References
514	Behave	Software Testing	"Any nontrivial program contains some errors in the source code. These ""bugs"" are annoying for users if they lead to application crashes and data loss, and they are worrisome if they lead to privacy leaks and security exploits. The economic damage caused by software bugs can be huge, and when software controls safety critical systems such as automotive software, then bugs can kill people. The primary tool to reveal and eliminate bugs is software testing: Testing a program means executing it with a selected set of inputs and checking whether the program behaves in the expected way; if it does not, then a bug has been detected. The aim of testing is to find as many bugs as possible, but it is a difficult task as it is impossible to runallpossible tests on a program. The challenge of being a good tester is thus to identify which are the best tests that help us find bugs, and to execute them as efficiently as possible. In this chapter, we explore different ways to measure how ""good"" a set of tests is, as well as techniques to generate good sets of tests."		Gordon Fraser; Jose Miguel Rojas	Handbook of Software Engineering	https://doi.org/10.1007/978-3-030-00262-6_4		123–192		Excluded	Excluded	new_screen			2	Springer Link		Software Testing	http://link.springer.com/chapter/10.1007/978-3-030-00262-6_4	Springer, Cham	nan; Keywords; References; Year; Bibtex
515	Behave	Specification by Example	http://link.springer.com/chapter/10.1007/978-3-030-00262-6_4		Michael Hüttermann		http://link.springer.com/chapter/10.1007/978-3-030-00262-6_4				Excluded	Excluded	new_screen			2						
516	Behave	Specifications and Testing	"Having good User Stories, acceptance criteria, and functional tests are all critical to being successful in Agile software development. The value of good acceptance criteria and using BDD to drive your design is something that Agile teams need to understand. The importance of investing in automated functional tests is also something that needs to be understood and invested in. Often teams waste a lot of time on writing documents in multiple places and keeping them synchronized. Quickly these get outdated and very rarely reflect what the software is actually doing. I think a better approach is to have what Gojko Adzic calls ""living documentation."""		Tim Brizard	Broken Agile	https://doi.org/10.1007/978-1-4842-1745-0_15		75–82		Excluded	Excluded	new_screen			2	Springer Link		Specifications and Testing	http://link.springer.com/chapter/10.1007/978-1-4842-1745-0_15	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
517	Behave	SportsStore: A Real Application	You've heard about the benefits of the ASP.NET MVC platform, and you've learned some of the theory behind its design. Now it's time to put the framework into action for real and see how those benefits work out in a realistic e-commerce application.	Real Application; Unit Test; Visual Studio; Public Class; Constructor Parameter	Sanderson, Steven	Pro ASP.NET MVC 2 Framework	https://doi.org/10.1007/978-1-4302-2887-5_4		91--134	"""@Inbook{Sanderson2010,
    author = ""Sanderson, Steven"",
    editor = ""Buckingham, Ewan and Andres, Clay and Anglin, Steve and Beckner, Mark and Buckingham, Ewan and Cornell, Gary and Gennick, Jonathan and Hassell, Jonathan and Lowman, Michelle and Moodie, Matthew and Parkes, Duncan and Pepper, Jeffrey and Pohlmann, Frank and Pundick, Douglas and Renow-Clarke, Ben and Shakeshaft, Dominic and Wade, Matt and Welsh, Tom and Collett, Anne and Larson, Damon"",
    title = ""SportsStore: A Real Application"",
    bookTitle = ""Pro ASP.NET MVC 2 Framework"",
    year = ""2010"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""91--134"",
    abstract = ""You've heard about the benefits of the ASP.NET MVC platform, and you've learned some of the theory behind its design. Now it's time to put the framework into action for real and see how those benefits work out in a realistic e-commerce application."",
    isbn = ""978-1-4302-2887-5"",
    doi = ""10.1007/978-1-4302-2887-5\_4"",
    url = ""https://doi.org/10.1007/978-1-4302-2887-5\_4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		SportsStore: A Real Application	http://link.springer.com/chapter/10.1007/978-1-4302-2887-5_4	Apress	nan; References
518	Behave	SportsStore: Navigation and Shopping Cart	In Chapter 4, you set up the majority of the core infrastructure needed to build SportsStore. There's already a basic product list backed by a SQL Server database. However, you're still several steps away from dominating global online commerce. In this chapter, then, you'll get deep into the ASP.NET MVC development process, adding catalog navigation, a shopping cart, and a checkout process. As you do, you'll learn how to do the following:	Action Method; Unit Test; Partial View; Controller Class; Session Collection	Sanderson, Steven	Pro ASP.NET MVC 2 Framework	https://doi.org/10.1007/978-1-4302-2887-5_5		135--178	"""@Inbook{Sanderson2010,
    author = ""Sanderson, Steven"",
    editor = ""Buckingham, Ewan and Andres, Clay and Anglin, Steve and Beckner, Mark and Buckingham, Ewan and Cornell, Gary and Gennick, Jonathan and Hassell, Jonathan and Lowman, Michelle and Moodie, Matthew and Parkes, Duncan and Pepper, Jeffrey and Pohlmann, Frank and Pundick, Douglas and Renow-Clarke, Ben and Shakeshaft, Dominic and Wade, Matt and Welsh, Tom and Collett, Anne and Larson, Damon"",
    title = ""SportsStore: Navigation and Shopping Cart"",
    bookTitle = ""Pro ASP.NET MVC 2 Framework"",
    year = ""2010"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""135--178"",
    abstract = ""In Chapter 4, you set up the majority of the core infrastructure needed to build SportsStore. There's already a basic product list backed by a SQL Server database. However, you're still several steps away from dominating global online commerce. In this chapter, then, you'll get deep into the ASP.NET MVC development process, adding catalog navigation, a shopping cart, and a checkout process. As you do, you'll learn how to do the following:"",
    isbn = ""978-1-4302-2887-5"",
    doi = ""10.1007/978-1-4302-2887-5\_5"",
    url = ""https://doi.org/10.1007/978-1-4302-2887-5\_5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		SportsStore: Navigation and Shopping Cart	http://link.springer.com/chapter/10.1007/978-1-4302-2887-5_5	Apress	nan; References
519	Behave	Spotify Tailoring for Architectural Governance	Organisations usually tailor Agile methods to fit their needs best. Spotify has developed its own Agile culture to facilitate software development for hundreds of developers across multiple cities. The Spotify model has become influential among agile proponents and hence formed the basis of methods used in other organisations. We have identified a lack of research into agile architecture using the Spotify model.	Spotify tailoring; Architecture governance; Autonomous teams; Large-scale; FinTech; Intervention embedded case study	Salameh, Abdallah; Bass, Julian M.	International Conference on Agile Software Development	https://doi.org/10.1007/978-3-030-58858-8_24		236--244	"""@InProceedings{10.1007/978-3-030-58858-8_24,
    author = ""Salameh, Abdallah and Bass, Julian M."",
    editor = ""Paasivaara, Maria and Kruchten, Philippe"",
    title = ""Spotify Tailoring for Architectural Governance"",
    booktitle = ""Agile Processes in Software Engineering and Extreme Programming -- Workshops"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""236--244"",
    abstract = ""Organisations usually tailor Agile methods to fit their needs best. Spotify has developed its own Agile culture to facilitate software development for hundreds of developers across multiple cities. The Spotify model has become influential among agile proponents and hence formed the basis of methods used in other organisations. We have identified a lack of research into agile architecture using the Spotify model."",
    isbn = ""978-3-030-58858-8""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Spotify Tailoring for Architectural Governance	http://link.springer.com/chapter/10.1007/978-3-030-58858-8_24	Springer International Publishing	nan; References
520	Behave	Sprint 1: Starting a Game	It's time to begin writing features for Kojack Games! With our initial backlog created and prioritized, our development infrastructure established, and our initial product backlog prioritized, we are ready to start coding features! In this chapter we'll layout a plan on how to approach writing features using BDD and see it through to the code implementation. We'll go through the practice of a sprint planning session, the way daily stands-up work, and how to manage the task board and burn-down charts.	Acceptance Criterion; Action Item; User Story; Feature File; Task Board	Blankenship, Jerrel; Bussa, Matthew; Millett, Scott	Pro Agile .NET Development with Scrum	https://doi.org/10.1007/978-1-4302-3534-7_5		87--133	"""@Inbook{Blankenship2011,
    author = ""Blankenship, Jerrel and Bussa, Matthew and Millett, Scott"",
    title = ""Sprint 1: Starting a Game"",
    bookTitle = ""Pro Agile .NET Development with Scrum"",
    year = ""2011"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""87--133"",
    abstract = ""It's time to begin writing features for Kojack Games! With our initial backlog created and prioritized, our development infrastructure established, and our initial product backlog prioritized, we are ready to start coding features! In this chapter we'll layout a plan on how to approach writing features using BDD and see it through to the code implementation. We'll go through the practice of a sprint planning session, the way daily stands-up work, and how to manage the task board and burn-down charts."",
    isbn = ""978-1-4302-3534-7"",
    doi = ""10.1007/978-1-4302-3534-7\_5"",
    url = ""https://doi.org/10.1007/978-1-4302-3534-7\_5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Sprint 1: Starting a Game	http://link.springer.com/chapter/10.1007/978-1-4302-3534-7_5	Apress	nan; References
521	Behave	Subconscious Requirements: The Fright of Every Tester			Hans van Loenhoud						Excluded	Excluded	new_screen			2						
522	Behave	Success and Failure Factors for Adopting a Combined Approach: A Case Study of Two Software Development Teams	The combination of Agile, User-Centered Design and Lean Startup has emerged as a solution for teams that are struggling with lack of user involvement and delivering products that fulfill stakeholder needs. Adopting such a development approach involves several factors, some of which can assist or hinder the adoption process. Currently, the literature reports on studies on such factors, but only for agile-only methods. Motivated by this knowledge gap, our goal is to map the success and failure factors of a combined approach adoption. We conduct a case study with two software development teams from a large organization transitioning to the combined approach. We used semi-structured interviews and focus group sessions to collect data. Our findings show five success factors categories (e.g., team engagement, technical aspects) and one failure factor category (team autonomy at risk), along with several argumentation points suggested by the teams to argue against a company policy perceived to be a very impactful failure factor. This study contributes to academic literature by reporting on success and failure factors of a combined approach transformation, and could be used as a starting point in defining tools (e.g., maturity models) to aid organizations in transitioning to the combined approach.	Agile; User-centered design; Lean startup; Success factors; Failure factors; Agile transformation	Signoretti, Ingrid; Zorzetti, Maximilian; Salerno, Larissa; Moralles, Cassiano; Pereira, Eliana; Trindade, C{\'a}ssio; Marczak, Sabrina; Bastos, Ricardo	International Conference on Product-Focused Software Process Improvement	https://doi.org/10.1007/978-3-030-64148-1_8		125--141	"""@InProceedings{10.1007/978-3-030-64148-1_8,
    author = ""Signoretti, Ingrid and Zorzetti, Maximilian and Salerno, Larissa and Moralles, Cassiano and Pereira, Eliana and Trindade, C{\'a}ssio and Marczak, Sabrina and Bastos, Ricardo"",
    editor = ""Morisio, Maurizio and Torchiano, Marco and Jedlitschka, Andreas"",
    title = ""Success and Failure Factors for Adopting a Combined Approach: A Case Study of Two Software Development Teams"",
    booktitle = ""Product-Focused Software Process Improvement"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""125--141"",
    abstract = ""The combination of Agile, User-Centered Design and Lean Startup has emerged as a solution for teams that are struggling with lack of user involvement and delivering products that fulfill stakeholder needs. Adopting such a development approach involves several factors, some of which can assist or hinder the adoption process. Currently, the literature reports on studies on such factors, but only for agile-only methods. Motivated by this knowledge gap, our goal is to map the success and failure factors of a combined approach adoption. We conduct a case study with two software development teams from a large organization transitioning to the combined approach. We used semi-structured interviews and focus group sessions to collect data. Our findings show five success factors categories (e.g., team engagement, technical aspects) and one failure factor category (team autonomy at risk), along with several argumentation points suggested by the teams to argue against a company policy perceived to be a very impactful failure factor. This study contributes to academic literature by reporting on success and failure factors of a combined approach transformation, and could be used as a starting point in defining tools (e.g., maturity models) to aid organizations in transitioning to the combined approach."",
    isbn = ""978-3-030-64148-1""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Success and Failure Factors for Adopting a Combined Approach: A Case Study of Two Software Development Teams	http://link.springer.com/chapter/10.1007/978-3-030-64148-1_8	Springer International Publishing	nan; References
523	Behave	Supporting Agile Software Development by Natural Language Processing	Agile software development puts more emphasis on working programs than on documentation. However, this may cause complications from the management perspective when an overview of the progress achieved within a project needs to be provided. In this paper, we outline the potential for applying natural language processing (NLP) in order to support agile development. We point out that using NLP, the artifacts created during agile software development activities can be traced back to the requirements expressed in user stories. This allows determining how far the project has progressed in terms of realized requirements.	Agile Software Development; Project Management; Machine Learning; Natural Language Processing	Plank, Barbara; Sauer, Thomas; Schaefer, Ina	International Workshop on Eternal Systems	https://doi.org/10.1007/978-3-642-45260-4_7		91--102	"""@InProceedings{10.1007/978-3-642-45260-4_7,
    author = ""Plank, Barbara and Sauer, Thomas and Schaefer, Ina"",
    editor = ""Moschitti, Alessandro and Plank, Barbara"",
    title = ""Supporting Agile Software Development by Natural Language Processing"",
    booktitle = ""Trustworthy Eternal Systems via Evolving Software, Data and Knowledge"",
    year = ""2013"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""91--102"",
    abstract = ""Agile software development puts more emphasis on working programs than on documentation. However, this may cause complications from the management perspective when an overview of the progress achieved within a project needs to be provided. In this paper, we outline the potential for applying natural language processing (NLP) in order to support agile development. We point out that using NLP, the artifacts created during agile software development activities can be traced back to the requirements expressed in user stories. This allows determining how far the project has progressed in terms of realized requirements."",
    isbn = ""978-3-642-45260-4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Supporting Agile Software Development by Natural Language Processing	http://link.springer.com/chapter/10.1007/978-3-642-45260-4_7	Springer Berlin Heidelberg	nan; References
524	Behave	Taking It to 11			Jeffrey ScheafferAruna RavichandranAlex Martins						Excluded	Excluded	new_screen			2						
525	Behave	TDD and BDD for Node.js with Mocha	Test-driven development (TDD), as many of you might know, is one of the main, agile development techniques. The genius of TDD lies in increased quality of code, faster development resulting from greater programmer confidence, and improved bug detection (duh!).		Mardan, Azat	Practical Node.js	https://doi.org/10.1007/978-1-4302-6596-2_3		57--69	"""@Inbook{Mardan2014,
    author = ""Mardan, Azat"",
    title = ""TDD and BDD for Node.js with Mocha"",
    bookTitle = ""Practical Node.js: Building Real-World Scalable Web Apps"",
    year = ""2014"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""57--69"",
    abstract = ""Test-driven development (TDD), as many of you might know, is one of the main, agile development techniques. The genius of TDD lies in increased quality of code, faster development resulting from greater programmer confidence, and improved bug detection (duh!)."",
    isbn = ""978-1-4302-6596-2"",
    doi = ""10.1007/978-1-4302-6596-2\_3"",
    url = ""https://doi.org/10.1007/978-1-4302-6596-2\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		TDD and BDD for Node.js with Mocha	http://link.springer.com/chapter/10.1007/978-1-4302-6596-2_3	Apress	nan; Keywords; References
526	Behave	TDD as an API Design Technique			Ervin Varga						Excluded	Excluded	new_screen			2						
527	Behave	Temporal Random Testing for Spark Streaming	With the rise of Big Data technologies, distributed stream processing systems (SPS) have gained popularity in the last years. Among them, Spark Streaming stands out as a particularly attractive option with a growing adoption in the industry. In this work we explore the combination of temporal logic and property-based testing for testing Spark Streaming programs, by adding temporal logic operators to ScalaCheck generators and properties. This allows us to deal with the time component that complicates the testing of Spark Streaming programs and SPS in general. In particular we propose a discrete time linear temporal logic for finite words, that allows to associate a timeout to each temporal operator in order to increase the expressiveness of generators and properties. Finally, our prototype is presented with some examples.	Stream processing systems; Spark streaming; Property-based testing; Random testing; Linear temporal logic; Scala; Big data	Riesco, Adri{\'a}n; Rodr{\'i}guez-Hortal{\'a}, Juan	International Conference on Integrated Formal Methods	https://doi.org/10.1007/978-3-319-33693-0_25		393--408	"""@InProceedings{10.1007/978-3-319-33693-0_25,
    author = ""Riesco, Adri{\'a}n and Rodr{\'i}guez-Hortal{\'a}, Juan"",
    editor = ""{\'A}brah{\'a}m, Erika and Huisman, Marieke"",
    title = ""Temporal Random Testing for Spark Streaming"",
    booktitle = ""Integrated Formal Methods"",
    year = ""2016"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""393--408"",
    abstract = ""With the rise of Big Data technologies, distributed stream processing systems (SPS) have gained popularity in the last years. Among them, Spark Streaming stands out as a particularly attractive option with a growing adoption in the industry. In this work we explore the combination of temporal logic and property-based testing for testing Spark Streaming programs, by adding temporal logic operators to ScalaCheck generators and properties. This allows us to deal with the time component that complicates the testing of Spark Streaming programs and SPS in general. In particular we propose a discrete time linear temporal logic for finite words, that allows to associate a timeout to each temporal operator in order to increase the expressiveness of generators and properties. Finally, our prototype is presented with some examples."",
    isbn = ""978-3-319-33693-0""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Temporal Random Testing for Spark Streaming	http://link.springer.com/chapter/10.1007/978-3-319-33693-0_25	Springer International Publishing	nan; References
528	Behave	Test Early, Test Often	As we'll show in this chapter, having a clear, well-defined testing process is especially important on the kinds of rapidly developed, large-team projects that Parallel Agile (PA) is often used on. In the first part of the chapter, we'll cover some of the main reasons we recommend our particular approach to testing. After that, we'll illustrate how to incorporate automated software testing into a PA project. To do this, we draw heavily from Matt's own software testing process, domain-oriented testing (DOT), which just happens to be a perfect fit for PA.		Doug Rosenberg; Barry Boehm; Matt Stephens; Charles Suscheck; Shobha Rani Dhalipathi; Bo Wang	Parallel Agile – faster delivery, fewer defects, lower cost	https://doi.org/10.1007/978-3-030-30701-1_6		107–130		Excluded	Excluded	new_screen			2	Springer Link		Test Early, Test Often	http://link.springer.com/chapter/10.1007/978-3-030-30701-1_6	Springer, Cham	nan; Keywords; References; Year; Bibtex
529	Behave	Test Frameworks	This chapter covers the topic of test frameworks. In a broad sense, a test framework is a technology or set of tools that supports automated software testing. Most developers are familiar with one of the code-driven test frameworks, which are commonly referred to as unit testing frameworks. In this chapter, you will learn about the four most popular unit testing frameworks. Another important component to any test framework is the test runner. You will learn about a variety of test runners, from the minimalist runners to those that are well-integrated into Visual Studio. This chapter also provides an overview of the xUnit test pattern and explains how each of the unit testing frameworks discussed fits the pattern.	Visual Studio; Generally Accept Account Principle; Test Framework; Test Code; Code Coverage	Ritchie, Stephen D.	Pro .NET Best Practices	https://doi.org/10.1007/978-1-4302-4024-2_12		265--312	"""@Inbook{Ritchie2011,
    author = ""Ritchie, Stephen D."",
    title = ""Test Frameworks"",
    bookTitle = ""Pro .NET Best Practices"",
    year = ""2011"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""265--312"",
    abstract = ""This chapter covers the topic of test frameworks. In a broad sense, a test framework is a technology or set of tools that supports automated software testing. Most developers are familiar with one of the code-driven test frameworks, which are commonly referred to as unit testing frameworks. In this chapter, you will learn about the four most popular unit testing frameworks. Another important component to any test framework is the test runner. You will learn about a variety of test runners, from the minimalist runners to those that are well-integrated into Visual Studio. This chapter also provides an overview of the xUnit test pattern and explains how each of the unit testing frameworks discussed fits the pattern."",
    isbn = ""978-1-4302-4024-2"",
    doi = ""10.1007/978-1-4302-4024-2\_12"",
    url = ""https://doi.org/10.1007/978-1-4302-4024-2\_12""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Test Frameworks	http://link.springer.com/chapter/10.1007/978-1-4302-4024-2_12	Apress	nan; References
530	Behave	Test-Driven Development	"In Chapter 2, ""Build a Safety-Net,"" we learned that a suite of well-crafted and fast unit tests can ensure that our code works correctly. So far, so good. But what is so special about test-driven development (TDD) so that this topic justifies a dedicated chapter?"		Stephan Roth	Clean C++20	https://doi.org/10.1007/978-1-4842-5949-8_8		335–373		Excluded	Excluded	new_screen			2	Springer Link		Test-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-5949-8_8	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
531	Behave	Test-Driven Development 101	In this chapter, we will learn how to apply TDD in our daily development routine through a step-by-step guide. Along with this demo, you will get an idea of how to split a big task into relatively smaller ones and complete each one with a set of passing tests while learning some refactoring techniques. Before we dive into the code, let's get a fundamental understanding of how to write a proper test.		Qiu, Juntao	Test-Driven Development with React	https://doi.org/10.1007/978-1-4842-6972-5_3		35--45	"""@Inbook{Qiu2021,
    author = ""Qiu, Juntao"",
    title = ""Test-Driven Development 101"",
    bookTitle = ""Test-Driven Development with React: Apply Test-Driven Development in Your Applications"",
    year = ""2021"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""35--45"",
    abstract = ""In this chapter, we will learn how to apply TDD in our daily development routine through a step-by-step guide. Along with this demo, you will get an idea of how to split a big task into relatively smaller ones and complete each one with a set of passing tests while learning some refactoring techniques. Before we dive into the code, let's get a fundamental understanding of how to write a proper test."",
    isbn = ""978-1-4842-6972-5"",
    doi = ""10.1007/978-1-4842-6972-5\_3"",
    url = ""https://doi.org/10.1007/978-1-4842-6972-5\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Test-Driven Development 101	http://link.springer.com/chapter/10.1007/978-1-4842-6972-5_3	Apress	nan; Keywords; References
532	Behave	Test-Driven Development as a Reliable Embedded Software Engineering Practice	Due to embedded co-design considerations, testing embedded software is typically deferred after the integration phase. Contrasting with the current embedded engineering practices, Test-Driven Development (TDD) promotes testing software during its development, even before the target hardware becomes available. Principally, TDD promotes a fast feedback cycle in which a test is written before the implementation. Moreover, each test is added to a test suite, which runs at every step in the TDD cycle. As a consequence, test-driven code is well tested and maintainable. Still, embedded software has some typical properties which impose challenges to apply the TDD cycle. Essentially, uploading software to target is generally too time-consuming to frequently run tests on target. Secondary issues are hardware dependencies and limited resources, such as memory footprint or processing power. In order to deal with these limitations, four methods have been identified and evaluated. Furthermore, a number of relevant design patterns are discussed to apply TDD in an embedded environment.		Cordemans, Piet; Van Landschoot, Sille; Boydens, Jeroen; Steegmans, Eric	Embedded and Real Time System Development: A Software Engineering Perspective	https://doi.org/10.1007/978-3-642-40888-5_4		91--130	"""@Inbook{Cordemans2014,
    author = ""Cordemans, Piet and Van Landschoot, Sille and Boydens, Jeroen and Steegmans, Eric"",
    editor = ""Khan, Mohammad Ayoub and Saeed, Saqib and Darwish, Ashraf and Abraham, Ajith"",
    title = ""Test-Driven Development as a Reliable Embedded Software Engineering Practice"",
    bookTitle = ""Embedded and Real Time System Development: A Software Engineering Perspective: Concepts, Methods and Principles"",
    year = ""2014"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""91--130"",
    abstract = ""Due to embedded co-design considerations, testing embedded software is typically deferred after the integration phase. Contrasting with the current embedded engineering practices, Test-Driven Development (TDD) promotes testing software during its development, even before the target hardware becomes available. Principally, TDD promotes a fast feedback cycle in which a test is written before the implementation. Moreover, each test is added to a test suite, which runs at every step in the TDD cycle. As a consequence, test-driven code is well tested and maintainable. Still, embedded software has some typical properties which impose challenges to apply the TDD cycle. Essentially, uploading software to target is generally too time-consuming to frequently run tests on target. Secondary issues are hardware dependencies and limited resources, such as memory footprint or processing power. In order to deal with these limitations, four methods have been identified and evaluated. Furthermore, a number of relevant design patterns are discussed to apply TDD in an embedded environment."",
    isbn = ""978-3-642-40888-5"",
    doi = ""10.1007/978-3-642-40888-5\_4"",
    url = ""https://doi.org/10.1007/978-3-642-40888-5\_4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Test-Driven Development as a Reliable Embedded Software Engineering Practice	http://link.springer.com/chapter/10.1007/978-3-642-40888-5_4	Springer Berlin Heidelberg	nan; Keywords; References
533	Behave	Test-Driven Development in Swift	http://link.springer.com/chapter/10.1007/978-1-4842-5602-2_12	Swift; iOS; Compiler; Dependency Injection; Mocks; App; development; programming; coding; networking; UIViewController; TDD; test-driven development; XCTest	Gio Lodi		https://link.springer.com/book/10.1007/978-1-4842-7002-8				Excluded	Excluded	new_screen			2	Springer Link		Test-Driven Development in Swift	https://link.springer.com/book/10.1007/978-1-4842-7002-8	Springer Link	nan; Venue; Abstract; References; Pages; Year; Bibtex; DOI
534	Behave	Testing	###		Basarat Ali Syed	Beginning Node.js	https://doi.org/10.1007/978-1-4842-0187-9_12		241–253		Excluded	Excluded	new_screen			2	Springer Link		Testing	http://link.springer.com/chapter/10.1007/978-1-4842-0187-9_12	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
535	Behave	Testing & Debugging	It is time to shift our focus to another important part of API design, which is the testing and debugging of the source code. This chapter will briefly share some interesting points on why testing is essential, as well as dive into the implementation details for creating unit and integration tests. Also included in this chapter will be complete instructions on how to debug the source code of compiled external libraries by using their symbols loaded from the Internet.	Dotnet; HttpClient; Behavior-driven Development (BDD); Class Integration Test; ICalculator	Fanie Reynders	Modern API Design with ASP.NET Core 2	https://doi.org/10.1007/978-1-4842-3519-5_10		185–201		Excluded	Excluded	new_screen			2	Springer Link		Testing & Debugging	http://link.springer.com/chapter/10.1007/978-1-4842-3519-5_10	Apress, Berkeley, CA	nan; References; Year; Bibtex
536	Behave	Testing and Debugging Projects	Test-driven development (TDD) promotes the writing of executable test cases before you start coding. After you add the desired functionality, you then run the tests to make sure the new functionality works as expected, and that the changes don't break something else. The NetBeans IDE provides quick access to the TDD support that is provided by Ruby and the Rails framework through the IDE's menu actions, keyboard shortcuts, and Test Results window.	Source Line; Unit Test; Main Menu; Output Window; Test File		NetBeans(tm) Ruby and Rails IDE with JRuby	https://doi.org/10.1007/978-1-4302-1637-7_7		105--125	"""@Inbook{Kutler2009,
    title = ""Testing and Debugging Projects"",
    bookTitle = ""NetBeans{\texttrademark} Ruby and Rails IDE with JRuby"",
    year = ""2009"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""105--125"",
    abstract = ""Test-driven development (TDD) promotes the writing of executable test cases before you start coding. After you add the desired functionality, you then run the tests to make sure the new functionality works as expected, and that the changes don't break something else. The NetBeans IDE provides quick access to the TDD support that is provided by Ruby and the Rails framework through the IDE's menu actions, keyboard shortcuts, and Test Results window."",
    isbn = ""978-1-4302-1637-7"",
    doi = ""10.1007/978-1-4302-1637-7\_7"",
    url = ""https://doi.org/10.1007/978-1-4302-1637-7\_7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Testing and Debugging Projects	http://link.springer.com/chapter/10.1007/978-1-4302-1637-7_7	Apress	nan; Authors; References
537	Behave	Testing Batch Processes	Testing is everyone's favorite part of programming. The funny thing is, like most things in life, once you get good at it, testing actually is fun. It allows you to be more productive. It provides a safety net for you to try new things. Programmatic tests also give you a test bed to try new technologies (most companies don't mind if you want to try something new in the tests but mind greatly if you try it in code that's going to production). You've spent the previous ten chapters writing code without the ability to prove that any of it works. This chapter looks at how to exercise your code in a variety of ways so you can not only prove that it works as designed, but also provide a safety net for when you change it.		Minella, Michael T.	The Definitive Guide to Spring Batch	https://doi.org/10.1007/978-1-4842-3724-3_13		435--454	"""@Inbook{Minella2019,
    author = ""Minella, Michael T."",
    title = ""Testing Batch Processes"",
    bookTitle = ""The Definitive Guide to Spring Batch: Modern Finite Batch Processing in the Cloud"",
    year = ""2019"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""435--454"",
    abstract = ""Testing is everyone's favorite part of programming. The funny thing is, like most things in life, once you get good at it, testing actually is fun. It allows you to be more productive. It provides a safety net for you to try new things. Programmatic tests also give you a test bed to try new technologies (most companies don't mind if you want to try something new in the tests but mind greatly if you try it in code that's going to production). You've spent the previous ten chapters writing code without the ability to prove that any of it works. This chapter looks at how to exercise your code in a variety of ways so you can not only prove that it works as designed, but also provide a safety net for when you change it."",
    isbn = ""978-1-4842-3724-3"",
    doi = ""10.1007/978-1-4842-3724-3\_13"",
    url = ""https://doi.org/10.1007/978-1-4842-3724-3\_13""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Testing Batch Processes	http://link.springer.com/chapter/10.1007/978-1-4842-3724-3_13	Apress	nan; Keywords; References
538	Behave	Testing Chatbots with Charm	Chatbots are software programs with a conversational user interface, typically embedded in webs or messaging systems like Slack, Facebook Messenger or Telegram. Many companies are investing in chatbots to improve their customer support. This has led to a proliferation of chatbot creation platforms (e.g., Dialogflow, Lex, Watson). However, there is currently little support for testing chatbots, which may impact in their final quality.	Chatbots; Testing; Botium; Dialogflow	Bravo-Santos, Sergio; Guerra, Esther; de Lara, Juan	International Conference on the Quality of Information and Communications Technology	https://doi.org/10.1007/978-3-030-58793-2_34		426--438	"""@InProceedings{10.1007/978-3-030-58793-2_34,
    author = ""Bravo-Santos, Sergio and Guerra, Esther and de Lara, Juan"",
    editor = ""Shepperd, Martin and Brito e Abreu, Fernando and Rodrigues da Silva, Alberto and P{\'e}rez-Castillo, Ricardo"",
    title = ""Testing Chatbots with Charm"",
    booktitle = ""Quality of Information and Communications Technology"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""426--438"",
    abstract = ""Chatbots are software programs with a conversational user interface, typically embedded in webs or messaging systems like Slack, Facebook Messenger or Telegram. Many companies are investing in chatbots to improve their customer support. This has led to a proliferation of chatbot creation platforms (e.g., Dialogflow, Lex, Watson). However, there is currently little support for testing chatbots, which may impact in their final quality."",
    isbn = ""978-3-030-58793-2""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Testing Chatbots with Charm	http://link.springer.com/chapter/10.1007/978-3-030-58793-2_34	Springer International Publishing	nan; References
539	Behave	Testing Go Applications	Automated testing is an important practice in software engineering that ensures the quality of your applications. If you are concerned about application quality, you should write automated tests to verify the behavior of the components of your applications. In your Go applications, automated tests can ensure that the Go packages behave the way they were designed to work. Go provides the fundamental testing capabilities through its standard library packages and tooling support. In this chapter, you will learn how to write unit tests using standard library packages and third-party packages.		Varghese, Shiju	Web Development with Go	https://doi.org/10.1007/978-1-4842-1052-9_10		211--249	"""@Inbook{Varghese2015,
    author = ""Varghese, Shiju"",
    title = ""Testing Go Applications"",
    bookTitle = ""Web Development with Go: Building Scalable Web Apps and RESTful Services"",
    year = ""2015"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""211--249"",
    abstract = ""Automated testing is an important practice in software engineering that ensures the quality of your applications. If you are concerned about application quality, you should write automated tests to verify the behavior of the components of your applications. In your Go applications, automated tests can ensure that the Go packages behave the way they were designed to work. Go provides the fundamental testing capabilities through its standard library packages and tooling support. In this chapter, you will learn how to write unit tests using standard library packages and third-party packages."",
    isbn = ""978-1-4842-1052-9"",
    doi = ""10.1007/978-1-4842-1052-9\_10"",
    url = ""https://doi.org/10.1007/978-1-4842-1052-9\_10""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Testing Go Applications	http://link.springer.com/chapter/10.1007/978-1-4842-1052-9_10	Apress	nan; Keywords; References
540	Behave	Testing Idempotence for Infrastructure as Code	Due to the competitiveness of the computing industry, software developers are pressured to quickly deliver new code releases. At the same time, operators are expected to update and keep production systems stable at all times. To overcome the development--operations barrier, organizations have started to adopt Infrastructure as Code (IaC) tools to efficiently deploy middleware and applications using automation scripts. These automations comprise a series of steps that should be idempotent to guarantee repeatability and convergence. Rigorous testing is required to ensure that the system idempotently converges to a desired state, starting from arbitrary states. We propose and evaluate a model-based testing framework for IaC. An abstracted system model is utilized to derive state transition graphs, based on which we systematically generate test cases for the automation. The test cases are executed in light-weight virtual machine environments. Our prototype targets one popular IaC tool (Chef), but the approach is general. We apply our framework to a large base of public IaC scripts written by operators, showing that it correctly detects non-idempotent automations.	Middleware Deployment; Software Automation; Idempotence; Convergence; Infrastructure as Code; Software Testing	Hummer, Waldemar; Rosenberg, Florian; Oliveira, F{\'a}bio; Eilam, Tamar	ACM/IFIP/USENIX International Conference on Distributed Systems Platforms and Open Distributed Processing	https://doi.org/10.1007/978-3-642-45065-5_19		368--388	"""@InProceedings{10.1007/978-3-642-45065-5_19,
    author = ""Hummer, Waldemar and Rosenberg, Florian and Oliveira, F{\'a}bio and Eilam, Tamar"",
    editor = ""Eyers, David and Schwan, Karsten"",
    title = ""Testing Idempotence for Infrastructure as Code"",
    booktitle = ""Middleware 2013"",
    year = ""2013"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""368--388"",
    abstract = ""Due to the competitiveness of the computing industry, software developers are pressured to quickly deliver new code releases. At the same time, operators are expected to update and keep production systems stable at all times. To overcome the development--operations barrier, organizations have started to adopt Infrastructure as Code (IaC) tools to efficiently deploy middleware and applications using automation scripts. These automations comprise a series of steps that should be idempotent to guarantee repeatability and convergence. Rigorous testing is required to ensure that the system idempotently converges to a desired state, starting from arbitrary states. We propose and evaluate a model-based testing framework for IaC. An abstracted system model is utilized to derive state transition graphs, based on which we systematically generate test cases for the automation. The test cases are executed in light-weight virtual machine environments. Our prototype targets one popular IaC tool (Chef), but the approach is general. We apply our framework to a large base of public IaC scripts written by operators, showing that it correctly detects non-idempotent automations."",
    isbn = ""978-3-642-45065-5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Testing Idempotence for Infrastructure as Code	https://link.springer.com/chapter/10.1007/978-3-642-45065-5_19	Springer Berlin Heidelberg	nan; References
541	Behave	Testing in DevOps	DevOps can be explained by a set of principles and these principles indicate that Testing in DevOps should be looked at differently. The customer must be at the center of testing and more specialized tests must also be used. To ensure that there is continuous feedback, automation should be used as much as possible. All these tests are the responsibility of one team. To achieve this, a test engineer in DevOps must become a T-shaped engineer.	Software testing; Software quality; Test automation; Test engineer; DevOps; Agile testing	Faber, Frank	The Future of Software Quality Assurance	https://doi.org/10.1007/978-3-030-29509-7_3		27--38	"""@Inbook{Faber2020,
    author = ""Faber, Frank"",
    editor = ""Goericke, Stephan"",
    title = ""Testing in DevOps"",
    bookTitle = ""The Future of Software Quality Assurance"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""27--38"",
    abstract = ""DevOps can be explained by a set of principles and these principles indicate that Testing in DevOps should be looked at differently. The customer must be at the center of testing and more specialized tests must also be used. To ensure that there is continuous feedback, automation should be used as much as possible. All these tests are the responsibility of one team. To achieve this, a test engineer in DevOps must become a T-shaped engineer."",
    isbn = ""978-3-030-29509-7"",
    doi = ""10.1007/978-3-030-29509-7\_3"",
    url = ""https://doi.org/10.1007/978-3-030-29509-7\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Testing in DevOps	https://link.springer.com/chapter/10.1007/978-3-030-29509-7_3	Springer International Publishing	nan; References
542	Behave	Testing in Node.js	Testing allows you the peace of mind to know that the code you wrote is actually performing the operations that it was intended to do. Node.js offers a native implementation for writing some form of unit tests, and the Node.js community has created several robust libraries to aid you in your test-driven development process.	Test Suite; Application Programming Interface; Coverage Test; Code Coverage; Callback Function	Gackenheimer, Cory	Node.js Recipes	https://doi.org/10.1007/978-1-4302-6059-2_11		281--310	"""@Inbook{Gackenheimer2013,
    author = ""Gackenheimer, Cory"",
    title = ""Testing in Node.js"",
    bookTitle = ""Node.js Recipes"",
    year = ""2013"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""281--310"",
    abstract = ""Testing allows you the peace of mind to know that the code you wrote is actually performing the operations that it was intended to do. Node.js offers a native implementation for writing some form of unit tests, and the Node.js community has created several robust libraries to aid you in your test-driven development process."",
    isbn = ""978-1-4302-6059-2"",
    doi = ""10.1007/978-1-4302-6059-2\_11"",
    url = ""https://doi.org/10.1007/978-1-4302-6059-2\_11""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Testing in Node.js	https://link.springer.com/chapter/10.1007/978-1-4302-6059-2_11	Apress	nan; References
543	Behave	Testing Strategies in an Agile Context	Testing in an Agile context is extremely important, not only with its function to ensure quality but also to guide development efforts into the right direction. This is related to a shift in testing paradigms, with quality being viewed as a factor early on in product development, rather than a late-stage reactive activity. It also requires the application of different approaches, such as automation, to enable the flow of potentially shippable product increments. Many teams find themselves stuck into the old ways of testing, especially as they work on legacy systems. However, investment in upskilling quality experts, applying the proper tools, and changing the way testing is done can bring tremendous value and opportunities for innovation. Proper change management needs to be applied to enable teams transition successfully into an Agile mindset and new practices.	Software testing; Software quality; Agile testing; Test automation	Nikolova, Zornitsa	The Future of Software Quality Assurance	https://doi.org/10.1007/978-3-030-29509-7_9		111--121	"""@Inbook{Nikolova2020,
    author = ""Nikolova, Zornitsa"",
    editor = ""Goericke, Stephan"",
    title = ""Testing Strategies in an Agile Context"",
    bookTitle = ""The Future of Software Quality Assurance"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""111--121"",
    abstract = ""Testing in an Agile context is extremely important, not only with its function to ensure quality but also to guide development efforts into the right direction. This is related to a shift in testing paradigms, with quality being viewed as a factor early on in product development, rather than a late-stage reactive activity. It also requires the application of different approaches, such as automation, to enable the flow of potentially shippable product increments. Many teams find themselves stuck into the old ways of testing, especially as they work on legacy systems. However, investment in upskilling quality experts, applying the proper tools, and changing the way testing is done can bring tremendous value and opportunities for innovation. Proper change management needs to be applied to enable teams transition successfully into an Agile mindset and new practices."",
    isbn = ""978-3-030-29509-7"",
    doi = ""10.1007/978-3-030-29509-7\_9"",
    url = ""https://doi.org/10.1007/978-3-030-29509-7\_9""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Testing Strategies in an Agile Context	http://link.springer.com/chapter/10.1007/978-3-030-29509-7_9	Springer International Publishing	nan; References
544	Behave	Testing Strategies: How to Become a Better Tester?	This chapter about the general strategies to testing. We present the possible sources of testers' inspiration, psychological aspects of software testing, and several methodological laws and tools that may be helpful in the tester's everyday work. We also discuss the role of several methods and techniques, such as: standards and norms, error models, plans, documentation, estimation, metrics and simulations.		Roman, Adam	Thinking-Driven Testing	https://doi.org/10.1007/978-3-319-73195-7_2		53--97	"""@Inbook{Roman2018,
    author = ""Roman, Adam"",
    title = ""Testing Strategies: How to Become a Better Tester?"",
    bookTitle = ""Thinking-Driven Testing: The Most Reasonable Approach to Quality Control"",
    year = ""2018"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""53--97"",
    abstract = ""This chapter about the general strategies to testing. We present the possible sources of testers' inspiration, psychological aspects of software testing, and several methodological laws and tools that may be helpful in the tester's everyday work. We also discuss the role of several methods and techniques, such as: standards and norms, error models, plans, documentation, estimation, metrics and simulations."",
    isbn = ""978-3-319-73195-7"",
    doi = ""10.1007/978-3-319-73195-7\_2"",
    url = ""https://doi.org/10.1007/978-3-319-73195-7\_2""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Testing Strategies: How to Become a Better Tester?	http://link.springer.com/chapter/10.1007/978-3-319-73195-7_2	Springer International Publishing	nan; Keywords; References
545	Behave	Testing the Distributed System	In this chapter, you'll see the importance of having good test suites in a distributed system. You'll realize how Cucumber and structuring the test project into layers can provide a simple and powerful solution to cover an end-to-end strategy. Cucumber provides a business-friendly language to design the test cases---Gherkin---and it integrates with Java, so it's a choice that combines perfectly with our use case.	Dependency Injection; User John; assertThat; Microservices; Spring Boot	Macero, Moises	Learn Microservices with Spring Boot	https://doi.org/10.1007/978-1-4842-3165-4_6		267--314	"""@Inbook{Macero2017,
    author = ""Macero, Moises"",
    title = ""Testing the Distributed System"",
    bookTitle = ""Learn Microservices with Spring Boot: A Practical Approach to RESTful Services using RabbitMQ, Eureka, Ribbon, Zuul and Cucumber"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""267--314"",
    abstract = ""In this chapter, you'll see the importance of having good test suites in a distributed system. You'll realize how Cucumber and structuring the test project into layers can provide a simple and powerful solution to cover an end-to-end strategy. Cucumber provides a business-friendly language to design the test cases---Gherkin---and it integrates with Java, so it's a choice that combines perfectly with our use case."",
    isbn = ""978-1-4842-3165-4"",
    doi = ""10.1007/978-1-4842-3165-4\_6"",
    url = ""https://doi.org/10.1007/978-1-4842-3165-4\_6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Testing the Distributed System	http://link.springer.com/chapter/10.1007/978-1-4842-3165-4_6	Apress	nan; References
546	Behave	Testing the User Interface	User Interface (UI) tests allow you to test your application from the outside, just as your users would see the application. Every time you decide to run your application on the simulator or device, you are, in effect, testing the UI of your application. Since Xcode 7, Apple has provided the ability to create automated UI tests. These automated UI tests are great at finding regression defects, and used correctly can reduce the regression testing effort for your apps.		Mishra, Abhishek	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_13		407--432	"""@Inbook{Mishra2017,
    author = ""Mishra, Abhishek"",
    title = ""Testing the User Interface"",
    bookTitle = ""iOS Code Testing: Test-Driven Development and Behavior-Driven Development with Swift"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""407--432"",
    abstract = ""User Interface (UI) tests allow you to test your application from the outside, just as your users would see the application. Every time you decide to run your application on the simulator or device, you are, in effect, testing the UI of your application. Since Xcode 7, Apple has provided the ability to create automated UI tests. These automated UI tests are great at finding regression defects, and used correctly can reduce the regression testing effort for your apps."",
    isbn = ""978-1-4842-2689-6"",
    doi = ""10.1007/978-1-4842-2689-6\_13"",
    url = ""https://doi.org/10.1007/978-1-4842-2689-6\_13""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Testing the User Interface	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_13	Apress	nan; Keywords; References
547	Behave	Testing URLSession	This chapter will examine the process of applying TDD techniques to the networking layer of your application. There are various types of networking technologies available to iOS developers. This chapter will only cover networking with the URLSession class. The URLSession connection allows you to conveniently download resources over HTTP connections.		Mishra, Abhishek	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_7		211--256	"""@Inbook{Mishra2017,
    author = ""Mishra, Abhishek"",
    title = ""Testing URLSession"",
    bookTitle = ""iOS Code Testing: Test-Driven Development and Behavior-Driven Development with Swift"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""211--256"",
    abstract = ""This chapter will examine the process of applying TDD techniques to the networking layer of your application. There are various types of networking technologies available to iOS developers. This chapter will only cover networking with the URLSession class. The URLSession connection allows you to conveniently download resources over HTTP connections."",
    isbn = ""978-1-4842-2689-6"",
    doi = ""10.1007/978-1-4842-2689-6\_7"",
    url = ""https://doi.org/10.1007/978-1-4842-2689-6\_7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Testing URLSession	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_7	Apress	nan; Keywords; References
548	Behave	Testing Your Backbone.js Application	Testing is one of the most essential development activities that you will undertake in large-scale JavaScript applications. Within the vast JavaScript ecosystem, there are a number of options for testing applications, which means there is no longer any excuse for not testing your JavaScript code. This chapter will take a look at the leading testing frameworks available and how creating testable code will not only improve the stability of your application but lead to a cleaner architecture. This chapter also examines some of the key reasons to apply Test-Driven Development to your JavaScript code.	Test Suite; Unit Test; Testing Framework; Test Execution; Profile View	Sugrue, James	Beginning Backbone.js	https://doi.org/10.1007/978-1-4302-6335-7_8		151--178	"""@Inbook{Sugrue2013,
    author = ""Sugrue, James"",
    title = ""Testing Your Backbone.js Application"",
    bookTitle = ""Beginning Backbone.js"",
    year = ""2013"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""151--178"",
    abstract = ""Testing is one of the most essential development activities that you will undertake in large-scale JavaScript applications. Within the vast JavaScript ecosystem, there are a number of options for testing applications, which means there is no longer any excuse for not testing your JavaScript code. This chapter will take a look at the leading testing frameworks available and how creating testable code will not only improve the stability of your application but lead to a cleaner architecture. This chapter also examines some of the key reasons to apply Test-Driven Development to your JavaScript code."",
    isbn = ""978-1-4302-6335-7"",
    doi = ""10.1007/978-1-4302-6335-7\_8"",
    url = ""https://doi.org/10.1007/978-1-4302-6335-7\_8""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Testing Your Backbone.js Application	http://link.springer.com/chapter/10.1007/978-1-4302-6335-7_8	Apress	nan; References
549	Behave	Testing, Deployment, and Troubleshooting	This chapter contains three small chapters in one, namely, Testing, Deployment, and Troubleshooting. They do not aim to be complete guides for these topics but to provide the essentials for those who are starting this journey and how they apply to a Vue on Rails approach.		Lim, Bryan; LaFranchi, Richard	Vue on Rails	https://doi.org/10.1007/978-1-4842-5116-4_7		155--182	"""@Inbook{Lim2019,
    author = ""Lim, Bryan and LaFranchi, Richard"",
    title = ""Testing, Deployment, and Troubleshooting"",
    bookTitle = ""Vue on Rails: End-to-End Guide to Building Web Apps Using Vue.js and Rails"",
    year = ""2019"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""155--182"",
    abstract = ""This chapter contains three small chapters in one, namely, Testing, Deployment, and Troubleshooting. They do not aim to be complete guides for these topics but to provide the essentials for those who are starting this journey and how they apply to a Vue on Rails approach."",
    isbn = ""978-1-4842-5116-4"",
    doi = ""10.1007/978-1-4842-5116-4\_7"",
    url = ""https://doi.org/10.1007/978-1-4842-5116-4\_7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Testing, Deployment, and Troubleshooting	http://link.springer.com/chapter/10.1007/978-1-4842-5116-4_7	Apress	nan; Keywords; References
550	Behave	Testmanagement und Softwaretest	http://link.springer.com/book/10.1007/978-3-658-25087-4	Softwaretest; Testprozess; Testmanagement; Testkonzept; Fehlermanagement; Testdurchfuhrung; Testplanung; Agiles Testen; Agile Testing; Mobile Testing; Modultest; Multivariate Testing; Systemtest; Testautomatisierung; Testnorm; V-Modell; Testen in der Cloud; Buch Softwaretest	Frank Witte		https://link.springer.com/book/10.1007/978-3-658-25087-4				Excluded	Excluded	new_screen			2	Springer Link		Testmanagement und Softwaretest	https://link.springer.com/book/10.1007/978-3-658-25087-4	Springer Link	nan; Venue; Abstract; References; Pages; Year; Bibtex; DOI
551	Behave	Thailand's Software Startup Ecosystem	Software startups are currently very popular in Thailand, and existing information reveals an increase in the number of participants and investors in software startup businesses. Moreover, widespread events have been held to showcase the products and services these businesses have contributed. Software startups primarily develop innovations in the form of software produced from limited resources within a limited time. This software must be able to contribute to a sustainable business, and must be adjustable to each business size. Previous research indicates that both attention and emphasis must be placed on the importance of studying software startups in the form of empirical research. This will assist decision-making for those who are interested in initiating software startups and those who want to support them. Research has scarcely studied software startups in Thailand, and therefore, we are interested in Thai startups' current situation as well as the startup ecosystem. This study clarifies that software startups in Thailand are defined as newly emerging businesses anticipated to help businesses grow quickly. Each software startup is in search of a different business model, as current software startups in Thailand have been created to help and support particular businesses. However, software startups rarely invent their own unique, exotic business models or apply advanced technologies and research in their startups.	Software startups; Software engineering; Case study	Nanthaamornphong, Aziz; Wetprasit, Rattana	Fundamentals of Software Startups	https://doi.org/10.1007/978-3-030-35983-6_12		195--213	"""@Inbook{Nanthaamornphong2020,
    author = ""Nanthaamornphong, Aziz and Wetprasit, Rattana"",
    editor = {Nguyen-Duc, Anh and M{\""u}nch, J{\""u}rgen and Prikladnicki, Rafael and Wang, Xiaofeng and Abrahamsson, Pekka},
    title = ""Thailand's Software Startup Ecosystem"",
    bookTitle = ""Fundamentals of Software Startups: Essential Engineering and Business Aspects"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""195--213"",
    abstract = ""Software startups are currently very popular in Thailand, and existing information reveals an increase in the number of participants and investors in software startup businesses. Moreover, widespread events have been held to showcase the products and services these businesses have contributed. Software startups primarily develop innovations in the form of software produced from limited resources within a limited time. This software must be able to contribute to a sustainable business, and must be adjustable to each business size. Previous research indicates that both attention and emphasis must be placed on the importance of studying software startups in the form of empirical research. This will assist decision-making for those who are interested in initiating software startups and those who want to support them. Research has scarcely studied software startups in Thailand, and therefore, we are interested in Thai startups' current situation as well as the startup ecosystem. This study clarifies that software startups in Thailand are defined as newly emerging businesses anticipated to help businesses grow quickly. Each software startup is in search of a different business model, as current software startups in Thailand have been created to help and support particular businesses. However, software startups rarely invent their own unique, exotic business models or apply advanced technologies and research in their startups."",
    isbn = ""978-3-030-35983-6"",
    doi = ""10.1007/978-3-030-35983-6\_12"",
    url = ""https://doi.org/10.1007/978-3-030-35983-6\_12""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Thailand’s Software Startup Ecosystem	http://link.springer.com/chapter/10.1007/978-3-030-35983-6_12	Springer International Publishing	nan; References
552	Behave	The ASMETA Approach to Safety Assurance of Software Systems	Safety-critical systems require development methods and processes that lead to provably correct systems in order to prevent catastrophic consequences due to system failure or unsafe operation. The use of models and formal analysis techniques is highly demanded both at design-time, to guarantee safety and other desired qualities already at the early stages of the system development, and at runtime, to address requirements assurance during the system operational stage.		Arcaini, Paolo; Bombarda, Andrea; Bonfanti, Silvia; Gargantini, Angelo; Riccobene, Elvinia; Scandurra, Patrizia	Logic, Computation and Rigorous Methods	https://doi.org/10.1007/978-3-030-76020-5_13		215--238	"""@Inbook{Arcaini2021,
    author = ""Arcaini, Paolo and Bombarda, Andrea and Bonfanti, Silvia and Gargantini, Angelo and Riccobene, Elvinia and Scandurra, Patrizia"",
    editor = ""Raschke, Alexander and Riccobene, Elvinia and Schewe, Klaus-Dieter"",
    title = ""The ASMETA Approach to Safety Assurance of Software Systems"",
    bookTitle = {Logic, Computation and Rigorous Methods: Essays Dedicated to Egon B{\""o}rger on the Occasion of His 75th Birthday},
    year = ""2021"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""215--238"",
    abstract = ""Safety-critical systems require development methods and processes that lead to provably correct systems in order to prevent catastrophic consequences due to system failure or unsafe operation. The use of models and formal analysis techniques is highly demanded both at design-time, to guarantee safety and other desired qualities already at the early stages of the system development, and at runtime, to address requirements assurance during the system operational stage."",
    isbn = ""978-3-030-76020-5"",
    doi = ""10.1007/978-3-030-76020-5\_13"",
    url = ""https://doi.org/10.1007/978-3-030-76020-5\_13""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		The ASMETA Approach to Safety Assurance of Software Systems	http://link.springer.com/chapter/10.1007/978-3-030-76020-5_13	Springer International Publishing	nan; Keywords; References
553	Behave	The Basic Spring Boot Application	The main goal of this chapter is to introduce the functional requirements of our application and the test-driven development approach you'll follow in this book. You'll create a Spring Boot application by developing some basic functionality using TDD.		Macero, Moises	Learn Microservices with Spring Boot	https://doi.org/10.1007/978-1-4842-3165-4_2		9--21	"""@Inbook{Macero2017,
    author = ""Macero, Moises"",
    title = ""The Basic Spring Boot Application"",
    bookTitle = ""Learn Microservices with Spring Boot: A Practical Approach to RESTful Services using RabbitMQ, Eureka, Ribbon, Zuul and Cucumber"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""9--21"",
    abstract = ""The main goal of this chapter is to introduce the functional requirements of our application and the test-driven development approach you'll follow in this book. You'll create a Spring Boot application by developing some basic functionality using TDD."",
    isbn = ""978-1-4842-3165-4"",
    doi = ""10.1007/978-1-4842-3165-4\_2"",
    url = ""https://doi.org/10.1007/978-1-4842-3165-4\_2""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		The Basic Spring Boot Application	http://link.springer.com/chapter/10.1007/978-1-4842-3165-4_2	Apress	nan; Keywords; References
554	Behave	The Basics	This chapter will discuss coding kata, basic terminology, overcoming difficulty in TDD, and how to improve your TDD skills over time.	Domain Analysis; Application Program Interface; Problem Domain; Solution Domain; Production Code	Bala Paranj	Test Driven Development in Ruby	https://doi.org/10.1007/978-1-4842-2638-4_1		1–55		Excluded	Excluded	new_screen			2	Springer Link		The Basics	http://link.springer.com/chapter/10.1007/978-1-4842-2638-4_1	Apress, Berkeley, CA	nan; References; Year; Bibtex
555	Behave	The Big Green Check Mark	All this is a long-winded and hunger-inducing way of saying that there are many elements that determine whether something as simple as a sandwich gets the thumbs up, the seal of approval, the big green check mark. Software is no different. When software is produced, particularly when produced by a team as part of a business, there are lots of ways in which the production of the software could, in the final analysis, be considered unsatisfactory.	Technical Debt; Drudge Work; Smoke Test; Edge Cases; Behavior-driven Development	Gleeson, Patrick	Working with Coders	https://doi.org/10.1007/978-1-4842-2701-5_5		113--138	"""@Inbook{Gleeson2017,
    author = ""Gleeson, Patrick"",
    title = ""The Big Green Check Mark"",
    bookTitle = ""Working with Coders: A Guide to Software Development for the Perplexed Non-Techie"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""113--138"",
    abstract = ""All this is a long-winded and hunger-inducing way of saying that there are many elements that determine whether something as simple as a sandwich gets the thumbs up, the seal of approval, the big green check mark. Software is no different. When software is produced, particularly when produced by a team as part of a business, there are lots of ways in which the production of the software could, in the final analysis, be considered unsatisfactory."",
    isbn = ""978-1-4842-2701-5"",
    doi = ""10.1007/978-1-4842-2701-5\_5"",
    url = ""https://doi.org/10.1007/978-1-4842-2701-5\_5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		The Big Green Check Mark	http://link.springer.com/chapter/10.1007/978-1-4842-2701-5_5	Apress	nan; References
556	Behave	The Design, Evolution, and Use of KernelF	KernelF is a functional language built on top of MPS. It is designed to be highly extensible and embeddable in order to support its use at the core of domain-specific languages, realising an approach we sometimes call Funclerative Programming. ``Funclerative'' is of course a mash-up of ``functional'' and ``declarative'' and refers to the idea of using functional programming in the small, and declarative language constructs for the larger-scale, often domain-specific, structures in a program. We have used KernelF in a wide range of languages including health and medicine, insurance contract definition, security analysis, salary calculations, smart contracts and language-definition. In this paper, I illustrate the evolution of KernelF over the last two years. I discuss requirements on the language, and how those drove design decisions. I showcase a couple of the DSLs we built on top of KernelF to explain how MPS was used to enable the necessary language modularity. I demonstrate how we have integrated the Z3 solver to verify some aspects of programs. I present the architecture we have used to use KernelF-based DSLs in safety-critical environments. I close the keynote with an outlook on how KernelF might evolve in the future, and point out a few challenges for which we don't yet have good solutions.	Domain-specific languages; Language modularity; Functional Language; Language engineering; Meta programming	Voelter, Markus	International Conference on Theory and Practice of Model Transformations	https://doi.org/10.1007/978-3-319-93317-7_1		3--55	"""@InProceedings{10.1007/978-3-319-93317-7_1,
    author = ""Voelter, Markus"",
    editor = ""Rensink, Arend and S{\'a}nchez Cuadrado, Jes{\'u}s"",
    title = ""The Design, Evolution, and Use of KernelF"",
    booktitle = ""Theory and Practice of Model Transformation"",
    year = ""2018"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""3--55"",
    abstract = ""KernelF is a functional language built on top of MPS. It is designed to be highly extensible and embeddable in order to support its use at the core of domain-specific languages, realising an approach we sometimes call Funclerative Programming. ``Funclerative'' is of course a mash-up of ``functional'' and ``declarative'' and refers to the idea of using functional programming in the small, and declarative language constructs for the larger-scale, often domain-specific, structures in a program. We have used KernelF in a wide range of languages including health and medicine, insurance contract definition, security analysis, salary calculations, smart contracts and language-definition. In this paper, I illustrate the evolution of KernelF over the last two years. I discuss requirements on the language, and how those drove design decisions. I showcase a couple of the DSLs we built on top of KernelF to explain how MPS was used to enable the necessary language modularity. I demonstrate how we have integrated the Z3 solver to verify some aspects of programs. I present the architecture we have used to use KernelF-based DSLs in safety-critical environments. I close the keynote with an outlook on how KernelF might evolve in the future, and point out a few challenges for which we don't yet have good solutions."",
    isbn = ""978-3-319-93317-7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		The Design, Evolution, and Use of KernelF	http://link.springer.com/chapter/10.1007/978-3-319-93317-7_1	Springer International Publishing	nan; References
557	Behave	The Distinct Trends and Transitions in the Information Technology (IT) Space	There is an overwhelming recognition that IT is the real game-changer not only for worldwide businesses but also for the total humanity. The world is investing its talents, treasures, and time on IT, and therefore, there are several noteworthy advancements and accomplishments emerging and evolving in the hot IT field. By sagaciously leveraging those praiseworthy innovations and inventions, business houses across the globe are keeping up the edge earned. All kinds of business acceleration, augmentation, and automation get done through the bevy of IT improvisations. In the recent past, there is a tectonic twist. That is, IT is being adeptly enabled to empower people. All sorts of decision-making, deals, and deeds are being facilitated by IT systems. We can safely anticipate that IT is going to be hugely people-centric hereafter. IT is being tuned for performing not only informational, commercial, and transactional services but also for context-aware, cognitive, and physical services. Humans individually and collectively are getting immensely and immeasurably benefited out of the enigmatic IT. Thus, there is a pioneering and path-breaking impact on people by various evolutions and revolutions in the IT landscape. The disruptions and transformations being brought in by IT are simply incredible. In short, all kinds of industry verticals accelerate their operations, offerings, and outputs through the consistently growing power of IT. Besides IT systems, our everyday devices, machines, instruments, equipment, utensils, wares, consumer electronics, drones, robots, etc., are adequately and adroitly enable to be distinct in their actions and reactions. Physical, mechanical, and electrical systems are IT-enabled to exhibit adaptive behavior in their activities.	Business Acceleration; deploymentDeployment; Cloud Idea; Containment Isolation; Docker Container	Raj, Pethuru; Raman, Anupama	Software-Defined Cloud Centers	https://doi.org/10.1007/978-3-319-78637-7_1		1--12	"""@Inbook{Raj2018,
    author = ""Raj, Pethuru and Raman, Anupama"",
    title = ""The Distinct Trends and Transitions in the Information Technology (IT) Space"",
    bookTitle = ""Software-Defined Cloud Centers: Operational and Management Technologies and Tools"",
    year = ""2018"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""1--12"",
    abstract = ""There is an overwhelming recognition that IT is the real game-changer not only for worldwide businesses but also for the total humanity. The world is investing its talents, treasures, and time on IT, and therefore, there are several noteworthy advancements and accomplishments emerging and evolving in the hot IT field. By sagaciously leveraging those praiseworthy innovations and inventions, business houses across the globe are keeping up the edge earned. All kinds of business acceleration, augmentation, and automation get done through the bevy of IT improvisations. In the recent past, there is a tectonic twist. That is, IT is being adeptly enabled to empower people. All sorts of decision-making, deals, and deeds are being facilitated by IT systems. We can safely anticipate that IT is going to be hugely people-centric hereafter. IT is being tuned for performing not only informational, commercial, and transactional services but also for context-aware, cognitive, and physical services. Humans individually and collectively are getting immensely and immeasurably benefited out of the enigmatic IT. Thus, there is a pioneering and path-breaking impact on people by various evolutions and revolutions in the IT landscape. The disruptions and transformations being brought in by IT are simply incredible. In short, all kinds of industry verticals accelerate their operations, offerings, and outputs through the consistently growing power of IT. Besides IT systems, our everyday devices, machines, instruments, equipment, utensils, wares, consumer electronics, drones, robots, etc., are adequately and adroitly enable to be distinct in their actions and reactions. Physical, mechanical, and electrical systems are IT-enabled to exhibit adaptive behavior in their activities."",
    isbn = ""978-3-319-78637-7"",
    doi = ""10.1007/978-3-319-78637-7\_1"",
    url = ""https://doi.org/10.1007/978-3-319-78637-7\_1""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		The Distinct Trends and Transitions in the Information Technology (IT) Space	http://link.springer.com/chapter/10.1007/978-3-319-78637-7_1	Springer International Publishing	nan; References
558	Behave	The Ecosystem: Extending React Native	If you have come this far, you can proudly say you have become a React Native developer. In this final chapter you learn how expedite your React Native development by using some very useful, stable, and popular libraries. These are designed to make your life a bit easier and help you create your apps faster. This chapter covers the following topics:		Paul, Akshat; Nalwaya, Abhishek	React Native for Mobile Development	https://doi.org/10.1007/978-1-4842-4454-8_10		225--232	"""@Inbook{Paul2019,
    author = ""Paul, Akshat and Nalwaya, Abhishek"",
    title = ""The Ecosystem: Extending React Native"",
    bookTitle = ""React Native for Mobile Development: Harness the Power of React Native to Create Stunning iOS and Android Applications"",
    year = ""2019"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""225--232"",
    abstract = ""If you have come this far, you can proudly say you have become a React Native developer. In this final chapter you learn how expedite your React Native development by using some very useful, stable, and popular libraries. These are designed to make your life a bit easier and help you create your apps faster. This chapter covers the following topics:"",
    isbn = ""978-1-4842-4454-8"",
    doi = ""10.1007/978-1-4842-4454-8\_10"",
    url = ""https://doi.org/10.1007/978-1-4842-4454-8\_10""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		The Ecosystem: Extending React Native	http://link.springer.com/chapter/10.1007/978-1-4842-4454-8_10	Apress	nan; Keywords; References
559	Behave	The evolution of agile software development in Brazil	Agile software development methods have been increasingly adopted worldwide and became one of the mainstream software development approaches. Agile methods have also had an impact on software engineering education with universities adapting their courses to accommodate this new form of software development. Software engineering research has tried to evaluate the impact of agile methods in industrial projects and discover in which situations it is beneficial to apply such methods. However, there are almost no studies focusing on the progress of the agile movement in Brazil. In this paper, we present an overview of the evolution of the agile movement in Brazil, outlining the history of its first advocates in academia and industry. We describe existing educational initiatives, discuss the impact of the agile development on the national research, and present a report on the agile state-of-the-practice in the Brazilian IT industry.	Artificial Intelligence; Agile software development; Agile educational initiatives; Brazilian agile research; Brazilian agile state-of-the-practice; Object-oriented programming; History of computing	Claudia de O. Melo; Viviane Santos; Eduardo Katayama; Hugo Corbucci; Rafael Prikladnicki; Alfredo Goldman; Fabio Kon	Journal of the Brazilian Computer Society	https://doi.org/10.1007/s13173-013-0114-x	"Abbas N, Gravell AM, Wills GB (2008) Historical roots of agile methods: where did agile thinking come from? In: Agile processes in software engineering and extreme programming. Lecture notes in business information processing, vol 9. Springer, Berlin, pp 94-103; Aniche M, Gerosa M (2010) Most common mistakes in test-driven development practice: results from an online survey with developers. In: 2010 third international conference on software testing, verification, and validation workshops (ICSTW), IEEE, pp 469-478; citation_journal_title=Commun Assoc Inf Syst; citation_title=Assessing personality profiles of software developers in agile development teams; citation_author=V Balijepally, R Mahapatra, SP Nerur; citation_volume=18; citation_publication_date=2006; citation_pages=55-75; citation_id=CR3; citation_title=Extreme programming explained: embrace change, 1999; citation_publication_date=1999; citation_id=CR4; citation_author=K Beck; citation_publisher=Addison-Wesley; Bernardo P, Kon F (2007) Desenvolvendo com agilidade: experiencias na reimplementacao de um sistema de grande porte. In: Proceedings of the 1st workshop on rapid application development (WDRA2007) in the Brazillian symposium on software, quality (SBQS2007), pp 1-4; citation_journal_title=IEEE Softw; citation_title=Management challenges to implementing agile processes in traditional development organizations; citation_author=B Boehm, R Turner; citation_volume=22; citation_issue=5; citation_publication_date=2005; citation_pages=30-39; citation_id=CR6; Bravo M, Goldman A (2010) Reinforcing the learning of agile practices using coding dojos. In: Aalst W, Mylopoulos J, Sadeh NM, Shaw MJ, Szyperski C, Sillitti A, Martin A, Wang X, Whitworth E (eds) Agile processes in software engineering and extreme programming. Lecture notes in business information processing vol 48. Springer, Berlin, pp 379-380.; Brooks FP (1975) The mythical man-month: essays on software engineering. Addison-Wesley, Reading; Bunse C, Feldmann RL, Dorr J (2004) Agile methods in software engineering education. In: Extreme programming and agile processes in software engineering. Lecture notes in computer science, vol 3092. Springer, Berlin, pp 284-293; Cagnin MI, Maldonado JC, Germano FSR, Penteado RD (2003) Parfait: towards a framework-based agile reengineering process. In: Agile development conference, pp 22-31; Cameron KS, Ettington DR (1988) The conceptual foundations of organizational culture. Higher education, vol 4. Kluwer, Dordrecht; Cameron KS, Quinn RE (2011) Diagnosing and changing organizational culture: based on the competing values framework. Jossey-Bass, San Francisco; Cockburn A (2006) Agile software development: the cooperative game. Addison-Wesley Professional, Reading; Cohen J (1988) Statistical power analysis for the behavioral sciences, 2nd edn. Routledge Academic, London; citation_journal_title=Inf Syst Res; citation_title=Agility from first principles: reconstructing the concept of agility in information systems development; citation_author=K Conboy; citation_volume=20; citation_publication_date=2009; citation_pages=329-354; citation_doi=10.1287/isre.1090.0236; citation_id=CR15; Conboy K, Fitzgerald B (2010) Method and developer characteristics for effective agile method tailoring: a study of xp expert opinion. In: ACM Trans Softw Eng Methodol (TOSEM) 20:2:1-2:30; Corbucci H, Bravo M (2007) Archimedes--o cad aberto: Uma aplicacao para desenho tecnico baseada na plataforma do eclipse; Corbucci H, Goldman A, Katayama E, Kon F, Melo C, Santos V (2011) Genesis and evolution of the agile movement in Brazil--perspective from academia and industry, 25th Brazilian symposium on software engineering (SBES), pp 98-107; Creswell J (2009) Research design: qualitative, quantitative, and mixed methods approaches. Sage Publications, London; Derby E, Larsen D (2006) Agile retrospectives--making good teams great. Pragmatic Bookshelf, North Carolina; Dingsoyr T, Dyba T, Brede Moe N (2010) Agile software development: an introduction and overview. In: Agile software development: current research and future directions, 1st edn. Springer, Berlin, pp 1-13; Dingsoyr T, Moe NB, Balijepally V, Nerur SP (eds) (2011) Agile conference 2011, Agile. 
                  http://agile2011.agilealliance.org/
                  
                . Accessed January 2012; Ducasse S (2005) Squeak: learn programming with robots. Apress, New York; citation_journal_title=Inf Softw Technol; citation_title=Empirical studies of agile software development: a systematic review; citation_author=T Dyba, T Dingsoyr; citation_volume=50; citation_publication_date=2008; citation_pages=833-859; citation_doi=10.1016/j.infsof.2008.01.006; citation_id=CR24; citation_journal_title=Inf Softw Technol; citation_title=Empirical studies of agile software development: a systematic review; citation_author=T Dyba, T Dingsoyr; citation_volume=50; citation_publication_date=2008; citation_pages=833-859; citation_doi=10.1016/j.infsof.2008.01.006; citation_id=CR25; citation_journal_title=Qual Res; citation_title=Pluralism in qualitative research: the impact of different researchers and qualitative approaches on the analysis of qualitative data; citation_author=N Frost, SM Nolas, BBGC Esin, A Holt, L Mehdizadeh, P Shinebourne; citation_volume=10; citation_publication_date=2010; citation_pages=441-460; citation_doi=10.1177/1468794110366802; citation_id=CR26; Goldman A, Katayama E (2011) Retrato da comunidade academica de metodos ageis no Brasil. In: Workshop Brasileiro de Metodos Ageis (WBMA 2011), pp 1-10; citation_journal_title=J Brazilian Comput Soc; citation_title=Being extreme in the classroom: experiences teaching xp; citation_author=A Goldman, F Kon, PJS Silva, JW Yoder; citation_volume=10; citation_publication_date=2004; citation_pages=5-21; citation_doi=10.1590/S0104-65002004000300002; citation_id=CR28; Guba EG, Lincoln YS (1994) Competing paradigms in qualitative research. In: Qualitative research. Sage, London, pp 105-117; Hazzan O, Dubinsky Y (2003) Teaching a software development methodology: the case of extreme programming. In: 16th software engineering education and training (CSEE &T), IEEE, pp 176-184; Jalali S, Wohlin C (2012) Systematic literature studies: database searches vs. backward snowballing. In: ESEM, pp 29-38; Krill P (2010) Agile software development is now mainstream. InfoWorld, Pune; citation_journal_title=J Softw Evol Process; citation_title=Contextualizing agile software development; citation_author=P Kruchten; citation_volume=25; citation_issue=4; citation_publication_date=2011; citation_pages=351-361; citation_id=CR33; Kuhn TS (1962) The structure of scientific revolutions. University of Chicago Press, Chicago; citation_journal_title=IEEE Comput Soc; citation_title=Iterative and incremental development: a brief history; citation_author=C Larman, VR Basili; citation_volume=36; citation_publication_date=2003; citation_pages=47-56; citation_doi=10.1109/MC.2003.1204375; citation_id=CR35; citation_journal_title=Inf Softw Technol; citation_title=Revealing actual documentation usage in software maintenance through war stories; citation_author=WG Lutters, CB Seaman; citation_volume=49; citation_publication_date=2007; citation_pages=576-587; citation_doi=10.1016/j.infsof.2007.02.013; citation_id=CR36; Meirelles P, Santos C, Miranda J, Kon F, Terceiro A, Chavez C (2010) A study of the relationships between source code metrics and attractiveness in free software projects. In: 2010 Brazilian symposium on software engineering (SBES), IEEE, pp 11-20; Melnik G, Maurer F (2003) Introducing agile methods in learning environments: lessons learned. In: Extreme programming and agile methods. Lecture notes in computer science, vol 2753. Springer, Berlin, pp 172-184; Melnik G, Maurer F (2005) A cross-program investigation of students' perceptions of agile methods. In: Proceedings of the 27th international conference on software engineering. ACM, New York, pp 481-488; citation_journal_title=Inf Softw Technol; citation_title=Interpretative case studies on agile team productivity and management; citation_author=CO Melo, D Cruzes, F Kon, R Conradi; citation_volume=55; citation_issue=2; citation_publication_date=2012a; citation_pages=412-427; citation_id=CR40; Melo C, Santos VA, Corbucci H, Katayama E, Goldman A, Kon F (2012b) Metodos ageis no Brasil: estado da pratica em times e organizacoes. Technical report 03, Departamento de Computacao (IME-USP). 
                  http://www.agilcoop.bg.br/MetodosAGE-isBrasil2011
                  
                . Accessed June 2013; citation_journal_title=J Brazilian Comput Soc; citation_title=Scriptlattes: an open-source knowledge extraction system from the lattes platform; citation_author=JP Mena-Chalco, RM Cesar; citation_volume=15; citation_publication_date=2009; citation_pages=31-39; citation_doi=10.1007/BF03194511; citation_id=CR42; citation_journal_title=Inf Softw Technol; citation_title=A teamwork model for understanding an agile team: a case study of a scrum project; citation_author=NB Moe, T Dingsoyr, T Dyba; citation_volume=52; citation_publication_date=2010; citation_pages=480-491; citation_doi=10.1016/j.infsof.2009.11.004; citation_id=CR43; Muller MM, Link J, Sand R, Malpohl G (2004) Extreme programming in curriculum: experiences from academia and industry. In: Extreme programming and agile processes in software engineering. Lecture notes in computer science, vol 3092. Springer, Berlin, pp 294-302; citation_journal_title=MIS Q; citation_title=Prototyping: the new paradigm for systems development; citation_author=JD Naumann, AM Jenkins; citation_volume=6; citation_publication_date=1982; citation_pages=29-44; citation_doi=10.2307/248654; citation_id=CR45; Nerur S, Cannon A, Balijepally V, Bond P (2010) Towards an understanding of the conceptual underpinnings of agile development methodologies. In: Dingsoyr T, Dyba T, Moe N (eds) Agile software development. Springer, Berlin, pp 15-29; Oliveira RdM, Goldman A, Melo C (2013) Designing and managing agile informative workspaces: discovering and exploring patterns. In: Proceedings of the 46th Hawaii international conference on systems science (HICSS-46). Grand Wailea, Maui, pp 4790-4799; citation_title=Lean software development: an agile toolkit; citation_publication_date=2003; citation_id=CR48; citation_author=M Poppendieck; citation_author=T Poppendieck; citation_publisher=Addison-Wesley Longman Publishing Co., Inc.; Rico D, Sayani HH (2009) Use of agile methods in software engineering education. In: Agile 2009 conference, IEEE Computer Society, pp 174-179; Ries E (2011) The Lean startup: how today's entrepreneurs use continuous innovation to create radically successful businesses. Crown Business, New York; Royce WW (1970) Managing the development of large software systems. In: Proceedings of WESCON, pp 1-9. Also available in Proc. of ICSE 9, Computer Society Press, 1987; citation_journal_title=J Brazilian Comput Soc; citation_title=Assessing agile methods: an empirical study; citation_author=A Sampaio, A Vasconcelos, P Sampaio; citation_volume=10; citation_publication_date=2004; citation_pages=22-41; citation_doi=10.1590/S0104-65002004000300003; citation_id=CR52; Santos A, Martinez M, Kon F, Gerosa M, Michalsky S, Rozestraten A (2011) Da coleta de dados ao conhecimento obtido durante o desenvolvimento do projeto arquigrafia-Brasil. In: Congresso Internacional de Design da Informacao, pp 1-10; Santos V, Goldman A (2010) Aplicando tecnicas de grounded theory e retrospectiva Agil para buscar melhorias para o curso laboratorio xp (in Portuguese). In: VII experimental software engineering Latin America workshop (ESELAW). Goiania, Goias, pp 60-69; Santos V, Goldman A (2011) An approach on applying organizational learning in agile software organizations. In: Agile processes in software engineering and extreme programming. Lecture notes in business information processing, vol 77. Springer, Berlin, pp 324-325; Sato DT, Corbucci H, Bravo MV (2008) Coding dojo: an environment for learning and sharing agile practices. In: Proceedings agile 2008 conference, IEEE Computer Society, pp 459-464; Sato DT, Goldman A, Kon F (2007) Tracking the evolution of object-oriented quality metrics on agile projects. In: XP, pp 84-92; SBC (ed) (2011a) Experimental software engineering Latin American workshop, ESELAW. 
                  http://cibse.inf.puc-rio.br/pt/program_eselaw.php
                  
                . Accessed January 2012; SBC (ed) (2011b) Simposio Brasileiro de Engenharia de Software, SBES. 
                  http://www.each.usp.br/cbsoft2011/portugues/sbes/sbes_pt.html
                  
                . Acessed January 2012; SBC (ed) (2011c) Workshop Brasileiro de Metodos Ageis, WBMA. 
                  http://www.agilebrazil.com/2011/pt/wbma.php
                  
                . Acessed January 2012; SBC (ed) (2011d) Workshop de Desenvolvimento Rapido de Aplicacoes, WDRA. 
                  http://promise.cin.ufpe.br/wdra2011/index.html
                  
                . Acessed January 2012; Schwaber K, Beedle M (2001) Agile software development with scrum, 1st edn. Prentice Hall PTR, Upper Saddle River; citation_journal_title=Qual Quant; citation_title=Conducting online surveys; citation_author=MV Selm, N Jankowski; citation_volume=40; citation_publication_date=2006; citation_pages=435-456; citation_doi=10.1007/s11135-005-8081-8; citation_id=CR63; citation_journal_title=Am J Sociol; citation_title=The integration of fieldwork and survey methods; citation_author=SD Sieber; citation_volume=78; citation_publication_date=1973; citation_pages=1335-1359; citation_doi=10.1086/225467; citation_id=CR64; Sillitti A, Hazzan O, Bache E, Albaladejo X (eds) (2011) Proceedings of the agile processes in software engineering and extreme programming--12th international conference, XP 2011. Lecture notes in business information processing, vol 77, Madrid, Spain, 10-13 May 2011. Springer, Berlin; Silva AF, Asmussen C, Kon F, Goldman A, Ferreira CE (2004) Mico--university schedule planner. In: 5th workshop on free software (WSL'2004), Porto Alegre, pp 147-150; Silva AFd, Kon F, Torteli C (2005) XP south of the equator: an eXperience implementing XP in Brazil. In: Proceedings of the 6th international conference on extreme programming and agile processes in software engineering (XP2005). Springer, Berlin, pp 10-18; Softex (2010) Software and IT services: the Brazilian industry in perspective, vol 1. Observatorio SOFTEX, Campinas; Sue VM, Ritter LA (2007) Conducting online surveys. Sage Publications, Inc., London; citation_journal_title=Commun ACM; citation_title=Training future software developers to acquire agile development skills; citation_author=CH Tan, HH Teo; citation_volume=50; citation_publication_date=2007; citation_pages=97-98; citation_doi=10.1145/1323688.1323715; citation_id=CR70; Terceiro A, Costa J, Miranda J, Meirelles P, Rios LR, Almeida L, Chavez C, Kon F (2010) Analizo: an extensible multi-language source code analysis and visualization toolkit; VersionOne (2009) 4th annual state of agile development. 
                  http://versionone.com/state_of_agile_development_survey/09; VersionOne (2010) 5th annual state of agile development. 
                  http://versionone.com/state_of_agile_development_survey/10; VersionOne (2012) 7th annual state of agile evelopment. 
                  http://www.versionone.com/pdf/7th-Annual-state-of-Agile-Developmen-survey.pdf; citation_journal_title=Inform Syst Manag; citation_title=Can agile and traditional systems development approaches coexist? An ambidextrous view; citation_author=V Vinekar, C Slinkman, S Nenu; citation_volume=23; citation_issue=3; citation_publication_date=2006; citation_pages=31-42; citation_id=CR75; Wainer M (2003) Adaptations for teaching software development with extreme programming: an experience report. In: Extreme programming and agile methods. Lecture notes in computer science. Springer, Berlin, vol 2753, pp 199-207; West D, Grant T (2010) Agile development: mainstream adoption has changed agility--trends in real-world adoption of agile methods. Technical report, Forrester Research; Whitworth E, Biddle R (2007) The social nature of agile teams. In: Proceedings of the AGILE 2007. IEEE Computer Society, Washington, pp 26-36; citation_journal_title=Adv Comput; citation_title=Agile software development methodologies and practices; citation_author=L Williams; citation_volume=80; citation_publication_date=2010; citation_pages=1-44; citation_doi=10.1016/S0065-2458(10)80001-4; citation_id=CR79"			Excluded	Excluded	new_screen			2	Springer Link		The evolution of agile software development in Brazil	http://link.springer.com/article/10.1007/s13173-013-0114-x	Springer Link	nan; Pages; Year; Bibtex
560	Behave	The Goals Approach: Agile Enterprise Driven Software Development	Continuous Business Process Improvement (BPI) is necessary in order to maintain and develop the enterprise competitiveness. However, achieving a level of software development performance that matches enterprise needs in terms of producing noticeable results within small amounts of time is a persnickety task, mainly because most available methods do not deliver full software architectures that can be directly used for in-house software development without iterations between implementation and design, as produced specifications are too close to the user interface, or too close to business regulations and domain modeling. Our approach applies a method that structures business processes, business rules and domain concepts, and uses this information in order to identify user tasks (use cases) and interaction spaces, and by means of their detail, methodically specify the software architecture for a particular BPI, bridging business and software using cross-consistent concepts. We present a theoretical example, and the validation of our method.	Enterprise engineering; Software engineering; Human-Computer interaction; Enterprise architecture; Software architecture	Valente, Pedro; Silva, Thiago; Winckler, Marco; Nunes, Nuno	Complexity in Information Systems Development	https://doi.org/10.1007/978-3-319-52593-8_13		201--219	"""@InProceedings{10.1007/978-3-319-52593-8_13,
    author = ""Valente, Pedro and Silva, Thiago and Winckler, Marco and Nunes, Nuno"",
    editor = ""Goluchowski, Jerzy and Pankowska, Malgorzata and Linger, Henry and Barry, Chris and Lang, Michael and Schneider, Christoph"",
    title = ""The Goals Approach: Agile Enterprise Driven Software Development"",
    booktitle = ""Complexity in Information Systems Development"",
    year = ""2017"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""201--219"",
    abstract = ""Continuous Business Process Improvement (BPI) is necessary in order to maintain and develop the enterprise competitiveness. However, achieving a level of software development performance that matches enterprise needs in terms of producing noticeable results within small amounts of time is a persnickety task, mainly because most available methods do not deliver full software architectures that can be directly used for in-house software development without iterations between implementation and design, as produced specifications are too close to the user interface, or too close to business regulations and domain modeling. Our approach applies a method that structures business processes, business rules and domain concepts, and uses this information in order to identify user tasks (use cases) and interaction spaces, and by means of their detail, methodically specify the software architecture for a particular BPI, bridging business and software using cross-consistent concepts. We present a theoretical example, and the validation of our method."",
    isbn = ""978-3-319-52593-8""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		The Goals Approach: Agile Enterprise Driven Software Development	http://link.springer.com/chapter/10.1007/978-3-319-52593-8_13	Springer International Publishing	nan; References
561	Behave	The Goals Approach: Enterprise Model-Driven Agile Human-Centered Software Engineering	Business Process Improvement (BPI) is a key issue in the development of the enterprise competitiveness. However, achieving a level of software development performance that matches enterprise BPI needs in terms of producing noticeable results in small amounts of time requires the existence of a comprehensive and also agile Software Development Process (SDP). Quite often, SDPs do not deliver software architectures that can be directly used for in-house development, as specifications are either too close to the user interface design or too close to business rules and application domain modeling, and produce architectures that do not cope with software development concerns. In this paper we present the Goals Approach, which structures business processes to extract requirements, and methodologically details them in order to specify the user interface, the business logic and the database structures for the architecture of a BPI. Our approach aims in-house software development in small and medium enterprises.	Enterprise engineering; Software engineering; Human-Computer Interaction; Agile software development process; Software architecture	Valente, Pedro; Silva, Thiago Rocha; Winckler, Marco; Nunes, Nuno Jardim	International Working Conference on Human Error, Safety, and System Development	https://doi.org/10.1007/978-3-319-44902-9_17		261--280	"""@InProceedings{10.1007/978-3-319-44902-9_17,
    author = ""Valente, Pedro and Silva, Thiago Rocha and Winckler, Marco and Nunes, Nuno Jardim"",
    editor = ""Bogdan, Cristian and Gulliksen, Jan and Sauer, Stefan and Forbrig, Peter and Winckler, Marco and Johnson, Chris and Palanque, Philippe and Bernhaupt, Regina and Kis, Filip"",
    title = ""The Goals Approach: Enterprise Model-Driven Agile Human-Centered Software Engineering"",
    booktitle = ""Human-Centered and Error-Resilient Systems Development"",
    year = ""2016"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""261--280"",
    abstract = ""Business Process Improvement (BPI) is a key issue in the development of the enterprise competitiveness. However, achieving a level of software development performance that matches enterprise BPI needs in terms of producing noticeable results in small amounts of time requires the existence of a comprehensive and also agile Software Development Process (SDP). Quite often, SDPs do not deliver software architectures that can be directly used for in-house development, as specifications are either too close to the user interface design or too close to business rules and application domain modeling, and produce architectures that do not cope with software development concerns. In this paper we present the Goals Approach, which structures business processes to extract requirements, and methodologically details them in order to specify the user interface, the business logic and the database structures for the architecture of a BPI. Our approach aims in-house software development in small and medium enterprises."",
    isbn = ""978-3-319-44902-9""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		The Goals Approach: Enterprise Model-Driven Agile Human-Centered Software Engineering	http://link.springer.com/chapter/10.1007/978-3-319-44902-9_17	Springer International Publishing	nan; References
562	Behave	The MVVM Architectural Pattern	Well over a billion apps have been developed for the iOS platform since its inception. Most of the early apps were rather simple and often developed by a single developer. Over the years, iOS apps have become increasingly complex pieces of software that often involve large, distributed teams of developers working in Agile environments with complex build and release pipelines.		Mishra, Abhishek	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_3		43--60	"""@Inbook{Mishra2017,
    author = ""Mishra, Abhishek"",
    title = ""The MVVM Architectural Pattern"",
    bookTitle = ""iOS Code Testing: Test-Driven Development and Behavior-Driven Development with Swift"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""43--60"",
    abstract = ""Well over a billion apps have been developed for the iOS platform since its inception. Most of the early apps were rather simple and often developed by a single developer. Over the years, iOS apps have become increasingly complex pieces of software that often involve large, distributed teams of developers working in Agile environments with complex build and release pipelines."",
    isbn = ""978-1-4842-2689-6"",
    doi = ""10.1007/978-1-4842-2689-6\_3"",
    url = ""https://doi.org/10.1007/978-1-4842-2689-6\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		The MVVM Architectural Pattern	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_3	Apress	nan; Keywords; References
563	Behave	The Product Backlog	One of the most important artifacts in the Scrum Framework is the Product Backlog. Like the other artifacts, its purpose is to make something transparent and clear. It is managed and maintained by the Product Owner, and its purpose is to make clear the plan for developing a product and the sequence in which the product's features and functions are to be created.		Fowler, Frederik M.	Navigating Hybrid Scrum Environments	https://doi.org/10.1007/978-1-4842-4164-6_9		59--66	"""@Inbook{Fowler2019,
    author = ""Fowler, Frederik M."",
    title = ""The Product Backlog"",
    bookTitle = ""Navigating Hybrid Scrum Environments: Understanding the Essentials, Avoiding the Pitfalls"",
    year = ""2019"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""59--66"",
    abstract = ""One of the most important artifacts in the Scrum Framework is the Product Backlog. Like the other artifacts, its purpose is to make something transparent and clear. It is managed and maintained by the Product Owner, and its purpose is to make clear the plan for developing a product and the sequence in which the product's features and functions are to be created."",
    isbn = ""978-1-4842-4164-6"",
    doi = ""10.1007/978-1-4842-4164-6\_9"",
    url = ""https://doi.org/10.1007/978-1-4842-4164-6\_9""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		The Product Backlog	http://link.springer.com/chapter/10.1007/978-1-4842-4164-6_9	Apress	nan; Keywords; References
564	Behave	The Protractor Handbook	http://link.springer.com/book/10.1007/978-1-4842-7289-3	Protractor; Selenium; WebDriverJS; Angular; JavaScript; Node.js; wdio; Jasmine; automation testing	Shashank Shukla		https://link.springer.com/book/10.1007/978-1-4842-7289-3				Excluded	Excluded	new_screen			2	Springer Link		The Protractor Handbook	https://link.springer.com/book/10.1007/978-1-4842-7289-3	Springer Link	nan; Venue; Abstract; References; Pages; Year; Bibtex; DOI
565	Behave	The State of Agile Software Development in the Czech Republic: Preliminary Findings Indicate the Dominance of ``Abridged'' Scrum	This paper presents preliminary results from a survey focused on the state of agile method adoption in the Czech Republic. To this end, an initial survey sample (N{\thinspace}={\thinspace}120) was analyzed. Scrum is the most frequently used agile software development method, reported by 46.7{\%} of respondents as the agile method of choice. However, the results indicate that Scrum seems to be introduced through cherry-picking of those practices that are quite easy to implement. Specifically, the only widely-spread Scrum practice is the maintenance of Product backlog. To the contrary, the teams are rarely cross-functional and the Scrum master role frequently absents. This suggests that in many organizations, Scrum might be invoked due to being a valuable ``brand name'', rather than due to professionals' subscribing to core Scrum values and assumptions. Our results contribute to the body of empirical knowledge on the state of agile software development initiatives. Our findings confirm the theoretical proposition that in the real world, the implementation of software development methods is often patchy and rarely done ``by the book''.	Software project management; Agile methods; Agile practices; Scrum practices; Scrum variations; Agile method tailoring; Hybrid methods	Dolezel, Michal; Buchalcevova, Alena; Mencik, Michal	International Conference on Research and Practical Issues of Enterprise Information Systems	https://doi.org/10.1007/978-3-030-37632-1_4		43--54	"""@InProceedings{10.1007/978-3-030-37632-1_4,
    author = ""Dolezel, Michal and Buchalcevova, Alena and Mencik, Michal"",
    editor = ""Doucek, Petr and Basl, Josef and Tjoa, A Min and Raffai, Maria and Pavlicek, Antonin and Detter, Katrin"",
    title = ""The State of Agile Software Development in the Czech Republic: Preliminary Findings Indicate the Dominance of ``Abridged'' Scrum"",
    booktitle = ""Research and Practical Issues of Enterprise Information Systems"",
    year = ""2019"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""43--54"",
    abstract = ""This paper presents preliminary results from a survey focused on the state of agile method adoption in the Czech Republic. To this end, an initial survey sample (N{\thinspace}={\thinspace}120) was analyzed. Scrum is the most frequently used agile software development method, reported by 46.7{\\%} of respondents as the agile method of choice. However, the results indicate that Scrum seems to be introduced through cherry-picking of those practices that are quite easy to implement. Specifically, the only widely-spread Scrum practice is the maintenance of Product backlog. To the contrary, the teams are rarely cross-functional and the Scrum master role frequently absents. This suggests that in many organizations, Scrum might be invoked due to being a valuable ``brand name'', rather than due to professionals' subscribing to core Scrum values and assumptions. Our results contribute to the body of empirical knowledge on the state of agile software development initiatives. Our findings confirm the theoretical proposition that in the real world, the implementation of software development methods is often patchy and rarely done ``by the book''."",
    isbn = ""978-3-030-37632-1""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		The State of Agile Software Development in the Czech Republic: Preliminary Findings Indicate the Dominance of “Abridged” Scrum	http://link.springer.com/chapter/10.1007/978-3-030-37632-1_4	Springer International Publishing	nan; References
566	Behave	The Study of the Effectiveness of the Secure Software Development Life-Cycle Models in IT Project Management	Software security is an important and a prevalent element in today's society. The System Development Life-Cycle (SDLC) process that is currently used for most of software development does not address any security components until after the software is developed. The Secure Software Development Life-Cycle (SSDLC) is similar to the SDLC but includes security components into the phases. There have been many models proposed that are primary modified from preexisting SSDLC models. A study was conducted to survey different SSDLC models and their effectiveness. The authors first identified four popular SSDLC models in the IT industry, and then analyzed their common characteristics to derived four sets of Criteria for comparison. These criteria are: Focus Areas of Application, Implementation of model, Security Implementations and Enhancements, and Security training and Staff. The comparison results demonstrate that the Rastogi and Jones model is an effective one for being used for many IT projects. However, it is worthy to mentioned that one specific model cannot be used for all types of IT projects because IT projects are different.	System Development Life-cycle (SDLC); Secure Software Development Life-cycle (SSDLC); Security; IT Project Management	Duclervil, Saniora R.; Liou, Jing-Chiou	16th International Conference on Information Technology-New Generations (ITNG 2019)	https://doi.org/10.1007/978-3-030-14070-0_14		91--96	"""@InProceedings{10.1007/978-3-030-14070-0_14,
    author = ""Duclervil, Saniora R. and Liou, Jing-Chiou"",
    editor = ""Latifi, Shahram"",
    title = ""The Study of the Effectiveness of the Secure Software Development Life-Cycle Models in IT Project Management"",
    booktitle = ""16th International Conference on Information Technology-New Generations (ITNG 2019)"",
    year = ""2019"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""91--96"",
    abstract = ""Software security is an important and a prevalent element in today's society. The System Development Life-Cycle (SDLC) process that is currently used for most of software development does not address any security components until after the software is developed. The Secure Software Development Life-Cycle (SSDLC) is similar to the SDLC but includes security components into the phases. There have been many models proposed that are primary modified from preexisting SSDLC models. A study was conducted to survey different SSDLC models and their effectiveness. The authors first identified four popular SSDLC models in the IT industry, and then analyzed their common characteristics to derived four sets of Criteria for comparison. These criteria are: Focus Areas of Application, Implementation of model, Security Implementations and Enhancements, and Security training and Staff. The comparison results demonstrate that the Rastogi and Jones model is an effective one for being used for many IT projects. However, it is worthy to mentioned that one specific model cannot be used for all types of IT projects because IT projects are different."",
    isbn = ""978-3-030-14070-0""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		The Study of the Effectiveness of the Secure Software Development Life-Cycle Models in IT Project Management	http://link.springer.com/chapter/10.1007/978-3-030-14070-0_14	Springer International Publishing	nan; References
567	Behave	To Build a Fire	Autumn arrives, and the team is celebrating a year into their journey. They can claim some real victories. They've really stepped up their game with monitoring and gathering metrics; just in the past few months, they've investigated some cool new SaaS-based monitoring services, which has improved their visibility into their application's actual performance in the field. Better yet, they're actually caring about the right things; showing business-facing metrics like their order processing rate is helping everyone visualize the part they're playing in a very long delivery chain. But they are still lacking executive support they need; how can they get the protection to finish the next step of their journey?		Harrison, Dave; Lively, Knox	Achieving DevOps	https://doi.org/10.1007/978-1-4842-4388-6_7		311--367	"""@Inbook{Harrison2019,
    author = ""Harrison, Dave and Lively, Knox"",
    title = ""To Build a Fire"",
    bookTitle = ""Achieving DevOps: A Novel About Delivering the Best of Agile, DevOps, and Microservices"",
    year = ""2019"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""311--367"",
    abstract = ""Autumn arrives, and the team is celebrating a year into their journey. They can claim some real victories. They've really stepped up their game with monitoring and gathering metrics; just in the past few months, they've investigated some cool new SaaS-based monitoring services, which has improved their visibility into their application's actual performance in the field. Better yet, they're actually caring about the right things; showing business-facing metrics like their order processing rate is helping everyone visualize the part they're playing in a very long delivery chain. But they are still lacking executive support they need; how can they get the protection to finish the next step of their journey?"",
    isbn = ""978-1-4842-4388-6"",
    doi = ""10.1007/978-1-4842-4388-6\_7"",
    url = ""https://doi.org/10.1007/978-1-4842-4388-6\_7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		To Build a Fire	http://link.springer.com/chapter/10.1007/978-1-4842-4388-6_7	Apress	nan; Keywords; References
568	Behave	Towards a Taxonomy of Microservices Architectures	The microservices architectural style is gaining more and more momentum for the development of applications as suites of small, autonomous, and conversational services, which are then easy to understand, deploy and scale. However, the proliferation of approaches leveraging microservices calls for a systematic way of analyzing and assessing them as a completely new ecosystem: the first cloud-native architectural style. This paper defines a preliminary analysis framework in the form of a taxonomy of concepts, encompassing the whole microservices lifecycle, as well as organizational aspects. This framework is necessary to enable effective exploration, understanding, assessing, comparing, and selecting microservice-based models, languages, techniques, platforms, and tools. Then, we analyze state of the art approaches related to microservices using this taxonomy to provide a holistic perspective of available solutions.	Microservice Architecture; Preliminary Analytical Framework; Resilience Patterns; Open Cloud Computing Interface (OCCI); OpenAPI Specification	Garriga, Martin	International Conference on Software Engineering and Formal Methods	https://doi.org/10.1007/978-3-319-74781-1_15		203--218	"""@InProceedings{10.1007/978-3-319-74781-1_15,
    author = ""Garriga, Martin"",
    editor = ""Cerone, Antonio and Roveri, Marco"",
    title = ""Towards a Taxonomy of Microservices Architectures"",
    booktitle = ""Software Engineering and Formal Methods"",
    year = ""2018"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""203--218"",
    abstract = ""The microservices architectural style is gaining more and more momentum for the development of applications as suites of small, autonomous, and conversational services, which are then easy to understand, deploy and scale. However, the proliferation of approaches leveraging microservices calls for a systematic way of analyzing and assessing them as a completely new ecosystem: the first cloud-native architectural style. This paper defines a preliminary analysis framework in the form of a taxonomy of concepts, encompassing the whole microservices lifecycle, as well as organizational aspects. This framework is necessary to enable effective exploration, understanding, assessing, comparing, and selecting microservice-based models, languages, techniques, platforms, and tools. Then, we analyze state of the art approaches related to microservices using this taxonomy to provide a holistic perspective of available solutions."",
    isbn = ""978-3-319-74781-1""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Towards a Taxonomy of Microservices Architectures	http://link.springer.com/chapter/10.1007/978-3-319-74781-1_15	Springer International Publishing	nan; References
569	Behave	Towards a Verification-Driven Iterative Development of Software for Safety-Critical Cyber-Physical Systems	Software systems are complicated, and the scientific and engineering methodologies for software development are relatively young. Cyber-physical systems are now in every corner of our lives, and we need robust methods for handling the ever-increasing complexity of their software systems. Model-Driven Development is a promising approach to tackle the complexity of systems through the concept of abstraction, enabling analysis at earlier phases of development. In this paper, we propose a model-driven approach with a focus on guaranteeing safety using formal verification. Cyber-physical systems are distributed, concurrent, asynchronous and event-based reactive systems with timing constraints. The actor-based textual modeling language, Rebeca, with model checking support is used for formal verification. Starting from structured requirements and system architecture design the behavioral models, including Rebeca models, are built. Properties of interest are also derived from the structured requirements, and then model checking is used to formally verify the properties. This process can be performed in iterations until satisfaction of desired properties are ensured, and possible ambiguities and inconsistencies in requirements are resolved. The formally verified models can then be used to develop the executable code. The Rebeca models include the details of the signals and messages that are passed at the network level including the timing, and this facilitates the generation of executable code. The natural mappings among the models for requirements, the formal models, and the executable code improve the effectiveness and efficiency of the approach.	Model checking; Verification & validation; Safety-critical systems; Model driven development; Requirements; Cyber-physical systems	Marjan Sirjani,; Luciana Provenzano; Sara Abbaspour Asadollah; Mahshid Helali Moghadam,; Mehrdad Saadatmand	Journal of Internet Services and Applications	https://doi.org/10.1186/s13174-021-00132-z	"Lee EA. Cyber physical systems: Design challenges. In: 2008 11th IEEE International Symposium on Object and Component-oriented Real-time Distributed Computing (ISORC). IEEE: 2008. p. 363-9.; citation_journal_title=Computer; citation_title=The problem with threads; citation_author=EA Lee; citation_volume=39; citation_issue=5; citation_publication_date=2006; citation_pages=33-42; citation_doi=10.1109/MC.2006.180; citation_id=CR2; citation_title=System Design, Modeling, and Simulation Using Ptolemy II, vol. 1; citation_publication_date=2014; citation_id=CR3; citation_author=C Ptolemaeus; citation_publisher=Ptolemy.org; Lee EA, Sirjani M. What good are models? In: Formal Aspects of Component Software - 15th International Conference, FACS 2018, Pohang, South Korea, October 10-12, 2018, Proceedings. Lecture Notes in Computer Science, vol. 11222. Springer: 2018. p. 3-31.; citation_title=Power is overrated, go for friendliness! expressiveness, faithfulness, and usability in modeling: the actor experience; citation_inbook_title=Principles of Modeling; citation_publication_date=2018; citation_id=CR5; citation_author=M Sirjani; citation_publisher=Springer; Holzmann G. Spin Model Checker, the: Primer and Reference Manual. 2003.; citation_journal_title=International Journal on Software Tools for Technology Transfer; citation_title=Nusmv: a new symbolic model checker; citation_author=A Cimatti, E Clarke, F Giunchiglia, M Roveri; citation_volume=2; citation_issue=4; citation_publication_date=2000; citation_pages=410-25; citation_doi=10.1007/s100090050046; citation_id=CR7; citation_journal_title=Int J Softw Tools Technol Tran (STTT); citation_title=Uppaal in a nutshell; citation_author=KG Larsen, P Pettersson, W Yi; citation_volume=1; citation_issue=1; citation_publication_date=1997; citation_pages=134-52; citation_doi=10.1007/s100090050010; citation_id=CR8; citation_journal_title=Sci Comput Program; citation_title=Modelling and simulation of asynchronous real-time systems using timed Rebeca; citation_author=AH Reynisson, M Sirjani, L Aceto, M Cimini, A Jafari, A Ingolfsdottir, SH Sigurdarson; citation_volume=89; citation_publication_date=2014; citation_pages=41-68; citation_doi=10.1016/j.scico.2014.01.008; citation_id=CR9; citation_title=On time actors; citation_inbook_title=Theory and Practice of Formal Methods; citation_publication_date=2016; citation_id=CR10; citation_author=M Sirjani; citation_author=E Khamespanah; citation_publisher=Springer; citation_journal_title=Sci Comput Program; citation_title=Timed Rebeca schedulability and deadlock freedom analysis using bounded floating time transition system; citation_author=E Khamespanah, M Sirjani, Z Sabahi-Kaviani, R Khosravi, M Izadi; citation_volume=98; citation_publication_date=2015; citation_pages=184-204; citation_doi=10.1016/j.scico.2014.07.005; citation_id=CR11; citation_journal_title=Mathematics; citation_title=Verification of cyberphysical systems; citation_author=M Sirjani, EA Lee, E Khamespanah; citation_volume=8; citation_issue=7; citation_publication_date=2020; citation_pages=1068; citation_doi=10.3390/math8071068; citation_id=CR12; citation_title=Formal modeling and analysis of medical systems; citation_inbook_title=International Conference on Coordination Languages and Models; citation_publication_date=2020; citation_id=CR13; citation_author=M Zarneshan; citation_author=F Ghassemi; citation_author=M Sirjani; citation_publisher=Springer; citation_title=An actor-based approach for security analysis of cyber-physical systems; citation_inbook_title=International Conference on Formal Methods for Industrial Critical Systems; citation_publication_date=2020; citation_id=CR14; citation_author=F Moradi; citation_author=SA Asadollah; citation_author=A Sedaghatbaf; citation_author=A Causevic; citation_author=M Sirjani; citation_author=C Talcott; citation_publisher=Springer; Rebeca. Rebeca Homepage. 
                  http://www.rebeca-lang.org/
                  
                . Retrieved July 2019.; citation_journal_title=Fundam Informaticae; citation_title=Modeling and verification of reactive systems using Rebeca; citation_author=M Sirjani, A Movaghar, A Shali, FS De Boer; citation_volume=63; citation_issue=4; citation_publication_date=2004; citation_pages=385-410; citation_id=CR16; citation_title=Rebeca: Theory, applications, and tools; citation_inbook_title=International Symposium on Formal Methods for Components and Objects; citation_publication_date=2006; citation_id=CR17; citation_author=M Sirjani; citation_publisher=Springer; citation_journal_title=ACM Comput Surv; citation_title=A survey of active object languages; citation_author=FS de Boer, V Serbanescu, R Hahnle, L Henrio, J Rochas, CC Din, EB Johnsen, M Sirjani, E Khamespanah, K Fernandez-Reyes, AM Yang; citation_volume=50; citation_issue=5; citation_publication_date=2017; citation_pages=76-17639; citation_id=CR18; Sirjani M, Provenzano L, Asadollah SA, Moghadam MH. From requirements to verifiable executable models using Rebeca. In: International Workshop on Automated and Verifiable Software sYstem DEvelopment: 2019. 
                  http://www.es.mdh.se/publications/5645-
                  
                .; Provenzano L, Hanninen K, Zhou J, Lundqvist K. An ontological approach to elicit safety requirements. In: 2017 24th Asia-Pacific Software Engineering Conference (APSEC). IEEE: 2017. p. 713-8.; Firesmith DG. A taxonomy of safety-related requirements. Requir Eng. 2004. White paper - Carnegie Mellon University.; Zhou J, Hanninen K, Lundqvist K, Provenzano L. An ontological approach to hazard identification for safety-critical systems. In: 2017 Second International Conference on Reliability Systems Engineering (ICRSE). IEEE: 2017. p. 1-7.; Zhou J, Hanninen K, Lundqvist K, Provenzano L. An ontological approach to identify the causes of hazards for safety-critical systems. In: 2017 2nd International Conference on System Reliability and Safety (ICSRS). IEEE: 2017. p. 405-13.; Fowler M. ThoughtWorks: GivenWhenThen. 2013. 
                  https://martinfowler.com/bliki/GivenWhenThen.html
                  
                . Retrieved July 2019.; North D. Introducing BDD. Better Softw Mag. 2006. 
                  https://dannorth.net/introducing-bdd/
                  
                . Retrieved July 2019.; citation_title=ACTORS - a Model of Concurrent Computation in Distributed Systems. MIT Press series in artificial intelligence; citation_publication_date=1990; citation_id=CR26; citation_author=GA Agha; citation_publisher=MIT Press; Hewitt C. Description and theoretical analysis (using schemata) of PLANNER: A language for proving theorems and manipulating models in a robot. Technical report, MIT Artificial Intelligence Technical Report. 1972.; citation_journal_title=STTT; citation_title=Modeling and analyzing real-time wireless sensor and actuator networks using actors and model checking; citation_author=E Khamespanah, M Sirjani, K Mechitov, G Agha; citation_volume=20; citation_issue=5; citation_publication_date=2018; citation_pages=547-61; citation_doi=10.1007/s10009-017-0480-3; citation_id=CR28; citation_journal_title=Form Asp Comput; citation_title=Modeling and efficient verification of wireless ad hoc networks; citation_author=B Yousefi, F Ghassemi, R Khosravi; citation_volume=29; citation_issue=6; citation_publication_date=2017; citation_pages=1051-86; citation_doi=10.1007/s00165-017-0429-z; citation_id=CR29; citation_journal_title=ECEASST; citation_title=Functional and performance analysis of network-on-chips using actor-based modeling and formal verification; citation_author=Z Sharifi, M Mosaffa, S Mohammadi, M Sirjani; citation_volume=66; citation_publication_date=2013; citation_pages=1-16; citation_id=CR30; Nigro L, Sciammarella PF. Time synchronization in wireless sensor networks: A modeling and analysis experience using theatre. In: 2018 IEEE/ACM 22nd International Symposium on Distributed Simulation and Real Time Applications (DS-RT). IEEE: 2018. p. 1-8.; citation_title=Deterministic actors; citation_inbook_title=2019 Forum for Specification and Design Languages (FDL); citation_publication_date=2019; citation_id=CR32; citation_author=M Lohstroh; citation_author=EA Lee; citation_publisher=IEEE; citation_title=Actors revisited for time-critical systems; citation_inbook_title=Proceedings of the 56th Annual Design Automation Conference 2019, DAC 2019; citation_publication_date=2019; citation_id=CR33; citation_author=M Lohstroh; citation_author=M Schoeberl; citation_author=A Goens; citation_author=A Wasicek; citation_author=C Gill; citation_author=M Sirjani; citation_author=EA Lee; citation_publisher=IEEE; Rebeca. Afra Tool. 2019. 
                  http://rebeca-lang.org/alltools/Afra
                  
                . Retrieved July 2019.; Rebeca. RMC Tool. 2016. 
                  http://rebeca-lang.org/alltools/RMC
                  
                . Retrieved July 2019.; Wikipedia. RailwayPlatform. 2019. 
                  https://en.wikipedia.org/wiki/Railway_platform
                  
                . Retrieved July 2019.; citation_title=Model-driven Software Development; citation_publication_date=2005; citation_id=CR37; citation_author=S Beydeda; citation_author=M Book; citation_author=V Gruhn; citation_publisher=Springer; citation_journal_title=Softw Syst Model; citation_title=Model-based engineering in the embedded systems domain: an industrial survey on the state-of-practice; citation_author=G Liebel, N Marko, M Tichy, A Leitner, J Hansson; citation_volume=17; citation_issue=1; citation_publication_date=2018; citation_pages=91-113; citation_doi=10.1007/s10270-016-0523-3; citation_id=CR38; citation_title=CPS Foundations; citation_inbook_title=Proceedings of the 47th Design Automation Conference (DAC '10); citation_publication_date=2010; citation_id=CR39; citation_author=EA Lee; citation_publisher=Association for Computing Machinery; Object Management Group. OMG Systems Modeling Language v1.5. 2017. 
                  https://sysmlforum.com/sysml-specs/
                  
                . Retrieved July 2019.; Object Management Group. UML profile for MARTE, beta 2. 2008. 
                  https://www.omg.org/omgmarte/Specification.htm
                  
                . Retrieved July 2019.; citation_journal_title=Impact Control Technol; citation_title=Cyber-physical systems; citation_author=R Baheti, H Gill; citation_volume=12; citation_issue=1; citation_publication_date=2011; citation_pages=161-6; citation_id=CR42; citation_title=Modeling and Simulation of Systems Using MATLAB and Simulink; citation_publication_date=2017; citation_id=CR43; citation_author=DK Chaturvedi; citation_publisher=CRC press; citation_title=Testing cyber-physical systems via evolutionary algorithms and machine learning; citation_inbook_title=Proceedings of the 12th International Workshop on Search-Based Software Testing (SBST '19); citation_publication_date=2019; citation_id=CR44; citation_author=S Nejati; citation_publisher=IEEE Press; citation_title=Automated model-in-the-loop testing of continuous controllers using search; citation_inbook_title=Search Based Software Engineering; citation_publication_date=2013; citation_id=CR45; citation_author=R Matinnejad; citation_author=S Nejati; citation_author=L Briand; citation_author=T Bruckmann; citation_author=C Poull; citation_publisher=Springer; Marinescu R, Saadatmand M, Bucaioni A, Seceleanu C, Pettersson P. A model-based testing framework for automotive embedded systems. In: 2014 40th EUROMICRO Conference on Software Engineering and Advanced Applications. IEEE: 2014. p. 38-47.; citation_title=dreach: -reachability analysis for hybrid systems; citation_inbook_title=International Conference on TOOLS and Algorithms for the Construction and Analysis of Systems; citation_publication_date=2015; citation_id=CR47; citation_author=S Kong; citation_author=S Gao; citation_author=W Chen; citation_author=E Clarke; citation_publisher=Springer; citation_title=Automatically finding bugs in a commercial cyber-physical system development tool chain with slforge; citation_inbook_title=Proceedings of the 40th International Conference on Software Engineering (ICSE '18); citation_publication_date=2018; citation_id=CR48; citation_author=SA Chowdhury; citation_author=S Mohian; citation_author=S Mehra; citation_author=S Gawsane; citation_author=TT Johnson; citation_author=C Csallner; citation_publisher=Association for Computing Machinery; MathWorks. Stateflow: Model and simulate decision logic using state machines and flow charts. 2018. 
                  https://www.mathworks.com/products/stateflow.html
                  
                . Retrieved July 2019.; citation_journal_title=Sci Comput Program; citation_title=An efficient TCTL model checking algorithm and a reduction technique for verification of timed actor models; citation_author=E Khamespanah, R Khosravi, M Sirjani; citation_volume=153; citation_publication_date=2018; citation_pages=1-29; citation_doi=10.1016/j.scico.2017.11.004; citation_id=CR50; citation_title=PRISM: Probabilistic symbolic model checker; citation_inbook_title=International Conference on Modelling Techniques and Tools for Computer Performance Evaluation; citation_publication_date=2002; citation_id=CR51; citation_author=M Kwiatkowska; citation_author=G Norman; citation_author=D Parker; citation_publisher=Springer; citation_journal_title=Int J Web Inf Syst; citation_title=Translation rules of SysML state machine diagrams into CSP# toward formal model checking; citation_author=T Ando, H Yatsu, W Kong, K Hisazumi, A Fukuda; citation_volume=10; citation_issue=2; citation_publication_date=2014; citation_pages=151-69; citation_doi=10.1108/IJWIS-02-2014-0004; citation_id=CR52; citation_journal_title=Innov Syst Softw Eng; citation_title=Towards model checking executable UML specifications in mCRL2; citation_author=HH Hansen, J Ketema, B Luttik, MR Mousavi, J Van De Pol; citation_volume=6; citation_issue=1-2; citation_publication_date=2010; citation_pages=83-90; citation_doi=10.1007/s11334-009-0116-1; citation_id=CR53; citation_title=A methodology for mapping SysML activity diagram to time petri net for requirement validation of embedded real-time systems with energy constraints; citation_inbook_title=2009 Third International Conference on Digital Society; citation_publication_date=2009; citation_id=CR54; citation_author=E Andrade; citation_author=P Maciel; citation_author=G Callou; citation_author=B Nogueira; citation_publisher=IEEE; Lucio L, Mustafiz S, Denil J, Meyers B, Vangheluwe H. The formalism transformation graph as a guide to model driven engineering. McGill University, Tech. Rep. SOCS-TR2012. 2012.; Lucio L, Denil J, Vangheluwe H. An overview of model transformations for a simple automotive power window. Technical report, McGill University, Tech. Rep. SOCS-TR-2012.2, 2012, http://msdl.cs.mcgill~.... 2012.; Molnar V, Graics B, Voros A, Majzik I, Varro D. The gamma statechart composition framework: Design, verification and code generation for component-based reactive systems. In: 2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion). IEEE: 2018. p. 113-6.; citation_title=A model-driven framework for hardware-software co-design of dataflow applications; citation_inbook_title=International Workshop on Design, Modeling, and Evaluation of Cyber Physical Systems; citation_publication_date=2016; citation_id=CR58; citation_author=W Ahmad; citation_author=BM Yildiz; citation_author=A Rensink; citation_author=M Stoelinga; citation_publisher=Springer; Gilliam DP, Powell JD, Bishop M. Application of lightweight formal methods to software security. In: 14th IEEE International Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprise (WETICE'05): 2005. p. 160-5.; citation_title=A first step in the translation of alloy to coq; citation_inbook_title=Formal Methods and Software Engineering; citation_publication_date=2019; citation_id=CR60; citation_author=S Souaf; citation_author=F Loulergue; citation_publisher=Springer; Schlingloff H, Kruse PM, Saadatmand M. Excellence in variant testing. In: Proceedings of the 14th International Working Conference on Variability Modelling of Software-Intensive Systems: 2020. p. 1-2."			Excluded	Excluded	new_screen			2	Springer Link		Towards a Verification-Driven Iterative Development of Software for Safety-Critical Cyber-Physical Systems	http://link.springer.com/article/10.1186/s13174-021-00132-z	Springer Link	nan; Pages; Year; Bibtex
570	Behave	Towards an Executable Methodology for the Formalization of Legal Texts	A methodology for the formalization of legal texts is presented. This methodology is based on features of the NAI Suite, a recently developed formalization environment for legal texts. The ability of the tool to execute queries is used in order to drive a correct formalization until all queries are validated. The approach is studied on a fragment of the Smoking Prohibition (Children in Motor Vehicles) (Scotland) Act 2016 of the Scottish Parliament.	Legal reasoning; Deontic logic; Automated reasoning	Libal, Tomer; Steen, Alexander	International Conference on Logic and Argumentation	https://doi.org/10.1007/978-3-030-44638-3_10		151--165	"""@InProceedings{10.1007/978-3-030-44638-3_10,
    author = ""Libal, Tomer and Steen, Alexander"",
    editor = ""Dastani, Mehdi and Dong, Huimin and van der Torre, Leon"",
    title = ""Towards an Executable Methodology for the Formalization of Legal Texts"",
    booktitle = ""Logic and Argumentation"",
    year = ""2020"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""151--165"",
    abstract = ""A methodology for the formalization of legal texts is presented. This methodology is based on features of the NAI Suite, a recently developed formalization environment for legal texts. The ability of the tool to execute queries is used in order to drive a correct formalization until all queries are validated. The approach is studied on a fragment of the Smoking Prohibition (Children in Motor Vehicles) (Scotland) Act 2016 of the Scottish Parliament."",
    isbn = ""978-3-030-44638-3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Towards an Executable Methodology for the Formalization of Legal Texts	http://link.springer.com/chapter/10.1007/978-3-030-44638-3_10	Springer International Publishing	nan; References
571	Behave	Towards Automated UI-Tests for Sensor-Based Mobile Applications	Mobile devices changed human-computer interaction, caused the need for specialized software engineering methods and created new business opportunities. The mobile app market is highly competitive and software developers need to maintain high software quality standards for long-lasting economic success. While powerful software development kits support developers in creating mobile applications, testing them is still cumbersome, time-consuming and error-prone. Especially interaction methods depending on sensor input like device motion gestures prevent automated UI testing -- developers and testers are forced to manually test all different aspects. We present an approach to integrate sensor information into user acceptance tests and use a sensor simulation engine to enable automatic test case execution for mobile applications.		Griebe, Tobias; Hesenius, Marc; Gruhn, Volker	International Conference on Intelligent Software Methodologies, Tools, and Techniques	https://doi.org/10.1007/978-3-319-22689-7_1		3--17	"""@InProceedings{10.1007/978-3-319-22689-7_1,
    author = ""Griebe, Tobias and Hesenius, Marc and Gruhn, Volker"",
    editor = ""Fujita, Hamido and Guizzi, Guido"",
    title = ""Towards Automated UI-Tests for Sensor-Based Mobile Applications"",
    booktitle = ""Intelligent Software Methodologies, Tools and Techniques"",
    year = ""2015"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""3--17"",
    abstract = ""Mobile devices changed human-computer interaction, caused the need for specialized software engineering methods and created new business opportunities. The mobile app market is highly competitive and software developers need to maintain high software quality standards for long-lasting economic success. While powerful software development kits support developers in creating mobile applications, testing them is still cumbersome, time-consuming and error-prone. Especially interaction methods depending on sensor input like device motion gestures prevent automated UI testing -- developers and testers are forced to manually test all different aspects. We present an approach to integrate sensor information into user acceptance tests and use a sensor simulation engine to enable automatic test case execution for mobile applications."",
    isbn = ""978-3-319-22689-7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Towards Automated UI-Tests for Sensor-Based Mobile Applications	http://link.springer.com/chapter/10.1007/978-3-319-22689-7_1	Springer International Publishing	nan; Keywords; References
572	Behave	Towards Establishing Mass Customization Methods for Cloud-Compliant Services	This paper proposes a chain of service models assembled by design, implementation and operation data. To obtain both economy of scale and economy of scope, appropriate chains are required for producing cloud-compliant services. By specifying a target domain and distributing models' attributes into commonality or variability, a chain, which consists of necessary and sufficient models with utmost customizable interfaces, can be determined decisively. A field trial elicits representative chains of models, and shows that the chains, i.e. lifecycle patterns, can be used as templates to develop new services on mass customization basis and tailored to meet clients' varied demands.	Mass Customization; Application Lifecycle Management; Product Line Engineering; Service Factory	Hosono, Shigeru; Shimomura, Yoshiki	The Philosopher's Stone for Sustainability	https://doi.org/10.1007/978-3-642-32847-3_75		447--452	"""@InProceedings{10.1007/978-3-642-32847-3_75,
    author = ""Hosono, Shigeru and Shimomura, Yoshiki"",
    editor = ""Shimomura, Yoshiki and Kimita, Koji"",
    title = ""Towards Establishing Mass Customization Methods for Cloud-Compliant Services"",
    booktitle = ""The Philosopher's Stone for Sustainability"",
    year = ""2013"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""447--452"",
    abstract = ""This paper proposes a chain of service models assembled by design, implementation and operation data. To obtain both economy of scale and economy of scope, appropriate chains are required for producing cloud-compliant services. By specifying a target domain and distributing models' attributes into commonality or variability, a chain, which consists of necessary and sufficient models with utmost customizable interfaces, can be determined decisively. A field trial elicits representative chains of models, and shows that the chains, i.e. lifecycle patterns, can be used as templates to develop new services on mass customization basis and tailored to meet clients' varied demands."",
    isbn = ""978-3-642-32847-3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Towards Establishing Mass Customization Methods for Cloud-Compliant Services	http://link.springer.com/chapter/10.1007/978-3-642-32847-3_75	Springer Berlin Heidelberg	nan; References
573	Behave	Towards More Flexible Enterprise Information Systems	The aim of this paper is to present the software development techniques used to build the EIS Patterns development framework, which is a testbed for a series of techniques that aim at giving more flexibility to EIS in general. Some of these techniques are customizations or extensions of practices created by the agile software development movement, while others represent new proposals. This paper also aims at helping promoting more discussion around the EIS development questions, since most of research papers in EIS area focus on deployment, IT, or business related issues, leaving the discussion on development techniques ill-treated.	Enterprise Information Systems; Domain Specific Languages; Design Patterns; Statechart Diagrams; Natural Language Processing	"de Carvalho, Rogerio Atem; Johansson, Bj{\""o}rn"	Enterprise Information Systems of the Future	https://doi.org/10.1007/978-3-642-36611-6_12		157--164	"""@InProceedings{10.1007/978-3-642-36611-6_12,
    author = {de Carvalho, Rogerio Atem and Johansson, Bj{\""o}rn},
    editor = ""Poels, Geert"",
    title = ""Towards More Flexible Enterprise Information Systems"",
    booktitle = ""Enterprise Information Systems of the Future"",
    year = ""2013"",
    publisher = ""Springer Berlin Heidelberg"",
    address = ""Berlin, Heidelberg"",
    pages = ""157--164"",
    abstract = ""The aim of this paper is to present the software development techniques used to build the EIS Patterns development framework, which is a testbed for a series of techniques that aim at giving more flexibility to EIS in general. Some of these techniques are customizations or extensions of practices created by the agile software development movement, while others represent new proposals. This paper also aims at helping promoting more discussion around the EIS development questions, since most of research papers in EIS area focus on deployment, IT, or business related issues, leaving the discussion on development techniques ill-treated."",
    isbn = ""978-3-642-36611-6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Towards More Flexible Enterprise Information Systems	http://link.springer.com/chapter/10.1007/978-3-642-36611-6_12	Springer Berlin Heidelberg	nan; References
574	Behave	Towards Transparent Legal Formalization	A key challenge in making a transparent formalization of a legal text is the dependency on two domain experts. While a legal expert is needed in order to interpret the legal text, a logician or a programmer is needed for encoding it into a program or a formula. Various existing methods are trying to solve this challenge by improving or automating the communication between the two experts. In this paper, we follow a different direction and attempt to eliminate the dependency on the target domain expert. This is achieved by inverting the translation back into the original text. By skipping over the logical translation, a legal expert can now both interpret and evaluate a translation.	Legal knowledge base; Annotation editor; Formal representation	Libal, Tomer; Novotn{\'a}, Tereza	International Workshop on Explainable, Transparent Autonomous Agents and Multi-Agent Systems	https://doi.org/10.1007/978-3-030-82017-6_18		296--313	"""@InProceedings{10.1007/978-3-030-82017-6_18,
    author = ""Libal, Tomer and Novotn{\'a}, Tereza"",
    editor = {Calvaresi, Davide and Najjar, Amro and Winikoff, Michael and Fr{\""a}mling, Kary},
    title = ""Towards Transparent Legal Formalization"",
    booktitle = ""Explainable and Transparent AI and Multi-Agent Systems"",
    year = ""2021"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""296--313"",
    abstract = ""A key challenge in making a transparent formalization of a legal text is the dependency on two domain experts. While a legal expert is needed in order to interpret the legal text, a logician or a programmer is needed for encoding it into a program or a formula. Various existing methods are trying to solve this challenge by improving or automating the communication between the two experts. In this paper, we follow a different direction and attempt to eliminate the dependency on the target domain expert. This is achieved by inverting the translation back into the original text. By skipping over the logical translation, a legal expert can now both interpret and evaluate a translation."",
    isbn = ""978-3-030-82017-6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Towards Transparent Legal Formalization	http://link.springer.com/chapter/10.1007/978-3-030-82017-6_18	Springer International Publishing	nan; References
575	Behave	Towards User-Friendly Projectional Editors	Today's challenges for language development include language extension and composition, as well as the use of diverse notations. A promising approach is projectional editing, a technique to directly manipulate the abstract syntax tree of a program, without relying on parsers. Its potential lies in the ability to combine diverse notational styles -- such as text, symbols, tables, and graphics -- and the support for a wide range of composition techniques. However, projectional editing is often perceived as problematic for developers. Expressed drawbacks include the unfamiliar editing experience and challenges in the integration with existing infrastructure. In this paper we investigate the usability of projectional editors. We systematically identify usability issues resulting from the architecture. We use JetBrains Meta Programming System (MPS) as a case study. The case study discusses the concepts that MPS incorporates to address the identified issues, evaluates effectiveness of these concepts by surveying professional developers, and reports industrial experiences from realizing large-scale systems. Our results show that the benefits of flexible language composition and diverse notations come at the cost of serious usability issues -- which, however, can be effectively mitigated with facilities that emulate editing experience of parser-based editors.		Voelter, Markus; Siegmund, Janet; Berger, Thorsten; Kolb, Bernd	International Conference on Software Language Engineering	https://doi.org/10.1007/978-3-319-11245-9_3		41--61	"""@InProceedings{10.1007/978-3-319-11245-9_3,
    author = ""Voelter, Markus and Siegmund, Janet and Berger, Thorsten and Kolb, Bernd"",
    editor = ""Combemale, Beno{\^i}t and Pearce, David J. and Barais, Olivier and Vinju, Jurgen J."",
    title = ""Towards User-Friendly Projectional Editors"",
    booktitle = ""Software Language Engineering"",
    year = ""2014"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""41--61"",
    abstract = ""Today's challenges for language development include language extension and composition, as well as the use of diverse notations. A promising approach is projectional editing, a technique to directly manipulate the abstract syntax tree of a program, without relying on parsers. Its potential lies in the ability to combine diverse notational styles -- such as text, symbols, tables, and graphics -- and the support for a wide range of composition techniques. However, projectional editing is often perceived as problematic for developers. Expressed drawbacks include the unfamiliar editing experience and challenges in the integration with existing infrastructure. In this paper we investigate the usability of projectional editors. We systematically identify usability issues resulting from the architecture. We use JetBrains Meta Programming System (MPS) as a case study. The case study discusses the concepts that MPS incorporates to address the identified issues, evaluates effectiveness of these concepts by surveying professional developers, and reports industrial experiences from realizing large-scale systems. Our results show that the benefits of flexible language composition and diverse notations come at the cost of serious usability issues -- which, however, can be effectively mitigated with facilities that emulate editing experience of parser-based editors."",
    isbn = ""978-3-319-11245-9""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Towards User-Friendly Projectional Editors	http://link.springer.com/chapter/10.1007/978-3-319-11245-9_3	Springer International Publishing	nan; Keywords; References
576	Behave	Transitioning Towards Continuous Experimentation in a Large Software Product and Service Development Organisation -- A Case Study	Context: Companies need capabilities to evaluate the customer value of software-intensive products and services. One way of systematically acquiring data on customer value is running continuous experiments as part of the overall development process. Objective: This paper investigates the first steps of transitioning towards continuous experimentation in a large company, including the challenges faced. Method: We conduct a single-case study using participant observation, interviews, and qualitative analysis of the collected data. Results: Results show that continuous experimentation was well received by the practitioners and practising experimentation helped them to enhance understanding of their product value and user needs. Although the complexities of a large multi-stakeholder business-to-business (B2B) environment presented several challenges such as inaccessible users, it was possible to address impediments and integrate an experiment in an ongoing development project. Conclusion: Developing the capability for continuous experimentation in large organisations is a learning process which can be supported by a systematic introduction approach with the guidance of experts. We gained experience by introducing the approach on a small scale in a large organisation, and one of the major steps for future work is to understand how this can be scaled up to the whole development organisation.	Continuous experimentation; Experiment-driven software development; Product management; Lean startup; Customer development; Customer involvement; Organisational transition; Agile software development; Case study	"Yaman, Sezin Gizem; Fagerholm, Fabian; Munezero, Myriam; M{\""u}nch, J{\""u}rgen; Aaltola, Mika; Palmu, Christina; M{\""a}nnist{\""o}, Tomi"	International Conference on Product-Focused Software Process Improvement	https://doi.org/10.1007/978-3-319-49094-6_22		344--359	"""@InProceedings{10.1007/978-3-319-49094-6_22,
    author = {Yaman, Sezin Gizem and Fagerholm, Fabian and Munezero, Myriam and M{\""u}nch, J{\""u}rgen and Aaltola, Mika and Palmu, Christina and M{\""a}nnist{\""o}, Tomi},
    editor = ""Abrahamsson, Pekka and Jedlitschka, Andreas and Nguyen Duc, Anh and Felderer, Michael and Amasaki, Sousuke and Mikkonen, Tommi"",
    title = ""Transitioning Towards Continuous Experimentation in a Large Software Product and Service Development Organisation -- A Case Study"",
    booktitle = ""Product-Focused Software Process Improvement"",
    year = ""2016"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""344--359"",
    abstract = ""Context: Companies need capabilities to evaluate the customer value of software-intensive products and services. One way of systematically acquiring data on customer value is running continuous experiments as part of the overall development process. Objective: This paper investigates the first steps of transitioning towards continuous experimentation in a large company, including the challenges faced. Method: We conduct a single-case study using participant observation, interviews, and qualitative analysis of the collected data. Results: Results show that continuous experimentation was well received by the practitioners and practising experimentation helped them to enhance understanding of their product value and user needs. Although the complexities of a large multi-stakeholder business-to-business (B2B) environment presented several challenges such as inaccessible users, it was possible to address impediments and integrate an experiment in an ongoing development project. Conclusion: Developing the capability for continuous experimentation in large organisations is a learning process which can be supported by a systematic introduction approach with the guidance of experts. We gained experience by introducing the approach on a small scale in a large organisation, and one of the major steps for future work is to understand how this can be scaled up to the whole development organisation."",
    isbn = ""978-3-319-49094-6""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Transitioning Towards Continuous Experimentation in a Large Software Product and Service Development Organisation – A Case Study	http://link.springer.com/chapter/10.1007/978-3-319-49094-6_22	Springer International Publishing	nan; References
577	Behave	TSTL: the template scripting testing language	A test harness, in automated test generation, defines the set of valid tests for a system, as well as their correctness properties. The difficulty of writing test harnesses is a major obstacle to the adoption of automated test generation and model checking. Languages for writing test harnesses are usually tied to a particular tool and unfamiliar to programmers, and often limit expressiveness. Writing test harnesses directly in the language of the software under test (SUT) is a tedious, repetitive, and error-prone task, offers little or no support for test case manipulation and debugging, and produces hard-to-read, hard-to-maintain code. Using existing harness languages or writing directly in the language of the SUT also tends to limit users to one algorithm for test generation, with little ability to explore alternative methods. In this paper, we present TSTL, the template scripting testing language, a domain-specific language (DSL) for writing test harnesses. TSTL compiles harness definitions into an interface for testing, making generic test generation and manipulation tools for all SUTs possible. TSTL includes tools for generating, manipulating, and analyzing test cases, including simple model checkers. This paper motivates TSTL via a large-scale testing effort, directed by an end-user, to find faults in the most widely used geographic information systems tool. This paper emphasizes a new approach to automated testing, where, rather than focus on developing a monolithic tool to extend, the aim is to convert a test harness into a language extension. This approach makes testing not a separate activity to be performed using a tool, but as natural to users of the language of the system under test as is the use of domain-specific libraries such as ArcPy, NumPy, or QIIME, in their domains. TSTL is a language and tool infrastructure, but is also a way to bring testing activities under the control of an existing programming language in a simple, natural way.	Artificial Intelligence; Software testing; Domain-specific languages; Explicit-state model checking; End-user testing; Geographic information systems	Josie Holmes; Alex Groce; Jervis Pinto; Pranjal Mittal; Pooria Azimi; Kevin Kellar; James O'Brien	International Journal on Software Tools for Technology Transfer	https://doi.org/10.1007/s10009-016-0445-y	"Groce, A., Erwig, M.: Finding common ground: choose, assert, and assume. In: Workshop on Dynamic Analysis, pp. 12-17 (2012); Groce, A., Joshi, R.: Random testing and model checking: building a common framework for nondeterministic exploration. In: Workshop on Dynamic Analysis, pp. 22-28 (2008); Gamma, E., Beck, K.: JUnit. 
                    http://junit.sourceforce.net
                    
                  . Accessed 1 Dec 2016; citation_journal_title=Ann. Math. Artif. Intell.; citation_title=Establishing flight software reliability: testing, model checking, constraint-solving, monitoring and learning; citation_author=A Groce, K Havelund, G Holzmann, R Joshi, RG Xu; citation_volume=70; citation_issue=4; citation_publication_date=2014; citation_pages=315-349; citation_doi=10.1007/s10472-014-9408-8; citation_id=CR4; Groce, A., Holzmann, G., Joshi, R.: Randomized differential testing as a prelude to formal verification. In: International Conference on Software Engineering, pp. 621-631 (2007); Cadar, C., Dunbar, D., Engler, D.: KLEE: Unassisted and automatic generation of high-coverage tests for complex systems programs. In: Operating System Design and Implementation, pp. 209-224 (2008); JPF: the Swiss army knife of Java(TM) verification. 
                    http://babelfish.arc.nasa.gov/trac/jpf
                    
                  . Accessed 1 Dec 2016; citation_journal_title=Autom. Softw. Eng.; citation_title=Model checking programs; citation_author=W Visser, K Havelund, G Brat, S Park, F Lerda; citation_volume=10; citation_issue=2; citation_publication_date=2003; citation_pages=203-232; citation_doi=10.1023/A:1022920129859; citation_id=CR8; Kroening, D.: The CBMC homepage. 
                    http://www.cs.cmu.edu/modelcheck/cbmc/
                    
                  . Accessed 1 Dec 2016; Kroening, D., Clarke, E.M., Lerda, F.: A tool for checking ANSI-C programs. In: Tools and Algorithms for the Construction and Analysis of Systems, pp. 168-176 (2004); Visser, W., Pasareanu, C., Pelanek, R.: Test input generation for Java containers using state matching. In: International Symposium on Software Testing and Analysis, pp. 37-48 (2006); Esri: What is ArcPy? 
                    http://resources.arcgis.com/EN/HELP/MAIN/10.1/index.html000v000000v7000000
                    
                  . Accessed 1 Dec 2016; Groce, A., Fern, A., Pinto, J., Bauer, T., Alipour, A., Erwig, M., Lopez, C.: Lightweight automated testing with adaptation-based programming. In: IEEE International Symposium on Software Reliability Engineering, pp. 161-170 (2012); Fraser, G., Arcuri, A.: EvoSuite: automatic test suite generation for object-oriented software. In: ACM SIGSOFT Symposium/European Conference on Foundations of Software Engineering, pp. 416-419 (2011); Pacheco, C., Lahiri, S.K., Ernst, M.D., Ball, T.: Feedback-directed random test generation. In: International Conference on Software Engineering, pp. 75-84 (2007); Groce, A., Pinto, J., Azimi, P., Mittal, P., Holmes, J., Kellar, K.: TSTL: the template scripting testing language. 
                    https://github.com/agroce/tstl
                    
                  . Accessed 1 Dec 2016; Groce, A., Pinto, J.: A little language for testing. In: NASA Formal Methods Symposium, pp. 204-218 (2015); Groce, A., Pinto, J., Azimi, P., Mittal, P.: TSTL: a language and tool for testing (demo). In: ACM International Symposium on Software Testing and Analysis, pp. 414-417 (2015); NumPy. 
                    https://www.numpy.org
                    
                  . Accessed 1 Dec 2016; SciPy. 
                    https://www.scipy.org
                    
                  . Accessed 1 Dec 2016; citation_journal_title=Nat. Methods; citation_title=QIIME allows analysis of high-throughput community sequencing data; citation_author=JG Caporaso, J Kuczynski, J Stombaugh, K Bittinger, FD Bushman, EK Costello, N Fierer, AG Pena, JK Goodrich, JI Gordon; citation_volume=7; citation_issue=5; citation_publication_date=2010; citation_pages=335-336; citation_doi=10.1038/nmeth.f.303; citation_id=CR21; Biopython. 
                    http://biopython.org/wiki/Biopython
                    
                  . Accessed 1 Dec 2016; scikit-bio. 
                    http://scikit-bio.org/
                    
                  . Accessed 1 Dec 2016; Groce, A., Fern, A., Erwig, M., Pinto, J., Bauer, T., Alipour, A.: Learning-based test programming for programmers. In: International Symposium on Leveraging Applications of Formal Methods, Verification and Validation, pp. 752-786 (2012); citation_title=Domain-Specific Languages; citation_publication_date=2010; citation_id=CR25; citation_author=M Fowler; citation_publisher=Addison-Wesley Professional; citation_journal_title=Commun. ACM; citation_title=Programming pearls: little languages; citation_author=J Bentley; citation_volume=29; citation_issue=8; citation_publication_date=1986; citation_pages=711-721; citation_doi=10.1145/6424.315691; citation_id=CR26; Gligoric, M., Gvero, T., Jagannath, V., Khurshid, S., Kuncak, V., Marinov, D.: Test generation through programming in UDITA. In: International Conference on Software Engineering, pp. 225-234 (2010); citation_title=The SPIN Model Checker: Primer and Reference Manual; citation_publication_date=2003; citation_id=CR28; citation_author=GJ Holzmann; citation_publisher=Addison-Wesley Professional; Holzmann, G., Joshi, R.: Model-driven software verification. In: SPIN Workshop on Model Checking of Software, pp. 76-91 (2004); citation_journal_title=Autom. Softw. Eng.; citation_title=Model driven code checking; citation_author=G Holzmann, R Joshi, A Groce; citation_volume=15; citation_issue=3-4; citation_publication_date=2008; citation_pages=283-297; citation_doi=10.1007/s10515-008-0033-9; citation_id=CR30; Groce, A., Havelund, K., Smith, M.: From scripts to specifications: the evolution of a flight software testing effort. In: International Conference on Software Engineering, pp. 129-138 (2010); citation_journal_title=Softw. Test. Verif. Reliab.; citation_title=A taxonomy of model-based testing approaches; citation_author=M Utting, A Pretschner, B Legeard; citation_volume=22; citation_issue=5; citation_publication_date=2012; citation_pages=297-312; citation_doi=10.1002/stvr.456; citation_id=CR32; Kellar, K.: Tstl-java. 
                    https://github.com/flipturnapps/TSTL-Java
                    
                  . Accessed 1 Dec 2016; citation_journal_title=Softw. Eng. IEEE Trans.; citation_title=Simplifying and isolating failure-inducing input; citation_author=A Zeller, R Hildebrandt; citation_volume=28; citation_issue=2; citation_publication_date=2002; citation_pages=183-200; citation_doi=10.1109/32.988498; citation_id=CR34; citation_journal_title=Softw. Pract. Exp.; citation_title=JCrasher: an automatic robustness tester for Java; citation_author=C Csallner, Y Smaragdakis; citation_volume=34; citation_issue=11; citation_publication_date=2004; citation_pages=1025-1050; citation_doi=10.1002/spe.602; citation_id=CR35; Claessen, K., Hughes, J.: QuickCheck: a lightweight tool for random testing of haskell programs. In: ICFP, pp. 268-279 (2000); MacIver, D.R.: Hypothesis: Test faster, fix more. 
                    http://hypothesis.works/
                    
                  . Accessed 1 Dec 2016; citation_journal_title=Digit. Tech. J. Dig. Equip. Corp.; citation_title=Differential testing for software; citation_author=W McKeeman; citation_volume=10; citation_issue=1; citation_publication_date=1998; citation_pages=100-107; citation_id=CR38; citation_journal_title=Commun. ACM; citation_title=End-user software engineering.; citation_author=M Burnett, C Cook, G Rothermel; citation_volume=47; citation_issue=9; citation_publication_date=2004; citation_pages=53-58; citation_doi=10.1145/1015864.1015889; citation_id=CR39; Burnett, M.M., Myers, B.A.: Future of end-user software engineering: beyond the silos. In: Future of Software Engineering, pp. 201-211 (2014); citation_journal_title=ACM Trans. Softw. Eng. Method.; citation_title=A methodology for testing spreadsheets; citation_author=G Rothermel, M Burnett, L Li, C DuPois, A Sheretov; citation_volume=10; citation_issue=1; citation_publication_date=2001; citation_pages=110-147; citation_doi=10.1145/366378.366385; citation_id=CR41; citation_journal_title=IEEE Trans. Softw. Eng.; citation_title=You are the only possible oracle: effective test selection for end users of interactive machine learning systems; citation_author=A Groce, T Kulesza, C Zhang, S Shamasunder, MM Burnett, W Wong, S Stumpf, S Das, A Shinsel, F Bice, K McIntosh; citation_volume=40; citation_issue=3; citation_publication_date=2014; citation_pages=307-323; citation_doi=10.1109/TSE.2013.59; citation_id=CR42; Groce, A., Holzmann, G., Joshi, R., Xu, R.G.: Putting flight software through the paces with testing, model checking, and constraint-solving. In: Workshop on Constraints in Formal Verification, pp. 1-15 (2008); Andrews, J., Zhang, Y.R., Groce, A.: Comparing automated unit testing strategies. Technical report 736, Department of Computer Science, University of Western Ontario (2010); citation_title=A Discipline of Programming; citation_publication_date=1976; citation_id=CR45; citation_author=EW Dijkstra; citation_publisher=Prentice-Hall; citation_journal_title=J. ACM; citation_title=Nondeterministic algorithms; citation_author=RW Floyd; citation_volume=14; citation_issue=4; citation_publication_date=1967; citation_pages=636-644; citation_doi=10.1145/321420.321422; citation_id=CR46; McCarthy, J.: A basis for a mathematical theory of computation, preliminary report. In: Papers Presented at the May 9-11, 1961, Western Joint IRE-AIEE-ACM Computer Conference, IRE-AIEE-ACM '61 (Western), pp. 225-238. ACM, New York, NY, USA (1961). doi:
                    10.1145/1460690.1460715; Batchelder, N.: Coverage.py. 
                    https://coverage.readthedocs.org/en/coverage-4.0.1/
                    
                  . Accessed 1 Dec 2016; Groce, A., Zhang, C., Eide, E., Chen, Y., Regehr, J.: Swarm testing. In: International Symposium on Software Testing and Analysis, pp. 78-88 (2012); Gligoric, M., Groce, A., Zhang, C., Sharma, R., Alipour, A., Marinov, D.: Comparing non-adequate test suites using coverage criteria. In: International Symposium on Software Testing and Analysis, pp. 302-313 (2013); Le, V., Afshari, M., Su, Z.: Compiler validation via equivalence modulo inputs. In: ACM SIGPLAN Conference on Programming Language Design and Implementation, pp. 216-226 (2014); Hamlet, R.: Random testing. In: Encyclopedia of Software Engineering, pp. 970-978. Wiley (1994); citation_title=Model Checking; citation_publication_date=2000; citation_id=CR53; citation_author=EM Clarke; citation_author=O Grumberg; citation_author=D Peled; citation_publisher=MIT Press; citation_journal_title=Int. J. Softw. Tools Technol. Transf.; citation_title=Directed explicit-state model checking in the validation of communication protocols; citation_author=S Edelkamp, S Leue, A Lluch-Lafuente; citation_volume=5; citation_issue=2; citation_publication_date=2004; citation_pages=247-267; citation_doi=10.1007/s10009-002-0104-3; citation_id=CR54; Groce, A., Visser, W.: Model checking Java programs using structural heuristics. In: International Symposium on Software Testing and Analysis, pp. 12-21 (2002); Courcoubetis, C., Vardi, M.Y., Wolper, P., Yannakakis, M.: Memory efficient algorithms for the verification of temporal properties. In: Proceedings of the 2nd International Workshop on Computer Aided Verification, CAV '90, pp. 233-242. Springer-Verlag, London, UK. 
                    http://dl.acm.org/citation.cfm?id=647759.735018
                    
                  . Accessed 1 Dec 2016 (1991); Groce, A., Alipour, M.A., Zhang, C., Chen, Y., Regehr, J.: Cause reduction for quick testing. In: 2014 IEEE Seventh International Conference on Software Testing, Verification and Validation (ICST), pp. 243-252. IEEE (2014); citation_journal_title=J. Softw. Test. Verif. Reliab.; citation_title=Cause reduction: Delta-debugging, even without bugs; citation_author=A Groce, MA Alipour, C Zhang, Y Chen, J Regehr; citation_volume=26; citation_issue=1; citation_publication_date=2016; citation_pages=40-68; citation_doi=10.1002/stvr.1574; citation_id=CR58; citation_journal_title=Softw. Eng.; citation_title=Test case prioritization. Trans; citation_author=G Rothermel, R Untch, C Chu, MJ Harrold; citation_volume=27; citation_publication_date=2001; citation_pages=929-948; citation_doi=10.1109/32.962562; citation_id=CR59; Rothermel, G., Untch, R.H., Chu, C., Harrold, M.J.: Test case prioritization: an empirical study. In: Proceedings of the IEEE International Conference on Software Maintenance, ICSM '99, pp. 179-188. IEEE Computer Society, Washington, DC, USA (1999). 
                    http://dl.acm.org/citation.cfm?id=519621.853398
                    
                  . Accessed 1 Dec 2016; Zhang, C., Groce, A., Alipour, M.A.: Using test case reduction and prioritization to improve symbolic execution. In: International Symposium on Software Testing and Analysis, pp. 160-170 (2014); Foundation, F.S.: GMP: The Gnu multiple precision arithmetic library. 
                    https://gmplib.org/
                    
                  . Accessed 1 Dec 2016; Groce, A.: Left shift of zero allocates memory. 
                    http://bugs.python.org/issue27870
                    
                  . Accessed 1 Dec 2016; Groce, A.: Raising zero to a large power mismatch with Python long. 
                    https://github.com/aleaxit/gmpy/issues/114
                    
                  . Accessed 1 Dec 2016; SymPy Development Team: SymPy. 
                    http://www.sympy.org/en/index.html
                    
                  . Accessed 1 Dec 2016; Klockner, A.: PyOpenCL. 
                    https://mathema.tician.de/software/pyopencl/
                    
                  . Accessed 1 Dec 2016; Khronos Group: The open standard for parallel programming of heterogenous systems. 
                    https://www.khronos.org/opencl/
                    
                  . Accessed 1 Dec 2016; Gonzalez, J.: FuzzyWuzzy. 
                    https://pypi.python.org/pypi/fuzzywuzzy
                    
                  . Accessed 1 Dec 2016; AstroPy: a community Python library for astronomy. 
                    http://www.astropy.org/
                    
                  . Accessed 1 Dec 2016; Godefroid, P., Klarlund, N., Sen, K.: DART: directed automated random testing. In: Programming Language Design and Implementation, pp. 213-223 (2005); Andrews, J.H., Groce, A., Weston, M., Xu, R.G.: Random test run length and effectiveness. In: Automated Software Engineering, pp. 19-28 (2008); Andrews, J.H., Haldar, S., Lei, Y., Li, C.H.F.: Tool support for randomized unit testing. In: Proceedings of the First International Workshop on Randomized Testing, Portland, Maine, pp. 36-45 (2006); citation_journal_title=IEEE Trans. Softw. Eng. (TSE); citation_title=Genetic algorithms for randomized unit testing; citation_author=JH Andrews, T Menzies, FC Li; citation_volume=37; citation_issue=1; citation_publication_date=2011; citation_pages=80-94; citation_doi=10.1109/TSE.2010.46; citation_id=CR73; Arcuri, A., Briand, L.: Adaptive random testing: An illusion of effectiveness. In: International Symposium on Software Testing and Analysis, pp. 265-275 (2011); Arcuri, A., Iqbal, M.Z.Z., Briand, L.C.: Formal analysis of the effectiveness and predictability of random testing. In: International Symposium on Software Testing and Analysis, pp. 219-230 (2010); Chen, T.Y., Leung, H., Mak, I.K.: Adaptive random testing. In: Advances in Computer Science, pp. 320-329 (2004); Ciupa, I., Leitner, A., Oriol, M., Meyer, B.: Experimental assessment of random testing for object-oriented software. In: Rosenblum, D.S., Elbaum, S.G. (eds.) International Symposium on Software Testing and Analysis, pp. 84-94. ACM (2007); citation_journal_title=IEEE Trans. Softw. Eng.; citation_title=Evaluation of random testing; citation_author=JW Duran, SC Ntafos; citation_volume=10; citation_issue=4; citation_publication_date=1984; citation_pages=438-444; citation_doi=10.1109/TSE.1984.5010257; citation_id=CR78; Hamlet, R.: When only random testing will do. In: International Workshop on Random Testing, pp. 1-9 (2006); Sharma, R., Gligoric, M., Arcuri, A., Fraser, G., Marinov, D.: Testing container classes: Random or systematic? In: Fundamental Approaches to Software Engineering, pp. 262-277 (2011); citation_journal_title=J. Syst. Softw.; citation_title=An orchestrated survey of methodologies for automated software test case generation; citation_author=S Anand, EK Burke, TY Chen, J Clark, MB Cohen, W Grieskamp, M Harman, MJ Harrold, P McMinn; citation_volume=86; citation_issue=8; citation_publication_date=2013; citation_pages=1978-2001; citation_doi=10.1016/j.jss.2013.02.061; citation_id=CR81; Orso, A., Rothermel, G.: Software testing: A research travelogue (2000-2014). In: Proceedings of the on Future of Software Engineering, FOSE, pp. 117-132 (2014); Nilsson, R.: ScalaCheck: property-based testing for Scala. 
                    https://www.scalacheck.org
                    
                  . Accessed 1 Dec 2016; Milicevic, A., Misailovic, S., Marinov, D., Khurshid, S.: Korat: A tool for generating structurally complex test inputs. In: International Conference on Software Engineering, pp. 771-774 (2007); Giannakopoulou, D., Howar, F., Isberner, M., Lauderdale, T., Rakamaric, Z., Raman, V.: Taming test inputs for separation assurance. In: International Conference on Automated Software Engineering, pp. 373-384 (2014); Felderer, M., Zech, P., Fiedler, F., Breu, R.: A tool-based methodology for system testing of service-oriented systems. In: 2010 Second International Conference on Advances in System Testing and Validation Lifecycle (VALID), pp. 108-113 (2010). doi:
                    10.1109/VALID.2010.12; Santiago, D., Cando, A., Mack, C., Nunez, G., Thomas, T., King, T.M.: Towards domain-specific testing languages for software-as-a-service. In: Proceedings of the 2nd International Workshop on Model-Driven Engineering for High Performance and Cloud computing co-located with 16th International Conference on Model Driven Engineering Languages and Systems (MODELS), pp. 43-52 (2013); Im, K., Im, T., McGregor, J.D.: Automating test case definition using a domain specific language. In: Proceedings of the 46th Annual Southeast Regional Conference on XX, ACM-SE, vol. 46, pp. 180-185. ACM, New York, NY, USA (2008). doi:
                    10.1145/1593105.1593152; Chelimsky, D., Astels, D., Helmkamp, B., North, D., Dennis, Z., Hellesoy, A.: The RSpec Book: Behaviour Driven Development with Rspec, Cucumber, and Friends, 1st edn. Pragmatic Bookshelf, Raleigh, NC (2010); Lei, Y., Andrews, J.H.: Minimization of randomized unit test cases. In: International Symposium on Software Reliability Engineering, pp. 267-276 (2005); Pike, L.: SmartCheck: automatic and efficient counterexample reduction and generalization. In: ACM SIGPLAN Symposium on Haskell, pp. 53-64 (2014); Daka, E., Campos, J., Dorn, J., Fraser, G., Weimer, W.: Generating readable unit tests for Guava. In: Search-Based Software Engineering--7th International Symposium, SSBSE 2015, Bergamo, Italy, 5-7 September 2015, Proceedings, pp. 235-241 (2015); Daka, E., Campos, J., Fraser, G., Dorn, J., Weimer, W.: Modeling readability to improve unit tests. In: Foundations of Software Engineering, ESEC/FSE, pp. 107-118 (2015); Maogui, H., Jinfeng, W.: Application of automated testing tool in GIS modeling. In: World Congress on Software Engineering, pp. 184-188 (2009); AbSharma: Functional testing of GIS applications (automated testing). 
                    http://osgeo-org.1560.x6.nabble.com/Functional-Testing-of-GIS-applications-Automated-Testing-td4493673.html
                    
                  . Accessed 1 Dec 2016; XBOSOFT: GIS software testing--lessons learned. 
                    http://xbosoft.com/gis-software-testing-lessons-learned/
                    
                  . Accessed 1 Dec 2016; GRASS Development Team: Testing GRASS GIS source code and modules. 
                    https://grass.osgeo.org/grass71/manuals/libpython/gunittest_testing.html
                    
                  . Accessed 1 Dec 2016; Segal, J.: Some problems of professional end user developers. In: IEEE Symposium on Visual Languages and Human-Centric Computing (2007); Rothermel, K., Cook, C., Burnett, M., Schonfeld, J., Green, T., Rothermel, G.: WYSIWYT testing in the spreadsheet paradigm: an empirical evaluation. Int. Conf. Softw. Eng. 22, 230-240 (2000); Phalgune, A., Kissinger, C., Burnett, M., Cook, C., Beckwith, L., Ruthruff, J.: Garbage in, garbage out? an empirical look at oracle mistakes by end-user programmers. In: IEEE Symp. Visual Languages and Human-Centric Computing, pp. 45-52 (2005); Kulesza, T., Burnett, M., Stumpf, S., Wong, W.K., Das, S., Groce, A., Shinsel, A., Bice, F., McIntosh, K.: Where are my intelligent assistant's mistakes? a systematic testing approach. In: International Symposium on End-User Development, pp. 171-186 (2011); Shinsel, A., Kulesza, T., Burnett, M.M., Curan, W., Groce, A., Stumpf, S., Wong, W.K.: Mini-crowdsourcing end-user assessment of intelligent assistants: a cost-benefit study. In: Visual Languages and Human-Centric Computing, pp. 47-54 (2011)"			Excluded	Excluded	new_screen			2	Springer Link		TSTL: the template scripting testing language	http://link.springer.com/article/10.1007/s10009-016-0445-y	Springer Link	nan; Pages; Year; Bibtex
578	Behave	Understanding Core JUnit 5	In the first chapter, we learned the importance of test-driven development (TDD). We also discussed the pivotal role of unit testing. But before we move on to building an application using JUnit 5, it is important to understand its core concepts.		Gulati, Shekhar; Sharma, Rahul	Java Unit Testing with JUnit 5	https://doi.org/10.1007/978-1-4842-3015-2_2		25--44	"""@Inbook{Gulati2017,
    author = ""Gulati, Shekhar and Sharma, Rahul"",
    title = ""Understanding Core JUnit 5"",
    bookTitle = ""Java Unit Testing with JUnit 5: Test Driven Development with JUnit 5"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""25--44"",
    abstract = ""In the first chapter, we learned the importance of test-driven development (TDD). We also discussed the pivotal role of unit testing. But before we move on to building an application using JUnit 5, it is important to understand its core concepts."",
    isbn = ""978-1-4842-3015-2"",
    doi = ""10.1007/978-1-4842-3015-2\_2"",
    url = ""https://doi.org/10.1007/978-1-4842-3015-2\_2""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Understanding Core JUnit 5	http://link.springer.com/chapter/10.1007/978-1-4842-3015-2_2	Apress	nan; Keywords; References
579	Behave	Understanding Services with Reactive Programming	Services are an important building block of any application. Usually, services are the entry point to retrieving data from some kind of provider as well as to updating it, when this option is available.	Search Method; Service Class; Media Item; Duration Property; Player Property	Farhi, Oren	Reactive Programming with Angular and ngrx	https://doi.org/10.1007/978-1-4842-2620-9_5		73--98	"""@Inbook{Farhi2017,
    author = ""Farhi, Oren"",
    title = ""Understanding Services with Reactive Programming"",
    bookTitle = ""Reactive Programming with Angular and ngrx: Learn to Harness the Power of Reactive Programming with RxJS and ngrx Extensions"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""73--98"",
    abstract = ""Services are an important building block of any application. Usually, services are the entry point to retrieving data from some kind of provider as well as to updating it, when this option is available."",
    isbn = ""978-1-4842-2620-9"",
    doi = ""10.1007/978-1-4842-2620-9\_5"",
    url = ""https://doi.org/10.1007/978-1-4842-2620-9\_5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Understanding Services with Reactive Programming	http://link.springer.com/chapter/10.1007/978-1-4842-2620-9_5	Apress	nan; References
580	Behave	Unit Testing	As a discipline, software engineering encompasses many different skills, techniques, and methods. Dabbling with database administration, setting up development and production environments, designing user interfaces are all occasional tasks aside from the primary role of implementing solutions, which is writing code.	Unit Test; Visual Studio; Code Coverage; Customer Class; Private Address	Gary McLean Hall	Pro WPF and Silverlight MVVM	https://doi.org/10.1007/978-1-4302-3163-9_7		145–162		Excluded	Excluded	new_screen			2	Springer Link		Unit Testing	http://link.springer.com/chapter/10.1007/978-1-4302-3163-9_7	Apress, Berkeley, CA	nan; References; Year; Bibtex
581	Behave	Unit Testing and Integration Testing	It is very likely you have already written unit tests for your projects and thus are familiar with the concepts, frameworks, and steps involved in writing unit tests. This chapter therefore mainly deals with how to apply those skills to the effective writing of unit tests for your Web API. As you will see, unit testing is where you start, not where you finish.	Unit Test; Integration Test; Feature File; Controller Context; Public Class	Ugurlu, Tugberk; Zeitler, Alexander; Kheyrollahi, Ali	Pro ASP.NET Web API	https://doi.org/10.1007/978-1-4302-4726-5_15		431--462	"""@Inbook{Ugurlu2013,
    author = ""Ugurlu, Tugberk and Zeitler, Alexander and Kheyrollahi, Ali"",
    title = ""Unit Testing and Integration Testing"",
    bookTitle = ""Pro ASP.NET Web API: HTTP Web Services in ASP.NET"",
    year = ""2013"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""431--462"",
    abstract = ""It is very likely you have already written unit tests for your projects and thus are familiar with the concepts, frameworks, and steps involved in writing unit tests. This chapter therefore mainly deals with how to apply those skills to the effective writing of unit tests for your Web API. As you will see, unit testing is where you start, not where you finish."",
    isbn = ""978-1-4302-4726-5"",
    doi = ""10.1007/978-1-4302-4726-5\_15"",
    url = ""https://doi.org/10.1007/978-1-4302-4726-5\_15""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Unit Testing and Integration Testing	http://link.springer.com/chapter/10.1007/978-1-4302-4726-5_15	Apress	nan; References
582	Behave	Unit Tests and TDD	While both acceptance-test-driven development (ATDD) and test-driven development (TDD) are methodologies that advocate writing the tests before the code, ATDD (or BDD) is usually considered to lend itself better to bigger test scopes and to scenarios that describe how the users use the system, while TDD is considered to lend itself more specifically to unit tests, which uses the smallest test scope (of a single class or even a method), and therefore tests more technical details. For that reason, unit tests and TDD are considered practices that are done directly by the same developer that implements the code under test (CUT). While toward the end of this chapter we'll question the distinction between TDD and ATDD, we first need to understand more about unit tests and TDD in general.		Axelrod, Arnon	Complete Guide to Test Automation	https://doi.org/10.1007/978-1-4842-3832-5_17		395--424	"""@Inbook{Axelrod2018,
    author = ""Axelrod, Arnon"",
    title = ""Unit Tests and TDD"",
    bookTitle = ""Complete Guide to Test Automation: Techniques, Practices, and Patterns for Building and Maintaining Effective Software Projects"",
    year = ""2018"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""395--424"",
    abstract = ""While both acceptance-test-driven development (ATDD) and test-driven development (TDD) are methodologies that advocate writing the tests before the code, ATDD (or BDD) is usually considered to lend itself better to bigger test scopes and to scenarios that describe how the users use the system, while TDD is considered to lend itself more specifically to unit tests, which uses the smallest test scope (of a single class or even a method), and therefore tests more technical details. For that reason, unit tests and TDD are considered practices that are done directly by the same developer that implements the code under test (CUT). While toward the end of this chapter we'll question the distinction between TDD and ATDD, we first need to understand more about unit tests and TDD in general."",
    isbn = ""978-1-4842-3832-5"",
    doi = ""10.1007/978-1-4842-3832-5\_17"",
    url = ""https://doi.org/10.1007/978-1-4842-3832-5\_17""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Unit Tests and TDD	http://link.springer.com/chapter/10.1007/978-1-4842-3832-5_17	Apress	nan; Keywords; References
583	Behave	Unity Application Testing Automation with Appium and Image Recognition	This work is dedicated to the problem of integrating simple functional tests (smoke tests) into the automated continuous integration pipeline. While functional testing is typically performed manually by the QA staff members, there is a large number of scenarios that can be automated, and readily available instruments, such as Appium and Calabash, designed for this task. Automated smoke testing is especially challenging for the applications with nonstandard GUI, such as games made with Unity. The only viable option in this case is to analyze screen content as a flat image and identify GUI elements with pattern matching algorithms. This approach is not novel, but its practical applicability and limitations are rarely discussed. We consider a case study of a mobile tennis game project, developed in Unity and covered with a suite of Appium-supported functional tests. We show how image matching capabilities of OpenCV library can be used in Appium tests to build a reliable automated QA pipeline.	GUI; Testing; Computer game; Automation; Non-native; Smoke test; OpenCV; Unity; Appium	Mozgovoy, Maxim; Pyshkin, Evgeny	International Conference on Tools and Methods for Program Analysis	https://doi.org/10.1007/978-3-319-71734-0_12		139--150	"""@InProceedings{10.1007/978-3-319-71734-0_12,
    author = ""Mozgovoy, Maxim and Pyshkin, Evgeny"",
    editor = ""Itsykson, Vladimir and Scedrov, Andre and Zakharov, Victor"",
    title = ""Unity Application Testing Automation with Appium and Image Recognition"",
    booktitle = ""Tools and Methods of Program Analysis"",
    year = ""2018"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""139--150"",
    abstract = ""This work is dedicated to the problem of integrating simple functional tests (smoke tests) into the automated continuous integration pipeline. While functional testing is typically performed manually by the QA staff members, there is a large number of scenarios that can be automated, and readily available instruments, such as Appium and Calabash, designed for this task. Automated smoke testing is especially challenging for the applications with nonstandard GUI, such as games made with Unity. The only viable option in this case is to analyze screen content as a flat image and identify GUI elements with pattern matching algorithms. This approach is not novel, but its practical applicability and limitations are rarely discussed. We consider a case study of a mobile tennis game project, developed in Unity and covered with a suite of Appium-supported functional tests. We show how image matching capabilities of OpenCV library can be used in Appium tests to build a reliable automated QA pipeline."",
    isbn = ""978-3-319-71734-0""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Unity Application Testing Automation with Appium and Image Recognition	http://link.springer.com/chapter/10.1007/978-3-319-71734-0_12	Springer International Publishing	nan; References
584	Behave	Use, potential, and showstoppers of models in automotive requirements engineering	Several studies report that the use of model-centric methods in the automotive domain is widespread and offers several benefits. However, existing work indicates that few modelling frameworks explicitly include requirements engineering (RE), and that natural language descriptions are still the status quo in RE. Therefore, we aim to increase the understanding of current and potential future use of models in RE, with respect to the automotive domain. In this paper, we report our findings from a multiple-case study with two automotive companies, collecting interview data from 14 practitioners. Our results show that models are used for a variety of different purposes during RE in the automotive domain, e.g. to improve communication and to handle complexity. However, these models are often used in an unsystematic fashion and restricted to few experts. A more widespread use of models is prevented by various challenges, most of which align with existing work on model use in a general sense. Furthermore, our results indicate that there are many potential benefits associated with future use of models during RE. Interestingly, existing research does not align well with several of the proposed use cases, e.g. restricting the use of models to informal notations for communication purposes. Based on our findings, we recommend a stronger focus on informal modelling and on using models for multi-disciplinary environments. Additionally, we see the need for future work in the area of model use, i.e. information extraction from models by non-expert modellers.	Artificial Intelligence; Modelling; MDE; MBE; Requirements engineering; Empirical research; Case study; Automotive	Grischa Liebel; Matthias Tichy; Eric Knauss	Software & Systems Modeling	https://doi.org/10.1007/s10270-018-0683-4	"citation_journal_title=J. Syst. Softw.; citation_title=A brazilian survey on UML and model-driven practices for embedded software development; citation_author=LTW Agner, IW Soares, PC Stadzisz, JM Simao; citation_volume=86; citation_issue=4; citation_publication_date=2013; citation_pages=997-1005; citation_doi=10.1016/j.jss.2012.11.023; citation_id=CR1; citation_journal_title=IEEE Trans. Softw. Eng.; citation_title=Aligning qualitative, real-time, and probabilistic property specification patterns using a structured english grammar; citation_author=M Autili, L Grunske, M Lumpe, P Pelliccione, A Tang; citation_volume=41; citation_issue=7; citation_publication_date=2015; citation_pages=620-638; citation_doi=10.1109/TSE.2015.2398877; citation_id=CR2; citation_title=Relating Software Requirements and Architectures; citation_publication_date=2011; citation_id=CR3; citation_author=P Avgeriou; citation_author=J Grundy; citation_author=JG Hall; citation_author=P Lago; citation_author=I Mistrik; citation_publisher=Springer; Baker, P., Loh, S., Weil, F.: Model-driven engineering in a large industrial context--motorola case study. In: Briand L.C., Williams C. (eds.) Model Driven Engineering Languages and Systems, Lecture Notes in Computer Science, vol. 3713, pp. 476-491 (2005); Barmi, Z.A., Ebrahimi, A.H., Feldt, R.: Alignment of requirements specification and testing: a systematic mapping study. In: 2011 IEEE Fourth International Conference on Software Testing, Verification and Validation Workshops, pp. 476-485 (2011); Berenbach, B., Schneider, F., Naughton, H.: The use of a requirements modeling language for industrial applications. In: 20th IEEE International Requirements Engineering Conference (RE), pp. 285-290 (2012); citation_journal_title=Procedia Comput. Sci.; citation_title=Bridging the gap between systems and software engineering by using the spes modeling framework as a general systems engineering philosophy; citation_author=W Bohm, S Henkler, F Houdek, A Vogelsang, T Weyer; citation_volume=28; citation_publication_date=2014; citation_pages=187-194; citation_doi=10.1016/j.procs.2014.03.024; citation_id=CR7; Bohm, W., Junker, M., Vogelsang, A., Teufl, S., Pinger, R., Rahn, K.: A formal systems engineering approach in practice: an experience report. In: Proceedings of the 1st International Workshop on Software Engineering Research and Industrial Practices, pp. 34-41. ACM (2014); citation_journal_title=Complex Syst. Inform. Model. Q.; citation_title=Early validation of automation plant control software using simulation based on assumption modeling and validation use cases; citation_author=V Brandstetter, A Froese, B Tenbergen, A Vogelsang, JC Wehrstedt, T Weyer; citation_volume=4; citation_publication_date=2015; citation_pages=50-65; citation_id=CR9; citation_journal_title=Comput. Sci. Res. Dev.; citation_title=Guiding requirements engineering for software-intensive embedded systems in the automotive industry; citation_author=P Braun, M Broy, F Houdek, M Kirchmayr, M Muller, B Penzenstadler, K Pohl, T Weyer; citation_volume=29; citation_issue=1; citation_publication_date=2014; citation_pages=21-43; citation_doi=10.1007/s00450-010-0136-y; citation_id=CR10; Brings, J., Bellendorf, J., Keller, K., Kempe, M., Kurt, N., Palm, A., Daun, M.: Applying the spes modeling framework. In: Joint Proceedings of REFSQ-2017 Workshops, Doctoral Symposium, Research Method Track, and Poster Track co-located with the 22nd International Conference on Requirements Engineering: Foundation for Software Quality (REFSQ 2017) (2017); Broy, M.: Challenges in automotive software engineering. In: Proceedings of 28th International Conference on Software Engineering (ICSE '06), pp. 33-42 (2006); citation_title=Research Design: Qualitative, Quantitative, and Mixed Methods Approaches, Chap. 10; citation_publication_date=2003; citation_id=CR13; citation_author=JW Creswell; citation_publisher=SAGE Publications; de Almeida Ferreira, D., da Silva, A.R.: A controlled natural language approach for integrating requirements and model-driven engineering. In: 2009 Fourth International Conference on Software Engineering Advances, pp. 518-523 (2009); Dwyer, M.B., Avrunin, G.S., Corbett, J.C.: Patterns in property specifications for finite-state verification. In: Proceedings of the 1999 International Conference on Software Engineering (IEEE Cat. No.99CB37002), pp. 411-420 (1999); Eliasson, U., Heldal, R., Knauss, E., Pelliccione, P.: The need of complementing plan-driven requirements engineering with emerging communication: Experiences from volvo car group. In: IEEE 23rd International Requirements Engineering Conference (RE '15), pp. 372-381 (2015). 
                    https://doi.org/10.1109/RE.2015.7320454; Fockel, M., Holtmann, J.: A requirements engineering methodology combining models and controlled natural language. In: IEEE 4th International Model-Driven Requirements Engineering Workshop (MoDRE '14), pp. 67-76 (2014); Forward, A., Lethbridge, T.C.: Problems and opportunities for model-centric versus code-centric software development: a survey of software professionals. In: International Workshop on Models in Software Engineering (MiSE '08), pp. 27-32 (2008); citation_journal_title=ACM Trans. Softw. Eng. Methodol.; citation_title=Reasoning about inconsistencies in natural language requirements; citation_author=V Gervasi, D Zowghi; citation_volume=14; citation_issue=3; citation_publication_date=2005; citation_pages=277-330; citation_doi=10.1145/1072997.1072999; citation_id=CR19; Glinz, M.: Problems and deficiencies of uml as a requirements specification language. In: 10th International Workshop on Software Specification and Design, p. 11 (2000); citation_journal_title=J. Syst. Softw.; citation_title=On the use of software design models in software development practice: an empirical investigation; citation_author=T Gorschek, E Tempero, L Angelis; citation_volume=95; citation_publication_date=2014; citation_pages=176-193; citation_doi=10.1016/j.jss.2014.03.082; citation_id=CR21; citation_journal_title=IEEE Softw.; citation_title=Improving the state of automotive software engineering; citation_author=A Haghighatkhah, M Oivo, A Banijamali, P Kuvaja; citation_volume=34; citation_issue=5; citation_publication_date=2017; citation_pages=82-86; citation_doi=10.1109/MS.2017.3571571; citation_id=CR22; Hebisch, E., Book, M., Gruhn, V.: Scenario-based architecting with architecture trace diagrams. In: 2015 IEEE/ACM 5th International Workshop on the Twin Peaks of Requirements and Architecture, pp. 16-19 (2015); Heumesser, N., Houdek, F.: Experiences in managing an automotive requirements engineering process. In: Proceedings of 12th IEEE International Requirements Engineering Conference (RE '04), pp. 322-327 (2004); Houdek, F., Pohl, K.: Analyzing requirements engineering processes: a case study. In: Proceedings of 11th International Workshop on Database and Expert Systems Applications, pp. 983-987 (2000); Hutchinson, J., Rouncefield, M., Whittle, J.: Model-driven engineering practices in industry. In: 33rd International Conference on Software Engineering (ICSE '11), pp. 633-642 (2011); citation_journal_title=Sci. Comput. Program.; citation_title=Model-driven engineering practices in industry: social, organizational and managerial factors that lead to success or failure; citation_author=J Hutchinson, J Whittle, M Rouncefield; citation_volume=89, Part B; citation_publication_date=2014; citation_pages=144-161; citation_doi=10.1016/j.scico.2013.03.017; citation_id=CR27; Hutchinson, J., Whittle, J., Rouncefield, M., Kristoffersen, S.: Empirical assessment of mde in industry. In: 33rd International Conference on Software Engineering (ICSE '11), pp. 471-480 (2011); Kirstan, S., Zimmermann, J.: Evaluating costs and benefits of model-based development of embedded software systems in the car industry-results of a qualitative case study. In: Workshop C2M: EEMDD; Liebel, G., Marko, N., Tichy, M., Leitner, A., Hansson, J.: Assessing the state-of-practice of model-based engineering in the embedded systems domain. In: Dingel J., Schulte W., Ramos I., Abraho S., Insfran E. (eds.) Model-Driven Engineering Languages and Systems, Lecture Notes in Computer Science, vol. 8767, pp. 166-182 (2014). 
                    https://doi.org/10.1007/978-3-319-11653-211; citation_journal_title=Softw. Syst. Model.; citation_title=Model-based engineering in the embedded systems domain: an industrial survey on the state-of-practice; citation_author=G Liebel, N Marko, M Tichy, A Leitner, J Hansson; citation_publication_date=2016; citation_id=CR31; citation_journal_title=Requir. Eng.; citation_title=Organisation and communication problems in automotive requirements engineering; citation_author=G Liebel, M Tichy, E Knauss, O Ljungkrantz, G Stieglbauer; citation_volume=23; citation_issue=1; citation_publication_date=2016; citation_pages=145-167; citation_doi=10.1007/s00766-016-0261-7; citation_id=CR32; Loniewski, G., Insfran, E., Abraho, S.: A systematic review of the use of requirements engineering techniques in model-driven development. In: Petriu D., Rouquette N., Haugen O. (eds.) Model Driven Engineering Languages and Systems, Lecture Notes in Computer Science, vol. 6395, pp. 213-227 (2010). 
                    https://doi.org/10.1007/978-3-642-16129-216; Marko, N., Leitner, A., Herbst, B., Wallner, A.: Combining xtext and oslc for integrated model-based requirements engineering. In: 2015 41st Euromicro Conference on Software Engineering and Advanced Applications, pp. 143-150 (2015); citation_journal_title=Role Res Qual. Psychol.; citation_title=Qualitative content analysis-research instrument or mode of interpretation; citation_author=P Mayring; citation_volume=2; citation_publication_date=2002; citation_pages=139-148; citation_id=CR35; Mendez Fernandez, D., Lochmann, K., Penzenstadler, B., Wagner, S.: A case study on the application of an artefact-based requirements engineering approach. In: Evaluation and Assessment in Software Engineering (EASE 2011), 15th Annual Conference on, pp. 104-113. IET (2011); Mendez Fernandez, D., Penzenstadler, B., Kuhrmann, M., Broy, M.: A meta model for artefact-orientation: fundamentals and lessons learned in requirements engineering. In: International Conference on Model Driven Engineering Languages and Systems, pp. 183-197. Springer Berlin Heidelberg (2010); citation_journal_title=Inf. Softw. Technol.; citation_title=Field study on requirements engineering: Investigation of artefacts, project parameters, and execution strategies; citation_author=D Mendez Fernandez, S Wagner, K Lochmann, A Baumann, H Carne; citation_volume=54; citation_publication_date=2011; citation_pages=162-178; citation_doi=10.1016/j.infsof.2011.09.001; citation_id=CR38; Mendez Fernandez, D., Wieringa, R.: Improving requirements engineering by artefact orientation. In: International Conference on Product Focused Software Process Improvement, pp. 108-122. Springer Berlin Heidelberg (2013); Mohagheghi, P., Dehlen, V.: Where is the proof?--A review of experiences from applying mde in industry. In: Schieferdecker I., Hartman A. (eds.) Model Driven Architecture--Foundations and Applications, Lecture Notes in Computer Science, vol. 5095, pp. 432-443 (2008); citation_journal_title=Softw. Syst. Model.; citation_title=Where does model-driven engineering help? Experiences from three industrial cases; citation_author=P Mohagheghi, W Gilani, A Stefanescu, MA Fernandez, B Nordmoen, M Fritzsche; citation_volume=12; citation_issue=3; citation_publication_date=2013; citation_pages=619-639; citation_doi=10.1007/s10270-011-0219-7; citation_id=CR41; North, D.: Introducing behaviour driven development. Better Software Magazine (2006). 
                    https://dannorth.neintroducinbdd/; citation_journal_title=Computer; citation_title=Weaving together requirements and architectures; citation_author=B Nuseibeh; citation_volume=34; citation_issue=3; citation_publication_date=2001; citation_pages=115-119; citation_doi=10.1109/2.910904; citation_id=CR43; Paech, B., Dutoit, A.H., Kerkow, D., Von Knethen, A.: Functional requirements, non-functional requirements, and architecture should not be separated oea position paper (2002); Penzenstadler, B., Sikora, E., Pohl, K.: A requirements reference model for model-based requirements engineering in the automotive domain. In: International Working Conference on Requirements Engineering: Foundation for Software Quality, pp. 212-217 (2009); citation_title=Model-Based Engineering of Embedded Systems: The SPES 2020 Methodology; citation_publication_date=2012; citation_id=CR46; citation_author=K Pohl; citation_author=H Honninger; citation_author=R Achatz; citation_author=M Broy; citation_publisher=Springer; citation_title=Case Study Research in Software Engineering; citation_publication_date=2012; citation_id=CR47; citation_author=P Runeson; citation_author=M Host; citation_author=A Rainer; citation_author=B Regnell; citation_publisher=Wiley; Rungta, N., Tkachuk, O., Person, S., Biatek, J., Whalen, M.W., Castle, J., Gundy-Burlet, K.: Helping system engineers bridge the peaks. In: Proceedings of the 4th International Workshop on Twin Peaks of Requirements and Architecture, TwinPeaks 2014, pp. 9-13 (2014); Scaled Agile Inc.: Scaled agile framework. 
                    http://www.scaledagileframework.com/
                    
                  . Last Accessed Feb 2015; Sikora, E., Tenbergen, B., Pohl, K.: Requirements engineering for embedded systems: an investigation of industry needs. In: Berry D., Franch X. (eds.) Requirements Engineering: Foundation for Software Quality, Lecture Notes in Computer Science, vol. 6606, pp. 151-165 (2011); Torchiano, M., Tomassetti, F., Ricca, F., Tiso, A., Reggio, G.: Preliminary findings from a survey on the md* state of the practice. In: 5th International Symposium on Empirical Software Engineering and Measurement (ESEM '11), pp. 372-375 (2011); van Akkeren, E., Baumann, L., Cannegieter, J.J., Hood, C., Hruschka, P., Lampe, M., Leutbecher, E., van Loenhoud, H., de Roo, P., Staal, S., et al.: Handbook of requirements modeling according to the ireb standard. IREB International Requirements Engineering Board e.V. (2016); Vogelsang, A., Eder, S., Hackenberg, G., Junker, M., Teufl, S.: Supporting concurrent development of requirements and architecture: A model-based approach. In: Model-Driven Engineering and Software Development (MODELSWARD), 2014 2nd International Conference on, pp. 587-595. IEEE (2014); Weber, M., Weisbrod, J.: Requirements engineering in automotive development-experiences and challenges. In: Proceedings of IEEE Joint International Conference on Requirements Engineering (RE '02), pp. 331-340 (2002); Weinstein, M.: TAMS Analyzer. 
                    http://tamsys.sourceforge.net/
                    
                  . Last Accessed Feb 2015; Whittle, J., Hutchinson, J., Rouncefield, M., Burden, H., Heldal, R.: Industrial adoption of model-driven engineering: Are the tools really the problem? In: Moreira A., Schatz B., Gray J., Vallecillo A., Clarke P. (eds.) Model-Driven Engineering Languages and Systems, Lecture Notes in Computer Science, vol. 8107, pp. 1-17 (2013); citation_title=Case study: Design and Methods; citation_publication_date=2009; citation_id=CR57; citation_author=RK Yin; citation_publisher=Sage"			Excluded	Excluded	new_screen			2	Springer Link		Use, potential, and showstoppers of models in automotive requirements engineering	http://link.springer.com/article/10.1007/s10270-018-0683-4	Springer Link	nan; Pages; Year; Bibtex
585	Behave	Useful RSpec Tools	RSpec is a very feature-rich library. In this chapter, you learn about the most frequently used features (Figure 5-1), and you try to apply them to a real Ruby application. Also, you will be requested to develop a Ruby class and test cover it with RSpec.		Matsinopoulos, Panos	Practical Test Automation	https://doi.org/10.1007/978-1-4842-6141-5_5		159--198	"""@Inbook{Matsinopoulos2020,
    author = ""Matsinopoulos, Panos"",
    title = ""Useful RSpec Tools"",
    bookTitle = ""Practical Test Automation: Learn to Use Jasmine, RSpec, and Cucumber Effectively for Your TDD and BDD"",
    year = ""2020"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""159--198"",
    abstract = ""RSpec is a very feature-rich library. In this chapter, you learn about the most frequently used features (Figure 5-1), and you try to apply them to a real Ruby application. Also, you will be requested to develop a Ruby class and test cover it with RSpec."",
    isbn = ""978-1-4842-6141-5"",
    doi = ""10.1007/978-1-4842-6141-5\_5"",
    url = ""https://doi.org/10.1007/978-1-4842-6141-5\_5""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Useful RSpec Tools	http://link.springer.com/chapter/10.1007/978-1-4842-6141-5_5	Apress	nan; Keywords; References
586	Behave	User Interface Design	As we are heading toward an open-source digital experience platform, DXP's provide collaborative user interface. This chapter provides DXP user interface (UI) concepts and shows how to develop intuitive and interactive UI designs. In this chapter we look at:		Shivakumar, Shailesh Kumar; Sethii, Sourabhh	Building Digital Experience Platforms	https://doi.org/10.1007/978-1-4842-4303-9_4		119--147	"""@Inbook{Shivakumar2019,
    author = ""Shivakumar, Shailesh Kumar and Sethii, Sourabhh"",
    title = ""User Interface Design"",
    bookTitle = ""Building Digital Experience Platforms: A Guide to Developing Next-Generation Enterprise Applications"",
    year = ""2019"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""119--147"",
    abstract = ""As we are heading toward an open-source digital experience platform, DXP's provide collaborative user interface. This chapter provides DXP user interface (UI) concepts and shows how to develop intuitive and interactive UI designs. In this chapter we look at:"",
    isbn = ""978-1-4842-4303-9"",
    doi = ""10.1007/978-1-4842-4303-9\_4"",
    url = ""https://doi.org/10.1007/978-1-4842-4303-9\_4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		User Interface Design	http://link.springer.com/chapter/10.1007/978-1-4842-4303-9_4	Apress	nan; Keywords; References
587	Behave	Using Agile Testing in an Academic Health System Case Study	During the first semester of 2017, at the Brazilian Aeronautics Institute of Technology (Instituto Tecnologico de Aeronautica -- ITA), 30 undergraduate and graduate students from three different courses applied Interdisciplinary Learning Based on Problems (IPBL) and during 17 academic weeks had the opportunity to conceive, model and develop a Computer System to combine data and integrate different actors such as PATIENT, HOSPITAL, PHYSICIAN and SUPPLIER to the decision-making process related to health crisis management, such as epidemics. The purpose of this system based on Big Data and Internet of Things (IoT) was to manage data and information to allow the appropriate decision making. The agile Scrum method and its best practices with Python or Java, Spark, NoSQL databases, Kafka and other technologies were applied collaboratively in a fictional crisis scenario as a proof of concept (PoC) to solve health system problems. The main contribution of this study was the use of agile tests in the verification and validation of this academic system related to the management of health crises.	Health care system; Health crisis management; Agile testing; Big data; Predictive models; Internet of things; Interdisciplinary problem-based learning	da Silva, Daniela America; dos Santos, Samara Cardoso; de Barros Santana, Rodrigo Monteiro; Queiroz, Filipe Santiago; Goncalves, Gildarcio Sousa; Pugliese, Victor Ulisses; Nascimento, Alexandre; Dias, Luiz Alberto Vieira; da Cunha, Adilson Marques; Marques, Johnny; Tasinaffo, Paulo Marcelo	16th International Conference on Information Technology-New Generations (ITNG 2019)	https://doi.org/10.1007/978-3-030-14070-0\_86		605--612	"""@InProceedings{10.1007/978-3-030-14070-0_86,
    author = ""da Silva, Daniela America and dos Santos, Samara Cardoso and de Barros Santana, Rodrigo Monteiro and Queiroz, Filipe Santiago and Goncalves, Gildarcio Sousa and Pugliese, Victor Ulisses and Nascimento, Alexandre and Dias, Luiz Alberto Vieira and da Cunha, Adilson Marques and Marques, Johnny and Tasinaffo, Paulo Marcelo"",
    editor = ""Latifi, Shahram"",
    title = ""Using Agile Testing in an Academic Health System Case Study"",
    booktitle = ""16th International Conference on Information Technology-New Generations (ITNG 2019)"",
    year = ""2019"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""605--612"",
    abstract = ""During the first semester of 2017, at the Brazilian Aeronautics Institute of Technology (Instituto Tecnologico de Aeronautica -- ITA), 30 undergraduate and graduate students from three different courses applied Interdisciplinary Learning Based on Problems (IPBL) and during 17 academic weeks had the opportunity to conceive, model and develop a Computer System to combine data and integrate different actors such as PATIENT, HOSPITAL, PHYSICIAN and SUPPLIER to the decision-making process related to health crisis management, such as epidemics. The purpose of this system based on Big Data and Internet of Things (IoT) was to manage data and information to allow the appropriate decision making. The agile Scrum method and its best practices with Python or Java, Spark, NoSQL databases, Kafka and other technologies were applied collaboratively in a fictional crisis scenario as a proof of concept (PoC) to solve health system problems. The main contribution of this study was the use of agile tests in the verification and validation of this academic system related to the management of health crises."",
    isbn = ""978-3-030-14070-0""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Using Agile Testing in an Academic Health System Case Study	https://link.springer.com/chapter/10.1007/978-3-030-14070-0_86	Springer International Publishing	nan; References
588	Behave	Using Data Integration for Security Testing	The explosion of digitisation makes a plethora of security data publicly available for developers. These numerous (often complex) documents expose them to the difficulty of choosing the most appropriate solution for securing their applications. We propose in this paper a method based upon data acquisition and integration, which assists developers in the Threat modelling stage and in the security test case execution. The method firstly helps devise Attack Defense Trees by means of a data-store. These trees show attacks, steps and defenses given under the form of security patterns, which are re-usable solutions to design more secure applications. These trees are then used for the test case generation. The data-store integrates test case stubs, which make this generation easier and developers more efficient. We evaluate our approach on 24 participants and show encouraging results on the use of data integration in software engineering.	Security; Security patterns; Attack Defense Trees; Test case generation	Salva, S{\'e}bastien; Regainia, Loukmen	IFIP International Conference on Testing Software and Systems	https://doi.org/10.1007/978-3-319-67549-7_11		178--194	"""@InProceedings{10.1007/978-3-319-67549-7_11,
    author = ""Salva, S{\'e}bastien and Regainia, Loukmen"",
    editor = {Yevtushenko, Nina and Cavalli, Ana Rosa and Yenig{\""u}n, H{\""u}sn{\""u}},
    title = ""Using Data Integration for Security Testing"",
    booktitle = ""Testing Software and Systems"",
    year = ""2017"",
    publisher = ""Springer International Publishing"",
    address = ""Cham"",
    pages = ""178--194"",
    abstract = ""The explosion of digitisation makes a plethora of security data publicly available for developers. These numerous (often complex) documents expose them to the difficulty of choosing the most appropriate solution for securing their applications. We propose in this paper a method based upon data acquisition and integration, which assists developers in the Threat modelling stage and in the security test case execution. The method firstly helps devise Attack Defense Trees by means of a data-store. These trees show attacks, steps and defenses given under the form of security patterns, which are re-usable solutions to design more secure applications. These trees are then used for the test case generation. The data-store integrates test case stubs, which make this generation easier and developers more efficient. We evaluate our approach on 24 participants and show encouraging results on the use of data integration in software engineering."",
    isbn = ""978-3-319-67549-7""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Using Data Integration for Security Testing	https://link.springer.com/chapter/10.1007/978-3-319-67549-7_11	Springer International Publishing	nan; References
589	Behave	Using language workbenches and domain-specific languages for safety-critical software development	Language workbenches support the efficient creation, integration, and use of domain-specific languages. Typically, they execute models by code generation to programming language code. This can lead to increased productivity and higher quality. However, in safety-/mission-critical environments, generated code may not be considered trustworthy, because of the lack of trust in the generation mechanisms. This makes it harder to justify the use of language workbenches in such an environment. In this paper, we demonstrate an approach to use such tools in critical environments. We argue that models created with domain-specific languages are easier to validate and that the additional risk resulting from the transformation to code can be mitigated by a suitably designed transformation and verification architecture. We validate the approach with an industrial case study from the healthcare domain. We also discuss the degree to which the approach is appropriate for critical software in space, automotive, and robotics systems.	Domain-specific languages; Safety-critical software development; Case study; Language workbenches; Domain-specific languages;  Safety-critical software development;  Case study;  Language workbenches	Voelter, Markus; Kolb, Bernd; Birken, Klaus; Tomassetti, Federico; Alff, Patrick; Wiart, Laurent; Wortmann, Andreas; Nordmann, Arne	SOFTWARE AND SYSTEMS MODELING	https://doi.org/10.1007/s10270-018-0679-0	"citation_journal_title=J. Object Technol.; citation_title=Formal verification techniques for model transformations: a tridimensional classification; citation_author=M Amrani, B Combemale, L Lucio, GMK Selim, J Dingel, YL Traon, H Vangheluwe, JR Cordy; citation_volume=14; citation_issue=3; citation_publication_date=2015; citation_pages=1:1-43; citation_doi=10.5381/jot.2015.14.3.a1; citation_id=CR1; citation_journal_title=IEEE Secur. Priv.; citation_title=Software penetration testing; citation_author=B Arkin, S Stender, G McGraw; citation_volume=3; citation_issue=1; citation_publication_date=2005; citation_pages=84-87; citation_doi=10.1109/MSP.2005.23; citation_id=CR2; Beine, M., Otterbach, R., Jungmann, M.: Development of safety-critical software using automatic code generation. Technical Report, SAE Technical Paper (2004); citation_title=Implementing Domain-Specific Languages with Xtext and Xtend; citation_publication_date=2016; citation_id=CR4; citation_author=L Bettini; citation_publisher=Packt Publishing Ltd; citation_title=Software Engineering Economics; citation_publication_date=1981; citation_id=CR5; citation_author=BW Boehm; citation_publisher=Prentice-hall; Broy, M., Kirstan, S., Krcmar, H., Schatz, B., Zimmermann, J.: What is the benefit of a model-based design of embedded software systems in the car industry? Softw Des Dev Concepts Methodol Tools Appl Concepts Methodol Tools Appl, p.310 (2013). 
                    https://doi.org/10.4018/978-1-4666-4301-7.ch017; citation_journal_title=IEEE Softw.; citation_title=The impact of tools on software productivity; citation_author=T Bruckhaus, N Madhavii, I Janssen, J Henshaw; citation_volume=13; citation_issue=5; citation_publication_date=1996; citation_pages=29-38; citation_doi=10.1109/52.536456; citation_id=CR7; Buckl, C., Regensburger, M., Knoll, A., Schrott, G.: Models for automatic generation of safety-critical real-time systems. In: ARES 2007 Conference. IEEE (2007); citation_journal_title=ACM SIGPLAN Not.; citation_title=A verified compiler for an impure functional language; citation_author=A Chlipala; citation_volume=45; citation_publication_date=2010; citation_pages=93-106; citation_doi=10.1145/1707801.1706312; citation_id=CR9; citation_journal_title=Acm SIGPLAN Not.; citation_title=Quickcheck: a lightweight tool for random testing of haskell programs; citation_author=K Claessen, J Hughes; citation_volume=46; citation_issue=4; citation_publication_date=2011; citation_pages=53-64; citation_doi=10.1145/1988042.1988046; citation_id=CR10; Conmy, P., Paige, R.F.: Challenges when using model driven architecture in the development of safety critical software. In: 4th Intl. Workshop on Model-Based Methodologies for Pervasive and Embedded Software. IEEE (2007); Conrad, M.: Verification and validation according to iso 26262: a workflow to facilitate the development of high-integrity software. In: ERTS2 Conference 2012; Cousot, P., Cousot, R., Feret, J., Mauborgne, L., Mine, A., Monniaux, D., Rival, X.: The astree analyzer. In: Esop, vol. 5, pp. 21-30. Springer (2005); Cuoq, P., Kirchner, F., Kosmatov, N., Prevosto, V., Signoles, J., Yakobowski, B.: Frama-c. In: International Conference on Software Engineering and Formal Methods. Springer (2012); Dahlweid, M., Moskal, M., Santen, T., Tobies, S., Schulte, W.: Vcc: Contract-based modular verification of concurrent c. In: ICSE Companion (2009); Dormoy, F.-X.: Scade 6: a model based solution for safety critical software development. In: Proceedings of the 4th European Congress on Embedded Real Time Software (ERTS'08), pp. 1-9 (2008); Erdweg, S., Van Der Storm, T., Volter, M., Boersma, M., Bosman, R., Cook, W. R., Gerritsen, A., Hulshout, A., Kelly, S., Loh, A., et al.: The state of the art in language workbenches. In: International Conference on Software Language Engineering, pp. 197-217. Springer (2013); Eysholdt, M.: Executable specifications for xtext. Website (2014). 
                    http://www.xpect-tests.org/; citation_journal_title=ACM SIGPLAN Not.; citation_title=Pop-pl: a patient-oriented prescription programming language; citation_author=SP Florence, B Fetscher, M Flatt, WH Temps, T Kiguradze, DP West, C Niznik, PR Yarnold, RB Findler, SM Belknap; citation_volume=51; citation_publication_date=2015; citation_pages=131-140; citation_doi=10.1145/2936314.2814221; citation_id=CR19; Gorke, S., Riebeling, R., Kraus, F., Reichel, R.: Flexible platform approach for fly-by-wire systems. In: 2013 IEEE/AIAA Digital Avionics Systems Conference. IEEE (2013); citation_journal_title=Ann. Rev. Control; citation_title=Programming languages for use in safety-related applications; citation_author=WA Halang, J Zalewski; citation_publication_date=2003; citation_id=CR21; citation_title=Patterns for Fault Tolerant Software; citation_publication_date=2013; citation_id=CR22; citation_author=R Hanmer; citation_publisher=Wiley; Hart, B.: Sdr security threats in an open source world. In: Software Defined Radio Conference, pp. 3-5 (2004); Haxthausen, A.E., Peleska, J.: A domain specific language for railway control systems. In: Proc. of the 6th biennial world conference on integrated design and process technology (2002); Hermans, F., Pinzger, M., Van Deursen, A.: Domain-specific languages in practice: a user study on the success factors. In: International Conference on Model Driven Engineering Languages and Systems, pp. 423-437. Springer (2009); citation_journal_title=ACM SIGPLAN Not.; citation_title=Building embedded systems with embedded dsls; citation_author=PC Hickey, L Pike, T Elliott, J Bielman, J Launchbury; citation_volume=49; citation_publication_date=2014; citation_pages=3-9; citation_doi=10.1145/2692915.2628146; citation_id=CR26; citation_title=Spin Model Checker, the: Primer and Reference Manual; citation_publication_date=2003; citation_id=CR27; citation_author=G Holzmann; citation_publisher=Addison-Wesley Professional; Huang, W.-l., Peleska, J.: Exhaustive model-based equivalence class testing. In: IFIP International Conference on Testing Software and Systems, pp. 49-64. Springer (2013); Karna, J., Tolvanen, J.-P., Kelly, S.: Evaluating the use of domain-specific modeling in practice. In: Proceedings of the 9th OOPSLA Workshop on Domain-Specific Modeling (2009); citation_journal_title=ACM SIGPLAN Not.; citation_title=Integrated language definition testing: enabling test-driven language development; citation_author=LC Kats, R Vermaas, E Visser; citation_volume=46; citation_publication_date=2011; citation_pages=139-154; citation_doi=10.1145/2076021.2048080; citation_id=CR30; Kieburtz, R. B., McKinney, L., Bell, J. M., Hook, J., Kotov, A., Lewis, J., Oliva, D. P., Sheard, T., Smith, I., Walton, L.: A software engineering experiment in software component generation. In: Proceedings of the 18th International Conference on Software Engineering, pp. 542-552. IEEE Computer Society (1996); Koopman, P.: Embedded Software Costs 15-40 per line of code (Update: 25-50). 
                    http://bit.ly/29QHOlo
                    
                   (URL too long); Koopman, P.: Risk areas in embedded software industry projects. In: 2010 Workshop on Embedded Systems Education. ACM (2010); citation_journal_title=Empir. Softw. Eng.; citation_title=Program comprehension of domain-specific and general-purpose languages: comparison using a family of experiments; citation_author=T Kosar, M Mernik, JC Carver; citation_volume=17; citation_issue=3; citation_publication_date=2012; citation_pages=276-304; citation_doi=10.1007/s10664-011-9172-x; citation_id=CR34; Kroening, D., Tautschnig, M.: Cbmc-c bounded model checker. In: International Conference on Tools and Algorithms for the Construction and Analysis of Systems, pp. 389-391. Springer (2014); Kuhn, A., Murphy, G.C., Thompson, C.A.: An exploratory study of forces and frictions affecting large-scale model-driven development. In: International Conference on Model Driven Engineering Languages and Systems, pp. 352-367. Springer (2012); citation_journal_title=ACM SIGPLAN Not.; citation_title=Cakeml: a verified implementation of ml; citation_author=R Kumar, MO Myreen, M Norrish, S Owens; citation_volume=49; citation_publication_date=2014; citation_pages=179-191; citation_id=CR37; Lammel, R.: Grammar testing. In: Proceedings of the 4th International Conference on Fundamental Approaches to Software Engineering (2001); Ledinot, E., Astruc, J.-M., Blanquart, J.-P., Baufreton, P., Boulanger, J.-L., Delseny, H., Gassino, J., Ladier, G., Leeman, M., Machrouh, J., et al.: A cross-domain comparison of software development assurance standards. In: Proc. of ERTS 2012; citation_journal_title=Commun. ACM; citation_title=Formal verification of a realistic compiler; citation_author=X Leroy; citation_volume=52; citation_issue=7; citation_publication_date=2009; citation_pages=107-115; citation_doi=10.1145/1538788.1538814; citation_id=CR40; Lewis, J.: Cryptol: specification, implementation and verification of high-grade cryptographic applications. In: Proceedings of the 2007 ACM workshop on Formal methods in security engineering, pp. 41-41. ACM (2007); Liebel, G., Marko, N., Tichy, M., Leitner, A., Hansson, J.: Assessing the state-of-practice of model-based engineering in the embedded systems domain. In: International Conference on Model Driven Engineering Languages and Systems, pp. 166-182. Springer (2014); citation_journal_title=IEEE Softw.; citation_title=Trends in embedded software engineering; citation_author=P Liggesmeyer, M Trapp; citation_volume=26; citation_issue=3; citation_publication_date=2009; citation_pages=19-25; citation_doi=10.1109/MS.2009.80; citation_id=CR43; Lucio, L., Barroca, B., Amaral, V.: A technique for automatic validation of model transformations. In: MODELS 2010. Springer (2010); Mery, D., Schatz, B., Wassyng, A.: The pacemaker challenge: developing certifiable medical devices (dagstuhl seminar 14062). In: Dagstuhl Reports, vol. 4. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik (2014); Michailidis, A., Spieth, U., Ringler, T., Hedenetz, B., Kowalewski, S.: Test front loading in early stages of automotive software development based on autosar. In: DATE 2010. IEEE; Motor Industry Software Reliability Association and Motor Industry Software Reliability Association staff: MISRA C: 2012: Guidelines for the Use of the C Language in Critical Systems. Motor Industry Research Association (2013); Molotnikov, Z., Volter, M., Ratiu, D.: Automated domain-specific c verification with mbeddr. In: Proceedings of the 29th ACM/IEEE International Conference on Automated Software Engineering, pp. 539-550. ACM (2014); Munier, P.: Polyspace(r). Industrial Use of Formal Methods: Formal Verification, pp. 123-153 (2012). 
                    https://www.mathworks.com/products/polyspace.html
                    
                  . Accessed 10 Apr 2018; citation_title=Software Reliability; citation_publication_date=1976; citation_id=CR50; citation_author=G J Myers; citation_publisher=Wiley; citation_journal_title=Commun. ACM; citation_title=A controlled experiment in program testing and code walkthroughs/inspections; citation_author=GJ Myers; citation_volume=21; citation_issue=9; citation_publication_date=1978; citation_pages=760-768; citation_doi=10.1145/359588.359602; citation_id=CR51; Nguyen-Tuong, A., Guarnieri, S., Greene, D., Shirley, J., Evans, D.: Automatically hardening web applications using precise tainting. In: IFIP International Information Security Conference. Springer, (2005); citation_journal_title=ACM Trans. Embed. Comput. Syst. (TECS); citation_title=Safety-critical medical device development using the upp2sf model translation tool; citation_author=M Pajic, Z Jiang, I Lee, O Sokolsky, R Mangharam; citation_volume=13; citation_issue=4s; citation_publication_date=2014; citation_pages=127; citation_id=CR53; Ratiu, D., Voelter, M.: Automated testing of DSL implementations. In: 11th IEEE/ACM International Workshop on Automation of Software Test (AST 2016) (2016); Ratiu, D., Schaetz, B., Voelter, M., Kolb, B.: Language engineering as an enabler for incrementally defined formal analyses. In: Proceedings of the First International Workshop on Formal Methods in Software Engineering: Rigorous and Agile Approaches, pp. 9-15. IEEE Press (2012); Ratiu, D., Zeller, M., Killian, L.: Safety.lab: model-based domain specific tooling for safety argumentation. In: International Conference on Computer Safety, Reliability, and Security, pp. 72-82. Springer (2014); Reveillere, L., Merillon, F., Consel, C., Marlet, R., Muller, G.: A dsl approach to improve productivity and safety in device drivers development. In: ASE 2000. IEEE; Santhanam, V.: The anatomy of an faa-qualifiable ada subset compiler. In: ACM SIGAda Ada Letters, vol. 23, pp. 40-43. ACM (2002); Svendsen, A., Olsen, G. K., Endresen, J., Moen, T., Carlson, E., Alme, K.-J., Haugen, O.: The future of train signaling. In: International Conference on Model Driven Engineering Languages and Systems, pp. 128-142. Springer (2008); citation_journal_title=Procedia Comput. Sci.; citation_title=Metamodeling for medical devices: code generation, model-debugging and run-time synchronization; citation_author=J-P Tolvanen, V Djukic, A Popovic; citation_volume=63; citation_publication_date=2015; citation_pages=539-544; citation_doi=10.1016/j.procs.2015.08.382; citation_id=CR60; citation_journal_title=ACM SIGPLAN Not.; citation_title=Domain-specific languages: an annotated bibliography; citation_author=A Deursen, P Klint, J Visser; citation_volume=35; citation_issue=6; citation_publication_date=2000; citation_pages=26-36; citation_doi=10.1145/352029.352035; citation_id=CR61; Vergu, V., Neron, P., Visser, E.: Dynsem: A dsl for dynamic semantics specification. Technical Report, Delft University of Technology, Software Engineering Research Group (2015); Visser, E., Wachsmuth, G., Tolmach, A., Neron, P., Vergu, V., Passalaqua, A., Konat, G.: A language designer's workbench: a one-stop-shop for implementation and verification of language designs. In: Proc. of the 2014 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software. ACM (2014); Voelter, M.: Language and ide modularization and composition with mps. In: Generative and Transformational Techniques in Software Engineering IV, pp. 383-430. Springer (2013); citation_title=Generic Tools, Specific Languages; citation_publication_date=2014; citation_id=CR65; citation_author=M Voelter; citation_publisher=TU Delft Delft University of Technology; Voelter, M., Lisson, S.: Supporting diverse notations in MPS' Projectional Editor. GEMOC Workshop; Voelter, M., Molotnikov, Z., Kolb, B.: Towards improving software security using language engineering and mbeddr c. In: Proceeding of the Workshop on Domain-Specific Modeling 2015, pp. 55-62. Pittsburgh, PA, USA, 27-27 October 2015; citation_journal_title=Autom. Softw. Eng.; citation_title=mbeddr: Instantiating a language workbench in the embedded software domain; citation_author=M Voelter, D Ratiu, B Kolb, B Schaetz; citation_volume=20; citation_issue=3; citation_publication_date=2013; citation_pages=339-390; citation_doi=10.1007/s10515-013-0120-4; citation_id=CR68; Voelter, M., Ratiu, D., Tomassetti, F.: Requirements as first-class citizens: integrating requirements closely with implementation artifacts. In: ACESMB@ MoDELS (2013); Voelter, M., Deursen, A. v., Kolb, B., Eberle, S.: Using C language extensions for developing embedded software: a case study In: Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications, pp. 655-674, Pittsburgh, PA, USA, 25-30 October 2015; Voelter, M., van Deursen, A., Kolb, B., Eberle, S.: Using c language extensions for developing embedded software: a case study. In: OOPSLA 2015 (2015); Voelter, M., Kolb, B., Szabo, T., Ratiu, D., van Deursen, A.: Lessons learned from developing mbeddr: a case study in language engineering with mps. Softw. Syst. Model., pp. 1-46 (2017). 
                    https://doi.org/10.1007/s10270-016-0575-4; Voelter, M., SzabO, T., Engelmann, B.: An Overview of Program Analysis using Formal Methods. Self-published (2017). 
                    http://voelter.de/data/books/introToFormalMethodsAndDSLs-1.0.pdf; citation_journal_title=Electron. Notes Theor. Comput. Sci.; citation_title=Modular architectural representation and analysis of fault propagation and transformation; citation_author=M Wallace; citation_volume=141; citation_issue=3; citation_publication_date=2005; citation_pages=53-71; citation_doi=10.1016/j.entcs.2005.02.051; citation_id=CR74; citation_journal_title=IEEE Softw.; citation_title=Comparison of structural test coverage metrics; citation_author=M Weiser, JD Gannon, PR McMullin; citation_volume=2; citation_issue=2; citation_publication_date=1985; citation_pages=80; citation_doi=10.1109/MS.1985.230356; citation_id=CR75; Whalen, M.W., Heimdahl, M.P.E.: An approach to automatic code generation for safety-critical systems. In: 14th IEEE International Conference on Automated Software Engineering, 1999, pp 315-318. IEEE (1999); citation_journal_title=Commun. ACM; citation_title=Computational thinking; citation_author=JM Wing; citation_volume=49; citation_issue=3; citation_publication_date=2006; citation_pages=33-35; citation_doi=10.1145/1118178.1118215; citation_id=CR77; Wortmann, A., Beet, M.: Domain specific languages for efficient satellite control software development. In: DASIA 2016, vol 736 (2016); Wu, H., Gray, J.G., Mernik, M.: Unit testing for domain-specific languages. In: Domain-Specific Languages, IFIP TC 2 Working Conference, DSL 2009, Oxford, UK, July 15-17, 2009, Proceedings, pp. 125-147 (2009)"	2507-2530	"""@article{WOS:000475599900006,
    Author = ""Voelter, Markus and Kolb, Bernd and Birken, Klaus and Tomassetti, Federico and Alff, Patrick and Wiart, Laurent and Wortmann, Andreas and Nordmann, Arne"",
    Title = ""Using language workbenches and domain-specific languages for safety-critical software development"",
    Journal = ""SOFTWARE AND SYSTEMS MODELING"",
    Year = ""2019"",
    Volume = ""18"",
    Number = ""4"",
    Pages = ""2507-2530"",
    Month = ""AUG"",
    Abstract = ""Language workbenches support the efficient creation, integration, and use of domain-specific languages. Typically, they execute models by code generation to programming language code. This can lead to increased productivity and higher quality. However, in safety-/mission-critical environments, generated code may not be considered trustworthy, because of the lack of trust in the generation mechanisms. This makes it harder to justify the use of language workbenches in such an environment. In this paper, we demonstrate an approach to use such tools in critical environments. We argue that models created with domain-specific languages are easier to validate and that the additional risk resulting from the transformation to code can be mitigated by a suitably designed transformation and verification architecture. We validate the approach with an industrial case study from the healthcare domain. We also discuss the degree to which the approach is appropriate for critical software in space, automotive, and robotics systems."",
    Publisher = ""SPRINGER HEIDELBERG"",
    Address = ""TIERGARTENSTRASSE 17, D-69121 HEIDELBERG, GERMANY"",
    Type = ""Article"",
    Language = ""English"",
    Affiliation = ""Voelter, M (Corresponding Author), Itemis AG, Stuttgart, Germany. Voelter, Markus; Kolb, Bernd; Birken, Klaus, Itemis AG, Stuttgart, Germany. Tomassetti, Federico, TripAdvisor \\& Groupon, Lyon, France. Alff, Patrick; Wiart, Laurent, Voluntis, Paris, France. Wortmann, Andreas, OHB Syst AG, Bremen, Germany. Nordmann, Arne, Bosch Corp Res, Stuttgart, Germany."",
    DOI = ""10.1007/s10270-018-0679-0"",
    ISSN = ""1619-1366"",
    EISSN = ""1619-1374"",
    Keywords = ""Domain-specific languages; Safety-critical software development; Case study; Language workbenches"",
    Keywords-Plus = ""EMBEDDED SOFTWARE; MBEDDR"",
    Research-Areas = ""Computer Science"",
    Web-of-Science-Categories = ""Computer Science, Software Engineering"",
    Author-Email = ""voelter@acm.org kolb@itemis.de birken@itemis.de federico@tomassetti.me Patrick.Alff@voluntis.com Laurent.Wiart@voluntis.com andreas.wortmann@ohb.de arne.nordmann@de.bosch.com"",
    Affiliations = ""OHB SE"",
    Number-of-Cited-References = ""79"",
    Times-Cited = ""16"",
    Usage-Count-Last-180-days = ""1"",
    Usage-Count-Since-2013 = ""2"",
    Journal-ISO = ""Softw. Syst. Model."",
    Doc-Delivery-Number = ""IJ0OR"",
    Web-of-Science-Index = ""Science Citation Index Expanded (SCI-EXPANDED)"",
    Unique-ID = ""WOS:000475599900006"",
    DA = ""2024-12-04""
}
"""	Excluded	Excluded	new_screen			2	Web of Science		Using language workbenches and domain-specific languages for safety-critical software development	https://link.springer.com/article/10.1007/s10270-018-0679-0	SPRINGER HEIDELBERG	
590	Behave	Web Testing Practices	Testing a web application requires not only testing the site itself, but also looking at the various application metrics at every layer of the stack. It's like building an aircraft: each part of the aircraft has to be engineered and tested for safety before it is made a part of the whole. Once each subsystem has been developed and tested, they can all be assembled into the finished product for a test flight. With such a complex system, it only makes sense to be sure you can trust the individual parts before you assume the finished product will get you off the ground.	Sustained Load; Content Delivery Network; Application Metrics; Page Load Time; Quality Assurance Engineer	Sacks, Matthew	Pro Website Development and Operations	https://doi.org/10.1007/978-1-4302-3970-3_3		27--43	"""@Inbook{Sacks2012,
    author = ""Sacks, Matthew"",
    title = ""Web Testing Practices"",
    bookTitle = ""Pro Website Development and Operations: Streamlining DevOps for Large-Scale Websites"",
    year = ""2012"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""27--43"",
    abstract = ""Testing a web application requires not only testing the site itself, but also looking at the various application metrics at every layer of the stack. It's like building an aircraft: each part of the aircraft has to be engineered and tested for safety before it is made a part of the whole. Once each subsystem has been developed and tested, they can all be assembled into the finished product for a test flight. With such a complex system, it only makes sense to be sure you can trust the individual parts before you assume the finished product will get you off the ground."",
    isbn = ""978-1-4302-3970-3"",
    doi = ""10.1007/978-1-4302-3970-3\_3"",
    url = ""https://doi.org/10.1007/978-1-4302-3970-3\_3""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Web Testing Practices	http://link.springer.com/chapter/10.1007/978-1-4302-3970-3_3	Apress	nan; References
591	Behave	What Do They Do All Day?	We're going to change gears. Having spent a couple of chapters looking at the management of software development, we're now going to take a closer look at software development itself, and the processes that involves.		Gleeson, Patrick	Working with Coders	https://doi.org/10.1007/978-1-4842-2701-5_4		73--111	"""@Inbook{Gleeson2017,
    author = ""Gleeson, Patrick"",
    title = ""What Do They Do All Day?"",
    bookTitle = ""Working with Coders: A Guide to Software Development for the Perplexed Non-Techie"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""73--111"",
    abstract = ""We're going to change gears. Having spent a couple of chapters looking at the management of software development, we're now going to take a closer look at software development itself, and the processes that involves."",
    isbn = ""978-1-4842-2701-5"",
    doi = ""10.1007/978-1-4842-2701-5\_4"",
    url = ""https://doi.org/10.1007/978-1-4842-2701-5\_4""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		What Do They Do All Day?	http://link.springer.com/chapter/10.1007/978-1-4842-2701-5_4	Apress	nan; Keywords; References
592	Behave	What Is Unit Testing?	Unit testing allows you to test your software in isolation.		D{\={a}}sa, R{\={a}}dh{\={a}}r{\={a}}dhya	Learn CakePHP	https://doi.org/10.1007/978-1-4842-1212-7_2		8--13	"""@Inbook{Dasa2016,
    author = ""D{\={a}}sa, R{\={a}}dh{\={a}}r{\={a}}dhya"",
    title = ""What Is Unit Testing?"",
    bookTitle = ""Learn CakePHP: With Unit Testing"",
    year = ""2016"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""8--13"",
    abstract = ""Unit testing allows you to test your software in isolation."",
    isbn = ""978-1-4842-1212-7"",
    doi = ""10.1007/978-1-4842-1212-7\_2"",
    url = ""https://doi.org/10.1007/978-1-4842-1212-7\_2""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		What Is Unit Testing?	http://link.springer.com/chapter/10.1007/978-1-4842-1212-7_2	Apress	nan; Keywords; References
593	Behave	What your plug-in test suites really test: an integration perspective on test suite understanding	Software architectures such as plug-in and service-oriented architectures enable developers to build extensible software products, whose functionality can be enriched by adding or configuring components. A well-known example of such an architecture is Eclipse, best known for its use to create a series of extensible IDEs. Although such architectures give users and developers a great deal of flexibility to create new products, the complexity of the built systems increases. In order to manage this complexity developers use extensive automated test suites. Unfortunately, current testing tools offer little insight in which of the many possible combinations of components and components configurations are actually tested. The goal of this paper is to remedy this problem. To that end, we interview 25 professional developers on the problems they experience in test suite understanding for plug-in architectures. The findings have been incorporated in five architectural views that provide an extensibility perspective on plug-in-based systems and their test suites. The views combine static and dynamic information on plug-in dependencies, extension initialization, extension and service usage, and the test suites. The views have been implemented in ETSE, the Eclipse Plug-in Test Suite Exploration tool. We evaluate the proposed views by analyzing eGit, Mylyn, and a Mylyn connector.	Artificial Intelligence; Plug-in systems; Dynamic analysis; Static analysis; Test suite understanding	Michaela Greiler; Arie van Deursen	Empirical Software Engineering	https://doi.org/10.1007/s10664-012-9235-7	"citation_journal_title=Empir Software Eng; citation_title=Using grounded theory to study the experience of software development; citation_author=S Adolph, W Hall, P Kruchten; citation_volume=16; citation_issue=4; citation_publication_date=2011; citation_pages=487-513; citation_doi=10.1007/s10664-010-9152-6; citation_id=CR1; Binder RV (1999) Testing object-oriented systems: models, patterns, and tools. Addison-Wesley Professional; Bryant A, Charmaz K (2007) The SAGE handbook of grounded theory. SAGE; Chatley R, Eisenbach S, Kramer J, Magee J, Uchitel S (2004) Predictable dynamic plugin systems. In: 7th international conference on fundamental approaches to software engineering (FASE). Springer, pp 129-143; citation_journal_title=Qual Sociol; citation_title=Grounded theory research: Procedures, canons, and evaluative criteria; citation_author=JM Corbin, A Strauss; citation_volume=13; citation_publication_date=1990; citation_pages=3-21; citation_doi=10.1007/BF00988593; citation_id=CR5; Cornelissen B, van Deursen A, Moonen L, Zaidman A (2007) Visualizing testsuites to aid in software understanding. In: Proceedings of the 11th European conference on software maintenance and reengineering (CSMR'07). IEEE Computer Society, pp 213-222; citation_journal_title=IEEE Trans Softw Eng; citation_title=A systematic survey of program comprehension through dynamic analysis; citation_author=B Cornelissen, A Zaidman, A Deursen, L Moonen, R Koschke; citation_volume=35; citation_issue=5; citation_publication_date=2009; citation_pages=684-702; citation_doi=10.1109/TSE.2009.28; citation_id=CR7; Dagenais B, Robillard MP (2010) Creating and evolving developer documentation: understanding the decisions of open source contributors. In: Proceedings foundations of sofatware engineering (FSE). ACM SIGSOFT, pp 127-136; Demeyer S, Ducasse S, Nierstrasz O (2003) Object-oriented reengineering patterns. Morgan Kaufmann; Evans E (2003) Domain-driven design: tackling complexity in the heart of software, 1. a. edn. Addison-Wesley Professional; Feathers M (2004) Working effectively with legacy code. Prentice Hall; Freeman S, Pryce N (2010) Growing object-oriented software, guided by tests. Addison-Wesley; Gaelli M, Lanza M, Nierstrasz O (2005) Towards a taxonomy of SUnit tests. In: 13th international european smalltalk conference (ESUG 2005), pp 1-22; citation_title=Contributing to eclipse: principles, patterns, and plugins; citation_publication_date=2003; citation_id=CR14; citation_author=E Gamma; citation_author=K Beck; citation_publisher=Addison Wesley Longman Publishing Co., Inc; citation_title=An empirical evaluation to study benefits of visual versus textual test coverage information; citation_inbook_title=Proceedings of the 5th international academic and industrial conference on testing--practice and research techniques, TAIC PART'10; citation_publication_date=2010; citation_pages=189-193; citation_id=CR15; citation_author=V Garousi; citation_author=N Koochakzadeh; citation_publisher=Springer; Glaser B, Strauss A (1967) The discovery of grounded theory: strategies for qualitative research. Aldine Transaction; citation_title=Test confessions: a study of testing practices for plug-in systems; citation_inbook_title=Proceedings of the 2012 international conference on software engineering, ICSE 2012; citation_publication_date=2012; citation_pages=244-254; citation_id=CR17; citation_author=M Greiler; citation_author=A Deursen; citation_author=MA Storey; citation_publisher=IEEE Press; Greiler M, Gross HG, van Deursen A (2010) Understanding plug-in test suites from an extensibility perspective. In: Proceedings 17th working conference on reverse engineering (WCRE). IEEE Computer Society, pp 67-76; Hartmann J, Imoberdorf C, Meisinger M (2000) UML-based integration testing. In: International symposium on software testing and analysis. ACM, pp 60-70; Hermans F, Pinzger M, van Deursen A (2011) Supporting professional spreadsheet users by generating leveled dataflow diagrams. In: Gall H, Medvidovic N (eds) Proceedings 33rd international conference on software engineering (ICSE 2011). ACM; citation_journal_title=Commun ACM; citation_title=Object-oriented integration testing; citation_author=PC Jorgensen, C Erickson; citation_volume=37; citation_issue=9; citation_publication_date=1994; citation_pages=30; citation_doi=10.1145/182987.182989; citation_id=CR21; citation_title=Tecrevis: a tool for test coverage and test redundancy visualization; citation_inbook_title=Proceedings of the 5th international academic and industrial conference on testing--practice and research techniques, TAIC PART'10; citation_publication_date=2010; citation_pages=129-136; citation_id=CR22; citation_author=N Koochakzadeh; citation_author=V Garousi; citation_publisher=Springer; citation_title=Patterns for plug-ins; citation_inbook_title=Proceedings 4th european conference on pattern languages of programs (EuroPLoP); citation_publication_date=1999; citation_pages=37; citation_id=CR23; citation_author=K Marquardt; citation_publisher=Bad Irsee; citation_title=Clean code: a handbook of agile software craftsmanship; citation_publication_date=2008; citation_id=CR24; citation_author=RC Martin; citation_publisher=Prentice Hall PTR; Mayer J, Melzer I, Schweiggert F (2003) Lightweight plug-in-based application development. In: International conference NetObjectDays, NODe 2002. Springer, pp 87-102; Mens T, Fernandez-Ramil J, Degrandsart S (2008) The evolution of eclipse. In: Proceedings 24th IEEE international conference on software maintenance (ICSM). IEEE, pp 386-395; Meszaros G (2007) xUnit test patterns: refactoring test code. Addison-Wesley; Pezze M, Young M (2008) Software testing and analysis. Wiley; Reis S, Metzger A, Pohl K (2007) Integration testing in software product line engineering: a model-based technique. In: Lecture notes in computer science, pp 321-335; Rigby PC, Storey MA (2011) Understanding broadcast based peer review on open source software projects. In: ICSE '11: Proceedings of the 33rd international conference on software engineering. ACM; citation_journal_title=IEEE Trans Softw Eng; citation_title=Fragment class analysis for testing of polymorphism in Java software; citation_author=A Rountev, A Milanova, B Ryder; citation_volume=30; citation_issue=6; citation_publication_date=2004; citation_pages=372-387; citation_doi=10.1109/TSE.2004.20; citation_id=CR31; citation_title=Testing with spring and OSGi, chap 9; citation_publication_date=2009; citation_id=CR32; citation_author=D Rubio; citation_publisher=Apress; citation_title=The Java developer's guide to Eclipse; citation_publication_date=2005; citation_id=CR33; citation_author=S Shavor; citation_author=J D'Anjou; citation_author=S Fairbrother; citation_author=D Kehn; citation_author=J Kellerman; citation_author=P McCarthy; citation_publisher=Addison-Wesley Longman; The OSGi Alliance (2011) OSGi Service Platform Core Specification; Release 4, Version 4.3. 
                    http://www.osgi.org
                    
                  . Accessed 22 Aug 2011; van Deursen A, Hofmeister C, Koschke R, Moonen L, Riva C. (2004) Symphony: view-driven software architecture reconstruction. In: Proceedings working IEEE/IFIP conference on software architecture (WICSA'04). IEEE Computer Society Press, pp 122-134; van Deursen A, Moonen L, van Den Bergh A, Kok G (2002) Refactoring test code. In: Succi G, Marchesi M, Wells D, Williams L (eds) Extreme programming perspectives. Addison Wesley, pp 141-152; citation_journal_title=IEEE Trans Softw Eng; citation_title=On the detection of test smells: a metrics-based approach for general fixture and eager test; citation_author=B Rompaey, B Du Bois, S Demeyer, M Rieger; citation_volume=33; citation_issue=12; citation_publication_date=2007; citation_pages=800-817; citation_doi=10.1109/TSE.2007.70745; citation_id=CR37; citation_title=Analyzing the evolution of eclipse plugins; citation_inbook_title=Proceedings of the 2008 international working conference on mining software repositories, MSR '08; citation_publication_date=2008; citation_pages=133-136; citation_id=CR38; citation_author=M Wermelinger; citation_author=Y Yu; citation_publisher=ACM; Zaidman A, van Rompaey B, Demeyer S, van Deursen A (2008) Mining software repositories to study co-evolution of production & test code. In: Proceedings 1st international conference on software testing verification and validation (ICST). IEEE Computer Society, pp 220-229"			Excluded	Excluded	new_screen			2	Springer Link		What your plug-in test suites really test: an integration perspective on test suite understanding	http://link.springer.com/article/10.1007/s10664-012-9235-7	Springer Link	nan; Pages; Year; Bibtex
594	Behave	What's Ahead for You and Scrum?	You made it! You read about the drawbacks of plan-driven development, also known as the ``waterfall'' development method. With plan-driven development, we were not providing value to our customers or being transparent with our customers about what we were doing and what they needed. We needed to improve our way of developing software. We needed to get away from 400-page design documents as the solution to a problem. We needed to put our customer back into the forefront of our efforts.		Blankenship, Jerrel; Bussa, Matthew; Millett, Scott	Pro Agile .NET Development with Scrum	https://doi.org/10.1007/978-1-4302-3534-7_10		273--279	"""@Inbook{Blankenship2011,
    author = ""Blankenship, Jerrel and Bussa, Matthew and Millett, Scott"",
    title = ""What's Ahead for You and Scrum?"",
    bookTitle = ""Pro Agile .NET Development with Scrum"",
    year = ""2011"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""273--279"",
    abstract = ""You made it! You read about the drawbacks of plan-driven development, also known as the ``waterfall'' development method. With plan-driven development, we were not providing value to our customers or being transparent with our customers about what we were doing and what they needed. We needed to improve our way of developing software. We needed to get away from 400-page design documents as the solution to a problem. We needed to put our customer back into the forefront of our efforts."",
    isbn = ""978-1-4302-3534-7"",
    doi = ""10.1007/978-1-4302-3534-7\_10"",
    url = ""https://doi.org/10.1007/978-1-4302-3534-7\_10""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		What’s Ahead for You and Scrum?	http://link.springer.com/chapter/10.1007/978-1-4302-2887-5_1	Apress	nan; Keywords; References
595	Behave	What's the Big Idea?	ASP.NET MVC is a Web development framework from Microsoft that combines the effectiveness and tidiness of model-view-controller (MVC) architecture, the most up-to-date ideas and techniques from agile development, and the best parts of the existing ASP.NET platform. It's a complete alternative to traditional ASP.NET Web Forms, delivering considerable advantages for all but the most trivial of Web development projects. In this chapter, you'll learn why Microsoft originally created ASP.NET MVC, how it compares to its predecessors and alternatives, and, finally, what's new in ASP.NET MVC 4.	Agile Development; Cascade Style Sheets; Common Gateway Interface; Independent Software Vendor; Abstract Base Class	Freeman, Adam	Pro ASP.NET MVC 4	https://doi.org/10.1007/978-1-4302-4237-6_1		3--13	"""@Inbook{Freeman2012,
    author = ""Freeman, Adam"",
    title = ""What's the Big Idea?"",
    bookTitle = ""Pro ASP.NET MVC 4"",
    year = ""2012"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""3--13"",
    abstract = ""ASP.NET MVC is a Web development framework from Microsoft that combines the effectiveness and tidiness of model-view-controller (MVC) architecture, the most up-to-date ideas and techniques from agile development, and the best parts of the existing ASP.NET platform. It's a complete alternative to traditional ASP.NET Web Forms, delivering considerable advantages for all but the most trivial of Web development projects. In this chapter, you'll learn why Microsoft originally created ASP.NET MVC, how it compares to its predecessors and alternatives, and, finally, what's new in ASP.NET MVC 4."",
    isbn = ""978-1-4302-4237-6"",
    doi = ""10.1007/978-1-4302-4237-6\_1"",
    url = ""https://doi.org/10.1007/978-1-4302-4237-6\_1""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		What’s the Big Idea?	http://link.springer.com/chapter/10.1007/978-1-4842-6711-0_2	Apress	nan; References
596	Behave	Why Test-Driven Development Is a Must for Code Quality	Recently, Amazon claimed that it puts a new change into its production system every 1.59 seconds with no risk at all. How can this possibly be true? It's all to do with test-driven development (hereafter TDD).		Hardy, Paul David	Improving the Quality of ABAP Code	https://doi.org/10.1007/978-1-4842-6711-0_2		55--111	"""@Inbook{Hardy2021,
    author = ""Hardy, Paul David"",
    title = ""Why Test-Driven Development Is a Must for Code Quality"",
    bookTitle = ""Improving the Quality of ABAP Code: Striving for Perfection"",
    year = ""2021"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""55--111"",
    abstract = ""Recently, Amazon claimed that it puts a new change into its production system every 1.59 seconds with no risk at all. How can this possibly be true? It's all to do with test-driven development (hereafter TDD)."",
    isbn = ""978-1-4842-6711-0"",
    doi = ""10.1007/978-1-4842-6711-0\_2"",
    url = ""https://doi.org/10.1007/978-1-4842-6711-0\_2""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Why Test-Driven Development Is a Must for Code Quality	https://link.springer.com/chapter/10.1007/978-1-4842-6711-0_2	Apress	nan; Keywords; References
597	Behave	Windows Server-Administration mit PowerShell 5.1	http://link.springer.com/book/10.1007/978-3-658-17666-2	Active Directory; .NET Framenwork; DevOps; Azure-Dienste; Cmdlets; Desired State Configuration; Konfigurationsmanagement; Gruppenrichtlinien-Verwaltung; Remote-Administration; Debuggen; Administration Active Directory; Linux	Peter Monadjemi		https://link.springer.com/book/10.1007/978-3-658-17666-2				Excluded	Excluded	new_screen			2	Springer Link		Windows Server-Administration mit PowerShell 5.1	https://link.springer.com/book/10.1007/978-3-658-17666-2	Springer Link	nan; Venue; Abstract; References; Pages; Year; Bibtex; DOI
598	Behave	Workflow	A freak snowstorm provided me with insights on how I could make JavaScript application development faster, more enjoyable, and ostensibly more profitable by improving my workflow. The goal of this chapter is to teach others how to do the same.	Test Runner; Package Manager; Configuration File; Source File; Test Framework	Mark E. Daggett	Expert JavaScript	https://doi.org/10.1007/978-1-4302-6098-1_8		151–173		Excluded	Excluded	new_screen			2	Springer Link		Workflow	http://link.springer.com/chapter/10.1007/978-1-4302-6098-1_8	Apress, Berkeley, CA	nan; References; Year; Bibtex
599	Behave	Working with Legacy Code	If you have been for a few years, chances are that you have been brought on to add new features to an existing app with a large code base that has been built over a few years and has been worked on by dozens of developers, most of whom have moved on to other projects.	Legal Code; BankAccount Class; Vigilance Control; NSData; EmailAddress	Mishra, Abhishek	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_8		257--282	"""@Inbook{Mishra2017,
    author = ""Mishra, Abhishek"",
    title = ""Working with Legacy Code"",
    bookTitle = ""iOS Code Testing: Test-Driven Development and Behavior-Driven Development with Swift"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""257--282"",
    abstract = ""If you have been for a few years, chances are that you have been brought on to add new features to an existing app with a large code base that has been built over a few years and has been worked on by dozens of developers, most of whom have moved on to other projects."",
    isbn = ""978-1-4842-2689-6"",
    doi = ""10.1007/978-1-4842-2689-6\_8"",
    url = ""https://doi.org/10.1007/978-1-4842-2689-6\_8""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Working with Legacy Code	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_8	Apress	nan; References
600	Behave	Writing Your First Set of Unit Tests with Xcode	In this chapter you will download Xcode and learn to use it to create a simple app using test-driven development techniques. The app you will build will use the Single View Application template and allow the user to create different types of cookies by tapping on buttons in the user interface. The app will present a running total of each type of cookie created as well as the total number of cookies created.		Mishra, Abhishek	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_2		13--41	"""@Inbook{Mishra2017,
    author = ""Mishra, Abhishek"",
    title = ""Writing Your First Set of Unit Tests with Xcode"",
    bookTitle = ""iOS Code Testing: Test-Driven Development and Behavior-Driven Development with Swift"",
    year = ""2017"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""13--41"",
    abstract = ""In this chapter you will download Xcode and learn to use it to create a simple app using test-driven development techniques. The app you will build will use the Single View Application template and allow the user to create different types of cookies by tapping on buttons in the user interface. The app will present a running total of each type of cookie created as well as the total number of cookies created."",
    isbn = ""978-1-4842-2689-6"",
    doi = ""10.1007/978-1-4842-2689-6\_2"",
    url = ""https://doi.org/10.1007/978-1-4842-2689-6\_2""
}
"""	Excluded	Excluded	new_screen			2	Springer Link		Writing Your First Set of Unit Tests with Xcode	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_2	Apress	nan; Keywords; References
